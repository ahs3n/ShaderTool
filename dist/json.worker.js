/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/arrays.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayQueue: () => (/* binding */ ArrayQueue),\n/* harmony export */   CallbackIterable: () => (/* binding */ CallbackIterable),\n/* harmony export */   CompareResult: () => (/* binding */ CompareResult),\n/* harmony export */   Permutation: () => (/* binding */ Permutation),\n/* harmony export */   arrayInsert: () => (/* binding */ arrayInsert),\n/* harmony export */   asArray: () => (/* binding */ asArray),\n/* harmony export */   binarySearch: () => (/* binding */ binarySearch),\n/* harmony export */   binarySearch2: () => (/* binding */ binarySearch2),\n/* harmony export */   booleanComparator: () => (/* binding */ booleanComparator),\n/* harmony export */   coalesce: () => (/* binding */ coalesce),\n/* harmony export */   coalesceInPlace: () => (/* binding */ coalesceInPlace),\n/* harmony export */   compareBy: () => (/* binding */ compareBy),\n/* harmony export */   distinct: () => (/* binding */ distinct),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   firstOrDefault: () => (/* binding */ firstOrDefault),\n/* harmony export */   forEachAdjacent: () => (/* binding */ forEachAdjacent),\n/* harmony export */   forEachWithNeighbors: () => (/* binding */ forEachWithNeighbors),\n/* harmony export */   groupAdjacentBy: () => (/* binding */ groupAdjacentBy),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   insertInto: () => (/* binding */ insertInto),\n/* harmony export */   isFalsyOrEmpty: () => (/* binding */ isFalsyOrEmpty),\n/* harmony export */   isNonEmptyArray: () => (/* binding */ isNonEmptyArray),\n/* harmony export */   numberComparator: () => (/* binding */ numberComparator),\n/* harmony export */   pushMany: () => (/* binding */ pushMany),\n/* harmony export */   pushToEnd: () => (/* binding */ pushToEnd),\n/* harmony export */   pushToStart: () => (/* binding */ pushToStart),\n/* harmony export */   quickSelect: () => (/* binding */ quickSelect),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   removeFastWithoutKeepingOrder: () => (/* binding */ removeFastWithoutKeepingOrder),\n/* harmony export */   reverseOrder: () => (/* binding */ reverseOrder),\n/* harmony export */   splice: () => (/* binding */ splice),\n/* harmony export */   tail: () => (/* binding */ tail),\n/* harmony export */   tail2: () => (/* binding */ tail2),\n/* harmony export */   tieBreakComparators: () => (/* binding */ tieBreakComparators)\n/* harmony export */ });\n/**\r\n * Returns the last element of an array.\r\n * @param array The array.\r\n * @param n Which element from the end (default is zero).\r\n */\r\nfunction tail(array, n = 0) {\r\n    return array[array.length - (1 + n)];\r\n}\r\nfunction tail2(arr) {\r\n    if (arr.length === 0) {\r\n        throw new Error('Invalid tail call');\r\n    }\r\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\r\n}\r\nfunction equals(one, other, itemEquals = (a, b) => a === b) {\r\n    if (one === other) {\r\n        return true;\r\n    }\r\n    if (!one || !other) {\r\n        return false;\r\n    }\r\n    if (one.length !== other.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0, len = one.length; i < len; i++) {\r\n        if (!itemEquals(one[i], other[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\r\n * but changes the order of the array\r\n */\r\nfunction removeFastWithoutKeepingOrder(array, index) {\r\n    const last = array.length - 1;\r\n    if (index < last) {\r\n        array[index] = array[last];\r\n    }\r\n    array.pop();\r\n}\r\n/**\r\n * Performs a binary search algorithm over a sorted array.\r\n *\r\n * @param array The array being searched.\r\n * @param key The value we search for.\r\n * @param comparator A function that takes two array elements and returns zero\r\n *   if they are equal, a negative number if the first element precedes the\r\n *   second one in the sorting order, or a positive number if the second element\r\n *   precedes the first one.\r\n * @return See {@link binarySearch2}\r\n */\r\nfunction binarySearch(array, key, comparator) {\r\n    return binarySearch2(array.length, i => comparator(array[i], key));\r\n}\r\n/**\r\n * Performs a binary search algorithm over a sorted collection. Useful for cases\r\n * when we need to perform a binary search over something that isn't actually an\r\n * array, and converting data to an array would defeat the use of binary search\r\n * in the first place.\r\n *\r\n * @param length The collection length.\r\n * @param compareToKey A function that takes an index of an element in the\r\n *   collection and returns zero if the value at this index is equal to the\r\n *   search key, a negative number if the value precedes the search key in the\r\n *   sorting order, or a positive number if the search key precedes the value.\r\n * @return A non-negative index of an element, if found. If not found, the\r\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\r\n *   where the key should be inserted to maintain the sorting order.\r\n */\r\nfunction binarySearch2(length, compareToKey) {\r\n    let low = 0, high = length - 1;\r\n    while (low <= high) {\r\n        const mid = ((low + high) / 2) | 0;\r\n        const comp = compareToKey(mid);\r\n        if (comp < 0) {\r\n            low = mid + 1;\r\n        }\r\n        else if (comp > 0) {\r\n            high = mid - 1;\r\n        }\r\n        else {\r\n            return mid;\r\n        }\r\n    }\r\n    return -(low + 1);\r\n}\r\nfunction quickSelect(nth, data, compare) {\r\n    nth = nth | 0;\r\n    if (nth >= data.length) {\r\n        throw new TypeError('invalid index');\r\n    }\r\n    const pivotValue = data[Math.floor(data.length * Math.random())];\r\n    const lower = [];\r\n    const higher = [];\r\n    const pivots = [];\r\n    for (const value of data) {\r\n        const val = compare(value, pivotValue);\r\n        if (val < 0) {\r\n            lower.push(value);\r\n        }\r\n        else if (val > 0) {\r\n            higher.push(value);\r\n        }\r\n        else {\r\n            pivots.push(value);\r\n        }\r\n    }\r\n    if (nth < lower.length) {\r\n        return quickSelect(nth, lower, compare);\r\n    }\r\n    else if (nth < lower.length + pivots.length) {\r\n        return pivots[0];\r\n    }\r\n    else {\r\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\r\n    }\r\n}\r\nfunction groupBy(data, compare) {\r\n    const result = [];\r\n    let currentGroup = undefined;\r\n    for (const element of data.slice(0).sort(compare)) {\r\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\r\n            currentGroup = [element];\r\n            result.push(currentGroup);\r\n        }\r\n        else {\r\n            currentGroup.push(element);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Splits the given items into a list of (non-empty) groups.\r\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\r\n * The order of the items is preserved.\r\n */\r\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\r\n    let currentGroup;\r\n    let last;\r\n    for (const item of items) {\r\n        if (last !== undefined && shouldBeGrouped(last, item)) {\r\n            currentGroup.push(item);\r\n        }\r\n        else {\r\n            if (currentGroup) {\r\n                yield currentGroup;\r\n            }\r\n            currentGroup = [item];\r\n        }\r\n        last = item;\r\n    }\r\n    if (currentGroup) {\r\n        yield currentGroup;\r\n    }\r\n}\r\nfunction forEachAdjacent(arr, f) {\r\n    for (let i = 0; i <= arr.length; i++) {\r\n        f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\r\n    }\r\n}\r\nfunction forEachWithNeighbors(arr, f) {\r\n    for (let i = 0; i < arr.length; i++) {\r\n        f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\r\n    }\r\n}\r\n/**\r\n * @returns New array with all falsy values removed. The original array IS NOT modified.\r\n */\r\nfunction coalesce(array) {\r\n    return array.filter((e) => !!e);\r\n}\r\n/**\r\n * Remove all falsy values from `array`. The original array IS modified.\r\n */\r\nfunction coalesceInPlace(array) {\r\n    let to = 0;\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!!array[i]) {\r\n            array[to] = array[i];\r\n            to += 1;\r\n        }\r\n    }\r\n    array.length = to;\r\n}\r\n/**\r\n * @returns false if the provided object is an array and not empty.\r\n */\r\nfunction isFalsyOrEmpty(obj) {\r\n    return !Array.isArray(obj) || obj.length === 0;\r\n}\r\nfunction isNonEmptyArray(obj) {\r\n    return Array.isArray(obj) && obj.length > 0;\r\n}\r\n/**\r\n * Removes duplicates from the given array. The optional keyFn allows to specify\r\n * how elements are checked for equality by returning an alternate value for each.\r\n */\r\nfunction distinct(array, keyFn = value => value) {\r\n    const seen = new Set();\r\n    return array.filter(element => {\r\n        const key = keyFn(element);\r\n        if (seen.has(key)) {\r\n            return false;\r\n        }\r\n        seen.add(key);\r\n        return true;\r\n    });\r\n}\r\nfunction firstOrDefault(array, notFoundValue) {\r\n    return array.length > 0 ? array[0] : notFoundValue;\r\n}\r\nfunction range(arg, to) {\r\n    let from = typeof to === 'number' ? arg : 0;\r\n    if (typeof to === 'number') {\r\n        from = arg;\r\n    }\r\n    else {\r\n        from = 0;\r\n        to = arg;\r\n    }\r\n    const result = [];\r\n    if (from <= to) {\r\n        for (let i = from; i < to; i++) {\r\n            result.push(i);\r\n        }\r\n    }\r\n    else {\r\n        for (let i = from; i > to; i--) {\r\n            result.push(i);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Insert `insertArr` inside `target` at `insertIndex`.\r\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\r\n */\r\nfunction arrayInsert(target, insertIndex, insertArr) {\r\n    const before = target.slice(0, insertIndex);\r\n    const after = target.slice(insertIndex);\r\n    return before.concat(insertArr, after);\r\n}\r\n/**\r\n * Pushes an element to the start of the array, if found.\r\n */\r\nfunction pushToStart(arr, value) {\r\n    const index = arr.indexOf(value);\r\n    if (index > -1) {\r\n        arr.splice(index, 1);\r\n        arr.unshift(value);\r\n    }\r\n}\r\n/**\r\n * Pushes an element to the end of the array, if found.\r\n */\r\nfunction pushToEnd(arr, value) {\r\n    const index = arr.indexOf(value);\r\n    if (index > -1) {\r\n        arr.splice(index, 1);\r\n        arr.push(value);\r\n    }\r\n}\r\nfunction pushMany(arr, items) {\r\n    for (const item of items) {\r\n        arr.push(item);\r\n    }\r\n}\r\nfunction asArray(x) {\r\n    return Array.isArray(x) ? x : [x];\r\n}\r\n/**\r\n * Insert the new items in the array.\r\n * @param array The original array.\r\n * @param start The zero-based location in the array from which to start inserting elements.\r\n * @param newItems The items to be inserted\r\n */\r\nfunction insertInto(array, start, newItems) {\r\n    const startIdx = getActualStartIndex(array, start);\r\n    const originalLength = array.length;\r\n    const newItemsLength = newItems.length;\r\n    array.length = originalLength + newItemsLength;\r\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\r\n    for (let i = originalLength - 1; i >= startIdx; i--) {\r\n        array[i + newItemsLength] = array[i];\r\n    }\r\n    for (let i = 0; i < newItemsLength; i++) {\r\n        array[i + startIdx] = newItems[i];\r\n    }\r\n}\r\n/**\r\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\r\n * can only support limited number of items due to the maximum call stack size limit.\r\n * @param array The original array.\r\n * @param start The zero-based location in the array from which to start removing elements.\r\n * @param deleteCount The number of elements to remove.\r\n * @returns An array containing the elements that were deleted.\r\n */\r\nfunction splice(array, start, deleteCount, newItems) {\r\n    const index = getActualStartIndex(array, start);\r\n    let result = array.splice(index, deleteCount);\r\n    if (result === undefined) {\r\n        // see https://bugs.webkit.org/show_bug.cgi?id=261140\r\n        result = [];\r\n    }\r\n    insertInto(array, index, newItems);\r\n    return result;\r\n}\r\n/**\r\n * Determine the actual start index (same logic as the native splice() or slice())\r\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\r\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\r\n * @param array The target array.\r\n * @param start The operation index.\r\n */\r\nfunction getActualStartIndex(array, start) {\r\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\r\n}\r\nvar CompareResult;\r\n(function (CompareResult) {\r\n    function isLessThan(result) {\r\n        return result < 0;\r\n    }\r\n    CompareResult.isLessThan = isLessThan;\r\n    function isLessThanOrEqual(result) {\r\n        return result <= 0;\r\n    }\r\n    CompareResult.isLessThanOrEqual = isLessThanOrEqual;\r\n    function isGreaterThan(result) {\r\n        return result > 0;\r\n    }\r\n    CompareResult.isGreaterThan = isGreaterThan;\r\n    function isNeitherLessOrGreaterThan(result) {\r\n        return result === 0;\r\n    }\r\n    CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\r\n    CompareResult.greaterThan = 1;\r\n    CompareResult.lessThan = -1;\r\n    CompareResult.neitherLessOrGreaterThan = 0;\r\n})(CompareResult || (CompareResult = {}));\r\nfunction compareBy(selector, comparator) {\r\n    return (a, b) => comparator(selector(a), selector(b));\r\n}\r\nfunction tieBreakComparators(...comparators) {\r\n    return (item1, item2) => {\r\n        for (const comparator of comparators) {\r\n            const result = comparator(item1, item2);\r\n            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {\r\n                return result;\r\n            }\r\n        }\r\n        return CompareResult.neitherLessOrGreaterThan;\r\n    };\r\n}\r\n/**\r\n * The natural order on numbers.\r\n*/\r\nconst numberComparator = (a, b) => a - b;\r\nconst booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\r\nfunction reverseOrder(comparator) {\r\n    return (a, b) => -comparator(a, b);\r\n}\r\nclass ArrayQueue {\r\n    /**\r\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\r\n    */\r\n    constructor(items) {\r\n        this.items = items;\r\n        this.firstIdx = 0;\r\n        this.lastIdx = this.items.length - 1;\r\n    }\r\n    get length() {\r\n        return this.lastIdx - this.firstIdx + 1;\r\n    }\r\n    /**\r\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\r\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\r\n    */\r\n    takeWhile(predicate) {\r\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\r\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\r\n        let startIdx = this.firstIdx;\r\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\r\n            startIdx++;\r\n        }\r\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\r\n        this.firstIdx = startIdx;\r\n        return result;\r\n    }\r\n    /**\r\n     * Consumes elements from the end of the queue as long as the predicate returns true.\r\n     * If no elements were consumed, `null` is returned.\r\n     * The result has the same order as the underlying array!\r\n    */\r\n    takeFromEndWhile(predicate) {\r\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\r\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\r\n        let endIdx = this.lastIdx;\r\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\r\n            endIdx--;\r\n        }\r\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\r\n        this.lastIdx = endIdx;\r\n        return result;\r\n    }\r\n    peek() {\r\n        if (this.length === 0) {\r\n            return undefined;\r\n        }\r\n        return this.items[this.firstIdx];\r\n    }\r\n    dequeue() {\r\n        const result = this.items[this.firstIdx];\r\n        this.firstIdx++;\r\n        return result;\r\n    }\r\n    takeCount(count) {\r\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\r\n        this.firstIdx += count;\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * This class is faster than an iterator and array for lazy computed data.\r\n*/\r\nclass CallbackIterable {\r\n    constructor(\r\n    /**\r\n     * Calls the callback for every item.\r\n     * Stops when the callback returns false.\r\n    */\r\n    iterate) {\r\n        this.iterate = iterate;\r\n    }\r\n    toArray() {\r\n        const result = [];\r\n        this.iterate(item => { result.push(item); return true; });\r\n        return result;\r\n    }\r\n    filter(predicate) {\r\n        return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\r\n    }\r\n    map(mapFn) {\r\n        return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));\r\n    }\r\n    findLast(predicate) {\r\n        let result;\r\n        this.iterate(item => {\r\n            if (predicate(item)) {\r\n                result = item;\r\n            }\r\n            return true;\r\n        });\r\n        return result;\r\n    }\r\n    findLastMaxBy(comparator) {\r\n        let result;\r\n        let first = true;\r\n        this.iterate(item => {\r\n            if (first || CompareResult.isGreaterThan(comparator(item, result))) {\r\n                first = false;\r\n                result = item;\r\n            }\r\n            return true;\r\n        });\r\n        return result;\r\n    }\r\n}\r\nCallbackIterable.empty = new CallbackIterable(_callback => { });\r\n/**\r\n * Represents a re-arrangement of items in an array.\r\n */\r\nclass Permutation {\r\n    constructor(_indexMap) {\r\n        this._indexMap = _indexMap;\r\n    }\r\n    /**\r\n     * Returns a permutation that sorts the given array according to the given compare function.\r\n     */\r\n    static createSortPermutation(arr, compareFn) {\r\n        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\r\n        return new Permutation(sortIndices);\r\n    }\r\n    /**\r\n     * Returns a new array with the elements of the given array re-arranged according to this permutation.\r\n     */\r\n    apply(arr) {\r\n        return arr.map((_, index) => arr[this._indexMap[index]]);\r\n    }\r\n    /**\r\n     * Returns a new permutation that undoes the re-arrangement of this permutation.\r\n    */\r\n    inverse() {\r\n        const inverseIndexMap = this._indexMap.slice();\r\n        for (let i = 0; i < this._indexMap.length; i++) {\r\n            inverseIndexMap[this._indexMap[i]] = i;\r\n        }\r\n        return new Permutation(inverseIndexMap);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYXJyYXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQixjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hcnJheXMuanM/ZThlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gbiBXaGljaCBlbGVtZW50IGZyb20gdGhlIGVuZCAoZGVmYXVsdCBpcyB6ZXJvKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0YWlsKGFycmF5LCBuID0gMCkge1xyXG4gICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtICgxICsgbildO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0YWlsMihhcnIpIHtcclxuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhaWwgY2FsbCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFthcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCAtIDEpLCBhcnJbYXJyLmxlbmd0aCAtIDFdXTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIsIGl0ZW1FcXVhbHMgPSAoYSwgYikgPT4gYSA9PT0gYikge1xyXG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICghb25lIHx8ICFvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb25lLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFpdGVtRXF1YWxzKG9uZVtpXSwgb3RoZXJbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBlbGVtZW50IGF0IGBpbmRleGAgYnkgcmVwbGFjaW5nIGl0IHdpdGggdGhlIGxhc3QgZWxlbWVudC4gVGhpcyBpcyBmYXN0ZXIgdGhhbiBgc3BsaWNlYFxyXG4gKiBidXQgY2hhbmdlcyB0aGUgb3JkZXIgb2YgdGhlIGFycmF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmFzdFdpdGhvdXRLZWVwaW5nT3JkZXIoYXJyYXksIGluZGV4KSB7XHJcbiAgICBjb25zdCBsYXN0ID0gYXJyYXkubGVuZ3RoIC0gMTtcclxuICAgIGlmIChpbmRleCA8IGxhc3QpIHtcclxuICAgICAgICBhcnJheVtpbmRleF0gPSBhcnJheVtsYXN0XTtcclxuICAgIH1cclxuICAgIGFycmF5LnBvcCgpO1xyXG59XHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIG92ZXIgYSBzb3J0ZWQgYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXHJcbiAqIEBwYXJhbSBrZXkgVGhlIHZhbHVlIHdlIHNlYXJjaCBmb3IuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0d28gYXJyYXkgZWxlbWVudHMgYW5kIHJldHVybnMgemVyb1xyXG4gKiAgIGlmIHRoZXkgYXJlIGVxdWFsLCBhIG5lZ2F0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVjZWRlcyB0aGVcclxuICogICBzZWNvbmQgb25lIGluIHRoZSBzb3J0aW5nIG9yZGVyLCBvciBhIHBvc2l0aXZlIG51bWJlciBpZiB0aGUgc2Vjb25kIGVsZW1lbnRcclxuICogICBwcmVjZWRlcyB0aGUgZmlyc3Qgb25lLlxyXG4gKiBAcmV0dXJuIFNlZSB7QGxpbmsgYmluYXJ5U2VhcmNoMn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXksIGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaDIoYXJyYXkubGVuZ3RoLCBpID0+IGNvbXBhcmF0b3IoYXJyYXlbaV0sIGtleSkpO1xyXG59XHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIG92ZXIgYSBzb3J0ZWQgY29sbGVjdGlvbi4gVXNlZnVsIGZvciBjYXNlc1xyXG4gKiB3aGVuIHdlIG5lZWQgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb3ZlciBzb21ldGhpbmcgdGhhdCBpc24ndCBhY3R1YWxseSBhblxyXG4gKiBhcnJheSwgYW5kIGNvbnZlcnRpbmcgZGF0YSB0byBhbiBhcnJheSB3b3VsZCBkZWZlYXQgdGhlIHVzZSBvZiBiaW5hcnkgc2VhcmNoXHJcbiAqIGluIHRoZSBmaXJzdCBwbGFjZS5cclxuICpcclxuICogQHBhcmFtIGxlbmd0aCBUaGUgY29sbGVjdGlvbiBsZW5ndGguXHJcbiAqIEBwYXJhbSBjb21wYXJlVG9LZXkgQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGluZGV4IG9mIGFuIGVsZW1lbnQgaW4gdGhlXHJcbiAqICAgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB6ZXJvIGlmIHRoZSB2YWx1ZSBhdCB0aGlzIGluZGV4IGlzIGVxdWFsIHRvIHRoZVxyXG4gKiAgIHNlYXJjaCBrZXksIGEgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZSB2YWx1ZSBwcmVjZWRlcyB0aGUgc2VhcmNoIGtleSBpbiB0aGVcclxuICogICBzb3J0aW5nIG9yZGVyLCBvciBhIHBvc2l0aXZlIG51bWJlciBpZiB0aGUgc2VhcmNoIGtleSBwcmVjZWRlcyB0aGUgdmFsdWUuXHJcbiAqIEByZXR1cm4gQSBub24tbmVnYXRpdmUgaW5kZXggb2YgYW4gZWxlbWVudCwgaWYgZm91bmQuIElmIG5vdCBmb3VuZCwgdGhlXHJcbiAqICAgcmVzdWx0IGlzIC0obisxKSAob3Igfm4sIHVzaW5nIGJpdHdpc2Ugbm90YXRpb24pLCB3aGVyZSBuIGlzIHRoZSBpbmRleFxyXG4gKiAgIHdoZXJlIHRoZSBrZXkgc2hvdWxkIGJlIGluc2VydGVkIHRvIG1haW50YWluIHRoZSBzb3J0aW5nIG9yZGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDIobGVuZ3RoLCBjb21wYXJlVG9LZXkpIHtcclxuICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xyXG4gICAgICAgIGNvbnN0IG1pZCA9ICgobG93ICsgaGlnaCkgLyAyKSB8IDA7XHJcbiAgICAgICAgY29uc3QgY29tcCA9IGNvbXBhcmVUb0tleShtaWQpO1xyXG4gICAgICAgIGlmIChjb21wIDwgMCkge1xyXG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wID4gMCkge1xyXG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0obG93ICsgMSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHF1aWNrU2VsZWN0KG50aCwgZGF0YSwgY29tcGFyZSkge1xyXG4gICAgbnRoID0gbnRoIHwgMDtcclxuICAgIGlmIChudGggPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGluZGV4Jyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwaXZvdFZhbHVlID0gZGF0YVtNYXRoLmZsb29yKGRhdGEubGVuZ3RoICogTWF0aC5yYW5kb20oKSldO1xyXG4gICAgY29uc3QgbG93ZXIgPSBbXTtcclxuICAgIGNvbnN0IGhpZ2hlciA9IFtdO1xyXG4gICAgY29uc3QgcGl2b3RzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRhdGEpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBjb21wYXJlKHZhbHVlLCBwaXZvdFZhbHVlKTtcclxuICAgICAgICBpZiAodmFsIDwgMCkge1xyXG4gICAgICAgICAgICBsb3dlci5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsID4gMCkge1xyXG4gICAgICAgICAgICBoaWdoZXIucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwaXZvdHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG50aCA8IGxvd2VyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBxdWlja1NlbGVjdChudGgsIGxvd2VyLCBjb21wYXJlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG50aCA8IGxvd2VyLmxlbmd0aCArIHBpdm90cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcGl2b3RzWzBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHF1aWNrU2VsZWN0KG50aCAtIChsb3dlci5sZW5ndGggKyBwaXZvdHMubGVuZ3RoKSwgaGlnaGVyLCBjb21wYXJlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBCeShkYXRhLCBjb21wYXJlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGxldCBjdXJyZW50R3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YS5zbGljZSgwKS5zb3J0KGNvbXBhcmUpKSB7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50R3JvdXAgfHwgY29tcGFyZShjdXJyZW50R3JvdXBbMF0sIGVsZW1lbnQpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IFtlbGVtZW50XTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudEdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFNwbGl0cyB0aGUgZ2l2ZW4gaXRlbXMgaW50byBhIGxpc3Qgb2YgKG5vbi1lbXB0eSkgZ3JvdXBzLlxyXG4gKiBgc2hvdWxkQmVHcm91cGVkYCBpcyB1c2VkIHRvIGRlY2lkZSBpZiB0d28gY29uc2VjdXRpdmUgaXRlbXMgc2hvdWxkIGJlIGluIHRoZSBzYW1lIGdyb3VwLlxyXG4gKiBUaGUgb3JkZXIgb2YgdGhlIGl0ZW1zIGlzIHByZXNlcnZlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogZ3JvdXBBZGphY2VudEJ5KGl0ZW1zLCBzaG91bGRCZUdyb3VwZWQpIHtcclxuICAgIGxldCBjdXJyZW50R3JvdXA7XHJcbiAgICBsZXQgbGFzdDtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xyXG4gICAgICAgIGlmIChsYXN0ICE9PSB1bmRlZmluZWQgJiYgc2hvdWxkQmVHcm91cGVkKGxhc3QsIGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgY3VycmVudEdyb3VwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IFtpdGVtXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdCA9IGl0ZW07XHJcbiAgICB9XHJcbiAgICBpZiAoY3VycmVudEdyb3VwKSB7XHJcbiAgICAgICAgeWllbGQgY3VycmVudEdyb3VwO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoQWRqYWNlbnQoYXJyLCBmKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmKGkgPT09IDAgPyB1bmRlZmluZWQgOiBhcnJbaSAtIDFdLCBpID09PSBhcnIubGVuZ3RoID8gdW5kZWZpbmVkIDogYXJyW2ldKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFdpdGhOZWlnaGJvcnMoYXJyLCBmKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGYoaSA9PT0gMCA/IHVuZGVmaW5lZCA6IGFycltpIC0gMV0sIGFycltpXSwgaSArIDEgPT09IGFyci5sZW5ndGggPyB1bmRlZmluZWQgOiBhcnJbaSArIDFdKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHJldHVybnMgTmV3IGFycmF5IHdpdGggYWxsIGZhbHN5IHZhbHVlcyByZW1vdmVkLiBUaGUgb3JpZ2luYWwgYXJyYXkgSVMgTk9UIG1vZGlmaWVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvYWxlc2NlKGFycmF5KSB7XHJcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKChlKSA9PiAhIWUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGBhcnJheWAuIFRoZSBvcmlnaW5hbCBhcnJheSBJUyBtb2RpZmllZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2FsZXNjZUluUGxhY2UoYXJyYXkpIHtcclxuICAgIGxldCB0byA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCEhYXJyYXlbaV0pIHtcclxuICAgICAgICAgICAgYXJyYXlbdG9dID0gYXJyYXlbaV07XHJcbiAgICAgICAgICAgIHRvICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXJyYXkubGVuZ3RoID0gdG87XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIGZhbHNlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgYW4gYXJyYXkgYW5kIG5vdCBlbXB0eS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZhbHN5T3JFbXB0eShvYmopIHtcclxuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShvYmopIHx8IG9iai5sZW5ndGggPT09IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA+IDA7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIHRoZSBnaXZlbiBhcnJheS4gVGhlIG9wdGlvbmFsIGtleUZuIGFsbG93cyB0byBzcGVjaWZ5XHJcbiAqIGhvdyBlbGVtZW50cyBhcmUgY2hlY2tlZCBmb3IgZXF1YWxpdHkgYnkgcmV0dXJuaW5nIGFuIGFsdGVybmF0ZSB2YWx1ZSBmb3IgZWFjaC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdChhcnJheSwga2V5Rm4gPSB2YWx1ZSA9PiB2YWx1ZSkge1xyXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIHJldHVybiBhcnJheS5maWx0ZXIoZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5Rm4oZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChrZXkpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0T3JEZWZhdWx0KGFycmF5LCBub3RGb3VuZFZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/IGFycmF5WzBdIDogbm90Rm91bmRWYWx1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UoYXJnLCB0bykge1xyXG4gICAgbGV0IGZyb20gPSB0eXBlb2YgdG8gPT09ICdudW1iZXInID8gYXJnIDogMDtcclxuICAgIGlmICh0eXBlb2YgdG8gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgZnJvbSA9IGFyZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZyb20gPSAwO1xyXG4gICAgICAgIHRvID0gYXJnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBpZiAoZnJvbSA8PSB0bykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA+IHRvOyBpLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogSW5zZXJ0IGBpbnNlcnRBcnJgIGluc2lkZSBgdGFyZ2V0YCBhdCBgaW5zZXJ0SW5kZXhgLlxyXG4gKiBQbGVhc2UgZG9uJ3QgdG91Y2ggdW5sZXNzIHlvdSB1bmRlcnN0YW5kIGh0dHBzOi8vanNwZXJmLmNvbS9pbnNlcnRpbmctYW4tYXJyYXktd2l0aGluLWFuLWFycmF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlJbnNlcnQodGFyZ2V0LCBpbnNlcnRJbmRleCwgaW5zZXJ0QXJyKSB7XHJcbiAgICBjb25zdCBiZWZvcmUgPSB0YXJnZXQuc2xpY2UoMCwgaW5zZXJ0SW5kZXgpO1xyXG4gICAgY29uc3QgYWZ0ZXIgPSB0YXJnZXQuc2xpY2UoaW5zZXJ0SW5kZXgpO1xyXG4gICAgcmV0dXJuIGJlZm9yZS5jb25jYXQoaW5zZXJ0QXJyLCBhZnRlcik7XHJcbn1cclxuLyoqXHJcbiAqIFB1c2hlcyBhbiBlbGVtZW50IHRvIHRoZSBzdGFydCBvZiB0aGUgYXJyYXksIGlmIGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hUb1N0YXJ0KGFyciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YodmFsdWUpO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBhcnIudW5zaGlmdCh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1c2hlcyBhbiBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LCBpZiBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwdXNoVG9FbmQoYXJyLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZih2YWx1ZSk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGFyci5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcHVzaE1hbnkoYXJyLCBpdGVtcykge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XHJcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoeCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xyXG59XHJcbi8qKlxyXG4gKiBJbnNlcnQgdGhlIG5ldyBpdGVtcyBpbiB0aGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgb3JpZ2luYWwgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSBuZXdJdGVtcyBUaGUgaXRlbXMgdG8gYmUgaW5zZXJ0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRJbnRvKGFycmF5LCBzdGFydCwgbmV3SXRlbXMpIHtcclxuICAgIGNvbnN0IHN0YXJ0SWR4ID0gZ2V0QWN0dWFsU3RhcnRJbmRleChhcnJheSwgc3RhcnQpO1xyXG4gICAgY29uc3Qgb3JpZ2luYWxMZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICBjb25zdCBuZXdJdGVtc0xlbmd0aCA9IG5ld0l0ZW1zLmxlbmd0aDtcclxuICAgIGFycmF5Lmxlbmd0aCA9IG9yaWdpbmFsTGVuZ3RoICsgbmV3SXRlbXNMZW5ndGg7XHJcbiAgICAvLyBNb3ZlIHRoZSBpdGVtcyBhZnRlciB0aGUgc3RhcnQgaW5kZXgsIHN0YXJ0IGZyb20gdGhlIGVuZCBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBhbnkgdmFsdWUuXHJcbiAgICBmb3IgKGxldCBpID0gb3JpZ2luYWxMZW5ndGggLSAxOyBpID49IHN0YXJ0SWR4OyBpLS0pIHtcclxuICAgICAgICBhcnJheVtpICsgbmV3SXRlbXNMZW5ndGhdID0gYXJyYXlbaV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0l0ZW1zTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhcnJheVtpICsgc3RhcnRJZHhdID0gbmV3SXRlbXNbaV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBhbmQgaW5zZXJ0cyBuZXcgZWxlbWVudHMgaW4gdGhlaXIgcGxhY2UsIHJldHVybmluZyB0aGUgZGVsZXRlZCBlbGVtZW50cy4gQWx0ZXJuYXRpdmUgdG8gdGhlIG5hdGl2ZSBBcnJheS5zcGxpY2UgbWV0aG9kLCBpdFxyXG4gKiBjYW4gb25seSBzdXBwb3J0IGxpbWl0ZWQgbnVtYmVyIG9mIGl0ZW1zIGR1ZSB0byB0aGUgbWF4aW11bSBjYWxsIHN0YWNrIHNpemUgbGltaXQuXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgb3JpZ2luYWwgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZyBlbGVtZW50cy5cclxuICogQHBhcmFtIGRlbGV0ZUNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBlbGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpY2UoYXJyYXksIHN0YXJ0LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gZ2V0QWN0dWFsU3RhcnRJbmRleChhcnJheSwgc3RhcnQpO1xyXG4gICAgbGV0IHJlc3VsdCA9IGFycmF5LnNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpO1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNjExNDBcclxuICAgICAgICByZXN1bHQgPSBbXTtcclxuICAgIH1cclxuICAgIGluc2VydEludG8oYXJyYXksIGluZGV4LCBuZXdJdGVtcyk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGFjdHVhbCBzdGFydCBpbmRleCAoc2FtZSBsb2dpYyBhcyB0aGUgbmF0aXZlIHNwbGljZSgpIG9yIHNsaWNlKCkpXHJcbiAqIElmIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSwgc3RhcnQgd2lsbCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIEluIHRoaXMgY2FzZSwgbm8gZWxlbWVudCB3aWxsIGJlIGRlbGV0ZWQgYnV0IHRoZSBtZXRob2Qgd2lsbCBiZWhhdmUgYXMgYW4gYWRkaW5nIGZ1bmN0aW9uLCBhZGRpbmcgYXMgbWFueSBlbGVtZW50IGFzIGl0ZW1bbipdIHByb3ZpZGVkLlxyXG4gKiBJZiBuZWdhdGl2ZSwgaXQgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS4gKEluIHRoaXMgY2FzZSwgdGhlIG9yaWdpbiAtMSwgbWVhbmluZyAtbiBpcyB0aGUgaW5kZXggb2YgdGhlIG50aCBsYXN0IGVsZW1lbnQsIGFuZCBpcyB0aGVyZWZvcmUgZXF1aXZhbGVudCB0byB0aGUgaW5kZXggb2YgYXJyYXkubGVuZ3RoIC0gbi4pIElmIGFycmF5Lmxlbmd0aCArIHN0YXJ0IGlzIGxlc3MgdGhhbiAwLCBpdCB3aWxsIGJlZ2luIGZyb20gaW5kZXggMC5cclxuICogQHBhcmFtIGFycmF5IFRoZSB0YXJnZXQgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdGFydCBUaGUgb3BlcmF0aW9uIGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWN0dWFsU3RhcnRJbmRleChhcnJheSwgc3RhcnQpIHtcclxuICAgIHJldHVybiBzdGFydCA8IDAgPyBNYXRoLm1heChzdGFydCArIGFycmF5Lmxlbmd0aCwgMCkgOiBNYXRoLm1pbihzdGFydCwgYXJyYXkubGVuZ3RoKTtcclxufVxyXG5leHBvcnQgdmFyIENvbXBhcmVSZXN1bHQ7XHJcbihmdW5jdGlvbiAoQ29tcGFyZVJlc3VsdCkge1xyXG4gICAgZnVuY3Rpb24gaXNMZXNzVGhhbihyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IDwgMDtcclxuICAgIH1cclxuICAgIENvbXBhcmVSZXN1bHQuaXNMZXNzVGhhbiA9IGlzTGVzc1RoYW47XHJcbiAgICBmdW5jdGlvbiBpc0xlc3NUaGFuT3JFcXVhbChyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IDw9IDA7XHJcbiAgICB9XHJcbiAgICBDb21wYXJlUmVzdWx0LmlzTGVzc1RoYW5PckVxdWFsID0gaXNMZXNzVGhhbk9yRXF1YWw7XHJcbiAgICBmdW5jdGlvbiBpc0dyZWF0ZXJUaGFuKHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgPiAwO1xyXG4gICAgfVxyXG4gICAgQ29tcGFyZVJlc3VsdC5pc0dyZWF0ZXJUaGFuID0gaXNHcmVhdGVyVGhhbjtcclxuICAgIGZ1bmN0aW9uIGlzTmVpdGhlckxlc3NPckdyZWF0ZXJUaGFuKHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IDA7XHJcbiAgICB9XHJcbiAgICBDb21wYXJlUmVzdWx0LmlzTmVpdGhlckxlc3NPckdyZWF0ZXJUaGFuID0gaXNOZWl0aGVyTGVzc09yR3JlYXRlclRoYW47XHJcbiAgICBDb21wYXJlUmVzdWx0LmdyZWF0ZXJUaGFuID0gMTtcclxuICAgIENvbXBhcmVSZXN1bHQubGVzc1RoYW4gPSAtMTtcclxuICAgIENvbXBhcmVSZXN1bHQubmVpdGhlckxlc3NPckdyZWF0ZXJUaGFuID0gMDtcclxufSkoQ29tcGFyZVJlc3VsdCB8fCAoQ29tcGFyZVJlc3VsdCA9IHt9KSk7XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnkoc2VsZWN0b3IsIGNvbXBhcmF0b3IpIHtcclxuICAgIHJldHVybiAoYSwgYikgPT4gY29tcGFyYXRvcihzZWxlY3RvcihhKSwgc2VsZWN0b3IoYikpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0aWVCcmVha0NvbXBhcmF0b3JzKC4uLmNvbXBhcmF0b3JzKSB7XHJcbiAgICByZXR1cm4gKGl0ZW0xLCBpdGVtMikgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJhdG9yKGl0ZW0xLCBpdGVtMik7XHJcbiAgICAgICAgICAgIGlmICghQ29tcGFyZVJlc3VsdC5pc05laXRoZXJMZXNzT3JHcmVhdGVyVGhhbihyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb21wYXJlUmVzdWx0Lm5laXRoZXJMZXNzT3JHcmVhdGVyVGhhbjtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBuYXR1cmFsIG9yZGVyIG9uIG51bWJlcnMuXHJcbiovXHJcbmV4cG9ydCBjb25zdCBudW1iZXJDb21wYXJhdG9yID0gKGEsIGIpID0+IGEgLSBiO1xyXG5leHBvcnQgY29uc3QgYm9vbGVhbkNvbXBhcmF0b3IgPSAoYSwgYikgPT4gbnVtYmVyQ29tcGFyYXRvcihhID8gMSA6IDAsIGIgPyAxIDogMCk7XHJcbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlT3JkZXIoY29tcGFyYXRvcikge1xyXG4gICAgcmV0dXJuIChhLCBiKSA9PiAtY29tcGFyYXRvcihhLCBiKTtcclxufVxyXG5leHBvcnQgY2xhc3MgQXJyYXlRdWV1ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBxdWV1ZSB0aGF0IGlzIGJhY2tlZCBieSB0aGUgZ2l2ZW4gYXJyYXkuIFJ1bnRpbWUgaXMgTygxKS5cclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpdGVtcykge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcclxuICAgICAgICB0aGlzLmZpcnN0SWR4ID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RJZHggPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgICB9XHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RJZHggLSB0aGlzLmZpcnN0SWR4ICsgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3VtZXMgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZSBhcyBsb25nIGFzIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxyXG4gICAgICogSWYgbm8gZWxlbWVudHMgd2VyZSBjb25zdW1lZCwgYG51bGxgIGlzIHJldHVybmVkLiBIYXMgYSBydW50aW1lIG9mIE8ocmVzdWx0Lmxlbmd0aCkuXHJcbiAgICAqL1xyXG4gICAgdGFrZVdoaWxlKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIC8vIFAoaykgOj0gayA8PSB0aGlzLmxhc3RJZHggJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNba10pXHJcbiAgICAgICAgLy8gRmluZCBzIDo9IG1pbiB7IGsgfCBrID49IHRoaXMuZmlyc3RJZHggJiYgIVAoaykgfSBhbmQgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmZpcnN0SWR4Li4ucylcclxuICAgICAgICBsZXQgc3RhcnRJZHggPSB0aGlzLmZpcnN0SWR4O1xyXG4gICAgICAgIHdoaWxlIChzdGFydElkeCA8IHRoaXMuaXRlbXMubGVuZ3RoICYmIHByZWRpY2F0ZSh0aGlzLml0ZW1zW3N0YXJ0SWR4XSkpIHtcclxuICAgICAgICAgICAgc3RhcnRJZHgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RhcnRJZHggPT09IHRoaXMuZmlyc3RJZHggPyBudWxsIDogdGhpcy5pdGVtcy5zbGljZSh0aGlzLmZpcnN0SWR4LCBzdGFydElkeCk7XHJcbiAgICAgICAgdGhpcy5maXJzdElkeCA9IHN0YXJ0SWR4O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnN1bWVzIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgcXVldWUgYXMgbG9uZyBhcyB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIElmIG5vIGVsZW1lbnRzIHdlcmUgY29uc3VtZWQsIGBudWxsYCBpcyByZXR1cm5lZC5cclxuICAgICAqIFRoZSByZXN1bHQgaGFzIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1bmRlcmx5aW5nIGFycmF5IVxyXG4gICAgKi9cclxuICAgIHRha2VGcm9tRW5kV2hpbGUocHJlZGljYXRlKSB7XHJcbiAgICAgICAgLy8gUChrKSA6PSB0aGlzLmZpcnN0SWR4ID49IGsgJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNba10pXHJcbiAgICAgICAgLy8gRmluZCBzIDo9IG1heCB7IGsgfCBrIDw9IHRoaXMubGFzdElkeCAmJiAhUChrKSB9IGFuZCByZXR1cm4gdGhpcy5kYXRhKHMuLi50aGlzLmxhc3RJZHhdXHJcbiAgICAgICAgbGV0IGVuZElkeCA9IHRoaXMubGFzdElkeDtcclxuICAgICAgICB3aGlsZSAoZW5kSWR4ID49IDAgJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNbZW5kSWR4XSkpIHtcclxuICAgICAgICAgICAgZW5kSWR4LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVuZElkeCA9PT0gdGhpcy5sYXN0SWR4ID8gbnVsbCA6IHRoaXMuaXRlbXMuc2xpY2UoZW5kSWR4ICsgMSwgdGhpcy5sYXN0SWR4ICsgMSk7XHJcbiAgICAgICAgdGhpcy5sYXN0SWR4ID0gZW5kSWR4O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBwZWVrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmZpcnN0SWR4XTtcclxuICAgIH1cclxuICAgIGRlcXVldWUoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtc1t0aGlzLmZpcnN0SWR4XTtcclxuICAgICAgICB0aGlzLmZpcnN0SWR4Kys7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHRha2VDb3VudChjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXRlbXMuc2xpY2UodGhpcy5maXJzdElkeCwgdGhpcy5maXJzdElkeCArIGNvdW50KTtcclxuICAgICAgICB0aGlzLmZpcnN0SWR4ICs9IGNvdW50O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaXMgZmFzdGVyIHRoYW4gYW4gaXRlcmF0b3IgYW5kIGFycmF5IGZvciBsYXp5IGNvbXB1dGVkIGRhdGEuXHJcbiovXHJcbmV4cG9ydCBjbGFzcyBDYWxsYmFja0l0ZXJhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyB0aGUgY2FsbGJhY2sgZm9yIGV2ZXJ5IGl0ZW0uXHJcbiAgICAgKiBTdG9wcyB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlLlxyXG4gICAgKi9cclxuICAgIGl0ZXJhdGUpIHtcclxuICAgICAgICB0aGlzLml0ZXJhdGUgPSBpdGVyYXRlO1xyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICB0aGlzLml0ZXJhdGUoaXRlbSA9PiB7IHJlc3VsdC5wdXNoKGl0ZW0pOyByZXR1cm4gdHJ1ZTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZpbHRlcihwcmVkaWNhdGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrSXRlcmFibGUoY2IgPT4gdGhpcy5pdGVyYXRlKGl0ZW0gPT4gcHJlZGljYXRlKGl0ZW0pID8gY2IoaXRlbSkgOiB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBtYXAobWFwRm4pIHtcclxuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrSXRlcmFibGUoY2IgPT4gdGhpcy5pdGVyYXRlKGl0ZW0gPT4gY2IobWFwRm4oaXRlbSkpKSk7XHJcbiAgICB9XHJcbiAgICBmaW5kTGFzdChwcmVkaWNhdGUpIHtcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIHRoaXMuaXRlcmF0ZShpdGVtID0+IHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZmluZExhc3RNYXhCeShjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXRlcmF0ZShpdGVtID0+IHtcclxuICAgICAgICAgICAgaWYgKGZpcnN0IHx8IENvbXBhcmVSZXN1bHQuaXNHcmVhdGVyVGhhbihjb21wYXJhdG9yKGl0ZW0sIHJlc3VsdCkpKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbkNhbGxiYWNrSXRlcmFibGUuZW1wdHkgPSBuZXcgQ2FsbGJhY2tJdGVyYWJsZShfY2FsbGJhY2sgPT4geyB9KTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSByZS1hcnJhbmdlbWVudCBvZiBpdGVtcyBpbiBhbiBhcnJheS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQZXJtdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihfaW5kZXhNYXApIHtcclxuICAgICAgICB0aGlzLl9pbmRleE1hcCA9IF9pbmRleE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBlcm11dGF0aW9uIHRoYXQgc29ydHMgdGhlIGdpdmVuIGFycmF5IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY29tcGFyZSBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVNvcnRQZXJtdXRhdGlvbihhcnIsIGNvbXBhcmVGbikge1xyXG4gICAgICAgIGNvbnN0IHNvcnRJbmRpY2VzID0gQXJyYXkuZnJvbShhcnIua2V5cygpKS5zb3J0KChpbmRleDEsIGluZGV4MikgPT4gY29tcGFyZUZuKGFycltpbmRleDFdLCBhcnJbaW5kZXgyXSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVybXV0YXRpb24oc29ydEluZGljZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheSByZS1hcnJhbmdlZCBhY2NvcmRpbmcgdG8gdGhpcyBwZXJtdXRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgYXBwbHkoYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKF8sIGluZGV4KSA9PiBhcnJbdGhpcy5faW5kZXhNYXBbaW5kZXhdXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgcGVybXV0YXRpb24gdGhhdCB1bmRvZXMgdGhlIHJlLWFycmFuZ2VtZW50IG9mIHRoaXMgcGVybXV0YXRpb24uXHJcbiAgICAqL1xyXG4gICAgaW52ZXJzZSgpIHtcclxuICAgICAgICBjb25zdCBpbnZlcnNlSW5kZXhNYXAgPSB0aGlzLl9pbmRleE1hcC5zbGljZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5kZXhNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaW52ZXJzZUluZGV4TWFwW3RoaXMuX2luZGV4TWFwW2ldXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUGVybXV0YXRpb24oaW52ZXJzZUluZGV4TWFwKTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/arrays.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MonotonousArray: () => (/* binding */ MonotonousArray),\n/* harmony export */   findFirstIdxMonotonousOrArrLen: () => (/* binding */ findFirstIdxMonotonousOrArrLen),\n/* harmony export */   findFirstMax: () => (/* binding */ findFirstMax),\n/* harmony export */   findFirstMin: () => (/* binding */ findFirstMin),\n/* harmony export */   findFirstMonotonous: () => (/* binding */ findFirstMonotonous),\n/* harmony export */   findLast: () => (/* binding */ findLast),\n/* harmony export */   findLastIdx: () => (/* binding */ findLastIdx),\n/* harmony export */   findLastIdxMonotonous: () => (/* binding */ findLastIdxMonotonous),\n/* harmony export */   findLastMax: () => (/* binding */ findLastMax),\n/* harmony export */   findLastMonotonous: () => (/* binding */ findLastMonotonous),\n/* harmony export */   findMaxIdx: () => (/* binding */ findMaxIdx),\n/* harmony export */   mapFindFirst: () => (/* binding */ mapFindFirst)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction findLast(array, predicate) {\r\n    const idx = findLastIdx(array, predicate);\r\n    if (idx === -1) {\r\n        return undefined;\r\n    }\r\n    return array[idx];\r\n}\r\nfunction findLastIdx(array, predicate, fromIndex = array.length - 1) {\r\n    for (let i = fromIndex; i >= 0; i--) {\r\n        const element = array[i];\r\n        if (predicate(element)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Finds the last item where predicate is true using binary search.\r\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\r\n *\r\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\r\n */\r\nfunction findLastMonotonous(array, predicate) {\r\n    const idx = findLastIdxMonotonous(array, predicate);\r\n    return idx === -1 ? undefined : array[idx];\r\n}\r\n/**\r\n * Finds the last item where predicate is true using binary search.\r\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\r\n *\r\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\r\n */\r\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\r\n    let i = startIdx;\r\n    let j = endIdxEx;\r\n    while (i < j) {\r\n        const k = Math.floor((i + j) / 2);\r\n        if (predicate(array[k])) {\r\n            i = k + 1;\r\n        }\r\n        else {\r\n            j = k;\r\n        }\r\n    }\r\n    return i - 1;\r\n}\r\n/**\r\n * Finds the first item where predicate is true using binary search.\r\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\r\n *\r\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\r\n */\r\nfunction findFirstMonotonous(array, predicate) {\r\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\r\n    return idx === array.length ? undefined : array[idx];\r\n}\r\n/**\r\n * Finds the first item where predicate is true using binary search.\r\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\r\n *\r\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\r\n */\r\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\r\n    let i = startIdx;\r\n    let j = endIdxEx;\r\n    while (i < j) {\r\n        const k = Math.floor((i + j) / 2);\r\n        if (predicate(array[k])) {\r\n            j = k;\r\n        }\r\n        else {\r\n            i = k + 1;\r\n        }\r\n    }\r\n    return i;\r\n}\r\n/**\r\n * Use this when\r\n * * You have a sorted array\r\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\r\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\r\n */\r\nclass MonotonousArray {\r\n    constructor(_array) {\r\n        this._array = _array;\r\n        this._findLastMonotonousLastIdx = 0;\r\n    }\r\n    /**\r\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\r\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\r\n     */\r\n    findLastMonotonous(predicate) {\r\n        if (MonotonousArray.assertInvariants) {\r\n            if (this._prevFindLastPredicate) {\r\n                for (const item of this._array) {\r\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\r\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\r\n                    }\r\n                }\r\n            }\r\n            this._prevFindLastPredicate = predicate;\r\n        }\r\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\r\n        this._findLastMonotonousLastIdx = idx + 1;\r\n        return idx === -1 ? undefined : this._array[idx];\r\n    }\r\n}\r\nMonotonousArray.assertInvariants = false;\r\n/**\r\n * Returns the first item that is equal to or greater than every other item.\r\n*/\r\nfunction findFirstMax(array, comparator) {\r\n    if (array.length === 0) {\r\n        return undefined;\r\n    }\r\n    let max = array[0];\r\n    for (let i = 1; i < array.length; i++) {\r\n        const item = array[i];\r\n        if (comparator(item, max) > 0) {\r\n            max = item;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n/**\r\n * Returns the last item that is equal to or greater than every other item.\r\n*/\r\nfunction findLastMax(array, comparator) {\r\n    if (array.length === 0) {\r\n        return undefined;\r\n    }\r\n    let max = array[0];\r\n    for (let i = 1; i < array.length; i++) {\r\n        const item = array[i];\r\n        if (comparator(item, max) >= 0) {\r\n            max = item;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n/**\r\n * Returns the first item that is equal to or less than every other item.\r\n*/\r\nfunction findFirstMin(array, comparator) {\r\n    return findFirstMax(array, (a, b) => -comparator(a, b));\r\n}\r\nfunction findMaxIdx(array, comparator) {\r\n    if (array.length === 0) {\r\n        return -1;\r\n    }\r\n    let maxIdx = 0;\r\n    for (let i = 1; i < array.length; i++) {\r\n        const item = array[i];\r\n        if (comparator(item, array[maxIdx]) > 0) {\r\n            maxIdx = i;\r\n        }\r\n    }\r\n    return maxIdx;\r\n}\r\n/**\r\n * Returns the first mapped value of the array which is not undefined.\r\n */\r\nfunction mapFindFirst(items, mapFn) {\r\n    for (const value of items) {\r\n        const mapped = mapFn(value);\r\n        if (mapped !== undefined) {\r\n            return mapped;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcz8wNjg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3QoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgY29uc3QgaWR4ID0gZmluZExhc3RJZHgoYXJyYXksIHByZWRpY2F0ZSk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXlbaWR4XTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RJZHgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMSkge1xyXG4gICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSBsYXN0IGl0ZW0gd2hlcmUgcHJlZGljYXRlIGlzIHRydWUgdXNpbmcgYmluYXJ5IHNlYXJjaC5cclxuICogYHByZWRpY2F0ZWAgbXVzdCBiZSBtb25vdG9ub3VzLCBpLmUuIGBhcnIubWFwKHByZWRpY2F0ZSlgIG11c3QgYmUgbGlrZSBgW3RydWUsIC4uLiwgdHJ1ZSwgZmFsc2UsIC4uLiwgZmFsc2VdYCFcclxuICpcclxuICogQHJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8gaXRlbSBtYXRjaGVzLCBvdGhlcndpc2UgdGhlIGxhc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGFzdE1vbm90b25vdXMoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgY29uc3QgaWR4ID0gZmluZExhc3RJZHhNb25vdG9ub3VzKGFycmF5LCBwcmVkaWNhdGUpO1xyXG4gICAgcmV0dXJuIGlkeCA9PT0gLTEgPyB1bmRlZmluZWQgOiBhcnJheVtpZHhdO1xyXG59XHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgbGFzdCBpdGVtIHdoZXJlIHByZWRpY2F0ZSBpcyB0cnVlIHVzaW5nIGJpbmFyeSBzZWFyY2guXHJcbiAqIGBwcmVkaWNhdGVgIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFt0cnVlLCAuLi4sIHRydWUsIGZhbHNlLCAuLi4sIGZhbHNlXWAhXHJcbiAqXHJcbiAqIEByZXR1cm5zIGBzdGFydElkeCAtIDFgIGlmIHByZWRpY2F0ZSBpcyBmYWxzZSBmb3IgYWxsIGl0ZW1zLCBvdGhlcndpc2UgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RJZHhNb25vdG9ub3VzKGFycmF5LCBwcmVkaWNhdGUsIHN0YXJ0SWR4ID0gMCwgZW5kSWR4RXggPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGxldCBpID0gc3RhcnRJZHg7XHJcbiAgICBsZXQgaiA9IGVuZElkeEV4O1xyXG4gICAgd2hpbGUgKGkgPCBqKSB7XHJcbiAgICAgICAgY29uc3QgayA9IE1hdGguZmxvb3IoKGkgKyBqKSAvIDIpO1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlba10pKSB7XHJcbiAgICAgICAgICAgIGkgPSBrICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGogPSBrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpIC0gMTtcclxufVxyXG4vKipcclxuICogRmluZHMgdGhlIGZpcnN0IGl0ZW0gd2hlcmUgcHJlZGljYXRlIGlzIHRydWUgdXNpbmcgYmluYXJ5IHNlYXJjaC5cclxuICogYHByZWRpY2F0ZWAgbXVzdCBiZSBtb25vdG9ub3VzLCBpLmUuIGBhcnIubWFwKHByZWRpY2F0ZSlgIG11c3QgYmUgbGlrZSBgW2ZhbHNlLCAuLi4sIGZhbHNlLCB0cnVlLCAuLi4sIHRydWVdYCFcclxuICpcclxuICogQHJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8gaXRlbSBtYXRjaGVzLCBvdGhlcndpc2UgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0TW9ub3Rvbm91cyhhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICBjb25zdCBpZHggPSBmaW5kRmlyc3RJZHhNb25vdG9ub3VzT3JBcnJMZW4oYXJyYXksIHByZWRpY2F0ZSk7XHJcbiAgICByZXR1cm4gaWR4ID09PSBhcnJheS5sZW5ndGggPyB1bmRlZmluZWQgOiBhcnJheVtpZHhdO1xyXG59XHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgZmlyc3QgaXRlbSB3aGVyZSBwcmVkaWNhdGUgaXMgdHJ1ZSB1c2luZyBiaW5hcnkgc2VhcmNoLlxyXG4gKiBgcHJlZGljYXRlYCBtdXN0IGJlIG1vbm90b25vdXMsIGkuZS4gYGFyci5tYXAocHJlZGljYXRlKWAgbXVzdCBiZSBsaWtlIGBbZmFsc2UsIC4uLiwgZmFsc2UsIHRydWUsIC4uLiwgdHJ1ZV1gIVxyXG4gKlxyXG4gKiBAcmV0dXJucyBgZW5kSWR4RXhgIGlmIHByZWRpY2F0ZSBpcyBmYWxzZSBmb3IgYWxsIGl0ZW1zLCBvdGhlcndpc2UgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbihhcnJheSwgcHJlZGljYXRlLCBzdGFydElkeCA9IDAsIGVuZElkeEV4ID0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICBsZXQgaSA9IHN0YXJ0SWR4O1xyXG4gICAgbGV0IGogPSBlbmRJZHhFeDtcclxuICAgIHdoaWxlIChpIDwgaikge1xyXG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLmZsb29yKChpICsgaikgLyAyKTtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2tdKSkge1xyXG4gICAgICAgICAgICBqID0gaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSBrICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaTtcclxufVxyXG4vKipcclxuICogVXNlIHRoaXMgd2hlblxyXG4gKiAqIFlvdSBoYXZlIGEgc29ydGVkIGFycmF5XHJcbiAqICogWW91IHF1ZXJ5IHRoaXMgYXJyYXkgd2l0aCBhIG1vbm90b25vdXMgcHJlZGljYXRlIHRvIGZpbmQgdGhlIGxhc3QgaXRlbSB0aGF0IGhhcyBhIGNlcnRhaW4gcHJvcGVydHkuXHJcbiAqICogWW91IHF1ZXJ5IHRoaXMgYXJyYXkgbXVsdGlwbGUgdGltZXMgd2l0aCBtb25vdG9ub3VzIHByZWRpY2F0ZXMgdGhhdCBnZXQgd2Vha2VyIGFuZCB3ZWFrZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTW9ub3Rvbm91c0FycmF5IHtcclxuICAgIGNvbnN0cnVjdG9yKF9hcnJheSkge1xyXG4gICAgICAgIHRoaXMuX2FycmF5ID0gX2FycmF5O1xyXG4gICAgICAgIHRoaXMuX2ZpbmRMYXN0TW9ub3Rvbm91c0xhc3RJZHggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcHJlZGljYXRlIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFt0cnVlLCAuLi4sIHRydWUsIGZhbHNlLCAuLi4sIGZhbHNlXWAhXHJcbiAgICAgKiBGb3Igc3Vic2VxdWVudCBjYWxscywgY3VycmVudCBwcmVkaWNhdGUgbXVzdCBiZSB3ZWFrZXIgdGhhbiAob3IgZXF1YWwgdG8pIHRoZSBwcmV2aW91cyBwcmVkaWNhdGUsIGkuZS4gbW9yZSBlbnRyaWVzIG11c3QgYmUgYHRydWVgLlxyXG4gICAgICovXHJcbiAgICBmaW5kTGFzdE1vbm90b25vdXMocHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKE1vbm90b25vdXNBcnJheS5hc3NlcnRJbnZhcmlhbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2RmluZExhc3RQcmVkaWNhdGUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9hcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2RmluZExhc3RQcmVkaWNhdGUoaXRlbSkgJiYgIXByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vbm90b25vdXNBcnJheTogY3VycmVudCBwcmVkaWNhdGUgbXVzdCBiZSB3ZWFrZXIgdGhhbiAob3IgZXF1YWwgdG8pIHRoZSBwcmV2aW91cyBwcmVkaWNhdGUuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZGaW5kTGFzdFByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaWR4ID0gZmluZExhc3RJZHhNb25vdG9ub3VzKHRoaXMuX2FycmF5LCBwcmVkaWNhdGUsIHRoaXMuX2ZpbmRMYXN0TW9ub3Rvbm91c0xhc3RJZHgpO1xyXG4gICAgICAgIHRoaXMuX2ZpbmRMYXN0TW9ub3Rvbm91c0xhc3RJZHggPSBpZHggKyAxO1xyXG4gICAgICAgIHJldHVybiBpZHggPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5fYXJyYXlbaWR4XTtcclxuICAgIH1cclxufVxyXG5Nb25vdG9ub3VzQXJyYXkuYXNzZXJ0SW52YXJpYW50cyA9IGZhbHNlO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBldmVyeSBvdGhlciBpdGVtLlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0TWF4KGFycmF5LCBjb21wYXJhdG9yKSB7XHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBtYXggPSBhcnJheVswXTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gYXJyYXlbaV07XHJcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgbWF4KSA+IDApIHtcclxuICAgICAgICAgICAgbWF4ID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF4O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGl0ZW0gdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gZXZlcnkgb3RoZXIgaXRlbS5cclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0TWF4KGFycmF5LCBjb21wYXJhdG9yKSB7XHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBtYXggPSBhcnJheVswXTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gYXJyYXlbaV07XHJcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgbWF4KSA+PSAwKSB7XHJcbiAgICAgICAgICAgIG1heCA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGF0IGlzIGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBldmVyeSBvdGhlciBpdGVtLlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0TWluKGFycmF5LCBjb21wYXJhdG9yKSB7XHJcbiAgICByZXR1cm4gZmluZEZpcnN0TWF4KGFycmF5LCAoYSwgYikgPT4gLWNvbXBhcmF0b3IoYSwgYikpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF4SWR4KGFycmF5LCBjb21wYXJhdG9yKSB7XHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgbGV0IG1heElkeCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycmF5W2ldO1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGl0ZW0sIGFycmF5W21heElkeF0pID4gMCkge1xyXG4gICAgICAgICAgICBtYXhJZHggPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXhJZHg7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IG1hcHBlZCB2YWx1ZSBvZiB0aGUgYXJyYXkgd2hpY2ggaXMgbm90IHVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBGaW5kRmlyc3QoaXRlbXMsIG1hcEZuKSB7XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZW1zKSB7XHJcbiAgICAgICAgY29uc3QgbWFwcGVkID0gbWFwRm4odmFsdWUpO1xyXG4gICAgICAgIGlmIChtYXBwZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwcGVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/assert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/assert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertFn: () => (/* binding */ assertFn),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   checkAdjacentItems: () => (/* binding */ checkAdjacentItems),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   softAssert: () => (/* binding */ softAssert)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\r\n *\r\n * @deprecated Use `assert(...)` instead.\r\n * This method is usually used like this:\r\n * ```ts\r\n * import * as assert from 'vs/base/common/assert';\r\n * assert.ok(...);\r\n * ```\r\n *\r\n * However, `assert` in that example is a user chosen name.\r\n * There is no tooling for generating such an import statement.\r\n * Thus, the `assert(...)` function should be used instead.\r\n */\r\nfunction ok(value, message) {\r\n    if (!value) {\r\n        throw new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\r\n    }\r\n}\r\nfunction assertNever(value, message = 'Unreachable') {\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Like assert, but doesn't throw.\r\n */\r\nfunction softAssert(condition) {\r\n    if (!condition) {\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Soft Assertion Failed'));\r\n    }\r\n}\r\n/**\r\n * condition must be side-effect free!\r\n */\r\nfunction assertFn(condition) {\r\n    if (!condition()) {\r\n        // eslint-disable-next-line no-debugger\r\n        debugger;\r\n        // Reevaluate `condition` again to make debugging easier\r\n        condition();\r\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Assertion Failed'));\r\n    }\r\n}\r\nfunction checkAdjacentItems(items, predicate) {\r\n    let i = 0;\r\n    while (i < items.length - 1) {\r\n        const a = items[i];\r\n        const b = items[i + 1];\r\n        if (!predicate(a, b)) {\r\n            return false;\r\n        }\r\n        i++;\r\n    }\r\n    return true;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLDZEQUFpQixLQUFLLDBEQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBaUIsS0FBSywwREFBa0I7QUFDaEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hc3NlcnQuanM/MTU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yLCBvblVuZXhwZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBldmFsdWF0ZSB0byBhIHRydWUgSmF2YXNjcmlwdCB2YWx1ZS5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgVXNlIGBhc3NlcnQoLi4uKWAgaW5zdGVhZC5cclxuICogVGhpcyBtZXRob2QgaXMgdXN1YWxseSB1c2VkIGxpa2UgdGhpczpcclxuICogYGBgdHNcclxuICogaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ3ZzL2Jhc2UvY29tbW9uL2Fzc2VydCc7XHJcbiAqIGFzc2VydC5vayguLi4pO1xyXG4gKiBgYGBcclxuICpcclxuICogSG93ZXZlciwgYGFzc2VydGAgaW4gdGhhdCBleGFtcGxlIGlzIGEgdXNlciBjaG9zZW4gbmFtZS5cclxuICogVGhlcmUgaXMgbm8gdG9vbGluZyBmb3IgZ2VuZXJhdGluZyBzdWNoIGFuIGltcG9ydCBzdGF0ZW1lbnQuXHJcbiAqIFRodXMsIHRoZSBgYXNzZXJ0KC4uLilgIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSA/IGBBc3NlcnRpb24gZmFpbGVkICgke21lc3NhZ2V9KWAgOiAnQXNzZXJ0aW9uIEZhaWxlZCcpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZSwgbWVzc2FnZSA9ICdVbnJlYWNoYWJsZScpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxufVxyXG4vKipcclxuICogTGlrZSBhc3NlcnQsIGJ1dCBkb2Vzbid0IHRocm93LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNvZnRBc3NlcnQoY29uZGl0aW9uKSB7XHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIG9uVW5leHBlY3RlZEVycm9yKG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ1NvZnQgQXNzZXJ0aW9uIEZhaWxlZCcpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogY29uZGl0aW9uIG11c3QgYmUgc2lkZS1lZmZlY3QgZnJlZSFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGbihjb25kaXRpb24pIHtcclxuICAgIGlmICghY29uZGl0aW9uKCkpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAvLyBSZWV2YWx1YXRlIGBjb25kaXRpb25gIGFnYWluIHRvIG1ha2UgZGVidWdnaW5nIGVhc2llclxyXG4gICAgICAgIGNvbmRpdGlvbigpO1xyXG4gICAgICAgIG9uVW5leHBlY3RlZEVycm9yKG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ0Fzc2VydGlvbiBGYWlsZWQnKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQWRqYWNlbnRJdGVtcyhpdGVtcywgcHJlZGljYXRlKSB7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGl0ZW1zLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBjb25zdCBhID0gaXRlbXNbaV07XHJcbiAgICAgICAgY29uc3QgYiA9IGl0ZW1zW2kgKyAxXTtcclxuICAgICAgICBpZiAoIXByZWRpY2F0ZShhLCBiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/assert.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/cache.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedFunction: () => (/* binding */ CachedFunction),\n/* harmony export */   LRUCachedFunction: () => (/* binding */ LRUCachedFunction),\n/* harmony export */   identity: () => (/* binding */ identity)\n/* harmony export */ });\nfunction identity(t) {\r\n    return t;\r\n}\r\n/**\r\n * Uses a LRU cache to make a given parametrized function cached.\r\n * Caches just the last key/value.\r\n*/\r\nclass LRUCachedFunction {\r\n    constructor(arg1, arg2) {\r\n        this.lastCache = undefined;\r\n        this.lastArgKey = undefined;\r\n        if (typeof arg1 === 'function') {\r\n            this._fn = arg1;\r\n            this._computeKey = identity;\r\n        }\r\n        else {\r\n            this._fn = arg2;\r\n            this._computeKey = arg1.getCacheKey;\r\n        }\r\n    }\r\n    get(arg) {\r\n        const key = this._computeKey(arg);\r\n        if (this.lastArgKey !== key) {\r\n            this.lastArgKey = key;\r\n            this.lastCache = this._fn(arg);\r\n        }\r\n        return this.lastCache;\r\n    }\r\n}\r\n/**\r\n * Uses an unbounded cache to memoize the results of the given function.\r\n*/\r\nclass CachedFunction {\r\n    get cachedValues() {\r\n        return this._map;\r\n    }\r\n    constructor(arg1, arg2) {\r\n        this._map = new Map();\r\n        this._map2 = new Map();\r\n        if (typeof arg1 === 'function') {\r\n            this._fn = arg1;\r\n            this._computeKey = identity;\r\n        }\r\n        else {\r\n            this._fn = arg2;\r\n            this._computeKey = arg1.getCacheKey;\r\n        }\r\n    }\r\n    get(arg) {\r\n        const key = this._computeKey(arg);\r\n        if (this._map2.has(key)) {\r\n            return this._map2.get(key);\r\n        }\r\n        const value = this._fn(arg);\r\n        this._map.set(arg, value);\r\n        this._map2.set(key, value);\r\n        return value;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY2FjaGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jYWNoZS5qcz9hYmFkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eSh0KSB7XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG4vKipcclxuICogVXNlcyBhIExSVSBjYWNoZSB0byBtYWtlIGEgZ2l2ZW4gcGFyYW1ldHJpemVkIGZ1bmN0aW9uIGNhY2hlZC5cclxuICogQ2FjaGVzIGp1c3QgdGhlIGxhc3Qga2V5L3ZhbHVlLlxyXG4qL1xyXG5leHBvcnQgY2xhc3MgTFJVQ2FjaGVkRnVuY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoYXJnMSwgYXJnMikge1xyXG4gICAgICAgIHRoaXMubGFzdENhY2hlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubGFzdEFyZ0tleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm4gPSBhcmcxO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wdXRlS2V5ID0gaWRlbnRpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9mbiA9IGFyZzI7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVLZXkgPSBhcmcxLmdldENhY2hlS2V5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldChhcmcpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9jb21wdXRlS2V5KGFyZyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdEFyZ0tleSAhPT0ga2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEFyZ0tleSA9IGtleTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q2FjaGUgPSB0aGlzLl9mbihhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2FjaGU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVzZXMgYW4gdW5ib3VuZGVkIGNhY2hlIHRvIG1lbW9pemUgdGhlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLlxyXG4qL1xyXG5leHBvcnQgY2xhc3MgQ2FjaGVkRnVuY3Rpb24ge1xyXG4gICAgZ2V0IGNhY2hlZFZhbHVlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoYXJnMSwgYXJnMikge1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9tYXAyID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLl9mbiA9IGFyZzE7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVLZXkgPSBpZGVudGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZuID0gYXJnMjtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUtleSA9IGFyZzEuZ2V0Q2FjaGVLZXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KGFyZykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX2NvbXB1dGVLZXkoYXJnKTtcclxuICAgICAgICBpZiAodGhpcy5fbWFwMi5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwMi5nZXQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9mbihhcmcpO1xyXG4gICAgICAgIHRoaXMuX21hcC5zZXQoYXJnLCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fbWFwMi5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/cache.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancellationToken: () => (/* binding */ CancellationToken),\n/* harmony export */   CancellationTokenSource: () => (/* binding */ CancellationTokenSource),\n/* harmony export */   cancelOnDispose: () => (/* binding */ cancelOnDispose)\n/* harmony export */ });\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nconst shortcutEvent = Object.freeze(function (callback, context) {\r\n    const handle = setTimeout(callback.bind(context), 0);\r\n    return { dispose() { clearTimeout(handle); } };\r\n});\r\nvar CancellationToken;\r\n(function (CancellationToken) {\r\n    function isCancellationToken(thing) {\r\n        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\r\n            return true;\r\n        }\r\n        if (thing instanceof MutableToken) {\r\n            return true;\r\n        }\r\n        if (!thing || typeof thing !== 'object') {\r\n            return false;\r\n        }\r\n        return typeof thing.isCancellationRequested === 'boolean'\r\n            && typeof thing.onCancellationRequested === 'function';\r\n    }\r\n    CancellationToken.isCancellationToken = isCancellationToken;\r\n    CancellationToken.None = Object.freeze({\r\n        isCancellationRequested: false,\r\n        onCancellationRequested: _event_js__WEBPACK_IMPORTED_MODULE_0__.Event.None\r\n    });\r\n    CancellationToken.Cancelled = Object.freeze({\r\n        isCancellationRequested: true,\r\n        onCancellationRequested: shortcutEvent\r\n    });\r\n})(CancellationToken || (CancellationToken = {}));\r\nclass MutableToken {\r\n    constructor() {\r\n        this._isCancelled = false;\r\n        this._emitter = null;\r\n    }\r\n    cancel() {\r\n        if (!this._isCancelled) {\r\n            this._isCancelled = true;\r\n            if (this._emitter) {\r\n                this._emitter.fire(undefined);\r\n                this.dispose();\r\n            }\r\n        }\r\n    }\r\n    get isCancellationRequested() {\r\n        return this._isCancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        if (this._isCancelled) {\r\n            return shortcutEvent;\r\n        }\r\n        if (!this._emitter) {\r\n            this._emitter = new _event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();\r\n        }\r\n        return this._emitter.event;\r\n    }\r\n    dispose() {\r\n        if (this._emitter) {\r\n            this._emitter.dispose();\r\n            this._emitter = null;\r\n        }\r\n    }\r\n}\r\nclass CancellationTokenSource {\r\n    constructor(parent) {\r\n        this._token = undefined;\r\n        this._parentListener = undefined;\r\n        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\r\n    }\r\n    get token() {\r\n        if (!this._token) {\r\n            // be lazy and create the token only when\r\n            // actually needed\r\n            this._token = new MutableToken();\r\n        }\r\n        return this._token;\r\n    }\r\n    cancel() {\r\n        if (!this._token) {\r\n            // save an object by returning the default\r\n            // cancelled token when cancellation happens\r\n            // before someone asks for the token\r\n            this._token = CancellationToken.Cancelled;\r\n        }\r\n        else if (this._token instanceof MutableToken) {\r\n            // actually cancel\r\n            this._token.cancel();\r\n        }\r\n    }\r\n    dispose(cancel = false) {\r\n        var _a;\r\n        if (cancel) {\r\n            this.cancel();\r\n        }\r\n        (_a = this._parentListener) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        if (!this._token) {\r\n            // ensure to initialize with an empty token if we had none\r\n            this._token = CancellationToken.None;\r\n        }\r\n        else if (this._token instanceof MutableToken) {\r\n            // actually dispose\r\n            this._token.dispose();\r\n        }\r\n    }\r\n}\r\nfunction cancelOnDispose(store) {\r\n    const source = new CancellationTokenSource();\r\n    store.add({ dispose() { source.cancel(); } });\r\n    return source.token;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM1QztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQUs7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDaEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jYW5jZWxsYXRpb24uanM/MjUwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgRW1pdHRlciwgRXZlbnQgfSBmcm9tICcuL2V2ZW50LmpzJztcclxuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQoY29udGV4dCksIDApO1xyXG4gICAgcmV0dXJuIHsgZGlzcG9zZSgpIHsgY2xlYXJUaW1lb3V0KGhhbmRsZSk7IH0gfTtcclxufSk7XHJcbmV4cG9ydCB2YXIgQ2FuY2VsbGF0aW9uVG9rZW47XHJcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uVG9rZW4pIHtcclxuICAgIGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uVG9rZW4odGhpbmcpIHtcclxuICAgICAgICBpZiAodGhpbmcgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmUgfHwgdGhpbmcgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaW5nIHx8IHR5cGVvZiB0aGluZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkID09PSAnYm9vbGVhbidcclxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uaXNDYW5jZWxsYXRpb25Ub2tlbiA9IGlzQ2FuY2VsbGF0aW9uVG9rZW47XHJcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBFdmVudC5Ob25lXHJcbiAgICB9KTtcclxuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxyXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBzaG9ydGN1dEV2ZW50XHJcbiAgICB9KTtcclxufSkoQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKENhbmNlbGxhdGlvblRva2VuID0ge30pKTtcclxuY2xhc3MgTXV0YWJsZVRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcclxuICAgIH1cclxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENhbmNlbGxhdGlvblRva2VuU291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuX3Rva2VuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gcGFyZW50ICYmIHBhcmVudC5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCh0aGlzLmNhbmNlbCwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgdG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xyXG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxyXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xyXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rva2VuIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGNhbmNlbFxyXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKGNhbmNlbCA9IGZhbHNlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChjYW5jZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5fcGFyZW50TGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxyXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxPbkRpc3Bvc2Uoc3RvcmUpIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xyXG4gICAgc3RvcmUuYWRkKHsgZGlzcG9zZSgpIHsgc291cmNlLmNhbmNlbCgpOyB9IH0pO1xyXG4gICAgcmV0dXJuIHNvdXJjZS50b2tlbjtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/codicons.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/codicons.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Codicon: () => (/* binding */ Codicon),\n/* harmony export */   codiconsDerived: () => (/* binding */ codiconsDerived)\n/* harmony export */ });\n/* harmony import */ var _codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codiconsUtil.js */ \"./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js\");\n/* harmony import */ var _codiconsLibrary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codiconsLibrary.js */ \"./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js\");\n\r\n\r\n/**\r\n * Derived icons, that could become separate icons.\r\n * These mappings should be moved into the mapping file in the vscode-codicons repo at some point.\r\n */\r\nconst codiconsDerived = {\r\n    dialogError: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-error', 'error'),\r\n    dialogWarning: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-warning', 'warning'),\r\n    dialogInfo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-info', 'info'),\r\n    dialogClose: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dialog-close', 'close'),\r\n    treeItemExpanded: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-item-expanded', 'chevron-down'), // collapsed is done with rotation\r\n    treeFilterOnTypeOn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-filter-on-type-on', 'list-filter'),\r\n    treeFilterOnTypeOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-filter-on-type-off', 'list-selection'),\r\n    treeFilterClear: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-filter-clear', 'close'),\r\n    treeItemLoading: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tree-item-loading', 'loading'),\r\n    menuSelection: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menu-selection', 'check'),\r\n    menuSubmenu: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menu-submenu', 'chevron-right'),\r\n    menuBarMore: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menubar-more', 'more'),\r\n    scrollbarButtonLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-left', 'triangle-left'),\r\n    scrollbarButtonRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-right', 'triangle-right'),\r\n    scrollbarButtonUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-up', 'triangle-up'),\r\n    scrollbarButtonDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('scrollbar-button-down', 'triangle-down'),\r\n    toolBarMore: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('toolbar-more', 'more'),\r\n    quickInputBack: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('quick-input-back', 'arrow-left'),\r\n    dropDownButton: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('drop-down-button', 0xeab4),\r\n    symbolCustomColor: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-customcolor', 0xeb5c),\r\n    exportIcon: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('export', 0xebac),\r\n    workspaceUnspecified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-unspecified', 0xebc3),\r\n    newLine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('newline', 0xebea),\r\n    thumbsDownFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsdown-filled', 0xec13),\r\n    thumbsUpFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsup-filled', 0xec14),\r\n    gitFetch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-fetch', 0xec1d),\r\n    lightbulbSparkleAutofix: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb-sparkle-autofix', 0xec1f),\r\n    debugBreakpointPending: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-pending', 0xebd9),\r\n};\r\n/**\r\n * The Codicon library is a set of default icons that are built-in in VS Code.\r\n *\r\n * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code\r\n * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.\r\n * In that call a Codicon can be named as default.\r\n */\r\nconst Codicon = {\r\n    ..._codiconsLibrary_js__WEBPACK_IMPORTED_MODULE_1__.codiconsLibrary,\r\n    ...codiconsDerived\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2QztBQUNVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsMERBQVE7QUFDekIsbUJBQW1CLDBEQUFRO0FBQzNCLGdCQUFnQiwwREFBUTtBQUN4QixpQkFBaUIsMERBQVE7QUFDekIsc0JBQXNCLDBEQUFRO0FBQzlCLHdCQUF3QiwwREFBUTtBQUNoQyx5QkFBeUIsMERBQVE7QUFDakMscUJBQXFCLDBEQUFRO0FBQzdCLHFCQUFxQiwwREFBUTtBQUM3QixtQkFBbUIsMERBQVE7QUFDM0IsaUJBQWlCLDBEQUFRO0FBQ3pCLGlCQUFpQiwwREFBUTtBQUN6Qix5QkFBeUIsMERBQVE7QUFDakMsMEJBQTBCLDBEQUFRO0FBQ2xDLHVCQUF1QiwwREFBUTtBQUMvQix5QkFBeUIsMERBQVE7QUFDakMsaUJBQWlCLDBEQUFRO0FBQ3pCLG9CQUFvQiwwREFBUTtBQUM1QixvQkFBb0IsMERBQVE7QUFDNUIsdUJBQXVCLDBEQUFRO0FBQy9CLGdCQUFnQiwwREFBUTtBQUN4QiwwQkFBMEIsMERBQVE7QUFDbEMsYUFBYSwwREFBUTtBQUNyQixzQkFBc0IsMERBQVE7QUFDOUIsb0JBQW9CLDBEQUFRO0FBQzVCLGNBQWMsMERBQVE7QUFDdEIsNkJBQTZCLDBEQUFRO0FBQ3JDLDRCQUE0QiwwREFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxPQUFPLGdFQUFlO0FBQ3RCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnMuanM/NTYxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4vY29kaWNvbnNVdGlsLmpzJztcclxuaW1wb3J0IHsgY29kaWNvbnNMaWJyYXJ5IH0gZnJvbSAnLi9jb2RpY29uc0xpYnJhcnkuanMnO1xyXG4vKipcclxuICogRGVyaXZlZCBpY29ucywgdGhhdCBjb3VsZCBiZWNvbWUgc2VwYXJhdGUgaWNvbnMuXHJcbiAqIFRoZXNlIG1hcHBpbmdzIHNob3VsZCBiZSBtb3ZlZCBpbnRvIHRoZSBtYXBwaW5nIGZpbGUgaW4gdGhlIHZzY29kZS1jb2RpY29ucyByZXBvIGF0IHNvbWUgcG9pbnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29kaWNvbnNEZXJpdmVkID0ge1xyXG4gICAgZGlhbG9nRXJyb3I6IHJlZ2lzdGVyKCdkaWFsb2ctZXJyb3InLCAnZXJyb3InKSxcclxuICAgIGRpYWxvZ1dhcm5pbmc6IHJlZ2lzdGVyKCdkaWFsb2ctd2FybmluZycsICd3YXJuaW5nJyksXHJcbiAgICBkaWFsb2dJbmZvOiByZWdpc3RlcignZGlhbG9nLWluZm8nLCAnaW5mbycpLFxyXG4gICAgZGlhbG9nQ2xvc2U6IHJlZ2lzdGVyKCdkaWFsb2ctY2xvc2UnLCAnY2xvc2UnKSxcclxuICAgIHRyZWVJdGVtRXhwYW5kZWQ6IHJlZ2lzdGVyKCd0cmVlLWl0ZW0tZXhwYW5kZWQnLCAnY2hldnJvbi1kb3duJyksIC8vIGNvbGxhcHNlZCBpcyBkb25lIHdpdGggcm90YXRpb25cclxuICAgIHRyZWVGaWx0ZXJPblR5cGVPbjogcmVnaXN0ZXIoJ3RyZWUtZmlsdGVyLW9uLXR5cGUtb24nLCAnbGlzdC1maWx0ZXInKSxcclxuICAgIHRyZWVGaWx0ZXJPblR5cGVPZmY6IHJlZ2lzdGVyKCd0cmVlLWZpbHRlci1vbi10eXBlLW9mZicsICdsaXN0LXNlbGVjdGlvbicpLFxyXG4gICAgdHJlZUZpbHRlckNsZWFyOiByZWdpc3RlcigndHJlZS1maWx0ZXItY2xlYXInLCAnY2xvc2UnKSxcclxuICAgIHRyZWVJdGVtTG9hZGluZzogcmVnaXN0ZXIoJ3RyZWUtaXRlbS1sb2FkaW5nJywgJ2xvYWRpbmcnKSxcclxuICAgIG1lbnVTZWxlY3Rpb246IHJlZ2lzdGVyKCdtZW51LXNlbGVjdGlvbicsICdjaGVjaycpLFxyXG4gICAgbWVudVN1Ym1lbnU6IHJlZ2lzdGVyKCdtZW51LXN1Ym1lbnUnLCAnY2hldnJvbi1yaWdodCcpLFxyXG4gICAgbWVudUJhck1vcmU6IHJlZ2lzdGVyKCdtZW51YmFyLW1vcmUnLCAnbW9yZScpLFxyXG4gICAgc2Nyb2xsYmFyQnV0dG9uTGVmdDogcmVnaXN0ZXIoJ3Njcm9sbGJhci1idXR0b24tbGVmdCcsICd0cmlhbmdsZS1sZWZ0JyksXHJcbiAgICBzY3JvbGxiYXJCdXR0b25SaWdodDogcmVnaXN0ZXIoJ3Njcm9sbGJhci1idXR0b24tcmlnaHQnLCAndHJpYW5nbGUtcmlnaHQnKSxcclxuICAgIHNjcm9sbGJhckJ1dHRvblVwOiByZWdpc3Rlcignc2Nyb2xsYmFyLWJ1dHRvbi11cCcsICd0cmlhbmdsZS11cCcpLFxyXG4gICAgc2Nyb2xsYmFyQnV0dG9uRG93bjogcmVnaXN0ZXIoJ3Njcm9sbGJhci1idXR0b24tZG93bicsICd0cmlhbmdsZS1kb3duJyksXHJcbiAgICB0b29sQmFyTW9yZTogcmVnaXN0ZXIoJ3Rvb2xiYXItbW9yZScsICdtb3JlJyksXHJcbiAgICBxdWlja0lucHV0QmFjazogcmVnaXN0ZXIoJ3F1aWNrLWlucHV0LWJhY2snLCAnYXJyb3ctbGVmdCcpLFxyXG4gICAgZHJvcERvd25CdXR0b246IHJlZ2lzdGVyKCdkcm9wLWRvd24tYnV0dG9uJywgMHhlYWI0KSxcclxuICAgIHN5bWJvbEN1c3RvbUNvbG9yOiByZWdpc3Rlcignc3ltYm9sLWN1c3RvbWNvbG9yJywgMHhlYjVjKSxcclxuICAgIGV4cG9ydEljb246IHJlZ2lzdGVyKCdleHBvcnQnLCAweGViYWMpLFxyXG4gICAgd29ya3NwYWNlVW5zcGVjaWZpZWQ6IHJlZ2lzdGVyKCd3b3Jrc3BhY2UtdW5zcGVjaWZpZWQnLCAweGViYzMpLFxyXG4gICAgbmV3TGluZTogcmVnaXN0ZXIoJ25ld2xpbmUnLCAweGViZWEpLFxyXG4gICAgdGh1bWJzRG93bkZpbGxlZDogcmVnaXN0ZXIoJ3RodW1ic2Rvd24tZmlsbGVkJywgMHhlYzEzKSxcclxuICAgIHRodW1ic1VwRmlsbGVkOiByZWdpc3RlcigndGh1bWJzdXAtZmlsbGVkJywgMHhlYzE0KSxcclxuICAgIGdpdEZldGNoOiByZWdpc3RlcignZ2l0LWZldGNoJywgMHhlYzFkKSxcclxuICAgIGxpZ2h0YnVsYlNwYXJrbGVBdXRvZml4OiByZWdpc3RlcignbGlnaHRidWxiLXNwYXJrbGUtYXV0b2ZpeCcsIDB4ZWMxZiksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRQZW5kaW5nOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1wZW5kaW5nJywgMHhlYmQ5KSxcclxufTtcclxuLyoqXHJcbiAqIFRoZSBDb2RpY29uIGxpYnJhcnkgaXMgYSBzZXQgb2YgZGVmYXVsdCBpY29ucyB0aGF0IGFyZSBidWlsdC1pbiBpbiBWUyBDb2RlLlxyXG4gKlxyXG4gKiBJbiB0aGUgcHJvZHVjdCAob3V0c2lkZSBvZiBiYXNlKSBDb2RpY29ucyBzaG91bGQgb25seSBiZSB1c2VkIGFzIGRlZmF1bHRzLiBJbiBvcmRlciB0byBoYXZlIGFsbCBpY29ucyBpbiBWUyBDb2RlXHJcbiAqIHRoZW1lYWJsZSwgY29tcG9uZW50IHNob3VsZCBkZWZpbmUgbmV3LCBVSSBjb21wb25lbnQgc3BlY2lmaWMgaWNvbnMgdXNpbmcgYGljb25SZWdpc3RyeS5yZWdpc3Rlckljb25gLlxyXG4gKiBJbiB0aGF0IGNhbGwgYSBDb2RpY29uIGNhbiBiZSBuYW1lZCBhcyBkZWZhdWx0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENvZGljb24gPSB7XHJcbiAgICAuLi5jb2RpY29uc0xpYnJhcnksXHJcbiAgICAuLi5jb2RpY29uc0Rlcml2ZWRcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/codicons.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codiconsLibrary: () => (/* binding */ codiconsLibrary)\n/* harmony export */ });\n/* harmony import */ var _codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codiconsUtil.js */ \"./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n// This file is automatically generated by (microsoft/vscode-codicons)/scripts/export-to-ts.js\r\n// Please don't edit it, as your changes will be overwritten.\r\n// Instead, add mappings to codiconsDerived in codicons.ts.\r\nconst codiconsLibrary = {\r\n    add: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('add', 0xea60),\r\n    plus: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('plus', 0xea60),\r\n    gistNew: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-new', 0xea60),\r\n    repoCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-create', 0xea60),\r\n    lightbulb: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb', 0xea61),\r\n    lightBulb: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('light-bulb', 0xea61),\r\n    repo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo', 0xea62),\r\n    repoDelete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-delete', 0xea62),\r\n    gistFork: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-fork', 0xea63),\r\n    repoForked: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-forked', 0xea63),\r\n    gitPullRequest: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request', 0xea64),\r\n    gitPullRequestAbandoned: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-abandoned', 0xea64),\r\n    recordKeys: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('record-keys', 0xea65),\r\n    keyboard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('keyboard', 0xea65),\r\n    tag: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tag', 0xea66),\r\n    gitPullRequestLabel: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-label', 0xea66),\r\n    tagAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tag-add', 0xea66),\r\n    tagRemove: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tag-remove', 0xea66),\r\n    person: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person', 0xea67),\r\n    personFollow: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-follow', 0xea67),\r\n    personOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-outline', 0xea67),\r\n    personFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-filled', 0xea67),\r\n    gitBranch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-branch', 0xea68),\r\n    gitBranchCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-branch-create', 0xea68),\r\n    gitBranchDelete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-branch-delete', 0xea68),\r\n    sourceControl: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('source-control', 0xea68),\r\n    mirror: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mirror', 0xea69),\r\n    mirrorPublic: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mirror-public', 0xea69),\r\n    star: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star', 0xea6a),\r\n    starAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-add', 0xea6a),\r\n    starDelete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-delete', 0xea6a),\r\n    starEmpty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-empty', 0xea6a),\r\n    comment: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment', 0xea6b),\r\n    commentAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-add', 0xea6b),\r\n    alert: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('alert', 0xea6c),\r\n    warning: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('warning', 0xea6c),\r\n    search: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search', 0xea6d),\r\n    searchSave: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search-save', 0xea6d),\r\n    logOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('log-out', 0xea6e),\r\n    signOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sign-out', 0xea6e),\r\n    logIn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('log-in', 0xea6f),\r\n    signIn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sign-in', 0xea6f),\r\n    eye: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye', 0xea70),\r\n    eyeUnwatch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye-unwatch', 0xea70),\r\n    eyeWatch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye-watch', 0xea70),\r\n    circleFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-filled', 0xea71),\r\n    primitiveDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('primitive-dot', 0xea71),\r\n    closeDirty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('close-dirty', 0xea71),\r\n    debugBreakpoint: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint', 0xea71),\r\n    debugBreakpointDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-disabled', 0xea71),\r\n    debugHint: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-hint', 0xea71),\r\n    terminalDecorationSuccess: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-success', 0xea71),\r\n    primitiveSquare: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('primitive-square', 0xea72),\r\n    edit: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('edit', 0xea73),\r\n    pencil: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pencil', 0xea73),\r\n    info: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('info', 0xea74),\r\n    issueOpened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-opened', 0xea74),\r\n    gistPrivate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-private', 0xea75),\r\n    gitForkPrivate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-fork-private', 0xea75),\r\n    lock: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lock', 0xea75),\r\n    mirrorPrivate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mirror-private', 0xea75),\r\n    close: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('close', 0xea76),\r\n    removeClose: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remove-close', 0xea76),\r\n    x: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('x', 0xea76),\r\n    repoSync: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-sync', 0xea77),\r\n    sync: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sync', 0xea77),\r\n    clone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clone', 0xea78),\r\n    desktopDownload: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('desktop-download', 0xea78),\r\n    beaker: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('beaker', 0xea79),\r\n    microscope: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('microscope', 0xea79),\r\n    vm: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm', 0xea7a),\r\n    deviceDesktop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-desktop', 0xea7a),\r\n    file: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file', 0xea7b),\r\n    fileText: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-text', 0xea7b),\r\n    more: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('more', 0xea7c),\r\n    ellipsis: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('ellipsis', 0xea7c),\r\n    kebabHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('kebab-horizontal', 0xea7c),\r\n    mailReply: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mail-reply', 0xea7d),\r\n    reply: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('reply', 0xea7d),\r\n    organization: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('organization', 0xea7e),\r\n    organizationFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('organization-filled', 0xea7e),\r\n    organizationOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('organization-outline', 0xea7e),\r\n    newFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('new-file', 0xea7f),\r\n    fileAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-add', 0xea7f),\r\n    newFolder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('new-folder', 0xea80),\r\n    fileDirectoryCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-directory-create', 0xea80),\r\n    trash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('trash', 0xea81),\r\n    trashcan: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('trashcan', 0xea81),\r\n    history: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('history', 0xea82),\r\n    clock: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clock', 0xea82),\r\n    folder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder', 0xea83),\r\n    fileDirectory: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-directory', 0xea83),\r\n    symbolFolder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-folder', 0xea83),\r\n    logoGithub: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('logo-github', 0xea84),\r\n    markGithub: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mark-github', 0xea84),\r\n    github: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github', 0xea84),\r\n    terminal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal', 0xea85),\r\n    console: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('console', 0xea85),\r\n    repl: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repl', 0xea85),\r\n    zap: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('zap', 0xea86),\r\n    symbolEvent: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-event', 0xea86),\r\n    error: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('error', 0xea87),\r\n    stop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('stop', 0xea87),\r\n    variable: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('variable', 0xea88),\r\n    symbolVariable: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-variable', 0xea88),\r\n    array: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('array', 0xea8a),\r\n    symbolArray: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-array', 0xea8a),\r\n    symbolModule: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-module', 0xea8b),\r\n    symbolPackage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-package', 0xea8b),\r\n    symbolNamespace: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-namespace', 0xea8b),\r\n    symbolObject: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-object', 0xea8b),\r\n    symbolMethod: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-method', 0xea8c),\r\n    symbolFunction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-function', 0xea8c),\r\n    symbolConstructor: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-constructor', 0xea8c),\r\n    symbolBoolean: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-boolean', 0xea8f),\r\n    symbolNull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-null', 0xea8f),\r\n    symbolNumeric: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-numeric', 0xea90),\r\n    symbolNumber: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-number', 0xea90),\r\n    symbolStructure: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-structure', 0xea91),\r\n    symbolStruct: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-struct', 0xea91),\r\n    symbolParameter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-parameter', 0xea92),\r\n    symbolTypeParameter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-type-parameter', 0xea92),\r\n    symbolKey: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-key', 0xea93),\r\n    symbolText: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-text', 0xea93),\r\n    symbolReference: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-reference', 0xea94),\r\n    goToFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('go-to-file', 0xea94),\r\n    symbolEnum: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-enum', 0xea95),\r\n    symbolValue: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-value', 0xea95),\r\n    symbolRuler: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-ruler', 0xea96),\r\n    symbolUnit: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-unit', 0xea96),\r\n    activateBreakpoints: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('activate-breakpoints', 0xea97),\r\n    archive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('archive', 0xea98),\r\n    arrowBoth: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-both', 0xea99),\r\n    arrowDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-down', 0xea9a),\r\n    arrowLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-left', 0xea9b),\r\n    arrowRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-right', 0xea9c),\r\n    arrowSmallDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-down', 0xea9d),\r\n    arrowSmallLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-left', 0xea9e),\r\n    arrowSmallRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-right', 0xea9f),\r\n    arrowSmallUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-small-up', 0xeaa0),\r\n    arrowUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-up', 0xeaa1),\r\n    bell: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell', 0xeaa2),\r\n    bold: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bold', 0xeaa3),\r\n    book: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('book', 0xeaa4),\r\n    bookmark: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bookmark', 0xeaa5),\r\n    debugBreakpointConditionalUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-conditional-unverified', 0xeaa6),\r\n    debugBreakpointConditional: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-conditional', 0xeaa7),\r\n    debugBreakpointConditionalDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-conditional-disabled', 0xeaa7),\r\n    debugBreakpointDataUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-data-unverified', 0xeaa8),\r\n    debugBreakpointData: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-data', 0xeaa9),\r\n    debugBreakpointDataDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-data-disabled', 0xeaa9),\r\n    debugBreakpointLogUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-log-unverified', 0xeaaa),\r\n    debugBreakpointLog: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-log', 0xeaab),\r\n    debugBreakpointLogDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-log-disabled', 0xeaab),\r\n    briefcase: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('briefcase', 0xeaac),\r\n    broadcast: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('broadcast', 0xeaad),\r\n    browser: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('browser', 0xeaae),\r\n    bug: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bug', 0xeaaf),\r\n    calendar: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('calendar', 0xeab0),\r\n    caseSensitive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('case-sensitive', 0xeab1),\r\n    check: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('check', 0xeab2),\r\n    checklist: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('checklist', 0xeab3),\r\n    chevronDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-down', 0xeab4),\r\n    chevronLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-left', 0xeab5),\r\n    chevronRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-right', 0xeab6),\r\n    chevronUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chevron-up', 0xeab7),\r\n    chromeClose: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-close', 0xeab8),\r\n    chromeMaximize: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-maximize', 0xeab9),\r\n    chromeMinimize: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-minimize', 0xeaba),\r\n    chromeRestore: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chrome-restore', 0xeabb),\r\n    circleOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-outline', 0xeabc),\r\n    circle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle', 0xeabc),\r\n    debugBreakpointUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-unverified', 0xeabc),\r\n    terminalDecorationIncomplete: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-incomplete', 0xeabc),\r\n    circleSlash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-slash', 0xeabd),\r\n    circuitBoard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circuit-board', 0xeabe),\r\n    clearAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clear-all', 0xeabf),\r\n    clippy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('clippy', 0xeac0),\r\n    closeAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('close-all', 0xeac1),\r\n    cloudDownload: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('cloud-download', 0xeac2),\r\n    cloudUpload: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('cloud-upload', 0xeac3),\r\n    code: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('code', 0xeac4),\r\n    collapseAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('collapse-all', 0xeac5),\r\n    colorMode: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('color-mode', 0xeac6),\r\n    commentDiscussion: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-discussion', 0xeac7),\r\n    creditCard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('credit-card', 0xeac9),\r\n    dash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dash', 0xeacc),\r\n    dashboard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('dashboard', 0xeacd),\r\n    database: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('database', 0xeace),\r\n    debugContinue: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-continue', 0xeacf),\r\n    debugDisconnect: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-disconnect', 0xead0),\r\n    debugPause: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-pause', 0xead1),\r\n    debugRestart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-restart', 0xead2),\r\n    debugStart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-start', 0xead3),\r\n    debugStepInto: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-into', 0xead4),\r\n    debugStepOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-out', 0xead5),\r\n    debugStepOver: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-over', 0xead6),\r\n    debugStop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stop', 0xead7),\r\n    debug: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug', 0xead8),\r\n    deviceCameraVideo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-camera-video', 0xead9),\r\n    deviceCamera: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-camera', 0xeada),\r\n    deviceMobile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('device-mobile', 0xeadb),\r\n    diffAdded: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-added', 0xeadc),\r\n    diffIgnored: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-ignored', 0xeadd),\r\n    diffModified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-modified', 0xeade),\r\n    diffRemoved: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-removed', 0xeadf),\r\n    diffRenamed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-renamed', 0xeae0),\r\n    diff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff', 0xeae1),\r\n    diffSidebyside: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-sidebyside', 0xeae1),\r\n    discard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('discard', 0xeae2),\r\n    editorLayout: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('editor-layout', 0xeae3),\r\n    emptyWindow: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('empty-window', 0xeae4),\r\n    exclude: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('exclude', 0xeae5),\r\n    extensions: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('extensions', 0xeae6),\r\n    eyeClosed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('eye-closed', 0xeae7),\r\n    fileBinary: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-binary', 0xeae8),\r\n    fileCode: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-code', 0xeae9),\r\n    fileMedia: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-media', 0xeaea),\r\n    filePdf: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-pdf', 0xeaeb),\r\n    fileSubmodule: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-submodule', 0xeaec),\r\n    fileSymlinkDirectory: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-symlink-directory', 0xeaed),\r\n    fileSymlinkFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-symlink-file', 0xeaee),\r\n    fileZip: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('file-zip', 0xeaef),\r\n    files: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('files', 0xeaf0),\r\n    filter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('filter', 0xeaf1),\r\n    flame: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('flame', 0xeaf2),\r\n    foldDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-down', 0xeaf3),\r\n    foldUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-up', 0xeaf4),\r\n    fold: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold', 0xeaf5),\r\n    folderActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder-active', 0xeaf6),\r\n    folderOpened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder-opened', 0xeaf7),\r\n    gear: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gear', 0xeaf8),\r\n    gift: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gift', 0xeaf9),\r\n    gistSecret: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist-secret', 0xeafa),\r\n    gist: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gist', 0xeafb),\r\n    gitCommit: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-commit', 0xeafc),\r\n    gitCompare: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-compare', 0xeafd),\r\n    compareChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compare-changes', 0xeafd),\r\n    gitMerge: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-merge', 0xeafe),\r\n    githubAction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-action', 0xeaff),\r\n    githubAlt: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-alt', 0xeb00),\r\n    globe: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('globe', 0xeb01),\r\n    grabber: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('grabber', 0xeb02),\r\n    graph: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph', 0xeb03),\r\n    gripper: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gripper', 0xeb04),\r\n    heart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('heart', 0xeb05),\r\n    home: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('home', 0xeb06),\r\n    horizontalRule: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('horizontal-rule', 0xeb07),\r\n    hubot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('hubot', 0xeb08),\r\n    inbox: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('inbox', 0xeb09),\r\n    issueReopened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-reopened', 0xeb0b),\r\n    issues: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issues', 0xeb0c),\r\n    italic: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('italic', 0xeb0d),\r\n    jersey: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('jersey', 0xeb0e),\r\n    json: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('json', 0xeb0f),\r\n    kebabVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('kebab-vertical', 0xeb10),\r\n    key: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('key', 0xeb11),\r\n    law: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('law', 0xeb12),\r\n    lightbulbAutofix: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb-autofix', 0xeb13),\r\n    linkExternal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('link-external', 0xeb14),\r\n    link: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('link', 0xeb15),\r\n    listOrdered: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-ordered', 0xeb16),\r\n    listUnordered: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-unordered', 0xeb17),\r\n    liveShare: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('live-share', 0xeb18),\r\n    loading: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('loading', 0xeb19),\r\n    location: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('location', 0xeb1a),\r\n    mailRead: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mail-read', 0xeb1b),\r\n    mail: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mail', 0xeb1c),\r\n    markdown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('markdown', 0xeb1d),\r\n    megaphone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('megaphone', 0xeb1e),\r\n    mention: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mention', 0xeb1f),\r\n    milestone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('milestone', 0xeb20),\r\n    gitPullRequestMilestone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-milestone', 0xeb20),\r\n    mortarBoard: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mortar-board', 0xeb21),\r\n    move: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('move', 0xeb22),\r\n    multipleWindows: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('multiple-windows', 0xeb23),\r\n    mute: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mute', 0xeb24),\r\n    noNewline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('no-newline', 0xeb25),\r\n    note: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('note', 0xeb26),\r\n    octoface: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('octoface', 0xeb27),\r\n    openPreview: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('open-preview', 0xeb28),\r\n    package: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('package', 0xeb29),\r\n    paintcan: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('paintcan', 0xeb2a),\r\n    pin: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pin', 0xeb2b),\r\n    play: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('play', 0xeb2c),\r\n    run: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run', 0xeb2c),\r\n    plug: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('plug', 0xeb2d),\r\n    preserveCase: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('preserve-case', 0xeb2e),\r\n    preview: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('preview', 0xeb2f),\r\n    project: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('project', 0xeb30),\r\n    pulse: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pulse', 0xeb31),\r\n    question: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('question', 0xeb32),\r\n    quote: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('quote', 0xeb33),\r\n    radioTower: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('radio-tower', 0xeb34),\r\n    reactions: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('reactions', 0xeb35),\r\n    references: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('references', 0xeb36),\r\n    refresh: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('refresh', 0xeb37),\r\n    regex: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('regex', 0xeb38),\r\n    remoteExplorer: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remote-explorer', 0xeb39),\r\n    remote: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remote', 0xeb3a),\r\n    remove: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('remove', 0xeb3b),\r\n    replaceAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('replace-all', 0xeb3c),\r\n    replace: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('replace', 0xeb3d),\r\n    repoClone: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-clone', 0xeb3e),\r\n    repoForcePush: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-force-push', 0xeb3f),\r\n    repoPull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-pull', 0xeb40),\r\n    repoPush: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-push', 0xeb41),\r\n    report: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('report', 0xeb42),\r\n    requestChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('request-changes', 0xeb43),\r\n    rocket: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('rocket', 0xeb44),\r\n    rootFolderOpened: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('root-folder-opened', 0xeb45),\r\n    rootFolder: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('root-folder', 0xeb46),\r\n    rss: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('rss', 0xeb47),\r\n    ruby: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('ruby', 0xeb48),\r\n    saveAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('save-all', 0xeb49),\r\n    saveAs: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('save-as', 0xeb4a),\r\n    save: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('save', 0xeb4b),\r\n    screenFull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('screen-full', 0xeb4c),\r\n    screenNormal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('screen-normal', 0xeb4d),\r\n    searchStop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search-stop', 0xeb4e),\r\n    server: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('server', 0xeb50),\r\n    settingsGear: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('settings-gear', 0xeb51),\r\n    settings: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('settings', 0xeb52),\r\n    shield: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('shield', 0xeb53),\r\n    smiley: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('smiley', 0xeb54),\r\n    sortPrecedence: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sort-precedence', 0xeb55),\r\n    splitHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('split-horizontal', 0xeb56),\r\n    splitVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('split-vertical', 0xeb57),\r\n    squirrel: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('squirrel', 0xeb58),\r\n    starFull: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-full', 0xeb59),\r\n    starHalf: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('star-half', 0xeb5a),\r\n    symbolClass: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-class', 0xeb5b),\r\n    symbolColor: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-color', 0xeb5c),\r\n    symbolConstant: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-constant', 0xeb5d),\r\n    symbolEnumMember: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-enum-member', 0xeb5e),\r\n    symbolField: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-field', 0xeb5f),\r\n    symbolFile: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-file', 0xeb60),\r\n    symbolInterface: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-interface', 0xeb61),\r\n    symbolKeyword: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-keyword', 0xeb62),\r\n    symbolMisc: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-misc', 0xeb63),\r\n    symbolOperator: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-operator', 0xeb64),\r\n    symbolProperty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-property', 0xeb65),\r\n    wrench: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('wrench', 0xeb65),\r\n    wrenchSubaction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('wrench-subaction', 0xeb65),\r\n    symbolSnippet: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-snippet', 0xeb66),\r\n    tasklist: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tasklist', 0xeb67),\r\n    telescope: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('telescope', 0xeb68),\r\n    textSize: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('text-size', 0xeb69),\r\n    threeBars: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('three-bars', 0xeb6a),\r\n    thumbsdown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsdown', 0xeb6b),\r\n    thumbsup: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsup', 0xeb6c),\r\n    tools: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('tools', 0xeb6d),\r\n    triangleDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-down', 0xeb6e),\r\n    triangleLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-left', 0xeb6f),\r\n    triangleRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-right', 0xeb70),\r\n    triangleUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('triangle-up', 0xeb71),\r\n    twitter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('twitter', 0xeb72),\r\n    unfold: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unfold', 0xeb73),\r\n    unlock: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unlock', 0xeb74),\r\n    unmute: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unmute', 0xeb75),\r\n    unverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('unverified', 0xeb76),\r\n    verified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('verified', 0xeb77),\r\n    versions: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('versions', 0xeb78),\r\n    vmActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-active', 0xeb79),\r\n    vmOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-outline', 0xeb7a),\r\n    vmRunning: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-running', 0xeb7b),\r\n    watch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('watch', 0xeb7c),\r\n    whitespace: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('whitespace', 0xeb7d),\r\n    wholeWord: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('whole-word', 0xeb7e),\r\n    window: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('window', 0xeb7f),\r\n    wordWrap: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('word-wrap', 0xeb80),\r\n    zoomIn: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('zoom-in', 0xeb81),\r\n    zoomOut: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('zoom-out', 0xeb82),\r\n    listFilter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-filter', 0xeb83),\r\n    listFlat: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-flat', 0xeb84),\r\n    listSelection: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-selection', 0xeb85),\r\n    selection: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('selection', 0xeb85),\r\n    listTree: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('list-tree', 0xeb86),\r\n    debugBreakpointFunctionUnverified: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-function-unverified', 0xeb87),\r\n    debugBreakpointFunction: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-function', 0xeb88),\r\n    debugBreakpointFunctionDisabled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-function-disabled', 0xeb88),\r\n    debugStackframeActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe-active', 0xeb89),\r\n    circleSmallFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-small-filled', 0xeb8a),\r\n    debugStackframeDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe-dot', 0xeb8a),\r\n    terminalDecorationMark: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-mark', 0xeb8a),\r\n    debugStackframe: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe', 0xeb8b),\r\n    debugStackframeFocused: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-stackframe-focused', 0xeb8b),\r\n    debugBreakpointUnsupported: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-breakpoint-unsupported', 0xeb8c),\r\n    symbolString: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('symbol-string', 0xeb8d),\r\n    debugReverseContinue: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-reverse-continue', 0xeb8e),\r\n    debugStepBack: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-step-back', 0xeb8f),\r\n    debugRestartFrame: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-restart-frame', 0xeb90),\r\n    debugAlt: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-alt', 0xeb91),\r\n    callIncoming: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('call-incoming', 0xeb92),\r\n    callOutgoing: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('call-outgoing', 0xeb93),\r\n    menu: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('menu', 0xeb94),\r\n    expandAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('expand-all', 0xeb95),\r\n    feedback: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('feedback', 0xeb96),\r\n    gitPullRequestReviewer: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-reviewer', 0xeb96),\r\n    groupByRefType: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('group-by-ref-type', 0xeb97),\r\n    ungroupByRefType: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('ungroup-by-ref-type', 0xeb98),\r\n    account: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('account', 0xeb99),\r\n    gitPullRequestAssignee: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-assignee', 0xeb99),\r\n    bellDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell-dot', 0xeb9a),\r\n    debugConsole: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-console', 0xeb9b),\r\n    library: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('library', 0xeb9c),\r\n    output: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('output', 0xeb9d),\r\n    runAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-all', 0xeb9e),\r\n    syncIgnored: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sync-ignored', 0xeb9f),\r\n    pinned: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pinned', 0xeba0),\r\n    githubInverted: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-inverted', 0xeba1),\r\n    serverProcess: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('server-process', 0xeba2),\r\n    serverEnvironment: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('server-environment', 0xeba3),\r\n    pass: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pass', 0xeba4),\r\n    issueClosed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-closed', 0xeba4),\r\n    stopCircle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('stop-circle', 0xeba5),\r\n    playCircle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('play-circle', 0xeba6),\r\n    record: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('record', 0xeba7),\r\n    debugAltSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-alt-small', 0xeba8),\r\n    vmConnect: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vm-connect', 0xeba9),\r\n    cloud: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('cloud', 0xebaa),\r\n    merge: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('merge', 0xebab),\r\n    export: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('export', 0xebac),\r\n    graphLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph-left', 0xebad),\r\n    magnet: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('magnet', 0xebae),\r\n    notebook: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('notebook', 0xebaf),\r\n    redo: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('redo', 0xebb0),\r\n    checkAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('check-all', 0xebb1),\r\n    pinnedDirty: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pinned-dirty', 0xebb2),\r\n    passFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pass-filled', 0xebb3),\r\n    circleLargeFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-large-filled', 0xebb4),\r\n    circleLarge: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-large', 0xebb5),\r\n    circleLargeOutline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-large-outline', 0xebb5),\r\n    combine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('combine', 0xebb6),\r\n    gather: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('gather', 0xebb6),\r\n    table: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('table', 0xebb7),\r\n    variableGroup: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('variable-group', 0xebb8),\r\n    typeHierarchy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('type-hierarchy', 0xebb9),\r\n    typeHierarchySub: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('type-hierarchy-sub', 0xebba),\r\n    typeHierarchySuper: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('type-hierarchy-super', 0xebbb),\r\n    gitPullRequestCreate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-create', 0xebbc),\r\n    runAbove: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-above', 0xebbd),\r\n    runBelow: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-below', 0xebbe),\r\n    notebookTemplate: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('notebook-template', 0xebbf),\r\n    debugRerun: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-rerun', 0xebc0),\r\n    workspaceTrusted: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-trusted', 0xebc1),\r\n    workspaceUntrusted: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-untrusted', 0xebc2),\r\n    workspaceUnknown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('workspace-unknown', 0xebc3),\r\n    terminalCmd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-cmd', 0xebc4),\r\n    terminalDebian: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-debian', 0xebc5),\r\n    terminalLinux: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-linux', 0xebc6),\r\n    terminalPowershell: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-powershell', 0xebc7),\r\n    terminalTmux: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-tmux', 0xebc8),\r\n    terminalUbuntu: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-ubuntu', 0xebc9),\r\n    terminalBash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-bash', 0xebca),\r\n    arrowSwap: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-swap', 0xebcb),\r\n    copy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('copy', 0xebcc),\r\n    personAdd: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('person-add', 0xebcd),\r\n    filterFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('filter-filled', 0xebce),\r\n    wand: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('wand', 0xebcf),\r\n    debugLineByLine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-line-by-line', 0xebd0),\r\n    inspect: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('inspect', 0xebd1),\r\n    layers: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layers', 0xebd2),\r\n    layersDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layers-dot', 0xebd3),\r\n    layersActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layers-active', 0xebd4),\r\n    compass: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compass', 0xebd5),\r\n    compassDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compass-dot', 0xebd6),\r\n    compassActive: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('compass-active', 0xebd7),\r\n    azure: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('azure', 0xebd8),\r\n    issueDraft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('issue-draft', 0xebd9),\r\n    gitPullRequestClosed: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-closed', 0xebda),\r\n    gitPullRequestDraft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-draft', 0xebdb),\r\n    debugAll: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-all', 0xebdc),\r\n    debugCoverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-coverage', 0xebdd),\r\n    runErrors: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-errors', 0xebde),\r\n    folderLibrary: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('folder-library', 0xebdf),\r\n    debugContinueSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('debug-continue-small', 0xebe0),\r\n    beakerStop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('beaker-stop', 0xebe1),\r\n    graphLine: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph-line', 0xebe2),\r\n    graphScatter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('graph-scatter', 0xebe3),\r\n    pieChart: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('pie-chart', 0xebe4),\r\n    bracket: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bracket', 0xeb0f),\r\n    bracketDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bracket-dot', 0xebe5),\r\n    bracketError: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bracket-error', 0xebe6),\r\n    lockSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lock-small', 0xebe7),\r\n    azureDevops: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('azure-devops', 0xebe8),\r\n    verifiedFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('verified-filled', 0xebe9),\r\n    newline: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('newline', 0xebea),\r\n    layout: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout', 0xebeb),\r\n    layoutActivitybarLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-activitybar-left', 0xebec),\r\n    layoutActivitybarRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-activitybar-right', 0xebed),\r\n    layoutPanelLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-left', 0xebee),\r\n    layoutPanelCenter: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-center', 0xebef),\r\n    layoutPanelJustify: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-justify', 0xebf0),\r\n    layoutPanelRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-right', 0xebf1),\r\n    layoutPanel: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel', 0xebf2),\r\n    layoutSidebarLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-left', 0xebf3),\r\n    layoutSidebarRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-right', 0xebf4),\r\n    layoutStatusbar: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-statusbar', 0xebf5),\r\n    layoutMenubar: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-menubar', 0xebf6),\r\n    layoutCentered: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-centered', 0xebf7),\r\n    target: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('target', 0xebf8),\r\n    indent: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('indent', 0xebf9),\r\n    recordSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('record-small', 0xebfa),\r\n    errorSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('error-small', 0xebfb),\r\n    terminalDecorationError: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('terminal-decoration-error', 0xebfb),\r\n    arrowCircleDown: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-down', 0xebfc),\r\n    arrowCircleLeft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-left', 0xebfd),\r\n    arrowCircleRight: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-right', 0xebfe),\r\n    arrowCircleUp: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('arrow-circle-up', 0xebff),\r\n    layoutSidebarRightOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-right-off', 0xec00),\r\n    layoutPanelOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-panel-off', 0xec01),\r\n    layoutSidebarLeftOff: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('layout-sidebar-left-off', 0xec02),\r\n    blank: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('blank', 0xec03),\r\n    heartFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('heart-filled', 0xec04),\r\n    map: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map', 0xec05),\r\n    mapHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-horizontal', 0xec05),\r\n    foldHorizontal: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-horizontal', 0xec05),\r\n    mapFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-filled', 0xec06),\r\n    mapHorizontalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-horizontal-filled', 0xec06),\r\n    foldHorizontalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-horizontal-filled', 0xec06),\r\n    circleSmall: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('circle-small', 0xec07),\r\n    bellSlash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell-slash', 0xec08),\r\n    bellSlashDot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('bell-slash-dot', 0xec09),\r\n    commentUnresolved: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-unresolved', 0xec0a),\r\n    gitPullRequestGoToChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-go-to-changes', 0xec0b),\r\n    gitPullRequestNewChanges: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-pull-request-new-changes', 0xec0c),\r\n    searchFuzzy: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('search-fuzzy', 0xec0d),\r\n    commentDraft: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('comment-draft', 0xec0e),\r\n    send: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('send', 0xec0f),\r\n    sparkle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sparkle', 0xec10),\r\n    insert: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('insert', 0xec11),\r\n    mic: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mic', 0xec12),\r\n    thumbsdownFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsdown-filled', 0xec13),\r\n    thumbsupFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('thumbsup-filled', 0xec14),\r\n    coffee: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('coffee', 0xec15),\r\n    snake: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('snake', 0xec16),\r\n    game: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('game', 0xec17),\r\n    vr: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vr', 0xec18),\r\n    chip: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('chip', 0xec19),\r\n    piano: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('piano', 0xec1a),\r\n    music: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('music', 0xec1b),\r\n    micFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('mic-filled', 0xec1c),\r\n    repoFetch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('repo-fetch', 0xec1d),\r\n    copilot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('copilot', 0xec1e),\r\n    lightbulbSparkle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('lightbulb-sparkle', 0xec1f),\r\n    robot: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('robot', 0xec20),\r\n    sparkleFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sparkle-filled', 0xec21),\r\n    diffSingle: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-single', 0xec22),\r\n    diffMultiple: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('diff-multiple', 0xec23),\r\n    surroundWith: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('surround-with', 0xec24),\r\n    share: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('share', 0xec25),\r\n    gitStash: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-stash', 0xec26),\r\n    gitStashApply: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-stash-apply', 0xec27),\r\n    gitStashPop: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('git-stash-pop', 0xec28),\r\n    vscode: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vscode', 0xec29),\r\n    vscodeInsiders: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('vscode-insiders', 0xec2a),\r\n    codeOss: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('code-oss', 0xec2b),\r\n    runCoverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-coverage', 0xec2c),\r\n    runAllCoverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('run-all-coverage', 0xec2d),\r\n    coverage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('coverage', 0xec2e),\r\n    githubProject: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('github-project', 0xec2f),\r\n    mapVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-vertical', 0xec30),\r\n    foldVertical: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-vertical', 0xec30),\r\n    mapVerticalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('map-vertical-filled', 0xec31),\r\n    foldVerticalFilled: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('fold-vertical-filled', 0xec31),\r\n    goToSearch: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('go-to-search', 0xec32),\r\n    percentage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('percentage', 0xec33),\r\n    sortPercentage: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('sort-percentage', 0xec33),\r\n    attach: (0,_codiconsUtil_js__WEBPACK_IMPORTED_MODULE_0__.register)('attach', 0xec34),\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnNMaWJyYXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUCxTQUFTLDBEQUFRO0FBQ2pCLFVBQVUsMERBQVE7QUFDbEIsYUFBYSwwREFBUTtBQUNyQixnQkFBZ0IsMERBQVE7QUFDeEIsZUFBZSwwREFBUTtBQUN2QixlQUFlLDBEQUFRO0FBQ3ZCLFVBQVUsMERBQVE7QUFDbEIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGNBQWMsMERBQVE7QUFDdEIsZ0JBQWdCLDBEQUFRO0FBQ3hCLG9CQUFvQiwwREFBUTtBQUM1Qiw2QkFBNkIsMERBQVE7QUFDckMsZ0JBQWdCLDBEQUFRO0FBQ3hCLGNBQWMsMERBQVE7QUFDdEIsU0FBUywwREFBUTtBQUNqQix5QkFBeUIsMERBQVE7QUFDakMsWUFBWSwwREFBUTtBQUNwQixlQUFlLDBEQUFRO0FBQ3ZCLFlBQVksMERBQVE7QUFDcEIsa0JBQWtCLDBEQUFRO0FBQzFCLG1CQUFtQiwwREFBUTtBQUMzQixrQkFBa0IsMERBQVE7QUFDMUIsZUFBZSwwREFBUTtBQUN2QixxQkFBcUIsMERBQVE7QUFDN0IscUJBQXFCLDBEQUFRO0FBQzdCLG1CQUFtQiwwREFBUTtBQUMzQixZQUFZLDBEQUFRO0FBQ3BCLGtCQUFrQiwwREFBUTtBQUMxQixVQUFVLDBEQUFRO0FBQ2xCLGFBQWEsMERBQVE7QUFDckIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGVBQWUsMERBQVE7QUFDdkIsYUFBYSwwREFBUTtBQUNyQixnQkFBZ0IsMERBQVE7QUFDeEIsV0FBVywwREFBUTtBQUNuQixhQUFhLDBEQUFRO0FBQ3JCLFlBQVksMERBQVE7QUFDcEIsZ0JBQWdCLDBEQUFRO0FBQ3hCLFlBQVksMERBQVE7QUFDcEIsYUFBYSwwREFBUTtBQUNyQixXQUFXLDBEQUFRO0FBQ25CLFlBQVksMERBQVE7QUFDcEIsU0FBUywwREFBUTtBQUNqQixnQkFBZ0IsMERBQVE7QUFDeEIsY0FBYywwREFBUTtBQUN0QixrQkFBa0IsMERBQVE7QUFDMUIsa0JBQWtCLDBEQUFRO0FBQzFCLGdCQUFnQiwwREFBUTtBQUN4QixxQkFBcUIsMERBQVE7QUFDN0IsNkJBQTZCLDBEQUFRO0FBQ3JDLGVBQWUsMERBQVE7QUFDdkIsK0JBQStCLDBEQUFRO0FBQ3ZDLHFCQUFxQiwwREFBUTtBQUM3QixVQUFVLDBEQUFRO0FBQ2xCLFlBQVksMERBQVE7QUFDcEIsVUFBVSwwREFBUTtBQUNsQixpQkFBaUIsMERBQVE7QUFDekIsaUJBQWlCLDBEQUFRO0FBQ3pCLG9CQUFvQiwwREFBUTtBQUM1QixVQUFVLDBEQUFRO0FBQ2xCLG1CQUFtQiwwREFBUTtBQUMzQixXQUFXLDBEQUFRO0FBQ25CLGlCQUFpQiwwREFBUTtBQUN6QixPQUFPLDBEQUFRO0FBQ2YsY0FBYywwREFBUTtBQUN0QixVQUFVLDBEQUFRO0FBQ2xCLFdBQVcsMERBQVE7QUFDbkIscUJBQXFCLDBEQUFRO0FBQzdCLFlBQVksMERBQVE7QUFDcEIsZ0JBQWdCLDBEQUFRO0FBQ3hCLFFBQVEsMERBQVE7QUFDaEIsbUJBQW1CLDBEQUFRO0FBQzNCLFVBQVUsMERBQVE7QUFDbEIsY0FBYywwREFBUTtBQUN0QixVQUFVLDBEQUFRO0FBQ2xCLGNBQWMsMERBQVE7QUFDdEIscUJBQXFCLDBEQUFRO0FBQzdCLGVBQWUsMERBQVE7QUFDdkIsV0FBVywwREFBUTtBQUNuQixrQkFBa0IsMERBQVE7QUFDMUIsd0JBQXdCLDBEQUFRO0FBQ2hDLHlCQUF5QiwwREFBUTtBQUNqQyxhQUFhLDBEQUFRO0FBQ3JCLGFBQWEsMERBQVE7QUFDckIsZUFBZSwwREFBUTtBQUN2Qix5QkFBeUIsMERBQVE7QUFDakMsV0FBVywwREFBUTtBQUNuQixjQUFjLDBEQUFRO0FBQ3RCLGFBQWEsMERBQVE7QUFDckIsV0FBVywwREFBUTtBQUNuQixZQUFZLDBEQUFRO0FBQ3BCLG1CQUFtQiwwREFBUTtBQUMzQixrQkFBa0IsMERBQVE7QUFDMUIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGdCQUFnQiwwREFBUTtBQUN4QixZQUFZLDBEQUFRO0FBQ3BCLGNBQWMsMERBQVE7QUFDdEIsYUFBYSwwREFBUTtBQUNyQixVQUFVLDBEQUFRO0FBQ2xCLFNBQVMsMERBQVE7QUFDakIsaUJBQWlCLDBEQUFRO0FBQ3pCLFdBQVcsMERBQVE7QUFDbkIsVUFBVSwwREFBUTtBQUNsQixjQUFjLDBEQUFRO0FBQ3RCLG9CQUFvQiwwREFBUTtBQUM1QixXQUFXLDBEQUFRO0FBQ25CLGlCQUFpQiwwREFBUTtBQUN6QixrQkFBa0IsMERBQVE7QUFDMUIsbUJBQW1CLDBEQUFRO0FBQzNCLHFCQUFxQiwwREFBUTtBQUM3QixrQkFBa0IsMERBQVE7QUFDMUIsa0JBQWtCLDBEQUFRO0FBQzFCLG9CQUFvQiwwREFBUTtBQUM1Qix1QkFBdUIsMERBQVE7QUFDL0IsbUJBQW1CLDBEQUFRO0FBQzNCLGdCQUFnQiwwREFBUTtBQUN4QixtQkFBbUIsMERBQVE7QUFDM0Isa0JBQWtCLDBEQUFRO0FBQzFCLHFCQUFxQiwwREFBUTtBQUM3QixrQkFBa0IsMERBQVE7QUFDMUIscUJBQXFCLDBEQUFRO0FBQzdCLHlCQUF5QiwwREFBUTtBQUNqQyxlQUFlLDBEQUFRO0FBQ3ZCLGdCQUFnQiwwREFBUTtBQUN4QixxQkFBcUIsMERBQVE7QUFDN0IsY0FBYywwREFBUTtBQUN0QixnQkFBZ0IsMERBQVE7QUFDeEIsaUJBQWlCLDBEQUFRO0FBQ3pCLGlCQUFpQiwwREFBUTtBQUN6QixnQkFBZ0IsMERBQVE7QUFDeEIseUJBQXlCLDBEQUFRO0FBQ2pDLGFBQWEsMERBQVE7QUFDckIsZUFBZSwwREFBUTtBQUN2QixlQUFlLDBEQUFRO0FBQ3ZCLGVBQWUsMERBQVE7QUFDdkIsZ0JBQWdCLDBEQUFRO0FBQ3hCLG9CQUFvQiwwREFBUTtBQUM1QixvQkFBb0IsMERBQVE7QUFDNUIscUJBQXFCLDBEQUFRO0FBQzdCLGtCQUFrQiwwREFBUTtBQUMxQixhQUFhLDBEQUFRO0FBQ3JCLFVBQVUsMERBQVE7QUFDbEIsVUFBVSwwREFBUTtBQUNsQixVQUFVLDBEQUFRO0FBQ2xCLGNBQWMsMERBQVE7QUFDdEIsMENBQTBDLDBEQUFRO0FBQ2xELGdDQUFnQywwREFBUTtBQUN4Qyx3Q0FBd0MsMERBQVE7QUFDaEQsbUNBQW1DLDBEQUFRO0FBQzNDLHlCQUF5QiwwREFBUTtBQUNqQyxpQ0FBaUMsMERBQVE7QUFDekMsa0NBQWtDLDBEQUFRO0FBQzFDLHdCQUF3QiwwREFBUTtBQUNoQyxnQ0FBZ0MsMERBQVE7QUFDeEMsZUFBZSwwREFBUTtBQUN2QixlQUFlLDBEQUFRO0FBQ3ZCLGFBQWEsMERBQVE7QUFDckIsU0FBUywwREFBUTtBQUNqQixjQUFjLDBEQUFRO0FBQ3RCLG1CQUFtQiwwREFBUTtBQUMzQixXQUFXLDBEQUFRO0FBQ25CLGVBQWUsMERBQVE7QUFDdkIsaUJBQWlCLDBEQUFRO0FBQ3pCLGlCQUFpQiwwREFBUTtBQUN6QixrQkFBa0IsMERBQVE7QUFDMUIsZUFBZSwwREFBUTtBQUN2QixpQkFBaUIsMERBQVE7QUFDekIsb0JBQW9CLDBEQUFRO0FBQzVCLG9CQUFvQiwwREFBUTtBQUM1QixtQkFBbUIsMERBQVE7QUFDM0IsbUJBQW1CLDBEQUFRO0FBQzNCLFlBQVksMERBQVE7QUFDcEIsK0JBQStCLDBEQUFRO0FBQ3ZDLGtDQUFrQywwREFBUTtBQUMxQyxpQkFBaUIsMERBQVE7QUFDekIsa0JBQWtCLDBEQUFRO0FBQzFCLGNBQWMsMERBQVE7QUFDdEIsWUFBWSwwREFBUTtBQUNwQixjQUFjLDBEQUFRO0FBQ3RCLG1CQUFtQiwwREFBUTtBQUMzQixpQkFBaUIsMERBQVE7QUFDekIsVUFBVSwwREFBUTtBQUNsQixpQkFBaUIsMERBQVE7QUFDekIsZUFBZSwwREFBUTtBQUN2Qix1QkFBdUIsMERBQVE7QUFDL0IsZ0JBQWdCLDBEQUFRO0FBQ3hCLFVBQVUsMERBQVE7QUFDbEIsZUFBZSwwREFBUTtBQUN2QixjQUFjLDBEQUFRO0FBQ3RCLG1CQUFtQiwwREFBUTtBQUMzQixxQkFBcUIsMERBQVE7QUFDN0IsZ0JBQWdCLDBEQUFRO0FBQ3hCLGtCQUFrQiwwREFBUTtBQUMxQixnQkFBZ0IsMERBQVE7QUFDeEIsbUJBQW1CLDBEQUFRO0FBQzNCLGtCQUFrQiwwREFBUTtBQUMxQixtQkFBbUIsMERBQVE7QUFDM0IsZUFBZSwwREFBUTtBQUN2QixXQUFXLDBEQUFRO0FBQ25CLHVCQUF1QiwwREFBUTtBQUMvQixrQkFBa0IsMERBQVE7QUFDMUIsa0JBQWtCLDBEQUFRO0FBQzFCLGVBQWUsMERBQVE7QUFDdkIsaUJBQWlCLDBEQUFRO0FBQ3pCLGtCQUFrQiwwREFBUTtBQUMxQixpQkFBaUIsMERBQVE7QUFDekIsaUJBQWlCLDBEQUFRO0FBQ3pCLFVBQVUsMERBQVE7QUFDbEIsb0JBQW9CLDBEQUFRO0FBQzVCLGFBQWEsMERBQVE7QUFDckIsa0JBQWtCLDBEQUFRO0FBQzFCLGlCQUFpQiwwREFBUTtBQUN6QixhQUFhLDBEQUFRO0FBQ3JCLGdCQUFnQiwwREFBUTtBQUN4QixlQUFlLDBEQUFRO0FBQ3ZCLGdCQUFnQiwwREFBUTtBQUN4QixjQUFjLDBEQUFRO0FBQ3RCLGVBQWUsMERBQVE7QUFDdkIsYUFBYSwwREFBUTtBQUNyQixtQkFBbUIsMERBQVE7QUFDM0IsMEJBQTBCLDBEQUFRO0FBQ2xDLHFCQUFxQiwwREFBUTtBQUM3QixhQUFhLDBEQUFRO0FBQ3JCLFdBQVcsMERBQVE7QUFDbkIsWUFBWSwwREFBUTtBQUNwQixXQUFXLDBEQUFRO0FBQ25CLGNBQWMsMERBQVE7QUFDdEIsWUFBWSwwREFBUTtBQUNwQixVQUFVLDBEQUFRO0FBQ2xCLGtCQUFrQiwwREFBUTtBQUMxQixrQkFBa0IsMERBQVE7QUFDMUIsVUFBVSwwREFBUTtBQUNsQixVQUFVLDBEQUFRO0FBQ2xCLGdCQUFnQiwwREFBUTtBQUN4QixVQUFVLDBEQUFRO0FBQ2xCLGVBQWUsMERBQVE7QUFDdkIsZ0JBQWdCLDBEQUFRO0FBQ3hCLG9CQUFvQiwwREFBUTtBQUM1QixjQUFjLDBEQUFRO0FBQ3RCLGtCQUFrQiwwREFBUTtBQUMxQixlQUFlLDBEQUFRO0FBQ3ZCLFdBQVcsMERBQVE7QUFDbkIsYUFBYSwwREFBUTtBQUNyQixXQUFXLDBEQUFRO0FBQ25CLGFBQWEsMERBQVE7QUFDckIsV0FBVywwREFBUTtBQUNuQixVQUFVLDBEQUFRO0FBQ2xCLG9CQUFvQiwwREFBUTtBQUM1QixXQUFXLDBEQUFRO0FBQ25CLFdBQVcsMERBQVE7QUFDbkIsbUJBQW1CLDBEQUFRO0FBQzNCLFlBQVksMERBQVE7QUFDcEIsWUFBWSwwREFBUTtBQUNwQixZQUFZLDBEQUFRO0FBQ3BCLFVBQVUsMERBQVE7QUFDbEIsbUJBQW1CLDBEQUFRO0FBQzNCLFNBQVMsMERBQVE7QUFDakIsU0FBUywwREFBUTtBQUNqQixzQkFBc0IsMERBQVE7QUFDOUIsa0JBQWtCLDBEQUFRO0FBQzFCLFVBQVUsMERBQVE7QUFDbEIsaUJBQWlCLDBEQUFRO0FBQ3pCLG1CQUFtQiwwREFBUTtBQUMzQixlQUFlLDBEQUFRO0FBQ3ZCLGFBQWEsMERBQVE7QUFDckIsY0FBYywwREFBUTtBQUN0QixjQUFjLDBEQUFRO0FBQ3RCLFVBQVUsMERBQVE7QUFDbEIsY0FBYywwREFBUTtBQUN0QixlQUFlLDBEQUFRO0FBQ3ZCLGFBQWEsMERBQVE7QUFDckIsZUFBZSwwREFBUTtBQUN2Qiw2QkFBNkIsMERBQVE7QUFDckMsaUJBQWlCLDBEQUFRO0FBQ3pCLFVBQVUsMERBQVE7QUFDbEIscUJBQXFCLDBEQUFRO0FBQzdCLFVBQVUsMERBQVE7QUFDbEIsZUFBZSwwREFBUTtBQUN2QixVQUFVLDBEQUFRO0FBQ2xCLGNBQWMsMERBQVE7QUFDdEIsaUJBQWlCLDBEQUFRO0FBQ3pCLGFBQWEsMERBQVE7QUFDckIsY0FBYywwREFBUTtBQUN0QixTQUFTLDBEQUFRO0FBQ2pCLFVBQVUsMERBQVE7QUFDbEIsU0FBUywwREFBUTtBQUNqQixVQUFVLDBEQUFRO0FBQ2xCLGtCQUFrQiwwREFBUTtBQUMxQixhQUFhLDBEQUFRO0FBQ3JCLGFBQWEsMERBQVE7QUFDckIsV0FBVywwREFBUTtBQUNuQixjQUFjLDBEQUFRO0FBQ3RCLFdBQVcsMERBQVE7QUFDbkIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGVBQWUsMERBQVE7QUFDdkIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGFBQWEsMERBQVE7QUFDckIsV0FBVywwREFBUTtBQUNuQixvQkFBb0IsMERBQVE7QUFDNUIsWUFBWSwwREFBUTtBQUNwQixZQUFZLDBEQUFRO0FBQ3BCLGdCQUFnQiwwREFBUTtBQUN4QixhQUFhLDBEQUFRO0FBQ3JCLGVBQWUsMERBQVE7QUFDdkIsbUJBQW1CLDBEQUFRO0FBQzNCLGNBQWMsMERBQVE7QUFDdEIsY0FBYywwREFBUTtBQUN0QixZQUFZLDBEQUFRO0FBQ3BCLG9CQUFvQiwwREFBUTtBQUM1QixZQUFZLDBEQUFRO0FBQ3BCLHNCQUFzQiwwREFBUTtBQUM5QixnQkFBZ0IsMERBQVE7QUFDeEIsU0FBUywwREFBUTtBQUNqQixVQUFVLDBEQUFRO0FBQ2xCLGFBQWEsMERBQVE7QUFDckIsWUFBWSwwREFBUTtBQUNwQixVQUFVLDBEQUFRO0FBQ2xCLGdCQUFnQiwwREFBUTtBQUN4QixrQkFBa0IsMERBQVE7QUFDMUIsZ0JBQWdCLDBEQUFRO0FBQ3hCLFlBQVksMERBQVE7QUFDcEIsa0JBQWtCLDBEQUFRO0FBQzFCLGNBQWMsMERBQVE7QUFDdEIsWUFBWSwwREFBUTtBQUNwQixZQUFZLDBEQUFRO0FBQ3BCLG9CQUFvQiwwREFBUTtBQUM1QixxQkFBcUIsMERBQVE7QUFDN0IsbUJBQW1CLDBEQUFRO0FBQzNCLGNBQWMsMERBQVE7QUFDdEIsY0FBYywwREFBUTtBQUN0QixjQUFjLDBEQUFRO0FBQ3RCLGlCQUFpQiwwREFBUTtBQUN6QixpQkFBaUIsMERBQVE7QUFDekIsb0JBQW9CLDBEQUFRO0FBQzVCLHNCQUFzQiwwREFBUTtBQUM5QixpQkFBaUIsMERBQVE7QUFDekIsZ0JBQWdCLDBEQUFRO0FBQ3hCLHFCQUFxQiwwREFBUTtBQUM3QixtQkFBbUIsMERBQVE7QUFDM0IsZ0JBQWdCLDBEQUFRO0FBQ3hCLG9CQUFvQiwwREFBUTtBQUM1QixvQkFBb0IsMERBQVE7QUFDNUIsWUFBWSwwREFBUTtBQUNwQixxQkFBcUIsMERBQVE7QUFDN0IsbUJBQW1CLDBEQUFRO0FBQzNCLGNBQWMsMERBQVE7QUFDdEIsZUFBZSwwREFBUTtBQUN2QixjQUFjLDBEQUFRO0FBQ3RCLGVBQWUsMERBQVE7QUFDdkIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGNBQWMsMERBQVE7QUFDdEIsV0FBVywwREFBUTtBQUNuQixrQkFBa0IsMERBQVE7QUFDMUIsa0JBQWtCLDBEQUFRO0FBQzFCLG1CQUFtQiwwREFBUTtBQUMzQixnQkFBZ0IsMERBQVE7QUFDeEIsYUFBYSwwREFBUTtBQUNyQixZQUFZLDBEQUFRO0FBQ3BCLFlBQVksMERBQVE7QUFDcEIsWUFBWSwwREFBUTtBQUNwQixnQkFBZ0IsMERBQVE7QUFDeEIsY0FBYywwREFBUTtBQUN0QixjQUFjLDBEQUFRO0FBQ3RCLGNBQWMsMERBQVE7QUFDdEIsZUFBZSwwREFBUTtBQUN2QixlQUFlLDBEQUFRO0FBQ3ZCLFdBQVcsMERBQVE7QUFDbkIsZ0JBQWdCLDBEQUFRO0FBQ3hCLGVBQWUsMERBQVE7QUFDdkIsWUFBWSwwREFBUTtBQUNwQixjQUFjLDBEQUFRO0FBQ3RCLFlBQVksMERBQVE7QUFDcEIsYUFBYSwwREFBUTtBQUNyQixnQkFBZ0IsMERBQVE7QUFDeEIsY0FBYywwREFBUTtBQUN0QixtQkFBbUIsMERBQVE7QUFDM0IsZUFBZSwwREFBUTtBQUN2QixjQUFjLDBEQUFRO0FBQ3RCLHVDQUF1QywwREFBUTtBQUMvQyw2QkFBNkIsMERBQVE7QUFDckMscUNBQXFDLDBEQUFRO0FBQzdDLDJCQUEyQiwwREFBUTtBQUNuQyx1QkFBdUIsMERBQVE7QUFDL0Isd0JBQXdCLDBEQUFRO0FBQ2hDLDRCQUE0QiwwREFBUTtBQUNwQyxxQkFBcUIsMERBQVE7QUFDN0IsNEJBQTRCLDBEQUFRO0FBQ3BDLGdDQUFnQywwREFBUTtBQUN4QyxrQkFBa0IsMERBQVE7QUFDMUIsMEJBQTBCLDBEQUFRO0FBQ2xDLG1CQUFtQiwwREFBUTtBQUMzQix1QkFBdUIsMERBQVE7QUFDL0IsY0FBYywwREFBUTtBQUN0QixrQkFBa0IsMERBQVE7QUFDMUIsa0JBQWtCLDBEQUFRO0FBQzFCLFVBQVUsMERBQVE7QUFDbEIsZUFBZSwwREFBUTtBQUN2QixjQUFjLDBEQUFRO0FBQ3RCLDRCQUE0QiwwREFBUTtBQUNwQyxvQkFBb0IsMERBQVE7QUFDNUIsc0JBQXNCLDBEQUFRO0FBQzlCLGFBQWEsMERBQVE7QUFDckIsNEJBQTRCLDBEQUFRO0FBQ3BDLGFBQWEsMERBQVE7QUFDckIsa0JBQWtCLDBEQUFRO0FBQzFCLGFBQWEsMERBQVE7QUFDckIsWUFBWSwwREFBUTtBQUNwQixZQUFZLDBEQUFRO0FBQ3BCLGlCQUFpQiwwREFBUTtBQUN6QixZQUFZLDBEQUFRO0FBQ3BCLG9CQUFvQiwwREFBUTtBQUM1QixtQkFBbUIsMERBQVE7QUFDM0IsdUJBQXVCLDBEQUFRO0FBQy9CLFVBQVUsMERBQVE7QUFDbEIsaUJBQWlCLDBEQUFRO0FBQ3pCLGdCQUFnQiwwREFBUTtBQUN4QixnQkFBZ0IsMERBQVE7QUFDeEIsWUFBWSwwREFBUTtBQUNwQixtQkFBbUIsMERBQVE7QUFDM0IsZUFBZSwwREFBUTtBQUN2QixXQUFXLDBEQUFRO0FBQ25CLFdBQVcsMERBQVE7QUFDbkIsWUFBWSwwREFBUTtBQUNwQixlQUFlLDBEQUFRO0FBQ3ZCLFlBQVksMERBQVE7QUFDcEIsY0FBYywwREFBUTtBQUN0QixVQUFVLDBEQUFRO0FBQ2xCLGNBQWMsMERBQVE7QUFDdEIsaUJBQWlCLDBEQUFRO0FBQ3pCLGdCQUFnQiwwREFBUTtBQUN4Qix1QkFBdUIsMERBQVE7QUFDL0IsaUJBQWlCLDBEQUFRO0FBQ3pCLHdCQUF3QiwwREFBUTtBQUNoQyxhQUFhLDBEQUFRO0FBQ3JCLFlBQVksMERBQVE7QUFDcEIsV0FBVywwREFBUTtBQUNuQixtQkFBbUIsMERBQVE7QUFDM0IsbUJBQW1CLDBEQUFRO0FBQzNCLHNCQUFzQiwwREFBUTtBQUM5Qix3QkFBd0IsMERBQVE7QUFDaEMsMEJBQTBCLDBEQUFRO0FBQ2xDLGNBQWMsMERBQVE7QUFDdEIsY0FBYywwREFBUTtBQUN0QixzQkFBc0IsMERBQVE7QUFDOUIsZ0JBQWdCLDBEQUFRO0FBQ3hCLHNCQUFzQiwwREFBUTtBQUM5Qix3QkFBd0IsMERBQVE7QUFDaEMsc0JBQXNCLDBEQUFRO0FBQzlCLGlCQUFpQiwwREFBUTtBQUN6QixvQkFBb0IsMERBQVE7QUFDNUIsbUJBQW1CLDBEQUFRO0FBQzNCLHdCQUF3QiwwREFBUTtBQUNoQyxrQkFBa0IsMERBQVE7QUFDMUIsb0JBQW9CLDBEQUFRO0FBQzVCLGtCQUFrQiwwREFBUTtBQUMxQixlQUFlLDBEQUFRO0FBQ3ZCLFVBQVUsMERBQVE7QUFDbEIsZUFBZSwwREFBUTtBQUN2QixrQkFBa0IsMERBQVE7QUFDMUIsVUFBVSwwREFBUTtBQUNsQixxQkFBcUIsMERBQVE7QUFDN0IsYUFBYSwwREFBUTtBQUNyQixZQUFZLDBEQUFRO0FBQ3BCLGVBQWUsMERBQVE7QUFDdkIsa0JBQWtCLDBEQUFRO0FBQzFCLGFBQWEsMERBQVE7QUFDckIsZ0JBQWdCLDBEQUFRO0FBQ3hCLG1CQUFtQiwwREFBUTtBQUMzQixXQUFXLDBEQUFRO0FBQ25CLGdCQUFnQiwwREFBUTtBQUN4QiwwQkFBMEIsMERBQVE7QUFDbEMseUJBQXlCLDBEQUFRO0FBQ2pDLGNBQWMsMERBQVE7QUFDdEIsbUJBQW1CLDBEQUFRO0FBQzNCLGVBQWUsMERBQVE7QUFDdkIsbUJBQW1CLDBEQUFRO0FBQzNCLHdCQUF3QiwwREFBUTtBQUNoQyxnQkFBZ0IsMERBQVE7QUFDeEIsZUFBZSwwREFBUTtBQUN2QixrQkFBa0IsMERBQVE7QUFDMUIsY0FBYywwREFBUTtBQUN0QixhQUFhLDBEQUFRO0FBQ3JCLGdCQUFnQiwwREFBUTtBQUN4QixrQkFBa0IsMERBQVE7QUFDMUIsZUFBZSwwREFBUTtBQUN2QixpQkFBaUIsMERBQVE7QUFDekIsb0JBQW9CLDBEQUFRO0FBQzVCLGFBQWEsMERBQVE7QUFDckIsWUFBWSwwREFBUTtBQUNwQiwyQkFBMkIsMERBQVE7QUFDbkMsNEJBQTRCLDBEQUFRO0FBQ3BDLHFCQUFxQiwwREFBUTtBQUM3Qix1QkFBdUIsMERBQVE7QUFDL0Isd0JBQXdCLDBEQUFRO0FBQ2hDLHNCQUFzQiwwREFBUTtBQUM5QixpQkFBaUIsMERBQVE7QUFDekIsdUJBQXVCLDBEQUFRO0FBQy9CLHdCQUF3QiwwREFBUTtBQUNoQyxxQkFBcUIsMERBQVE7QUFDN0IsbUJBQW1CLDBEQUFRO0FBQzNCLG9CQUFvQiwwREFBUTtBQUM1QixZQUFZLDBEQUFRO0FBQ3BCLFlBQVksMERBQVE7QUFDcEIsaUJBQWlCLDBEQUFRO0FBQ3pCLGdCQUFnQiwwREFBUTtBQUN4Qiw2QkFBNkIsMERBQVE7QUFDckMscUJBQXFCLDBEQUFRO0FBQzdCLHFCQUFxQiwwREFBUTtBQUM3QixzQkFBc0IsMERBQVE7QUFDOUIsbUJBQW1CLDBEQUFRO0FBQzNCLDJCQUEyQiwwREFBUTtBQUNuQyxvQkFBb0IsMERBQVE7QUFDNUIsMEJBQTBCLDBEQUFRO0FBQ2xDLFdBQVcsMERBQVE7QUFDbkIsaUJBQWlCLDBEQUFRO0FBQ3pCLFNBQVMsMERBQVE7QUFDakIsbUJBQW1CLDBEQUFRO0FBQzNCLG9CQUFvQiwwREFBUTtBQUM1QixlQUFlLDBEQUFRO0FBQ3ZCLHlCQUF5QiwwREFBUTtBQUNqQywwQkFBMEIsMERBQVE7QUFDbEMsaUJBQWlCLDBEQUFRO0FBQ3pCLGVBQWUsMERBQVE7QUFDdkIsa0JBQWtCLDBEQUFRO0FBQzFCLHVCQUF1QiwwREFBUTtBQUMvQiwrQkFBK0IsMERBQVE7QUFDdkMsOEJBQThCLDBEQUFRO0FBQ3RDLGlCQUFpQiwwREFBUTtBQUN6QixrQkFBa0IsMERBQVE7QUFDMUIsVUFBVSwwREFBUTtBQUNsQixhQUFhLDBEQUFRO0FBQ3JCLFlBQVksMERBQVE7QUFDcEIsU0FBUywwREFBUTtBQUNqQixzQkFBc0IsMERBQVE7QUFDOUIsb0JBQW9CLDBEQUFRO0FBQzVCLFlBQVksMERBQVE7QUFDcEIsV0FBVywwREFBUTtBQUNuQixVQUFVLDBEQUFRO0FBQ2xCLFFBQVEsMERBQVE7QUFDaEIsVUFBVSwwREFBUTtBQUNsQixXQUFXLDBEQUFRO0FBQ25CLFdBQVcsMERBQVE7QUFDbkIsZUFBZSwwREFBUTtBQUN2QixlQUFlLDBEQUFRO0FBQ3ZCLGFBQWEsMERBQVE7QUFDckIsc0JBQXNCLDBEQUFRO0FBQzlCLFdBQVcsMERBQVE7QUFDbkIsbUJBQW1CLDBEQUFRO0FBQzNCLGdCQUFnQiwwREFBUTtBQUN4QixrQkFBa0IsMERBQVE7QUFDMUIsa0JBQWtCLDBEQUFRO0FBQzFCLFdBQVcsMERBQVE7QUFDbkIsY0FBYywwREFBUTtBQUN0QixtQkFBbUIsMERBQVE7QUFDM0IsaUJBQWlCLDBEQUFRO0FBQ3pCLFlBQVksMERBQVE7QUFDcEIsb0JBQW9CLDBEQUFRO0FBQzVCLGFBQWEsMERBQVE7QUFDckIsaUJBQWlCLDBEQUFRO0FBQ3pCLG9CQUFvQiwwREFBUTtBQUM1QixjQUFjLDBEQUFRO0FBQ3RCLG1CQUFtQiwwREFBUTtBQUMzQixpQkFBaUIsMERBQVE7QUFDekIsa0JBQWtCLDBEQUFRO0FBQzFCLHVCQUF1QiwwREFBUTtBQUMvQix3QkFBd0IsMERBQVE7QUFDaEMsZ0JBQWdCLDBEQUFRO0FBQ3hCLGdCQUFnQiwwREFBUTtBQUN4QixvQkFBb0IsMERBQVE7QUFDNUIsWUFBWSwwREFBUTtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jb2RpY29uc0xpYnJhcnkuanM/NDUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuL2NvZGljb25zVXRpbC5qcyc7XHJcbi8vIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSAobWljcm9zb2Z0L3ZzY29kZS1jb2RpY29ucykvc2NyaXB0cy9leHBvcnQtdG8tdHMuanNcclxuLy8gUGxlYXNlIGRvbid0IGVkaXQgaXQsIGFzIHlvdXIgY2hhbmdlcyB3aWxsIGJlIG92ZXJ3cml0dGVuLlxyXG4vLyBJbnN0ZWFkLCBhZGQgbWFwcGluZ3MgdG8gY29kaWNvbnNEZXJpdmVkIGluIGNvZGljb25zLnRzLlxyXG5leHBvcnQgY29uc3QgY29kaWNvbnNMaWJyYXJ5ID0ge1xyXG4gICAgYWRkOiByZWdpc3RlcignYWRkJywgMHhlYTYwKSxcclxuICAgIHBsdXM6IHJlZ2lzdGVyKCdwbHVzJywgMHhlYTYwKSxcclxuICAgIGdpc3ROZXc6IHJlZ2lzdGVyKCdnaXN0LW5ldycsIDB4ZWE2MCksXHJcbiAgICByZXBvQ3JlYXRlOiByZWdpc3RlcigncmVwby1jcmVhdGUnLCAweGVhNjApLFxyXG4gICAgbGlnaHRidWxiOiByZWdpc3RlcignbGlnaHRidWxiJywgMHhlYTYxKSxcclxuICAgIGxpZ2h0QnVsYjogcmVnaXN0ZXIoJ2xpZ2h0LWJ1bGInLCAweGVhNjEpLFxyXG4gICAgcmVwbzogcmVnaXN0ZXIoJ3JlcG8nLCAweGVhNjIpLFxyXG4gICAgcmVwb0RlbGV0ZTogcmVnaXN0ZXIoJ3JlcG8tZGVsZXRlJywgMHhlYTYyKSxcclxuICAgIGdpc3RGb3JrOiByZWdpc3RlcignZ2lzdC1mb3JrJywgMHhlYTYzKSxcclxuICAgIHJlcG9Gb3JrZWQ6IHJlZ2lzdGVyKCdyZXBvLWZvcmtlZCcsIDB4ZWE2MyksXHJcbiAgICBnaXRQdWxsUmVxdWVzdDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QnLCAweGVhNjQpLFxyXG4gICAgZ2l0UHVsbFJlcXVlc3RBYmFuZG9uZWQ6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LWFiYW5kb25lZCcsIDB4ZWE2NCksXHJcbiAgICByZWNvcmRLZXlzOiByZWdpc3RlcigncmVjb3JkLWtleXMnLCAweGVhNjUpLFxyXG4gICAga2V5Ym9hcmQ6IHJlZ2lzdGVyKCdrZXlib2FyZCcsIDB4ZWE2NSksXHJcbiAgICB0YWc6IHJlZ2lzdGVyKCd0YWcnLCAweGVhNjYpLFxyXG4gICAgZ2l0UHVsbFJlcXVlc3RMYWJlbDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtbGFiZWwnLCAweGVhNjYpLFxyXG4gICAgdGFnQWRkOiByZWdpc3RlcigndGFnLWFkZCcsIDB4ZWE2NiksXHJcbiAgICB0YWdSZW1vdmU6IHJlZ2lzdGVyKCd0YWctcmVtb3ZlJywgMHhlYTY2KSxcclxuICAgIHBlcnNvbjogcmVnaXN0ZXIoJ3BlcnNvbicsIDB4ZWE2NyksXHJcbiAgICBwZXJzb25Gb2xsb3c6IHJlZ2lzdGVyKCdwZXJzb24tZm9sbG93JywgMHhlYTY3KSxcclxuICAgIHBlcnNvbk91dGxpbmU6IHJlZ2lzdGVyKCdwZXJzb24tb3V0bGluZScsIDB4ZWE2NyksXHJcbiAgICBwZXJzb25GaWxsZWQ6IHJlZ2lzdGVyKCdwZXJzb24tZmlsbGVkJywgMHhlYTY3KSxcclxuICAgIGdpdEJyYW5jaDogcmVnaXN0ZXIoJ2dpdC1icmFuY2gnLCAweGVhNjgpLFxyXG4gICAgZ2l0QnJhbmNoQ3JlYXRlOiByZWdpc3RlcignZ2l0LWJyYW5jaC1jcmVhdGUnLCAweGVhNjgpLFxyXG4gICAgZ2l0QnJhbmNoRGVsZXRlOiByZWdpc3RlcignZ2l0LWJyYW5jaC1kZWxldGUnLCAweGVhNjgpLFxyXG4gICAgc291cmNlQ29udHJvbDogcmVnaXN0ZXIoJ3NvdXJjZS1jb250cm9sJywgMHhlYTY4KSxcclxuICAgIG1pcnJvcjogcmVnaXN0ZXIoJ21pcnJvcicsIDB4ZWE2OSksXHJcbiAgICBtaXJyb3JQdWJsaWM6IHJlZ2lzdGVyKCdtaXJyb3ItcHVibGljJywgMHhlYTY5KSxcclxuICAgIHN0YXI6IHJlZ2lzdGVyKCdzdGFyJywgMHhlYTZhKSxcclxuICAgIHN0YXJBZGQ6IHJlZ2lzdGVyKCdzdGFyLWFkZCcsIDB4ZWE2YSksXHJcbiAgICBzdGFyRGVsZXRlOiByZWdpc3Rlcignc3Rhci1kZWxldGUnLCAweGVhNmEpLFxyXG4gICAgc3RhckVtcHR5OiByZWdpc3Rlcignc3Rhci1lbXB0eScsIDB4ZWE2YSksXHJcbiAgICBjb21tZW50OiByZWdpc3RlcignY29tbWVudCcsIDB4ZWE2YiksXHJcbiAgICBjb21tZW50QWRkOiByZWdpc3RlcignY29tbWVudC1hZGQnLCAweGVhNmIpLFxyXG4gICAgYWxlcnQ6IHJlZ2lzdGVyKCdhbGVydCcsIDB4ZWE2YyksXHJcbiAgICB3YXJuaW5nOiByZWdpc3Rlcignd2FybmluZycsIDB4ZWE2YyksXHJcbiAgICBzZWFyY2g6IHJlZ2lzdGVyKCdzZWFyY2gnLCAweGVhNmQpLFxyXG4gICAgc2VhcmNoU2F2ZTogcmVnaXN0ZXIoJ3NlYXJjaC1zYXZlJywgMHhlYTZkKSxcclxuICAgIGxvZ091dDogcmVnaXN0ZXIoJ2xvZy1vdXQnLCAweGVhNmUpLFxyXG4gICAgc2lnbk91dDogcmVnaXN0ZXIoJ3NpZ24tb3V0JywgMHhlYTZlKSxcclxuICAgIGxvZ0luOiByZWdpc3RlcignbG9nLWluJywgMHhlYTZmKSxcclxuICAgIHNpZ25JbjogcmVnaXN0ZXIoJ3NpZ24taW4nLCAweGVhNmYpLFxyXG4gICAgZXllOiByZWdpc3RlcignZXllJywgMHhlYTcwKSxcclxuICAgIGV5ZVVud2F0Y2g6IHJlZ2lzdGVyKCdleWUtdW53YXRjaCcsIDB4ZWE3MCksXHJcbiAgICBleWVXYXRjaDogcmVnaXN0ZXIoJ2V5ZS13YXRjaCcsIDB4ZWE3MCksXHJcbiAgICBjaXJjbGVGaWxsZWQ6IHJlZ2lzdGVyKCdjaXJjbGUtZmlsbGVkJywgMHhlYTcxKSxcclxuICAgIHByaW1pdGl2ZURvdDogcmVnaXN0ZXIoJ3ByaW1pdGl2ZS1kb3QnLCAweGVhNzEpLFxyXG4gICAgY2xvc2VEaXJ0eTogcmVnaXN0ZXIoJ2Nsb3NlLWRpcnR5JywgMHhlYTcxKSxcclxuICAgIGRlYnVnQnJlYWtwb2ludDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQnLCAweGVhNzEpLFxyXG4gICAgZGVidWdCcmVha3BvaW50RGlzYWJsZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWRpc2FibGVkJywgMHhlYTcxKSxcclxuICAgIGRlYnVnSGludDogcmVnaXN0ZXIoJ2RlYnVnLWhpbnQnLCAweGVhNzEpLFxyXG4gICAgdGVybWluYWxEZWNvcmF0aW9uU3VjY2VzczogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWRlY29yYXRpb24tc3VjY2VzcycsIDB4ZWE3MSksXHJcbiAgICBwcmltaXRpdmVTcXVhcmU6IHJlZ2lzdGVyKCdwcmltaXRpdmUtc3F1YXJlJywgMHhlYTcyKSxcclxuICAgIGVkaXQ6IHJlZ2lzdGVyKCdlZGl0JywgMHhlYTczKSxcclxuICAgIHBlbmNpbDogcmVnaXN0ZXIoJ3BlbmNpbCcsIDB4ZWE3MyksXHJcbiAgICBpbmZvOiByZWdpc3RlcignaW5mbycsIDB4ZWE3NCksXHJcbiAgICBpc3N1ZU9wZW5lZDogcmVnaXN0ZXIoJ2lzc3VlLW9wZW5lZCcsIDB4ZWE3NCksXHJcbiAgICBnaXN0UHJpdmF0ZTogcmVnaXN0ZXIoJ2dpc3QtcHJpdmF0ZScsIDB4ZWE3NSksXHJcbiAgICBnaXRGb3JrUHJpdmF0ZTogcmVnaXN0ZXIoJ2dpdC1mb3JrLXByaXZhdGUnLCAweGVhNzUpLFxyXG4gICAgbG9jazogcmVnaXN0ZXIoJ2xvY2snLCAweGVhNzUpLFxyXG4gICAgbWlycm9yUHJpdmF0ZTogcmVnaXN0ZXIoJ21pcnJvci1wcml2YXRlJywgMHhlYTc1KSxcclxuICAgIGNsb3NlOiByZWdpc3RlcignY2xvc2UnLCAweGVhNzYpLFxyXG4gICAgcmVtb3ZlQ2xvc2U6IHJlZ2lzdGVyKCdyZW1vdmUtY2xvc2UnLCAweGVhNzYpLFxyXG4gICAgeDogcmVnaXN0ZXIoJ3gnLCAweGVhNzYpLFxyXG4gICAgcmVwb1N5bmM6IHJlZ2lzdGVyKCdyZXBvLXN5bmMnLCAweGVhNzcpLFxyXG4gICAgc3luYzogcmVnaXN0ZXIoJ3N5bmMnLCAweGVhNzcpLFxyXG4gICAgY2xvbmU6IHJlZ2lzdGVyKCdjbG9uZScsIDB4ZWE3OCksXHJcbiAgICBkZXNrdG9wRG93bmxvYWQ6IHJlZ2lzdGVyKCdkZXNrdG9wLWRvd25sb2FkJywgMHhlYTc4KSxcclxuICAgIGJlYWtlcjogcmVnaXN0ZXIoJ2JlYWtlcicsIDB4ZWE3OSksXHJcbiAgICBtaWNyb3Njb3BlOiByZWdpc3RlcignbWljcm9zY29wZScsIDB4ZWE3OSksXHJcbiAgICB2bTogcmVnaXN0ZXIoJ3ZtJywgMHhlYTdhKSxcclxuICAgIGRldmljZURlc2t0b3A6IHJlZ2lzdGVyKCdkZXZpY2UtZGVza3RvcCcsIDB4ZWE3YSksXHJcbiAgICBmaWxlOiByZWdpc3RlcignZmlsZScsIDB4ZWE3YiksXHJcbiAgICBmaWxlVGV4dDogcmVnaXN0ZXIoJ2ZpbGUtdGV4dCcsIDB4ZWE3YiksXHJcbiAgICBtb3JlOiByZWdpc3RlcignbW9yZScsIDB4ZWE3YyksXHJcbiAgICBlbGxpcHNpczogcmVnaXN0ZXIoJ2VsbGlwc2lzJywgMHhlYTdjKSxcclxuICAgIGtlYmFiSG9yaXpvbnRhbDogcmVnaXN0ZXIoJ2tlYmFiLWhvcml6b250YWwnLCAweGVhN2MpLFxyXG4gICAgbWFpbFJlcGx5OiByZWdpc3RlcignbWFpbC1yZXBseScsIDB4ZWE3ZCksXHJcbiAgICByZXBseTogcmVnaXN0ZXIoJ3JlcGx5JywgMHhlYTdkKSxcclxuICAgIG9yZ2FuaXphdGlvbjogcmVnaXN0ZXIoJ29yZ2FuaXphdGlvbicsIDB4ZWE3ZSksXHJcbiAgICBvcmdhbml6YXRpb25GaWxsZWQ6IHJlZ2lzdGVyKCdvcmdhbml6YXRpb24tZmlsbGVkJywgMHhlYTdlKSxcclxuICAgIG9yZ2FuaXphdGlvbk91dGxpbmU6IHJlZ2lzdGVyKCdvcmdhbml6YXRpb24tb3V0bGluZScsIDB4ZWE3ZSksXHJcbiAgICBuZXdGaWxlOiByZWdpc3RlcignbmV3LWZpbGUnLCAweGVhN2YpLFxyXG4gICAgZmlsZUFkZDogcmVnaXN0ZXIoJ2ZpbGUtYWRkJywgMHhlYTdmKSxcclxuICAgIG5ld0ZvbGRlcjogcmVnaXN0ZXIoJ25ldy1mb2xkZXInLCAweGVhODApLFxyXG4gICAgZmlsZURpcmVjdG9yeUNyZWF0ZTogcmVnaXN0ZXIoJ2ZpbGUtZGlyZWN0b3J5LWNyZWF0ZScsIDB4ZWE4MCksXHJcbiAgICB0cmFzaDogcmVnaXN0ZXIoJ3RyYXNoJywgMHhlYTgxKSxcclxuICAgIHRyYXNoY2FuOiByZWdpc3RlcigndHJhc2hjYW4nLCAweGVhODEpLFxyXG4gICAgaGlzdG9yeTogcmVnaXN0ZXIoJ2hpc3RvcnknLCAweGVhODIpLFxyXG4gICAgY2xvY2s6IHJlZ2lzdGVyKCdjbG9jaycsIDB4ZWE4MiksXHJcbiAgICBmb2xkZXI6IHJlZ2lzdGVyKCdmb2xkZXInLCAweGVhODMpLFxyXG4gICAgZmlsZURpcmVjdG9yeTogcmVnaXN0ZXIoJ2ZpbGUtZGlyZWN0b3J5JywgMHhlYTgzKSxcclxuICAgIHN5bWJvbEZvbGRlcjogcmVnaXN0ZXIoJ3N5bWJvbC1mb2xkZXInLCAweGVhODMpLFxyXG4gICAgbG9nb0dpdGh1YjogcmVnaXN0ZXIoJ2xvZ28tZ2l0aHViJywgMHhlYTg0KSxcclxuICAgIG1hcmtHaXRodWI6IHJlZ2lzdGVyKCdtYXJrLWdpdGh1YicsIDB4ZWE4NCksXHJcbiAgICBnaXRodWI6IHJlZ2lzdGVyKCdnaXRodWInLCAweGVhODQpLFxyXG4gICAgdGVybWluYWw6IHJlZ2lzdGVyKCd0ZXJtaW5hbCcsIDB4ZWE4NSksXHJcbiAgICBjb25zb2xlOiByZWdpc3RlcignY29uc29sZScsIDB4ZWE4NSksXHJcbiAgICByZXBsOiByZWdpc3RlcigncmVwbCcsIDB4ZWE4NSksXHJcbiAgICB6YXA6IHJlZ2lzdGVyKCd6YXAnLCAweGVhODYpLFxyXG4gICAgc3ltYm9sRXZlbnQ6IHJlZ2lzdGVyKCdzeW1ib2wtZXZlbnQnLCAweGVhODYpLFxyXG4gICAgZXJyb3I6IHJlZ2lzdGVyKCdlcnJvcicsIDB4ZWE4NyksXHJcbiAgICBzdG9wOiByZWdpc3Rlcignc3RvcCcsIDB4ZWE4NyksXHJcbiAgICB2YXJpYWJsZTogcmVnaXN0ZXIoJ3ZhcmlhYmxlJywgMHhlYTg4KSxcclxuICAgIHN5bWJvbFZhcmlhYmxlOiByZWdpc3Rlcignc3ltYm9sLXZhcmlhYmxlJywgMHhlYTg4KSxcclxuICAgIGFycmF5OiByZWdpc3RlcignYXJyYXknLCAweGVhOGEpLFxyXG4gICAgc3ltYm9sQXJyYXk6IHJlZ2lzdGVyKCdzeW1ib2wtYXJyYXknLCAweGVhOGEpLFxyXG4gICAgc3ltYm9sTW9kdWxlOiByZWdpc3Rlcignc3ltYm9sLW1vZHVsZScsIDB4ZWE4YiksXHJcbiAgICBzeW1ib2xQYWNrYWdlOiByZWdpc3Rlcignc3ltYm9sLXBhY2thZ2UnLCAweGVhOGIpLFxyXG4gICAgc3ltYm9sTmFtZXNwYWNlOiByZWdpc3Rlcignc3ltYm9sLW5hbWVzcGFjZScsIDB4ZWE4YiksXHJcbiAgICBzeW1ib2xPYmplY3Q6IHJlZ2lzdGVyKCdzeW1ib2wtb2JqZWN0JywgMHhlYThiKSxcclxuICAgIHN5bWJvbE1ldGhvZDogcmVnaXN0ZXIoJ3N5bWJvbC1tZXRob2QnLCAweGVhOGMpLFxyXG4gICAgc3ltYm9sRnVuY3Rpb246IHJlZ2lzdGVyKCdzeW1ib2wtZnVuY3Rpb24nLCAweGVhOGMpLFxyXG4gICAgc3ltYm9sQ29uc3RydWN0b3I6IHJlZ2lzdGVyKCdzeW1ib2wtY29uc3RydWN0b3InLCAweGVhOGMpLFxyXG4gICAgc3ltYm9sQm9vbGVhbjogcmVnaXN0ZXIoJ3N5bWJvbC1ib29sZWFuJywgMHhlYThmKSxcclxuICAgIHN5bWJvbE51bGw6IHJlZ2lzdGVyKCdzeW1ib2wtbnVsbCcsIDB4ZWE4ZiksXHJcbiAgICBzeW1ib2xOdW1lcmljOiByZWdpc3Rlcignc3ltYm9sLW51bWVyaWMnLCAweGVhOTApLFxyXG4gICAgc3ltYm9sTnVtYmVyOiByZWdpc3Rlcignc3ltYm9sLW51bWJlcicsIDB4ZWE5MCksXHJcbiAgICBzeW1ib2xTdHJ1Y3R1cmU6IHJlZ2lzdGVyKCdzeW1ib2wtc3RydWN0dXJlJywgMHhlYTkxKSxcclxuICAgIHN5bWJvbFN0cnVjdDogcmVnaXN0ZXIoJ3N5bWJvbC1zdHJ1Y3QnLCAweGVhOTEpLFxyXG4gICAgc3ltYm9sUGFyYW1ldGVyOiByZWdpc3Rlcignc3ltYm9sLXBhcmFtZXRlcicsIDB4ZWE5MiksXHJcbiAgICBzeW1ib2xUeXBlUGFyYW1ldGVyOiByZWdpc3Rlcignc3ltYm9sLXR5cGUtcGFyYW1ldGVyJywgMHhlYTkyKSxcclxuICAgIHN5bWJvbEtleTogcmVnaXN0ZXIoJ3N5bWJvbC1rZXknLCAweGVhOTMpLFxyXG4gICAgc3ltYm9sVGV4dDogcmVnaXN0ZXIoJ3N5bWJvbC10ZXh0JywgMHhlYTkzKSxcclxuICAgIHN5bWJvbFJlZmVyZW5jZTogcmVnaXN0ZXIoJ3N5bWJvbC1yZWZlcmVuY2UnLCAweGVhOTQpLFxyXG4gICAgZ29Ub0ZpbGU6IHJlZ2lzdGVyKCdnby10by1maWxlJywgMHhlYTk0KSxcclxuICAgIHN5bWJvbEVudW06IHJlZ2lzdGVyKCdzeW1ib2wtZW51bScsIDB4ZWE5NSksXHJcbiAgICBzeW1ib2xWYWx1ZTogcmVnaXN0ZXIoJ3N5bWJvbC12YWx1ZScsIDB4ZWE5NSksXHJcbiAgICBzeW1ib2xSdWxlcjogcmVnaXN0ZXIoJ3N5bWJvbC1ydWxlcicsIDB4ZWE5NiksXHJcbiAgICBzeW1ib2xVbml0OiByZWdpc3Rlcignc3ltYm9sLXVuaXQnLCAweGVhOTYpLFxyXG4gICAgYWN0aXZhdGVCcmVha3BvaW50czogcmVnaXN0ZXIoJ2FjdGl2YXRlLWJyZWFrcG9pbnRzJywgMHhlYTk3KSxcclxuICAgIGFyY2hpdmU6IHJlZ2lzdGVyKCdhcmNoaXZlJywgMHhlYTk4KSxcclxuICAgIGFycm93Qm90aDogcmVnaXN0ZXIoJ2Fycm93LWJvdGgnLCAweGVhOTkpLFxyXG4gICAgYXJyb3dEb3duOiByZWdpc3RlcignYXJyb3ctZG93bicsIDB4ZWE5YSksXHJcbiAgICBhcnJvd0xlZnQ6IHJlZ2lzdGVyKCdhcnJvdy1sZWZ0JywgMHhlYTliKSxcclxuICAgIGFycm93UmlnaHQ6IHJlZ2lzdGVyKCdhcnJvdy1yaWdodCcsIDB4ZWE5YyksXHJcbiAgICBhcnJvd1NtYWxsRG93bjogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLWRvd24nLCAweGVhOWQpLFxyXG4gICAgYXJyb3dTbWFsbExlZnQ6IHJlZ2lzdGVyKCdhcnJvdy1zbWFsbC1sZWZ0JywgMHhlYTllKSxcclxuICAgIGFycm93U21hbGxSaWdodDogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLXJpZ2h0JywgMHhlYTlmKSxcclxuICAgIGFycm93U21hbGxVcDogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLXVwJywgMHhlYWEwKSxcclxuICAgIGFycm93VXA6IHJlZ2lzdGVyKCdhcnJvdy11cCcsIDB4ZWFhMSksXHJcbiAgICBiZWxsOiByZWdpc3RlcignYmVsbCcsIDB4ZWFhMiksXHJcbiAgICBib2xkOiByZWdpc3RlcignYm9sZCcsIDB4ZWFhMyksXHJcbiAgICBib29rOiByZWdpc3RlcignYm9vaycsIDB4ZWFhNCksXHJcbiAgICBib29rbWFyazogcmVnaXN0ZXIoJ2Jvb2ttYXJrJywgMHhlYWE1KSxcclxuICAgIGRlYnVnQnJlYWtwb2ludENvbmRpdGlvbmFsVW52ZXJpZmllZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtY29uZGl0aW9uYWwtdW52ZXJpZmllZCcsIDB4ZWFhNiksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRDb25kaXRpb25hbDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtY29uZGl0aW9uYWwnLCAweGVhYTcpLFxyXG4gICAgZGVidWdCcmVha3BvaW50Q29uZGl0aW9uYWxEaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtY29uZGl0aW9uYWwtZGlzYWJsZWQnLCAweGVhYTcpLFxyXG4gICAgZGVidWdCcmVha3BvaW50RGF0YVVudmVyaWZpZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWRhdGEtdW52ZXJpZmllZCcsIDB4ZWFhOCksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnREYXRhOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1kYXRhJywgMHhlYWE5KSxcclxuICAgIGRlYnVnQnJlYWtwb2ludERhdGFEaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtZGF0YS1kaXNhYmxlZCcsIDB4ZWFhOSksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRMb2dVbnZlcmlmaWVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1sb2ctdW52ZXJpZmllZCcsIDB4ZWFhYSksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRMb2c6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWxvZycsIDB4ZWFhYiksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRMb2dEaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtbG9nLWRpc2FibGVkJywgMHhlYWFiKSxcclxuICAgIGJyaWVmY2FzZTogcmVnaXN0ZXIoJ2JyaWVmY2FzZScsIDB4ZWFhYyksXHJcbiAgICBicm9hZGNhc3Q6IHJlZ2lzdGVyKCdicm9hZGNhc3QnLCAweGVhYWQpLFxyXG4gICAgYnJvd3NlcjogcmVnaXN0ZXIoJ2Jyb3dzZXInLCAweGVhYWUpLFxyXG4gICAgYnVnOiByZWdpc3RlcignYnVnJywgMHhlYWFmKSxcclxuICAgIGNhbGVuZGFyOiByZWdpc3RlcignY2FsZW5kYXInLCAweGVhYjApLFxyXG4gICAgY2FzZVNlbnNpdGl2ZTogcmVnaXN0ZXIoJ2Nhc2Utc2Vuc2l0aXZlJywgMHhlYWIxKSxcclxuICAgIGNoZWNrOiByZWdpc3RlcignY2hlY2snLCAweGVhYjIpLFxyXG4gICAgY2hlY2tsaXN0OiByZWdpc3RlcignY2hlY2tsaXN0JywgMHhlYWIzKSxcclxuICAgIGNoZXZyb25Eb3duOiByZWdpc3RlcignY2hldnJvbi1kb3duJywgMHhlYWI0KSxcclxuICAgIGNoZXZyb25MZWZ0OiByZWdpc3RlcignY2hldnJvbi1sZWZ0JywgMHhlYWI1KSxcclxuICAgIGNoZXZyb25SaWdodDogcmVnaXN0ZXIoJ2NoZXZyb24tcmlnaHQnLCAweGVhYjYpLFxyXG4gICAgY2hldnJvblVwOiByZWdpc3RlcignY2hldnJvbi11cCcsIDB4ZWFiNyksXHJcbiAgICBjaHJvbWVDbG9zZTogcmVnaXN0ZXIoJ2Nocm9tZS1jbG9zZScsIDB4ZWFiOCksXHJcbiAgICBjaHJvbWVNYXhpbWl6ZTogcmVnaXN0ZXIoJ2Nocm9tZS1tYXhpbWl6ZScsIDB4ZWFiOSksXHJcbiAgICBjaHJvbWVNaW5pbWl6ZTogcmVnaXN0ZXIoJ2Nocm9tZS1taW5pbWl6ZScsIDB4ZWFiYSksXHJcbiAgICBjaHJvbWVSZXN0b3JlOiByZWdpc3RlcignY2hyb21lLXJlc3RvcmUnLCAweGVhYmIpLFxyXG4gICAgY2lyY2xlT3V0bGluZTogcmVnaXN0ZXIoJ2NpcmNsZS1vdXRsaW5lJywgMHhlYWJjKSxcclxuICAgIGNpcmNsZTogcmVnaXN0ZXIoJ2NpcmNsZScsIDB4ZWFiYyksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRVbnZlcmlmaWVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC11bnZlcmlmaWVkJywgMHhlYWJjKSxcclxuICAgIHRlcm1pbmFsRGVjb3JhdGlvbkluY29tcGxldGU6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1kZWNvcmF0aW9uLWluY29tcGxldGUnLCAweGVhYmMpLFxyXG4gICAgY2lyY2xlU2xhc2g6IHJlZ2lzdGVyKCdjaXJjbGUtc2xhc2gnLCAweGVhYmQpLFxyXG4gICAgY2lyY3VpdEJvYXJkOiByZWdpc3RlcignY2lyY3VpdC1ib2FyZCcsIDB4ZWFiZSksXHJcbiAgICBjbGVhckFsbDogcmVnaXN0ZXIoJ2NsZWFyLWFsbCcsIDB4ZWFiZiksXHJcbiAgICBjbGlwcHk6IHJlZ2lzdGVyKCdjbGlwcHknLCAweGVhYzApLFxyXG4gICAgY2xvc2VBbGw6IHJlZ2lzdGVyKCdjbG9zZS1hbGwnLCAweGVhYzEpLFxyXG4gICAgY2xvdWREb3dubG9hZDogcmVnaXN0ZXIoJ2Nsb3VkLWRvd25sb2FkJywgMHhlYWMyKSxcclxuICAgIGNsb3VkVXBsb2FkOiByZWdpc3RlcignY2xvdWQtdXBsb2FkJywgMHhlYWMzKSxcclxuICAgIGNvZGU6IHJlZ2lzdGVyKCdjb2RlJywgMHhlYWM0KSxcclxuICAgIGNvbGxhcHNlQWxsOiByZWdpc3RlcignY29sbGFwc2UtYWxsJywgMHhlYWM1KSxcclxuICAgIGNvbG9yTW9kZTogcmVnaXN0ZXIoJ2NvbG9yLW1vZGUnLCAweGVhYzYpLFxyXG4gICAgY29tbWVudERpc2N1c3Npb246IHJlZ2lzdGVyKCdjb21tZW50LWRpc2N1c3Npb24nLCAweGVhYzcpLFxyXG4gICAgY3JlZGl0Q2FyZDogcmVnaXN0ZXIoJ2NyZWRpdC1jYXJkJywgMHhlYWM5KSxcclxuICAgIGRhc2g6IHJlZ2lzdGVyKCdkYXNoJywgMHhlYWNjKSxcclxuICAgIGRhc2hib2FyZDogcmVnaXN0ZXIoJ2Rhc2hib2FyZCcsIDB4ZWFjZCksXHJcbiAgICBkYXRhYmFzZTogcmVnaXN0ZXIoJ2RhdGFiYXNlJywgMHhlYWNlKSxcclxuICAgIGRlYnVnQ29udGludWU6IHJlZ2lzdGVyKCdkZWJ1Zy1jb250aW51ZScsIDB4ZWFjZiksXHJcbiAgICBkZWJ1Z0Rpc2Nvbm5lY3Q6IHJlZ2lzdGVyKCdkZWJ1Zy1kaXNjb25uZWN0JywgMHhlYWQwKSxcclxuICAgIGRlYnVnUGF1c2U6IHJlZ2lzdGVyKCdkZWJ1Zy1wYXVzZScsIDB4ZWFkMSksXHJcbiAgICBkZWJ1Z1Jlc3RhcnQ6IHJlZ2lzdGVyKCdkZWJ1Zy1yZXN0YXJ0JywgMHhlYWQyKSxcclxuICAgIGRlYnVnU3RhcnQ6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGFydCcsIDB4ZWFkMyksXHJcbiAgICBkZWJ1Z1N0ZXBJbnRvOiByZWdpc3RlcignZGVidWctc3RlcC1pbnRvJywgMHhlYWQ0KSxcclxuICAgIGRlYnVnU3RlcE91dDogcmVnaXN0ZXIoJ2RlYnVnLXN0ZXAtb3V0JywgMHhlYWQ1KSxcclxuICAgIGRlYnVnU3RlcE92ZXI6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGVwLW92ZXInLCAweGVhZDYpLFxyXG4gICAgZGVidWdTdG9wOiByZWdpc3RlcignZGVidWctc3RvcCcsIDB4ZWFkNyksXHJcbiAgICBkZWJ1ZzogcmVnaXN0ZXIoJ2RlYnVnJywgMHhlYWQ4KSxcclxuICAgIGRldmljZUNhbWVyYVZpZGVvOiByZWdpc3RlcignZGV2aWNlLWNhbWVyYS12aWRlbycsIDB4ZWFkOSksXHJcbiAgICBkZXZpY2VDYW1lcmE6IHJlZ2lzdGVyKCdkZXZpY2UtY2FtZXJhJywgMHhlYWRhKSxcclxuICAgIGRldmljZU1vYmlsZTogcmVnaXN0ZXIoJ2RldmljZS1tb2JpbGUnLCAweGVhZGIpLFxyXG4gICAgZGlmZkFkZGVkOiByZWdpc3RlcignZGlmZi1hZGRlZCcsIDB4ZWFkYyksXHJcbiAgICBkaWZmSWdub3JlZDogcmVnaXN0ZXIoJ2RpZmYtaWdub3JlZCcsIDB4ZWFkZCksXHJcbiAgICBkaWZmTW9kaWZpZWQ6IHJlZ2lzdGVyKCdkaWZmLW1vZGlmaWVkJywgMHhlYWRlKSxcclxuICAgIGRpZmZSZW1vdmVkOiByZWdpc3RlcignZGlmZi1yZW1vdmVkJywgMHhlYWRmKSxcclxuICAgIGRpZmZSZW5hbWVkOiByZWdpc3RlcignZGlmZi1yZW5hbWVkJywgMHhlYWUwKSxcclxuICAgIGRpZmY6IHJlZ2lzdGVyKCdkaWZmJywgMHhlYWUxKSxcclxuICAgIGRpZmZTaWRlYnlzaWRlOiByZWdpc3RlcignZGlmZi1zaWRlYnlzaWRlJywgMHhlYWUxKSxcclxuICAgIGRpc2NhcmQ6IHJlZ2lzdGVyKCdkaXNjYXJkJywgMHhlYWUyKSxcclxuICAgIGVkaXRvckxheW91dDogcmVnaXN0ZXIoJ2VkaXRvci1sYXlvdXQnLCAweGVhZTMpLFxyXG4gICAgZW1wdHlXaW5kb3c6IHJlZ2lzdGVyKCdlbXB0eS13aW5kb3cnLCAweGVhZTQpLFxyXG4gICAgZXhjbHVkZTogcmVnaXN0ZXIoJ2V4Y2x1ZGUnLCAweGVhZTUpLFxyXG4gICAgZXh0ZW5zaW9uczogcmVnaXN0ZXIoJ2V4dGVuc2lvbnMnLCAweGVhZTYpLFxyXG4gICAgZXllQ2xvc2VkOiByZWdpc3RlcignZXllLWNsb3NlZCcsIDB4ZWFlNyksXHJcbiAgICBmaWxlQmluYXJ5OiByZWdpc3RlcignZmlsZS1iaW5hcnknLCAweGVhZTgpLFxyXG4gICAgZmlsZUNvZGU6IHJlZ2lzdGVyKCdmaWxlLWNvZGUnLCAweGVhZTkpLFxyXG4gICAgZmlsZU1lZGlhOiByZWdpc3RlcignZmlsZS1tZWRpYScsIDB4ZWFlYSksXHJcbiAgICBmaWxlUGRmOiByZWdpc3RlcignZmlsZS1wZGYnLCAweGVhZWIpLFxyXG4gICAgZmlsZVN1Ym1vZHVsZTogcmVnaXN0ZXIoJ2ZpbGUtc3VibW9kdWxlJywgMHhlYWVjKSxcclxuICAgIGZpbGVTeW1saW5rRGlyZWN0b3J5OiByZWdpc3RlcignZmlsZS1zeW1saW5rLWRpcmVjdG9yeScsIDB4ZWFlZCksXHJcbiAgICBmaWxlU3ltbGlua0ZpbGU6IHJlZ2lzdGVyKCdmaWxlLXN5bWxpbmstZmlsZScsIDB4ZWFlZSksXHJcbiAgICBmaWxlWmlwOiByZWdpc3RlcignZmlsZS16aXAnLCAweGVhZWYpLFxyXG4gICAgZmlsZXM6IHJlZ2lzdGVyKCdmaWxlcycsIDB4ZWFmMCksXHJcbiAgICBmaWx0ZXI6IHJlZ2lzdGVyKCdmaWx0ZXInLCAweGVhZjEpLFxyXG4gICAgZmxhbWU6IHJlZ2lzdGVyKCdmbGFtZScsIDB4ZWFmMiksXHJcbiAgICBmb2xkRG93bjogcmVnaXN0ZXIoJ2ZvbGQtZG93bicsIDB4ZWFmMyksXHJcbiAgICBmb2xkVXA6IHJlZ2lzdGVyKCdmb2xkLXVwJywgMHhlYWY0KSxcclxuICAgIGZvbGQ6IHJlZ2lzdGVyKCdmb2xkJywgMHhlYWY1KSxcclxuICAgIGZvbGRlckFjdGl2ZTogcmVnaXN0ZXIoJ2ZvbGRlci1hY3RpdmUnLCAweGVhZjYpLFxyXG4gICAgZm9sZGVyT3BlbmVkOiByZWdpc3RlcignZm9sZGVyLW9wZW5lZCcsIDB4ZWFmNyksXHJcbiAgICBnZWFyOiByZWdpc3RlcignZ2VhcicsIDB4ZWFmOCksXHJcbiAgICBnaWZ0OiByZWdpc3RlcignZ2lmdCcsIDB4ZWFmOSksXHJcbiAgICBnaXN0U2VjcmV0OiByZWdpc3RlcignZ2lzdC1zZWNyZXQnLCAweGVhZmEpLFxyXG4gICAgZ2lzdDogcmVnaXN0ZXIoJ2dpc3QnLCAweGVhZmIpLFxyXG4gICAgZ2l0Q29tbWl0OiByZWdpc3RlcignZ2l0LWNvbW1pdCcsIDB4ZWFmYyksXHJcbiAgICBnaXRDb21wYXJlOiByZWdpc3RlcignZ2l0LWNvbXBhcmUnLCAweGVhZmQpLFxyXG4gICAgY29tcGFyZUNoYW5nZXM6IHJlZ2lzdGVyKCdjb21wYXJlLWNoYW5nZXMnLCAweGVhZmQpLFxyXG4gICAgZ2l0TWVyZ2U6IHJlZ2lzdGVyKCdnaXQtbWVyZ2UnLCAweGVhZmUpLFxyXG4gICAgZ2l0aHViQWN0aW9uOiByZWdpc3RlcignZ2l0aHViLWFjdGlvbicsIDB4ZWFmZiksXHJcbiAgICBnaXRodWJBbHQ6IHJlZ2lzdGVyKCdnaXRodWItYWx0JywgMHhlYjAwKSxcclxuICAgIGdsb2JlOiByZWdpc3RlcignZ2xvYmUnLCAweGViMDEpLFxyXG4gICAgZ3JhYmJlcjogcmVnaXN0ZXIoJ2dyYWJiZXInLCAweGViMDIpLFxyXG4gICAgZ3JhcGg6IHJlZ2lzdGVyKCdncmFwaCcsIDB4ZWIwMyksXHJcbiAgICBncmlwcGVyOiByZWdpc3RlcignZ3JpcHBlcicsIDB4ZWIwNCksXHJcbiAgICBoZWFydDogcmVnaXN0ZXIoJ2hlYXJ0JywgMHhlYjA1KSxcclxuICAgIGhvbWU6IHJlZ2lzdGVyKCdob21lJywgMHhlYjA2KSxcclxuICAgIGhvcml6b250YWxSdWxlOiByZWdpc3RlcignaG9yaXpvbnRhbC1ydWxlJywgMHhlYjA3KSxcclxuICAgIGh1Ym90OiByZWdpc3RlcignaHVib3QnLCAweGViMDgpLFxyXG4gICAgaW5ib3g6IHJlZ2lzdGVyKCdpbmJveCcsIDB4ZWIwOSksXHJcbiAgICBpc3N1ZVJlb3BlbmVkOiByZWdpc3RlcignaXNzdWUtcmVvcGVuZWQnLCAweGViMGIpLFxyXG4gICAgaXNzdWVzOiByZWdpc3RlcignaXNzdWVzJywgMHhlYjBjKSxcclxuICAgIGl0YWxpYzogcmVnaXN0ZXIoJ2l0YWxpYycsIDB4ZWIwZCksXHJcbiAgICBqZXJzZXk6IHJlZ2lzdGVyKCdqZXJzZXknLCAweGViMGUpLFxyXG4gICAganNvbjogcmVnaXN0ZXIoJ2pzb24nLCAweGViMGYpLFxyXG4gICAga2ViYWJWZXJ0aWNhbDogcmVnaXN0ZXIoJ2tlYmFiLXZlcnRpY2FsJywgMHhlYjEwKSxcclxuICAgIGtleTogcmVnaXN0ZXIoJ2tleScsIDB4ZWIxMSksXHJcbiAgICBsYXc6IHJlZ2lzdGVyKCdsYXcnLCAweGViMTIpLFxyXG4gICAgbGlnaHRidWxiQXV0b2ZpeDogcmVnaXN0ZXIoJ2xpZ2h0YnVsYi1hdXRvZml4JywgMHhlYjEzKSxcclxuICAgIGxpbmtFeHRlcm5hbDogcmVnaXN0ZXIoJ2xpbmstZXh0ZXJuYWwnLCAweGViMTQpLFxyXG4gICAgbGluazogcmVnaXN0ZXIoJ2xpbmsnLCAweGViMTUpLFxyXG4gICAgbGlzdE9yZGVyZWQ6IHJlZ2lzdGVyKCdsaXN0LW9yZGVyZWQnLCAweGViMTYpLFxyXG4gICAgbGlzdFVub3JkZXJlZDogcmVnaXN0ZXIoJ2xpc3QtdW5vcmRlcmVkJywgMHhlYjE3KSxcclxuICAgIGxpdmVTaGFyZTogcmVnaXN0ZXIoJ2xpdmUtc2hhcmUnLCAweGViMTgpLFxyXG4gICAgbG9hZGluZzogcmVnaXN0ZXIoJ2xvYWRpbmcnLCAweGViMTkpLFxyXG4gICAgbG9jYXRpb246IHJlZ2lzdGVyKCdsb2NhdGlvbicsIDB4ZWIxYSksXHJcbiAgICBtYWlsUmVhZDogcmVnaXN0ZXIoJ21haWwtcmVhZCcsIDB4ZWIxYiksXHJcbiAgICBtYWlsOiByZWdpc3RlcignbWFpbCcsIDB4ZWIxYyksXHJcbiAgICBtYXJrZG93bjogcmVnaXN0ZXIoJ21hcmtkb3duJywgMHhlYjFkKSxcclxuICAgIG1lZ2FwaG9uZTogcmVnaXN0ZXIoJ21lZ2FwaG9uZScsIDB4ZWIxZSksXHJcbiAgICBtZW50aW9uOiByZWdpc3RlcignbWVudGlvbicsIDB4ZWIxZiksXHJcbiAgICBtaWxlc3RvbmU6IHJlZ2lzdGVyKCdtaWxlc3RvbmUnLCAweGViMjApLFxyXG4gICAgZ2l0UHVsbFJlcXVlc3RNaWxlc3RvbmU6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LW1pbGVzdG9uZScsIDB4ZWIyMCksXHJcbiAgICBtb3J0YXJCb2FyZDogcmVnaXN0ZXIoJ21vcnRhci1ib2FyZCcsIDB4ZWIyMSksXHJcbiAgICBtb3ZlOiByZWdpc3RlcignbW92ZScsIDB4ZWIyMiksXHJcbiAgICBtdWx0aXBsZVdpbmRvd3M6IHJlZ2lzdGVyKCdtdWx0aXBsZS13aW5kb3dzJywgMHhlYjIzKSxcclxuICAgIG11dGU6IHJlZ2lzdGVyKCdtdXRlJywgMHhlYjI0KSxcclxuICAgIG5vTmV3bGluZTogcmVnaXN0ZXIoJ25vLW5ld2xpbmUnLCAweGViMjUpLFxyXG4gICAgbm90ZTogcmVnaXN0ZXIoJ25vdGUnLCAweGViMjYpLFxyXG4gICAgb2N0b2ZhY2U6IHJlZ2lzdGVyKCdvY3RvZmFjZScsIDB4ZWIyNyksXHJcbiAgICBvcGVuUHJldmlldzogcmVnaXN0ZXIoJ29wZW4tcHJldmlldycsIDB4ZWIyOCksXHJcbiAgICBwYWNrYWdlOiByZWdpc3RlcigncGFja2FnZScsIDB4ZWIyOSksXHJcbiAgICBwYWludGNhbjogcmVnaXN0ZXIoJ3BhaW50Y2FuJywgMHhlYjJhKSxcclxuICAgIHBpbjogcmVnaXN0ZXIoJ3BpbicsIDB4ZWIyYiksXHJcbiAgICBwbGF5OiByZWdpc3RlcigncGxheScsIDB4ZWIyYyksXHJcbiAgICBydW46IHJlZ2lzdGVyKCdydW4nLCAweGViMmMpLFxyXG4gICAgcGx1ZzogcmVnaXN0ZXIoJ3BsdWcnLCAweGViMmQpLFxyXG4gICAgcHJlc2VydmVDYXNlOiByZWdpc3RlcigncHJlc2VydmUtY2FzZScsIDB4ZWIyZSksXHJcbiAgICBwcmV2aWV3OiByZWdpc3RlcigncHJldmlldycsIDB4ZWIyZiksXHJcbiAgICBwcm9qZWN0OiByZWdpc3RlcigncHJvamVjdCcsIDB4ZWIzMCksXHJcbiAgICBwdWxzZTogcmVnaXN0ZXIoJ3B1bHNlJywgMHhlYjMxKSxcclxuICAgIHF1ZXN0aW9uOiByZWdpc3RlcigncXVlc3Rpb24nLCAweGViMzIpLFxyXG4gICAgcXVvdGU6IHJlZ2lzdGVyKCdxdW90ZScsIDB4ZWIzMyksXHJcbiAgICByYWRpb1Rvd2VyOiByZWdpc3RlcigncmFkaW8tdG93ZXInLCAweGViMzQpLFxyXG4gICAgcmVhY3Rpb25zOiByZWdpc3RlcigncmVhY3Rpb25zJywgMHhlYjM1KSxcclxuICAgIHJlZmVyZW5jZXM6IHJlZ2lzdGVyKCdyZWZlcmVuY2VzJywgMHhlYjM2KSxcclxuICAgIHJlZnJlc2g6IHJlZ2lzdGVyKCdyZWZyZXNoJywgMHhlYjM3KSxcclxuICAgIHJlZ2V4OiByZWdpc3RlcigncmVnZXgnLCAweGViMzgpLFxyXG4gICAgcmVtb3RlRXhwbG9yZXI6IHJlZ2lzdGVyKCdyZW1vdGUtZXhwbG9yZXInLCAweGViMzkpLFxyXG4gICAgcmVtb3RlOiByZWdpc3RlcigncmVtb3RlJywgMHhlYjNhKSxcclxuICAgIHJlbW92ZTogcmVnaXN0ZXIoJ3JlbW92ZScsIDB4ZWIzYiksXHJcbiAgICByZXBsYWNlQWxsOiByZWdpc3RlcigncmVwbGFjZS1hbGwnLCAweGViM2MpLFxyXG4gICAgcmVwbGFjZTogcmVnaXN0ZXIoJ3JlcGxhY2UnLCAweGViM2QpLFxyXG4gICAgcmVwb0Nsb25lOiByZWdpc3RlcigncmVwby1jbG9uZScsIDB4ZWIzZSksXHJcbiAgICByZXBvRm9yY2VQdXNoOiByZWdpc3RlcigncmVwby1mb3JjZS1wdXNoJywgMHhlYjNmKSxcclxuICAgIHJlcG9QdWxsOiByZWdpc3RlcigncmVwby1wdWxsJywgMHhlYjQwKSxcclxuICAgIHJlcG9QdXNoOiByZWdpc3RlcigncmVwby1wdXNoJywgMHhlYjQxKSxcclxuICAgIHJlcG9ydDogcmVnaXN0ZXIoJ3JlcG9ydCcsIDB4ZWI0MiksXHJcbiAgICByZXF1ZXN0Q2hhbmdlczogcmVnaXN0ZXIoJ3JlcXVlc3QtY2hhbmdlcycsIDB4ZWI0MyksXHJcbiAgICByb2NrZXQ6IHJlZ2lzdGVyKCdyb2NrZXQnLCAweGViNDQpLFxyXG4gICAgcm9vdEZvbGRlck9wZW5lZDogcmVnaXN0ZXIoJ3Jvb3QtZm9sZGVyLW9wZW5lZCcsIDB4ZWI0NSksXHJcbiAgICByb290Rm9sZGVyOiByZWdpc3Rlcigncm9vdC1mb2xkZXInLCAweGViNDYpLFxyXG4gICAgcnNzOiByZWdpc3RlcigncnNzJywgMHhlYjQ3KSxcclxuICAgIHJ1Ynk6IHJlZ2lzdGVyKCdydWJ5JywgMHhlYjQ4KSxcclxuICAgIHNhdmVBbGw6IHJlZ2lzdGVyKCdzYXZlLWFsbCcsIDB4ZWI0OSksXHJcbiAgICBzYXZlQXM6IHJlZ2lzdGVyKCdzYXZlLWFzJywgMHhlYjRhKSxcclxuICAgIHNhdmU6IHJlZ2lzdGVyKCdzYXZlJywgMHhlYjRiKSxcclxuICAgIHNjcmVlbkZ1bGw6IHJlZ2lzdGVyKCdzY3JlZW4tZnVsbCcsIDB4ZWI0YyksXHJcbiAgICBzY3JlZW5Ob3JtYWw6IHJlZ2lzdGVyKCdzY3JlZW4tbm9ybWFsJywgMHhlYjRkKSxcclxuICAgIHNlYXJjaFN0b3A6IHJlZ2lzdGVyKCdzZWFyY2gtc3RvcCcsIDB4ZWI0ZSksXHJcbiAgICBzZXJ2ZXI6IHJlZ2lzdGVyKCdzZXJ2ZXInLCAweGViNTApLFxyXG4gICAgc2V0dGluZ3NHZWFyOiByZWdpc3Rlcignc2V0dGluZ3MtZ2VhcicsIDB4ZWI1MSksXHJcbiAgICBzZXR0aW5nczogcmVnaXN0ZXIoJ3NldHRpbmdzJywgMHhlYjUyKSxcclxuICAgIHNoaWVsZDogcmVnaXN0ZXIoJ3NoaWVsZCcsIDB4ZWI1MyksXHJcbiAgICBzbWlsZXk6IHJlZ2lzdGVyKCdzbWlsZXknLCAweGViNTQpLFxyXG4gICAgc29ydFByZWNlZGVuY2U6IHJlZ2lzdGVyKCdzb3J0LXByZWNlZGVuY2UnLCAweGViNTUpLFxyXG4gICAgc3BsaXRIb3Jpem9udGFsOiByZWdpc3Rlcignc3BsaXQtaG9yaXpvbnRhbCcsIDB4ZWI1NiksXHJcbiAgICBzcGxpdFZlcnRpY2FsOiByZWdpc3Rlcignc3BsaXQtdmVydGljYWwnLCAweGViNTcpLFxyXG4gICAgc3F1aXJyZWw6IHJlZ2lzdGVyKCdzcXVpcnJlbCcsIDB4ZWI1OCksXHJcbiAgICBzdGFyRnVsbDogcmVnaXN0ZXIoJ3N0YXItZnVsbCcsIDB4ZWI1OSksXHJcbiAgICBzdGFySGFsZjogcmVnaXN0ZXIoJ3N0YXItaGFsZicsIDB4ZWI1YSksXHJcbiAgICBzeW1ib2xDbGFzczogcmVnaXN0ZXIoJ3N5bWJvbC1jbGFzcycsIDB4ZWI1YiksXHJcbiAgICBzeW1ib2xDb2xvcjogcmVnaXN0ZXIoJ3N5bWJvbC1jb2xvcicsIDB4ZWI1YyksXHJcbiAgICBzeW1ib2xDb25zdGFudDogcmVnaXN0ZXIoJ3N5bWJvbC1jb25zdGFudCcsIDB4ZWI1ZCksXHJcbiAgICBzeW1ib2xFbnVtTWVtYmVyOiByZWdpc3Rlcignc3ltYm9sLWVudW0tbWVtYmVyJywgMHhlYjVlKSxcclxuICAgIHN5bWJvbEZpZWxkOiByZWdpc3Rlcignc3ltYm9sLWZpZWxkJywgMHhlYjVmKSxcclxuICAgIHN5bWJvbEZpbGU6IHJlZ2lzdGVyKCdzeW1ib2wtZmlsZScsIDB4ZWI2MCksXHJcbiAgICBzeW1ib2xJbnRlcmZhY2U6IHJlZ2lzdGVyKCdzeW1ib2wtaW50ZXJmYWNlJywgMHhlYjYxKSxcclxuICAgIHN5bWJvbEtleXdvcmQ6IHJlZ2lzdGVyKCdzeW1ib2wta2V5d29yZCcsIDB4ZWI2MiksXHJcbiAgICBzeW1ib2xNaXNjOiByZWdpc3Rlcignc3ltYm9sLW1pc2MnLCAweGViNjMpLFxyXG4gICAgc3ltYm9sT3BlcmF0b3I6IHJlZ2lzdGVyKCdzeW1ib2wtb3BlcmF0b3InLCAweGViNjQpLFxyXG4gICAgc3ltYm9sUHJvcGVydHk6IHJlZ2lzdGVyKCdzeW1ib2wtcHJvcGVydHknLCAweGViNjUpLFxyXG4gICAgd3JlbmNoOiByZWdpc3Rlcignd3JlbmNoJywgMHhlYjY1KSxcclxuICAgIHdyZW5jaFN1YmFjdGlvbjogcmVnaXN0ZXIoJ3dyZW5jaC1zdWJhY3Rpb24nLCAweGViNjUpLFxyXG4gICAgc3ltYm9sU25pcHBldDogcmVnaXN0ZXIoJ3N5bWJvbC1zbmlwcGV0JywgMHhlYjY2KSxcclxuICAgIHRhc2tsaXN0OiByZWdpc3RlcigndGFza2xpc3QnLCAweGViNjcpLFxyXG4gICAgdGVsZXNjb3BlOiByZWdpc3RlcigndGVsZXNjb3BlJywgMHhlYjY4KSxcclxuICAgIHRleHRTaXplOiByZWdpc3RlcigndGV4dC1zaXplJywgMHhlYjY5KSxcclxuICAgIHRocmVlQmFyczogcmVnaXN0ZXIoJ3RocmVlLWJhcnMnLCAweGViNmEpLFxyXG4gICAgdGh1bWJzZG93bjogcmVnaXN0ZXIoJ3RodW1ic2Rvd24nLCAweGViNmIpLFxyXG4gICAgdGh1bWJzdXA6IHJlZ2lzdGVyKCd0aHVtYnN1cCcsIDB4ZWI2YyksXHJcbiAgICB0b29sczogcmVnaXN0ZXIoJ3Rvb2xzJywgMHhlYjZkKSxcclxuICAgIHRyaWFuZ2xlRG93bjogcmVnaXN0ZXIoJ3RyaWFuZ2xlLWRvd24nLCAweGViNmUpLFxyXG4gICAgdHJpYW5nbGVMZWZ0OiByZWdpc3RlcigndHJpYW5nbGUtbGVmdCcsIDB4ZWI2ZiksXHJcbiAgICB0cmlhbmdsZVJpZ2h0OiByZWdpc3RlcigndHJpYW5nbGUtcmlnaHQnLCAweGViNzApLFxyXG4gICAgdHJpYW5nbGVVcDogcmVnaXN0ZXIoJ3RyaWFuZ2xlLXVwJywgMHhlYjcxKSxcclxuICAgIHR3aXR0ZXI6IHJlZ2lzdGVyKCd0d2l0dGVyJywgMHhlYjcyKSxcclxuICAgIHVuZm9sZDogcmVnaXN0ZXIoJ3VuZm9sZCcsIDB4ZWI3MyksXHJcbiAgICB1bmxvY2s6IHJlZ2lzdGVyKCd1bmxvY2snLCAweGViNzQpLFxyXG4gICAgdW5tdXRlOiByZWdpc3RlcigndW5tdXRlJywgMHhlYjc1KSxcclxuICAgIHVudmVyaWZpZWQ6IHJlZ2lzdGVyKCd1bnZlcmlmaWVkJywgMHhlYjc2KSxcclxuICAgIHZlcmlmaWVkOiByZWdpc3RlcigndmVyaWZpZWQnLCAweGViNzcpLFxyXG4gICAgdmVyc2lvbnM6IHJlZ2lzdGVyKCd2ZXJzaW9ucycsIDB4ZWI3OCksXHJcbiAgICB2bUFjdGl2ZTogcmVnaXN0ZXIoJ3ZtLWFjdGl2ZScsIDB4ZWI3OSksXHJcbiAgICB2bU91dGxpbmU6IHJlZ2lzdGVyKCd2bS1vdXRsaW5lJywgMHhlYjdhKSxcclxuICAgIHZtUnVubmluZzogcmVnaXN0ZXIoJ3ZtLXJ1bm5pbmcnLCAweGViN2IpLFxyXG4gICAgd2F0Y2g6IHJlZ2lzdGVyKCd3YXRjaCcsIDB4ZWI3YyksXHJcbiAgICB3aGl0ZXNwYWNlOiByZWdpc3Rlcignd2hpdGVzcGFjZScsIDB4ZWI3ZCksXHJcbiAgICB3aG9sZVdvcmQ6IHJlZ2lzdGVyKCd3aG9sZS13b3JkJywgMHhlYjdlKSxcclxuICAgIHdpbmRvdzogcmVnaXN0ZXIoJ3dpbmRvdycsIDB4ZWI3ZiksXHJcbiAgICB3b3JkV3JhcDogcmVnaXN0ZXIoJ3dvcmQtd3JhcCcsIDB4ZWI4MCksXHJcbiAgICB6b29tSW46IHJlZ2lzdGVyKCd6b29tLWluJywgMHhlYjgxKSxcclxuICAgIHpvb21PdXQ6IHJlZ2lzdGVyKCd6b29tLW91dCcsIDB4ZWI4MiksXHJcbiAgICBsaXN0RmlsdGVyOiByZWdpc3RlcignbGlzdC1maWx0ZXInLCAweGViODMpLFxyXG4gICAgbGlzdEZsYXQ6IHJlZ2lzdGVyKCdsaXN0LWZsYXQnLCAweGViODQpLFxyXG4gICAgbGlzdFNlbGVjdGlvbjogcmVnaXN0ZXIoJ2xpc3Qtc2VsZWN0aW9uJywgMHhlYjg1KSxcclxuICAgIHNlbGVjdGlvbjogcmVnaXN0ZXIoJ3NlbGVjdGlvbicsIDB4ZWI4NSksXHJcbiAgICBsaXN0VHJlZTogcmVnaXN0ZXIoJ2xpc3QtdHJlZScsIDB4ZWI4NiksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRGdW5jdGlvblVudmVyaWZpZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWZ1bmN0aW9uLXVudmVyaWZpZWQnLCAweGViODcpLFxyXG4gICAgZGVidWdCcmVha3BvaW50RnVuY3Rpb246IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWZ1bmN0aW9uJywgMHhlYjg4KSxcclxuICAgIGRlYnVnQnJlYWtwb2ludEZ1bmN0aW9uRGlzYWJsZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWZ1bmN0aW9uLWRpc2FibGVkJywgMHhlYjg4KSxcclxuICAgIGRlYnVnU3RhY2tmcmFtZUFjdGl2ZTogcmVnaXN0ZXIoJ2RlYnVnLXN0YWNrZnJhbWUtYWN0aXZlJywgMHhlYjg5KSxcclxuICAgIGNpcmNsZVNtYWxsRmlsbGVkOiByZWdpc3RlcignY2lyY2xlLXNtYWxsLWZpbGxlZCcsIDB4ZWI4YSksXHJcbiAgICBkZWJ1Z1N0YWNrZnJhbWVEb3Q6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGFja2ZyYW1lLWRvdCcsIDB4ZWI4YSksXHJcbiAgICB0ZXJtaW5hbERlY29yYXRpb25NYXJrOiByZWdpc3RlcigndGVybWluYWwtZGVjb3JhdGlvbi1tYXJrJywgMHhlYjhhKSxcclxuICAgIGRlYnVnU3RhY2tmcmFtZTogcmVnaXN0ZXIoJ2RlYnVnLXN0YWNrZnJhbWUnLCAweGViOGIpLFxyXG4gICAgZGVidWdTdGFja2ZyYW1lRm9jdXNlZDogcmVnaXN0ZXIoJ2RlYnVnLXN0YWNrZnJhbWUtZm9jdXNlZCcsIDB4ZWI4YiksXHJcbiAgICBkZWJ1Z0JyZWFrcG9pbnRVbnN1cHBvcnRlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtdW5zdXBwb3J0ZWQnLCAweGViOGMpLFxyXG4gICAgc3ltYm9sU3RyaW5nOiByZWdpc3Rlcignc3ltYm9sLXN0cmluZycsIDB4ZWI4ZCksXHJcbiAgICBkZWJ1Z1JldmVyc2VDb250aW51ZTogcmVnaXN0ZXIoJ2RlYnVnLXJldmVyc2UtY29udGludWUnLCAweGViOGUpLFxyXG4gICAgZGVidWdTdGVwQmFjazogcmVnaXN0ZXIoJ2RlYnVnLXN0ZXAtYmFjaycsIDB4ZWI4ZiksXHJcbiAgICBkZWJ1Z1Jlc3RhcnRGcmFtZTogcmVnaXN0ZXIoJ2RlYnVnLXJlc3RhcnQtZnJhbWUnLCAweGViOTApLFxyXG4gICAgZGVidWdBbHQ6IHJlZ2lzdGVyKCdkZWJ1Zy1hbHQnLCAweGViOTEpLFxyXG4gICAgY2FsbEluY29taW5nOiByZWdpc3RlcignY2FsbC1pbmNvbWluZycsIDB4ZWI5MiksXHJcbiAgICBjYWxsT3V0Z29pbmc6IHJlZ2lzdGVyKCdjYWxsLW91dGdvaW5nJywgMHhlYjkzKSxcclxuICAgIG1lbnU6IHJlZ2lzdGVyKCdtZW51JywgMHhlYjk0KSxcclxuICAgIGV4cGFuZEFsbDogcmVnaXN0ZXIoJ2V4cGFuZC1hbGwnLCAweGViOTUpLFxyXG4gICAgZmVlZGJhY2s6IHJlZ2lzdGVyKCdmZWVkYmFjaycsIDB4ZWI5NiksXHJcbiAgICBnaXRQdWxsUmVxdWVzdFJldmlld2VyOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1yZXZpZXdlcicsIDB4ZWI5NiksXHJcbiAgICBncm91cEJ5UmVmVHlwZTogcmVnaXN0ZXIoJ2dyb3VwLWJ5LXJlZi10eXBlJywgMHhlYjk3KSxcclxuICAgIHVuZ3JvdXBCeVJlZlR5cGU6IHJlZ2lzdGVyKCd1bmdyb3VwLWJ5LXJlZi10eXBlJywgMHhlYjk4KSxcclxuICAgIGFjY291bnQ6IHJlZ2lzdGVyKCdhY2NvdW50JywgMHhlYjk5KSxcclxuICAgIGdpdFB1bGxSZXF1ZXN0QXNzaWduZWU6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LWFzc2lnbmVlJywgMHhlYjk5KSxcclxuICAgIGJlbGxEb3Q6IHJlZ2lzdGVyKCdiZWxsLWRvdCcsIDB4ZWI5YSksXHJcbiAgICBkZWJ1Z0NvbnNvbGU6IHJlZ2lzdGVyKCdkZWJ1Zy1jb25zb2xlJywgMHhlYjliKSxcclxuICAgIGxpYnJhcnk6IHJlZ2lzdGVyKCdsaWJyYXJ5JywgMHhlYjljKSxcclxuICAgIG91dHB1dDogcmVnaXN0ZXIoJ291dHB1dCcsIDB4ZWI5ZCksXHJcbiAgICBydW5BbGw6IHJlZ2lzdGVyKCdydW4tYWxsJywgMHhlYjllKSxcclxuICAgIHN5bmNJZ25vcmVkOiByZWdpc3Rlcignc3luYy1pZ25vcmVkJywgMHhlYjlmKSxcclxuICAgIHBpbm5lZDogcmVnaXN0ZXIoJ3Bpbm5lZCcsIDB4ZWJhMCksXHJcbiAgICBnaXRodWJJbnZlcnRlZDogcmVnaXN0ZXIoJ2dpdGh1Yi1pbnZlcnRlZCcsIDB4ZWJhMSksXHJcbiAgICBzZXJ2ZXJQcm9jZXNzOiByZWdpc3Rlcignc2VydmVyLXByb2Nlc3MnLCAweGViYTIpLFxyXG4gICAgc2VydmVyRW52aXJvbm1lbnQ6IHJlZ2lzdGVyKCdzZXJ2ZXItZW52aXJvbm1lbnQnLCAweGViYTMpLFxyXG4gICAgcGFzczogcmVnaXN0ZXIoJ3Bhc3MnLCAweGViYTQpLFxyXG4gICAgaXNzdWVDbG9zZWQ6IHJlZ2lzdGVyKCdpc3N1ZS1jbG9zZWQnLCAweGViYTQpLFxyXG4gICAgc3RvcENpcmNsZTogcmVnaXN0ZXIoJ3N0b3AtY2lyY2xlJywgMHhlYmE1KSxcclxuICAgIHBsYXlDaXJjbGU6IHJlZ2lzdGVyKCdwbGF5LWNpcmNsZScsIDB4ZWJhNiksXHJcbiAgICByZWNvcmQ6IHJlZ2lzdGVyKCdyZWNvcmQnLCAweGViYTcpLFxyXG4gICAgZGVidWdBbHRTbWFsbDogcmVnaXN0ZXIoJ2RlYnVnLWFsdC1zbWFsbCcsIDB4ZWJhOCksXHJcbiAgICB2bUNvbm5lY3Q6IHJlZ2lzdGVyKCd2bS1jb25uZWN0JywgMHhlYmE5KSxcclxuICAgIGNsb3VkOiByZWdpc3RlcignY2xvdWQnLCAweGViYWEpLFxyXG4gICAgbWVyZ2U6IHJlZ2lzdGVyKCdtZXJnZScsIDB4ZWJhYiksXHJcbiAgICBleHBvcnQ6IHJlZ2lzdGVyKCdleHBvcnQnLCAweGViYWMpLFxyXG4gICAgZ3JhcGhMZWZ0OiByZWdpc3RlcignZ3JhcGgtbGVmdCcsIDB4ZWJhZCksXHJcbiAgICBtYWduZXQ6IHJlZ2lzdGVyKCdtYWduZXQnLCAweGViYWUpLFxyXG4gICAgbm90ZWJvb2s6IHJlZ2lzdGVyKCdub3RlYm9vaycsIDB4ZWJhZiksXHJcbiAgICByZWRvOiByZWdpc3RlcigncmVkbycsIDB4ZWJiMCksXHJcbiAgICBjaGVja0FsbDogcmVnaXN0ZXIoJ2NoZWNrLWFsbCcsIDB4ZWJiMSksXHJcbiAgICBwaW5uZWREaXJ0eTogcmVnaXN0ZXIoJ3Bpbm5lZC1kaXJ0eScsIDB4ZWJiMiksXHJcbiAgICBwYXNzRmlsbGVkOiByZWdpc3RlcigncGFzcy1maWxsZWQnLCAweGViYjMpLFxyXG4gICAgY2lyY2xlTGFyZ2VGaWxsZWQ6IHJlZ2lzdGVyKCdjaXJjbGUtbGFyZ2UtZmlsbGVkJywgMHhlYmI0KSxcclxuICAgIGNpcmNsZUxhcmdlOiByZWdpc3RlcignY2lyY2xlLWxhcmdlJywgMHhlYmI1KSxcclxuICAgIGNpcmNsZUxhcmdlT3V0bGluZTogcmVnaXN0ZXIoJ2NpcmNsZS1sYXJnZS1vdXRsaW5lJywgMHhlYmI1KSxcclxuICAgIGNvbWJpbmU6IHJlZ2lzdGVyKCdjb21iaW5lJywgMHhlYmI2KSxcclxuICAgIGdhdGhlcjogcmVnaXN0ZXIoJ2dhdGhlcicsIDB4ZWJiNiksXHJcbiAgICB0YWJsZTogcmVnaXN0ZXIoJ3RhYmxlJywgMHhlYmI3KSxcclxuICAgIHZhcmlhYmxlR3JvdXA6IHJlZ2lzdGVyKCd2YXJpYWJsZS1ncm91cCcsIDB4ZWJiOCksXHJcbiAgICB0eXBlSGllcmFyY2h5OiByZWdpc3RlcigndHlwZS1oaWVyYXJjaHknLCAweGViYjkpLFxyXG4gICAgdHlwZUhpZXJhcmNoeVN1YjogcmVnaXN0ZXIoJ3R5cGUtaGllcmFyY2h5LXN1YicsIDB4ZWJiYSksXHJcbiAgICB0eXBlSGllcmFyY2h5U3VwZXI6IHJlZ2lzdGVyKCd0eXBlLWhpZXJhcmNoeS1zdXBlcicsIDB4ZWJiYiksXHJcbiAgICBnaXRQdWxsUmVxdWVzdENyZWF0ZTogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtY3JlYXRlJywgMHhlYmJjKSxcclxuICAgIHJ1bkFib3ZlOiByZWdpc3RlcigncnVuLWFib3ZlJywgMHhlYmJkKSxcclxuICAgIHJ1bkJlbG93OiByZWdpc3RlcigncnVuLWJlbG93JywgMHhlYmJlKSxcclxuICAgIG5vdGVib29rVGVtcGxhdGU6IHJlZ2lzdGVyKCdub3RlYm9vay10ZW1wbGF0ZScsIDB4ZWJiZiksXHJcbiAgICBkZWJ1Z1JlcnVuOiByZWdpc3RlcignZGVidWctcmVydW4nLCAweGViYzApLFxyXG4gICAgd29ya3NwYWNlVHJ1c3RlZDogcmVnaXN0ZXIoJ3dvcmtzcGFjZS10cnVzdGVkJywgMHhlYmMxKSxcclxuICAgIHdvcmtzcGFjZVVudHJ1c3RlZDogcmVnaXN0ZXIoJ3dvcmtzcGFjZS11bnRydXN0ZWQnLCAweGViYzIpLFxyXG4gICAgd29ya3NwYWNlVW5rbm93bjogcmVnaXN0ZXIoJ3dvcmtzcGFjZS11bmtub3duJywgMHhlYmMzKSxcclxuICAgIHRlcm1pbmFsQ21kOiByZWdpc3RlcigndGVybWluYWwtY21kJywgMHhlYmM0KSxcclxuICAgIHRlcm1pbmFsRGViaWFuOiByZWdpc3RlcigndGVybWluYWwtZGViaWFuJywgMHhlYmM1KSxcclxuICAgIHRlcm1pbmFsTGludXg6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1saW51eCcsIDB4ZWJjNiksXHJcbiAgICB0ZXJtaW5hbFBvd2Vyc2hlbGw6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1wb3dlcnNoZWxsJywgMHhlYmM3KSxcclxuICAgIHRlcm1pbmFsVG11eDogcmVnaXN0ZXIoJ3Rlcm1pbmFsLXRtdXgnLCAweGViYzgpLFxyXG4gICAgdGVybWluYWxVYnVudHU6IHJlZ2lzdGVyKCd0ZXJtaW5hbC11YnVudHUnLCAweGViYzkpLFxyXG4gICAgdGVybWluYWxCYXNoOiByZWdpc3RlcigndGVybWluYWwtYmFzaCcsIDB4ZWJjYSksXHJcbiAgICBhcnJvd1N3YXA6IHJlZ2lzdGVyKCdhcnJvdy1zd2FwJywgMHhlYmNiKSxcclxuICAgIGNvcHk6IHJlZ2lzdGVyKCdjb3B5JywgMHhlYmNjKSxcclxuICAgIHBlcnNvbkFkZDogcmVnaXN0ZXIoJ3BlcnNvbi1hZGQnLCAweGViY2QpLFxyXG4gICAgZmlsdGVyRmlsbGVkOiByZWdpc3RlcignZmlsdGVyLWZpbGxlZCcsIDB4ZWJjZSksXHJcbiAgICB3YW5kOiByZWdpc3Rlcignd2FuZCcsIDB4ZWJjZiksXHJcbiAgICBkZWJ1Z0xpbmVCeUxpbmU6IHJlZ2lzdGVyKCdkZWJ1Zy1saW5lLWJ5LWxpbmUnLCAweGViZDApLFxyXG4gICAgaW5zcGVjdDogcmVnaXN0ZXIoJ2luc3BlY3QnLCAweGViZDEpLFxyXG4gICAgbGF5ZXJzOiByZWdpc3RlcignbGF5ZXJzJywgMHhlYmQyKSxcclxuICAgIGxheWVyc0RvdDogcmVnaXN0ZXIoJ2xheWVycy1kb3QnLCAweGViZDMpLFxyXG4gICAgbGF5ZXJzQWN0aXZlOiByZWdpc3RlcignbGF5ZXJzLWFjdGl2ZScsIDB4ZWJkNCksXHJcbiAgICBjb21wYXNzOiByZWdpc3RlcignY29tcGFzcycsIDB4ZWJkNSksXHJcbiAgICBjb21wYXNzRG90OiByZWdpc3RlcignY29tcGFzcy1kb3QnLCAweGViZDYpLFxyXG4gICAgY29tcGFzc0FjdGl2ZTogcmVnaXN0ZXIoJ2NvbXBhc3MtYWN0aXZlJywgMHhlYmQ3KSxcclxuICAgIGF6dXJlOiByZWdpc3RlcignYXp1cmUnLCAweGViZDgpLFxyXG4gICAgaXNzdWVEcmFmdDogcmVnaXN0ZXIoJ2lzc3VlLWRyYWZ0JywgMHhlYmQ5KSxcclxuICAgIGdpdFB1bGxSZXF1ZXN0Q2xvc2VkOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1jbG9zZWQnLCAweGViZGEpLFxyXG4gICAgZ2l0UHVsbFJlcXVlc3REcmFmdDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtZHJhZnQnLCAweGViZGIpLFxyXG4gICAgZGVidWdBbGw6IHJlZ2lzdGVyKCdkZWJ1Zy1hbGwnLCAweGViZGMpLFxyXG4gICAgZGVidWdDb3ZlcmFnZTogcmVnaXN0ZXIoJ2RlYnVnLWNvdmVyYWdlJywgMHhlYmRkKSxcclxuICAgIHJ1bkVycm9yczogcmVnaXN0ZXIoJ3J1bi1lcnJvcnMnLCAweGViZGUpLFxyXG4gICAgZm9sZGVyTGlicmFyeTogcmVnaXN0ZXIoJ2ZvbGRlci1saWJyYXJ5JywgMHhlYmRmKSxcclxuICAgIGRlYnVnQ29udGludWVTbWFsbDogcmVnaXN0ZXIoJ2RlYnVnLWNvbnRpbnVlLXNtYWxsJywgMHhlYmUwKSxcclxuICAgIGJlYWtlclN0b3A6IHJlZ2lzdGVyKCdiZWFrZXItc3RvcCcsIDB4ZWJlMSksXHJcbiAgICBncmFwaExpbmU6IHJlZ2lzdGVyKCdncmFwaC1saW5lJywgMHhlYmUyKSxcclxuICAgIGdyYXBoU2NhdHRlcjogcmVnaXN0ZXIoJ2dyYXBoLXNjYXR0ZXInLCAweGViZTMpLFxyXG4gICAgcGllQ2hhcnQ6IHJlZ2lzdGVyKCdwaWUtY2hhcnQnLCAweGViZTQpLFxyXG4gICAgYnJhY2tldDogcmVnaXN0ZXIoJ2JyYWNrZXQnLCAweGViMGYpLFxyXG4gICAgYnJhY2tldERvdDogcmVnaXN0ZXIoJ2JyYWNrZXQtZG90JywgMHhlYmU1KSxcclxuICAgIGJyYWNrZXRFcnJvcjogcmVnaXN0ZXIoJ2JyYWNrZXQtZXJyb3InLCAweGViZTYpLFxyXG4gICAgbG9ja1NtYWxsOiByZWdpc3RlcignbG9jay1zbWFsbCcsIDB4ZWJlNyksXHJcbiAgICBhenVyZURldm9wczogcmVnaXN0ZXIoJ2F6dXJlLWRldm9wcycsIDB4ZWJlOCksXHJcbiAgICB2ZXJpZmllZEZpbGxlZDogcmVnaXN0ZXIoJ3ZlcmlmaWVkLWZpbGxlZCcsIDB4ZWJlOSksXHJcbiAgICBuZXdsaW5lOiByZWdpc3RlcignbmV3bGluZScsIDB4ZWJlYSksXHJcbiAgICBsYXlvdXQ6IHJlZ2lzdGVyKCdsYXlvdXQnLCAweGViZWIpLFxyXG4gICAgbGF5b3V0QWN0aXZpdHliYXJMZWZ0OiByZWdpc3RlcignbGF5b3V0LWFjdGl2aXR5YmFyLWxlZnQnLCAweGViZWMpLFxyXG4gICAgbGF5b3V0QWN0aXZpdHliYXJSaWdodDogcmVnaXN0ZXIoJ2xheW91dC1hY3Rpdml0eWJhci1yaWdodCcsIDB4ZWJlZCksXHJcbiAgICBsYXlvdXRQYW5lbExlZnQ6IHJlZ2lzdGVyKCdsYXlvdXQtcGFuZWwtbGVmdCcsIDB4ZWJlZSksXHJcbiAgICBsYXlvdXRQYW5lbENlbnRlcjogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbC1jZW50ZXInLCAweGViZWYpLFxyXG4gICAgbGF5b3V0UGFuZWxKdXN0aWZ5OiByZWdpc3RlcignbGF5b3V0LXBhbmVsLWp1c3RpZnknLCAweGViZjApLFxyXG4gICAgbGF5b3V0UGFuZWxSaWdodDogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbC1yaWdodCcsIDB4ZWJmMSksXHJcbiAgICBsYXlvdXRQYW5lbDogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbCcsIDB4ZWJmMiksXHJcbiAgICBsYXlvdXRTaWRlYmFyTGVmdDogcmVnaXN0ZXIoJ2xheW91dC1zaWRlYmFyLWxlZnQnLCAweGViZjMpLFxyXG4gICAgbGF5b3V0U2lkZWJhclJpZ2h0OiByZWdpc3RlcignbGF5b3V0LXNpZGViYXItcmlnaHQnLCAweGViZjQpLFxyXG4gICAgbGF5b3V0U3RhdHVzYmFyOiByZWdpc3RlcignbGF5b3V0LXN0YXR1c2JhcicsIDB4ZWJmNSksXHJcbiAgICBsYXlvdXRNZW51YmFyOiByZWdpc3RlcignbGF5b3V0LW1lbnViYXInLCAweGViZjYpLFxyXG4gICAgbGF5b3V0Q2VudGVyZWQ6IHJlZ2lzdGVyKCdsYXlvdXQtY2VudGVyZWQnLCAweGViZjcpLFxyXG4gICAgdGFyZ2V0OiByZWdpc3RlcigndGFyZ2V0JywgMHhlYmY4KSxcclxuICAgIGluZGVudDogcmVnaXN0ZXIoJ2luZGVudCcsIDB4ZWJmOSksXHJcbiAgICByZWNvcmRTbWFsbDogcmVnaXN0ZXIoJ3JlY29yZC1zbWFsbCcsIDB4ZWJmYSksXHJcbiAgICBlcnJvclNtYWxsOiByZWdpc3RlcignZXJyb3Itc21hbGwnLCAweGViZmIpLFxyXG4gICAgdGVybWluYWxEZWNvcmF0aW9uRXJyb3I6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1kZWNvcmF0aW9uLWVycm9yJywgMHhlYmZiKSxcclxuICAgIGFycm93Q2lyY2xlRG93bjogcmVnaXN0ZXIoJ2Fycm93LWNpcmNsZS1kb3duJywgMHhlYmZjKSxcclxuICAgIGFycm93Q2lyY2xlTGVmdDogcmVnaXN0ZXIoJ2Fycm93LWNpcmNsZS1sZWZ0JywgMHhlYmZkKSxcclxuICAgIGFycm93Q2lyY2xlUmlnaHQ6IHJlZ2lzdGVyKCdhcnJvdy1jaXJjbGUtcmlnaHQnLCAweGViZmUpLFxyXG4gICAgYXJyb3dDaXJjbGVVcDogcmVnaXN0ZXIoJ2Fycm93LWNpcmNsZS11cCcsIDB4ZWJmZiksXHJcbiAgICBsYXlvdXRTaWRlYmFyUmlnaHRPZmY6IHJlZ2lzdGVyKCdsYXlvdXQtc2lkZWJhci1yaWdodC1vZmYnLCAweGVjMDApLFxyXG4gICAgbGF5b3V0UGFuZWxPZmY6IHJlZ2lzdGVyKCdsYXlvdXQtcGFuZWwtb2ZmJywgMHhlYzAxKSxcclxuICAgIGxheW91dFNpZGViYXJMZWZ0T2ZmOiByZWdpc3RlcignbGF5b3V0LXNpZGViYXItbGVmdC1vZmYnLCAweGVjMDIpLFxyXG4gICAgYmxhbms6IHJlZ2lzdGVyKCdibGFuaycsIDB4ZWMwMyksXHJcbiAgICBoZWFydEZpbGxlZDogcmVnaXN0ZXIoJ2hlYXJ0LWZpbGxlZCcsIDB4ZWMwNCksXHJcbiAgICBtYXA6IHJlZ2lzdGVyKCdtYXAnLCAweGVjMDUpLFxyXG4gICAgbWFwSG9yaXpvbnRhbDogcmVnaXN0ZXIoJ21hcC1ob3Jpem9udGFsJywgMHhlYzA1KSxcclxuICAgIGZvbGRIb3Jpem9udGFsOiByZWdpc3RlcignZm9sZC1ob3Jpem9udGFsJywgMHhlYzA1KSxcclxuICAgIG1hcEZpbGxlZDogcmVnaXN0ZXIoJ21hcC1maWxsZWQnLCAweGVjMDYpLFxyXG4gICAgbWFwSG9yaXpvbnRhbEZpbGxlZDogcmVnaXN0ZXIoJ21hcC1ob3Jpem9udGFsLWZpbGxlZCcsIDB4ZWMwNiksXHJcbiAgICBmb2xkSG9yaXpvbnRhbEZpbGxlZDogcmVnaXN0ZXIoJ2ZvbGQtaG9yaXpvbnRhbC1maWxsZWQnLCAweGVjMDYpLFxyXG4gICAgY2lyY2xlU21hbGw6IHJlZ2lzdGVyKCdjaXJjbGUtc21hbGwnLCAweGVjMDcpLFxyXG4gICAgYmVsbFNsYXNoOiByZWdpc3RlcignYmVsbC1zbGFzaCcsIDB4ZWMwOCksXHJcbiAgICBiZWxsU2xhc2hEb3Q6IHJlZ2lzdGVyKCdiZWxsLXNsYXNoLWRvdCcsIDB4ZWMwOSksXHJcbiAgICBjb21tZW50VW5yZXNvbHZlZDogcmVnaXN0ZXIoJ2NvbW1lbnQtdW5yZXNvbHZlZCcsIDB4ZWMwYSksXHJcbiAgICBnaXRQdWxsUmVxdWVzdEdvVG9DaGFuZ2VzOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1nby10by1jaGFuZ2VzJywgMHhlYzBiKSxcclxuICAgIGdpdFB1bGxSZXF1ZXN0TmV3Q2hhbmdlczogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtbmV3LWNoYW5nZXMnLCAweGVjMGMpLFxyXG4gICAgc2VhcmNoRnV6enk6IHJlZ2lzdGVyKCdzZWFyY2gtZnV6enknLCAweGVjMGQpLFxyXG4gICAgY29tbWVudERyYWZ0OiByZWdpc3RlcignY29tbWVudC1kcmFmdCcsIDB4ZWMwZSksXHJcbiAgICBzZW5kOiByZWdpc3Rlcignc2VuZCcsIDB4ZWMwZiksXHJcbiAgICBzcGFya2xlOiByZWdpc3Rlcignc3BhcmtsZScsIDB4ZWMxMCksXHJcbiAgICBpbnNlcnQ6IHJlZ2lzdGVyKCdpbnNlcnQnLCAweGVjMTEpLFxyXG4gICAgbWljOiByZWdpc3RlcignbWljJywgMHhlYzEyKSxcclxuICAgIHRodW1ic2Rvd25GaWxsZWQ6IHJlZ2lzdGVyKCd0aHVtYnNkb3duLWZpbGxlZCcsIDB4ZWMxMyksXHJcbiAgICB0aHVtYnN1cEZpbGxlZDogcmVnaXN0ZXIoJ3RodW1ic3VwLWZpbGxlZCcsIDB4ZWMxNCksXHJcbiAgICBjb2ZmZWU6IHJlZ2lzdGVyKCdjb2ZmZWUnLCAweGVjMTUpLFxyXG4gICAgc25ha2U6IHJlZ2lzdGVyKCdzbmFrZScsIDB4ZWMxNiksXHJcbiAgICBnYW1lOiByZWdpc3RlcignZ2FtZScsIDB4ZWMxNyksXHJcbiAgICB2cjogcmVnaXN0ZXIoJ3ZyJywgMHhlYzE4KSxcclxuICAgIGNoaXA6IHJlZ2lzdGVyKCdjaGlwJywgMHhlYzE5KSxcclxuICAgIHBpYW5vOiByZWdpc3RlcigncGlhbm8nLCAweGVjMWEpLFxyXG4gICAgbXVzaWM6IHJlZ2lzdGVyKCdtdXNpYycsIDB4ZWMxYiksXHJcbiAgICBtaWNGaWxsZWQ6IHJlZ2lzdGVyKCdtaWMtZmlsbGVkJywgMHhlYzFjKSxcclxuICAgIHJlcG9GZXRjaDogcmVnaXN0ZXIoJ3JlcG8tZmV0Y2gnLCAweGVjMWQpLFxyXG4gICAgY29waWxvdDogcmVnaXN0ZXIoJ2NvcGlsb3QnLCAweGVjMWUpLFxyXG4gICAgbGlnaHRidWxiU3BhcmtsZTogcmVnaXN0ZXIoJ2xpZ2h0YnVsYi1zcGFya2xlJywgMHhlYzFmKSxcclxuICAgIHJvYm90OiByZWdpc3Rlcigncm9ib3QnLCAweGVjMjApLFxyXG4gICAgc3BhcmtsZUZpbGxlZDogcmVnaXN0ZXIoJ3NwYXJrbGUtZmlsbGVkJywgMHhlYzIxKSxcclxuICAgIGRpZmZTaW5nbGU6IHJlZ2lzdGVyKCdkaWZmLXNpbmdsZScsIDB4ZWMyMiksXHJcbiAgICBkaWZmTXVsdGlwbGU6IHJlZ2lzdGVyKCdkaWZmLW11bHRpcGxlJywgMHhlYzIzKSxcclxuICAgIHN1cnJvdW5kV2l0aDogcmVnaXN0ZXIoJ3N1cnJvdW5kLXdpdGgnLCAweGVjMjQpLFxyXG4gICAgc2hhcmU6IHJlZ2lzdGVyKCdzaGFyZScsIDB4ZWMyNSksXHJcbiAgICBnaXRTdGFzaDogcmVnaXN0ZXIoJ2dpdC1zdGFzaCcsIDB4ZWMyNiksXHJcbiAgICBnaXRTdGFzaEFwcGx5OiByZWdpc3RlcignZ2l0LXN0YXNoLWFwcGx5JywgMHhlYzI3KSxcclxuICAgIGdpdFN0YXNoUG9wOiByZWdpc3RlcignZ2l0LXN0YXNoLXBvcCcsIDB4ZWMyOCksXHJcbiAgICB2c2NvZGU6IHJlZ2lzdGVyKCd2c2NvZGUnLCAweGVjMjkpLFxyXG4gICAgdnNjb2RlSW5zaWRlcnM6IHJlZ2lzdGVyKCd2c2NvZGUtaW5zaWRlcnMnLCAweGVjMmEpLFxyXG4gICAgY29kZU9zczogcmVnaXN0ZXIoJ2NvZGUtb3NzJywgMHhlYzJiKSxcclxuICAgIHJ1bkNvdmVyYWdlOiByZWdpc3RlcigncnVuLWNvdmVyYWdlJywgMHhlYzJjKSxcclxuICAgIHJ1bkFsbENvdmVyYWdlOiByZWdpc3RlcigncnVuLWFsbC1jb3ZlcmFnZScsIDB4ZWMyZCksXHJcbiAgICBjb3ZlcmFnZTogcmVnaXN0ZXIoJ2NvdmVyYWdlJywgMHhlYzJlKSxcclxuICAgIGdpdGh1YlByb2plY3Q6IHJlZ2lzdGVyKCdnaXRodWItcHJvamVjdCcsIDB4ZWMyZiksXHJcbiAgICBtYXBWZXJ0aWNhbDogcmVnaXN0ZXIoJ21hcC12ZXJ0aWNhbCcsIDB4ZWMzMCksXHJcbiAgICBmb2xkVmVydGljYWw6IHJlZ2lzdGVyKCdmb2xkLXZlcnRpY2FsJywgMHhlYzMwKSxcclxuICAgIG1hcFZlcnRpY2FsRmlsbGVkOiByZWdpc3RlcignbWFwLXZlcnRpY2FsLWZpbGxlZCcsIDB4ZWMzMSksXHJcbiAgICBmb2xkVmVydGljYWxGaWxsZWQ6IHJlZ2lzdGVyKCdmb2xkLXZlcnRpY2FsLWZpbGxlZCcsIDB4ZWMzMSksXHJcbiAgICBnb1RvU2VhcmNoOiByZWdpc3RlcignZ28tdG8tc2VhcmNoJywgMHhlYzMyKSxcclxuICAgIHBlcmNlbnRhZ2U6IHJlZ2lzdGVyKCdwZXJjZW50YWdlJywgMHhlYzMzKSxcclxuICAgIHNvcnRQZXJjZW50YWdlOiByZWdpc3Rlcignc29ydC1wZXJjZW50YWdlJywgMHhlYzMzKSxcclxuICAgIGF0dGFjaDogcmVnaXN0ZXIoJ2F0dGFjaCcsIDB4ZWMzNCksXHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCodiconFontCharacters: () => (/* binding */ getCodiconFontCharacters),\n/* harmony export */   register: () => (/* binding */ register)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/monaco-editor/esm/vs/base/common/types.js\");\n\r\nconst _codiconFontCharacters = Object.create(null);\r\nfunction register(id, fontCharacter) {\r\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isString)(fontCharacter)) {\r\n        const val = _codiconFontCharacters[fontCharacter];\r\n        if (val === undefined) {\r\n            throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);\r\n        }\r\n        fontCharacter = val;\r\n    }\r\n    _codiconFontCharacters[id] = fontCharacter;\r\n    return { id };\r\n}\r\n/**\r\n * Only to be used by the iconRegistry.\r\n */\r\nfunction getCodiconFontCharacters() {\r\n    return _codiconFontCharacters;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnNVdGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzQztBQUN0QztBQUNPO0FBQ1AsUUFBUSxtREFBUTtBQUNoQjtBQUNBO0FBQ0EsK0JBQStCLElBQUksaUNBQWlDLGNBQWM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnNVdGlsLmpzP2Y4MmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGVzLmpzJztcclxuY29uc3QgX2NvZGljb25Gb250Q2hhcmFjdGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9udENoYXJhY3Rlcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGZvbnRDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgY29uc3QgdmFsID0gX2NvZGljb25Gb250Q2hhcmFjdGVyc1tmb250Q2hhcmFjdGVyXTtcclxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2lkfSByZWZlcmVuY2VzIGFuIHVua25vd24gY29kaWNvbjogJHtmb250Q2hhcmFjdGVyfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb250Q2hhcmFjdGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgX2NvZGljb25Gb250Q2hhcmFjdGVyc1tpZF0gPSBmb250Q2hhcmFjdGVyO1xyXG4gICAgcmV0dXJuIHsgaWQgfTtcclxufVxyXG4vKipcclxuICogT25seSB0byBiZSB1c2VkIGJ5IHRoZSBpY29uUmVnaXN0cnkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29kaWNvbkZvbnRDaGFyYWN0ZXJzKCkge1xyXG4gICAgcmV0dXJuIF9jb2RpY29uRm9udENoYXJhY3RlcnM7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/color.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/color.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   HSLA: () => (/* binding */ HSLA),\n/* harmony export */   HSVA: () => (/* binding */ HSVA),\n/* harmony export */   RGBA: () => (/* binding */ RGBA)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction roundFloat(number, decimalPoints) {\r\n    const decimal = Math.pow(10, decimalPoints);\r\n    return Math.round(number * decimal) / decimal;\r\n}\r\nclass RGBA {\r\n    constructor(r, g, b, a = 1) {\r\n        this._rgbaBrand = undefined;\r\n        this.r = Math.min(255, Math.max(0, r)) | 0;\r\n        this.g = Math.min(255, Math.max(0, g)) | 0;\r\n        this.b = Math.min(255, Math.max(0, b)) | 0;\r\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\r\n    }\r\n    static equals(a, b) {\r\n        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\r\n    }\r\n}\r\nclass HSLA {\r\n    constructor(h, s, l, a) {\r\n        this._hslaBrand = undefined;\r\n        this.h = Math.max(Math.min(360, h), 0) | 0;\r\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\r\n        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\r\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\r\n    }\r\n    static equals(a, b) {\r\n        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;\r\n    }\r\n    /**\r\n     * Converts an RGB color value to HSL. Conversion formula\r\n     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n     * Assumes r, g, and b are contained in the set [0, 255] and\r\n     * returns h in the set [0, 360], s, and l in the set [0, 1].\r\n     */\r\n    static fromRGBA(rgba) {\r\n        const r = rgba.r / 255;\r\n        const g = rgba.g / 255;\r\n        const b = rgba.b / 255;\r\n        const a = rgba.a;\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        let h = 0;\r\n        let s = 0;\r\n        const l = (min + max) / 2;\r\n        const chroma = max - min;\r\n        if (chroma > 0) {\r\n            s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);\r\n            switch (max) {\r\n                case r:\r\n                    h = (g - b) / chroma + (g < b ? 6 : 0);\r\n                    break;\r\n                case g:\r\n                    h = (b - r) / chroma + 2;\r\n                    break;\r\n                case b:\r\n                    h = (r - g) / chroma + 4;\r\n                    break;\r\n            }\r\n            h *= 60;\r\n            h = Math.round(h);\r\n        }\r\n        return new HSLA(h, s, l, a);\r\n    }\r\n    static _hue2rgb(p, q, t) {\r\n        if (t < 0) {\r\n            t += 1;\r\n        }\r\n        if (t > 1) {\r\n            t -= 1;\r\n        }\r\n        if (t < 1 / 6) {\r\n            return p + (q - p) * 6 * t;\r\n        }\r\n        if (t < 1 / 2) {\r\n            return q;\r\n        }\r\n        if (t < 2 / 3) {\r\n            return p + (q - p) * (2 / 3 - t) * 6;\r\n        }\r\n        return p;\r\n    }\r\n    /**\r\n     * Converts an HSL color value to RGB. Conversion formula\r\n     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\r\n     * returns r, g, and b in the set [0, 255].\r\n     */\r\n    static toRGBA(hsla) {\r\n        const h = hsla.h / 360;\r\n        const { s, l, a } = hsla;\r\n        let r, g, b;\r\n        if (s === 0) {\r\n            r = g = b = l; // achromatic\r\n        }\r\n        else {\r\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n            const p = 2 * l - q;\r\n            r = HSLA._hue2rgb(p, q, h + 1 / 3);\r\n            g = HSLA._hue2rgb(p, q, h);\r\n            b = HSLA._hue2rgb(p, q, h - 1 / 3);\r\n        }\r\n        return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);\r\n    }\r\n}\r\nclass HSVA {\r\n    constructor(h, s, v, a) {\r\n        this._hsvaBrand = undefined;\r\n        this.h = Math.max(Math.min(360, h), 0) | 0;\r\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\r\n        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\r\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\r\n    }\r\n    static equals(a, b) {\r\n        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;\r\n    }\r\n    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\r\n    static fromRGBA(rgba) {\r\n        const r = rgba.r / 255;\r\n        const g = rgba.g / 255;\r\n        const b = rgba.b / 255;\r\n        const cmax = Math.max(r, g, b);\r\n        const cmin = Math.min(r, g, b);\r\n        const delta = cmax - cmin;\r\n        const s = cmax === 0 ? 0 : (delta / cmax);\r\n        let m;\r\n        if (delta === 0) {\r\n            m = 0;\r\n        }\r\n        else if (cmax === r) {\r\n            m = ((((g - b) / delta) % 6) + 6) % 6;\r\n        }\r\n        else if (cmax === g) {\r\n            m = ((b - r) / delta) + 2;\r\n        }\r\n        else {\r\n            m = ((r - g) / delta) + 4;\r\n        }\r\n        return new HSVA(Math.round(m * 60), s, cmax, rgba.a);\r\n    }\r\n    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\r\n    static toRGBA(hsva) {\r\n        const { h, s, v, a } = hsva;\r\n        const c = v * s;\r\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\r\n        const m = v - c;\r\n        let [r, g, b] = [0, 0, 0];\r\n        if (h < 60) {\r\n            r = c;\r\n            g = x;\r\n        }\r\n        else if (h < 120) {\r\n            r = x;\r\n            g = c;\r\n        }\r\n        else if (h < 180) {\r\n            g = c;\r\n            b = x;\r\n        }\r\n        else if (h < 240) {\r\n            g = x;\r\n            b = c;\r\n        }\r\n        else if (h < 300) {\r\n            r = x;\r\n            b = c;\r\n        }\r\n        else if (h <= 360) {\r\n            r = c;\r\n            b = x;\r\n        }\r\n        r = Math.round((r + m) * 255);\r\n        g = Math.round((g + m) * 255);\r\n        b = Math.round((b + m) * 255);\r\n        return new RGBA(r, g, b, a);\r\n    }\r\n}\r\nclass Color {\r\n    static fromHex(hex) {\r\n        return Color.Format.CSS.parseHex(hex) || Color.red;\r\n    }\r\n    static equals(a, b) {\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        if (!a || !b) {\r\n            return false;\r\n        }\r\n        return a.equals(b);\r\n    }\r\n    get hsla() {\r\n        if (this._hsla) {\r\n            return this._hsla;\r\n        }\r\n        else {\r\n            return HSLA.fromRGBA(this.rgba);\r\n        }\r\n    }\r\n    get hsva() {\r\n        if (this._hsva) {\r\n            return this._hsva;\r\n        }\r\n        return HSVA.fromRGBA(this.rgba);\r\n    }\r\n    constructor(arg) {\r\n        if (!arg) {\r\n            throw new Error('Color needs a value');\r\n        }\r\n        else if (arg instanceof RGBA) {\r\n            this.rgba = arg;\r\n        }\r\n        else if (arg instanceof HSLA) {\r\n            this._hsla = arg;\r\n            this.rgba = HSLA.toRGBA(arg);\r\n        }\r\n        else if (arg instanceof HSVA) {\r\n            this._hsva = arg;\r\n            this.rgba = HSVA.toRGBA(arg);\r\n        }\r\n        else {\r\n            throw new Error('Invalid color ctor argument');\r\n        }\r\n    }\r\n    equals(other) {\r\n        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);\r\n    }\r\n    /**\r\n     * http://www.w3.org/TR/WCAG20/#relativeluminancedef\r\n     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.\r\n     */\r\n    getRelativeLuminance() {\r\n        const R = Color._relativeLuminanceForComponent(this.rgba.r);\r\n        const G = Color._relativeLuminanceForComponent(this.rgba.g);\r\n        const B = Color._relativeLuminanceForComponent(this.rgba.b);\r\n        const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\r\n        return roundFloat(luminance, 4);\r\n    }\r\n    static _relativeLuminanceForComponent(color) {\r\n        const c = color / 255;\r\n        return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);\r\n    }\r\n    /**\r\n     *\thttp://24ways.org/2010/calculating-color-contrast\r\n     *  Return 'true' if lighter color otherwise 'false'\r\n     */\r\n    isLighter() {\r\n        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\r\n        return yiq >= 128;\r\n    }\r\n    isLighterThan(another) {\r\n        const lum1 = this.getRelativeLuminance();\r\n        const lum2 = another.getRelativeLuminance();\r\n        return lum1 > lum2;\r\n    }\r\n    isDarkerThan(another) {\r\n        const lum1 = this.getRelativeLuminance();\r\n        const lum2 = another.getRelativeLuminance();\r\n        return lum1 < lum2;\r\n    }\r\n    lighten(factor) {\r\n        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\r\n    }\r\n    darken(factor) {\r\n        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\r\n    }\r\n    transparent(factor) {\r\n        const { r, g, b, a } = this.rgba;\r\n        return new Color(new RGBA(r, g, b, a * factor));\r\n    }\r\n    isTransparent() {\r\n        return this.rgba.a === 0;\r\n    }\r\n    isOpaque() {\r\n        return this.rgba.a === 1;\r\n    }\r\n    opposite() {\r\n        return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\r\n    }\r\n    makeOpaque(opaqueBackground) {\r\n        if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\r\n            // only allow to blend onto a non-opaque color onto a opaque color\r\n            return this;\r\n        }\r\n        const { r, g, b, a } = this.rgba;\r\n        // https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity\r\n        return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));\r\n    }\r\n    toString() {\r\n        if (!this._toString) {\r\n            this._toString = Color.Format.CSS.format(this);\r\n        }\r\n        return this._toString;\r\n    }\r\n    static getLighterColor(of, relative, factor) {\r\n        if (of.isLighterThan(relative)) {\r\n            return of;\r\n        }\r\n        factor = factor ? factor : 0.5;\r\n        const lum1 = of.getRelativeLuminance();\r\n        const lum2 = relative.getRelativeLuminance();\r\n        factor = factor * (lum2 - lum1) / lum2;\r\n        return of.lighten(factor);\r\n    }\r\n    static getDarkerColor(of, relative, factor) {\r\n        if (of.isDarkerThan(relative)) {\r\n            return of;\r\n        }\r\n        factor = factor ? factor : 0.5;\r\n        const lum1 = of.getRelativeLuminance();\r\n        const lum2 = relative.getRelativeLuminance();\r\n        factor = factor * (lum1 - lum2) / lum1;\r\n        return of.darken(factor);\r\n    }\r\n}\r\nColor.white = new Color(new RGBA(255, 255, 255, 1));\r\nColor.black = new Color(new RGBA(0, 0, 0, 1));\r\nColor.red = new Color(new RGBA(255, 0, 0, 1));\r\nColor.blue = new Color(new RGBA(0, 0, 255, 1));\r\nColor.green = new Color(new RGBA(0, 255, 0, 1));\r\nColor.cyan = new Color(new RGBA(0, 255, 255, 1));\r\nColor.lightgrey = new Color(new RGBA(211, 211, 211, 1));\r\nColor.transparent = new Color(new RGBA(0, 0, 0, 0));\r\n(function (Color) {\r\n    let Format;\r\n    (function (Format) {\r\n        let CSS;\r\n        (function (CSS) {\r\n            function formatRGB(color) {\r\n                if (color.rgba.a === 1) {\r\n                    return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\r\n                }\r\n                return Color.Format.CSS.formatRGBA(color);\r\n            }\r\n            CSS.formatRGB = formatRGB;\r\n            function formatRGBA(color) {\r\n                return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;\r\n            }\r\n            CSS.formatRGBA = formatRGBA;\r\n            function formatHSL(color) {\r\n                if (color.hsla.a === 1) {\r\n                    return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;\r\n                }\r\n                return Color.Format.CSS.formatHSLA(color);\r\n            }\r\n            CSS.formatHSL = formatHSL;\r\n            function formatHSLA(color) {\r\n                return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;\r\n            }\r\n            CSS.formatHSLA = formatHSLA;\r\n            function _toTwoDigitHex(n) {\r\n                const r = n.toString(16);\r\n                return r.length !== 2 ? '0' + r : r;\r\n            }\r\n            /**\r\n             * Formats the color as #RRGGBB\r\n             */\r\n            function formatHex(color) {\r\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\r\n            }\r\n            CSS.formatHex = formatHex;\r\n            /**\r\n             * Formats the color as #RRGGBBAA\r\n             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB\r\n             */\r\n            function formatHexA(color, compact = false) {\r\n                if (compact && color.rgba.a === 1) {\r\n                    return Color.Format.CSS.formatHex(color);\r\n                }\r\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\r\n            }\r\n            CSS.formatHexA = formatHexA;\r\n            /**\r\n             * The default format will use HEX if opaque and RGBA otherwise.\r\n             */\r\n            function format(color) {\r\n                if (color.isOpaque()) {\r\n                    return Color.Format.CSS.formatHex(color);\r\n                }\r\n                return Color.Format.CSS.formatRGBA(color);\r\n            }\r\n            CSS.format = format;\r\n            /**\r\n             * Converts an Hex color value to a Color.\r\n             * returns r, g, and b are contained in the set [0, 255]\r\n             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).\r\n             */\r\n            function parseHex(hex) {\r\n                const length = hex.length;\r\n                if (length === 0) {\r\n                    // Invalid color\r\n                    return null;\r\n                }\r\n                if (hex.charCodeAt(0) !== 35 /* CharCode.Hash */) {\r\n                    // Does not begin with a #\r\n                    return null;\r\n                }\r\n                if (length === 7) {\r\n                    // #RRGGBB format\r\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\r\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\r\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\r\n                    return new Color(new RGBA(r, g, b, 1));\r\n                }\r\n                if (length === 9) {\r\n                    // #RRGGBBAA format\r\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\r\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\r\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\r\n                    const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\r\n                    return new Color(new RGBA(r, g, b, a / 255));\r\n                }\r\n                if (length === 4) {\r\n                    // #RGB format\r\n                    const r = _parseHexDigit(hex.charCodeAt(1));\r\n                    const g = _parseHexDigit(hex.charCodeAt(2));\r\n                    const b = _parseHexDigit(hex.charCodeAt(3));\r\n                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\r\n                }\r\n                if (length === 5) {\r\n                    // #RGBA format\r\n                    const r = _parseHexDigit(hex.charCodeAt(1));\r\n                    const g = _parseHexDigit(hex.charCodeAt(2));\r\n                    const b = _parseHexDigit(hex.charCodeAt(3));\r\n                    const a = _parseHexDigit(hex.charCodeAt(4));\r\n                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));\r\n                }\r\n                // Invalid color\r\n                return null;\r\n            }\r\n            CSS.parseHex = parseHex;\r\n            function _parseHexDigit(charCode) {\r\n                switch (charCode) {\r\n                    case 48 /* CharCode.Digit0 */: return 0;\r\n                    case 49 /* CharCode.Digit1 */: return 1;\r\n                    case 50 /* CharCode.Digit2 */: return 2;\r\n                    case 51 /* CharCode.Digit3 */: return 3;\r\n                    case 52 /* CharCode.Digit4 */: return 4;\r\n                    case 53 /* CharCode.Digit5 */: return 5;\r\n                    case 54 /* CharCode.Digit6 */: return 6;\r\n                    case 55 /* CharCode.Digit7 */: return 7;\r\n                    case 56 /* CharCode.Digit8 */: return 8;\r\n                    case 57 /* CharCode.Digit9 */: return 9;\r\n                    case 97 /* CharCode.a */: return 10;\r\n                    case 65 /* CharCode.A */: return 10;\r\n                    case 98 /* CharCode.b */: return 11;\r\n                    case 66 /* CharCode.B */: return 11;\r\n                    case 99 /* CharCode.c */: return 12;\r\n                    case 67 /* CharCode.C */: return 12;\r\n                    case 100 /* CharCode.d */: return 13;\r\n                    case 68 /* CharCode.D */: return 13;\r\n                    case 101 /* CharCode.e */: return 14;\r\n                    case 69 /* CharCode.E */: return 14;\r\n                    case 102 /* CharCode.f */: return 15;\r\n                    case 70 /* CharCode.F */: return 15;\r\n                }\r\n                return 0;\r\n            }\r\n        })(CSS = Format.CSS || (Format.CSS = {}));\r\n    })(Format = Color.Format || (Color.Format = {}));\r\n})(Color || (Color = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29sb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWEsSUFBSSxhQUFhLElBQUksYUFBYTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWEsSUFBSSxhQUFhLElBQUksYUFBYSxJQUFJLDJCQUEyQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhLElBQUksZ0NBQWdDLEtBQUssZ0NBQWdDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYSxJQUFJLGdDQUFnQyxLQUFLLGdDQUFnQyxLQUFLLHdCQUF3QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkIsRUFBRSw2QkFBNkIsRUFBRSw2QkFBNkI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCLEVBQUUsNkJBQTZCLEVBQUUsNkJBQTZCLEVBQUUsK0NBQStDO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0MsS0FBSyw2Q0FBNkM7QUFDbEQsQ0FBQyxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29sb3IuanM/Y2ViOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gcm91bmRGbG9hdChudW1iZXIsIGRlY2ltYWxQb2ludHMpIHtcclxuICAgIGNvbnN0IGRlY2ltYWwgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFBvaW50cyk7XHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBkZWNpbWFsKSAvIGRlY2ltYWw7XHJcbn1cclxuZXhwb3J0IGNsYXNzIFJHQkEge1xyXG4gICAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEpIHtcclxuICAgICAgICB0aGlzLl9yZ2JhQnJhbmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCByKSkgfCAwO1xyXG4gICAgICAgIHRoaXMuZyA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgZykpIHwgMDtcclxuICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGIpKSB8IDA7XHJcbiAgICAgICAgdGhpcy5hID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBhKSwgMCksIDMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuciA9PT0gYi5yICYmIGEuZyA9PT0gYi5nICYmIGEuYiA9PT0gYi5iICYmIGEuYSA9PT0gYi5hO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBIU0xBIHtcclxuICAgIGNvbnN0cnVjdG9yKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICB0aGlzLl9oc2xhQnJhbmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5oID0gTWF0aC5tYXgoTWF0aC5taW4oMzYwLCBoKSwgMCkgfCAwO1xyXG4gICAgICAgIHRoaXMucyA9IHJvdW5kRmxvYXQoTWF0aC5tYXgoTWF0aC5taW4oMSwgcyksIDApLCAzKTtcclxuICAgICAgICB0aGlzLmwgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIGwpLCAwKSwgMyk7XHJcbiAgICAgICAgdGhpcy5hID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBhKSwgMCksIDMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuaCA9PT0gYi5oICYmIGEucyA9PT0gYi5zICYmIGEubCA9PT0gYi5sICYmIGEuYSA9PT0gYi5hO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLiBDb252ZXJzaW9uIGZvcm11bGFcclxuICAgICAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cclxuICAgICAqIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxyXG4gICAgICogcmV0dXJucyBoIGluIHRoZSBzZXQgWzAsIDM2MF0sIHMsIGFuZCBsIGluIHRoZSBzZXQgWzAsIDFdLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVJHQkEocmdiYSkge1xyXG4gICAgICAgIGNvbnN0IHIgPSByZ2JhLnIgLyAyNTU7XHJcbiAgICAgICAgY29uc3QgZyA9IHJnYmEuZyAvIDI1NTtcclxuICAgICAgICBjb25zdCBiID0gcmdiYS5iIC8gMjU1O1xyXG4gICAgICAgIGNvbnN0IGEgPSByZ2JhLmE7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICAgICAgbGV0IGggPSAwO1xyXG4gICAgICAgIGxldCBzID0gMDtcclxuICAgICAgICBjb25zdCBsID0gKG1pbiArIG1heCkgLyAyO1xyXG4gICAgICAgIGNvbnN0IGNocm9tYSA9IG1heCAtIG1pbjtcclxuICAgICAgICBpZiAoY2hyb21hID4gMCkge1xyXG4gICAgICAgICAgICBzID0gTWF0aC5taW4oKGwgPD0gMC41ID8gY2hyb21hIC8gKDIgKiBsKSA6IGNocm9tYSAvICgyIC0gKDIgKiBsKSkpLCAxKTtcclxuICAgICAgICAgICAgc3dpdGNoIChtYXgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgcjpcclxuICAgICAgICAgICAgICAgICAgICBoID0gKGcgLSBiKSAvIGNocm9tYSArIChnIDwgYiA/IDYgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgICAgICBoID0gKGIgLSByKSAvIGNocm9tYSArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGI6XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBjaHJvbWEgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGggKj0gNjA7XHJcbiAgICAgICAgICAgIGggPSBNYXRoLnJvdW5kKGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEhTTEEoaCwgcywgbCwgYSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2h1ZTJyZ2IocCwgcSwgdCkge1xyXG4gICAgICAgIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICB0ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ID4gMSkge1xyXG4gICAgICAgICAgICB0IC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMSAvIDYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMSAvIDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMiAvIDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi4gQ29udmVyc2lvbiBmb3JtdWxhXHJcbiAgICAgKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXHJcbiAgICAgKiBBc3N1bWVzIGggaW4gdGhlIHNldCBbMCwgMzYwXSBzLCBhbmQgbCBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDFdIGFuZFxyXG4gICAgICogcmV0dXJucyByLCBnLCBhbmQgYiBpbiB0aGUgc2V0IFswLCAyNTVdLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9SR0JBKGhzbGEpIHtcclxuICAgICAgICBjb25zdCBoID0gaHNsYS5oIC8gMzYwO1xyXG4gICAgICAgIGNvbnN0IHsgcywgbCwgYSB9ID0gaHNsYTtcclxuICAgICAgICBsZXQgciwgZywgYjtcclxuICAgICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcclxuICAgICAgICAgICAgY29uc3QgcCA9IDIgKiBsIC0gcTtcclxuICAgICAgICAgICAgciA9IEhTTEEuX2h1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcclxuICAgICAgICAgICAgZyA9IEhTTEEuX2h1ZTJyZ2IocCwgcSwgaCk7XHJcbiAgICAgICAgICAgIGIgPSBIU0xBLl9odWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUkdCQShNYXRoLnJvdW5kKHIgKiAyNTUpLCBNYXRoLnJvdW5kKGcgKiAyNTUpLCBNYXRoLnJvdW5kKGIgKiAyNTUpLCBhKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSFNWQSB7XHJcbiAgICBjb25zdHJ1Y3RvcihoLCBzLCB2LCBhKSB7XHJcbiAgICAgICAgdGhpcy5faHN2YUJyYW5kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaCA9IE1hdGgubWF4KE1hdGgubWluKDM2MCwgaCksIDApIHwgMDtcclxuICAgICAgICB0aGlzLnMgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIHMpLCAwKSwgMyk7XHJcbiAgICAgICAgdGhpcy52ID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCB2KSwgMCksIDMpO1xyXG4gICAgICAgIHRoaXMuYSA9IHJvdW5kRmxvYXQoTWF0aC5tYXgoTWF0aC5taW4oMSwgYSksIDApLCAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhLmggPT09IGIuaCAmJiBhLnMgPT09IGIucyAmJiBhLnYgPT09IGIudiAmJiBhLmEgPT09IGIuYTtcclxuICAgIH1cclxuICAgIC8vIGZyb20gaHR0cDovL3d3dy5yYXBpZHRhYmxlcy5jb20vY29udmVydC9jb2xvci9yZ2ItdG8taHN2Lmh0bVxyXG4gICAgc3RhdGljIGZyb21SR0JBKHJnYmEpIHtcclxuICAgICAgICBjb25zdCByID0gcmdiYS5yIC8gMjU1O1xyXG4gICAgICAgIGNvbnN0IGcgPSByZ2JhLmcgLyAyNTU7XHJcbiAgICAgICAgY29uc3QgYiA9IHJnYmEuYiAvIDI1NTtcclxuICAgICAgICBjb25zdCBjbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICAgICAgY29uc3QgY21pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gY21heCAtIGNtaW47XHJcbiAgICAgICAgY29uc3QgcyA9IGNtYXggPT09IDAgPyAwIDogKGRlbHRhIC8gY21heCk7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XHJcbiAgICAgICAgICAgIG0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbWF4ID09PSByKSB7XHJcbiAgICAgICAgICAgIG0gPSAoKCgoZyAtIGIpIC8gZGVsdGEpICUgNikgKyA2KSAlIDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtYXggPT09IGcpIHtcclxuICAgICAgICAgICAgbSA9ICgoYiAtIHIpIC8gZGVsdGEpICsgMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG0gPSAoKHIgLSBnKSAvIGRlbHRhKSArIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSFNWQShNYXRoLnJvdW5kKG0gKiA2MCksIHMsIGNtYXgsIHJnYmEuYSk7XHJcbiAgICB9XHJcbiAgICAvLyBmcm9tIGh0dHA6Ly93d3cucmFwaWR0YWJsZXMuY29tL2NvbnZlcnQvY29sb3IvaHN2LXRvLXJnYi5odG1cclxuICAgIHN0YXRpYyB0b1JHQkEoaHN2YSkge1xyXG4gICAgICAgIGNvbnN0IHsgaCwgcywgdiwgYSB9ID0gaHN2YTtcclxuICAgICAgICBjb25zdCBjID0gdiAqIHM7XHJcbiAgICAgICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcclxuICAgICAgICBjb25zdCBtID0gdiAtIGM7XHJcbiAgICAgICAgbGV0IFtyLCBnLCBiXSA9IFswLCAwLCAwXTtcclxuICAgICAgICBpZiAoaCA8IDYwKSB7XHJcbiAgICAgICAgICAgIHIgPSBjO1xyXG4gICAgICAgICAgICBnID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaCA8IDEyMCkge1xyXG4gICAgICAgICAgICByID0geDtcclxuICAgICAgICAgICAgZyA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGggPCAxODApIHtcclxuICAgICAgICAgICAgZyA9IGM7XHJcbiAgICAgICAgICAgIGIgPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoIDwgMjQwKSB7XHJcbiAgICAgICAgICAgIGcgPSB4O1xyXG4gICAgICAgICAgICBiID0gYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaCA8IDMwMCkge1xyXG4gICAgICAgICAgICByID0geDtcclxuICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGggPD0gMzYwKSB7XHJcbiAgICAgICAgICAgIHIgPSBjO1xyXG4gICAgICAgICAgICBiID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgciA9IE1hdGgucm91bmQoKHIgKyBtKSAqIDI1NSk7XHJcbiAgICAgICAgZyA9IE1hdGgucm91bmQoKGcgKyBtKSAqIDI1NSk7XHJcbiAgICAgICAgYiA9IE1hdGgucm91bmQoKGIgKyBtKSAqIDI1NSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSR0JBKHIsIGcsIGIsIGEpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDb2xvciB7XHJcbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuRm9ybWF0LkNTUy5wYXJzZUhleChoZXgpIHx8IENvbG9yLnJlZDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhIHx8ICFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuZXF1YWxzKGIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhzbGEoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hzbGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hzbGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gSFNMQS5mcm9tUkdCQSh0aGlzLnJnYmEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBoc3ZhKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oc3ZhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oc3ZhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSFNWQS5mcm9tUkdCQSh0aGlzLnJnYmEpO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoYXJnKSB7XHJcbiAgICAgICAgaWYgKCFhcmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2xvciBuZWVkcyBhIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFJHQkEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZ2JhID0gYXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBIU0xBKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hzbGEgPSBhcmc7XHJcbiAgICAgICAgICAgIHRoaXMucmdiYSA9IEhTTEEudG9SR0JBKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEhTVkEpIHtcclxuICAgICAgICAgICAgdGhpcy5faHN2YSA9IGFyZztcclxuICAgICAgICAgICAgdGhpcy5yZ2JhID0gSFNWQS50b1JHQkEoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvciBjdG9yIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICEhb3RoZXIgJiYgUkdCQS5lcXVhbHModGhpcy5yZ2JhLCBvdGhlci5yZ2JhKSAmJiBIU0xBLmVxdWFscyh0aGlzLmhzbGEsIG90aGVyLmhzbGEpICYmIEhTVkEuZXF1YWxzKHRoaXMuaHN2YSwgb3RoZXIuaHN2YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBpbiB0aGUgc2V0IFswLCAxXS4gTyA9PiBEYXJrZXN0IEJsYWNrLiAxID0+IExpZ2h0ZXN0IHdoaXRlLlxyXG4gICAgICovXHJcbiAgICBnZXRSZWxhdGl2ZUx1bWluYW5jZSgpIHtcclxuICAgICAgICBjb25zdCBSID0gQ29sb3IuX3JlbGF0aXZlTHVtaW5hbmNlRm9yQ29tcG9uZW50KHRoaXMucmdiYS5yKTtcclxuICAgICAgICBjb25zdCBHID0gQ29sb3IuX3JlbGF0aXZlTHVtaW5hbmNlRm9yQ29tcG9uZW50KHRoaXMucmdiYS5nKTtcclxuICAgICAgICBjb25zdCBCID0gQ29sb3IuX3JlbGF0aXZlTHVtaW5hbmNlRm9yQ29tcG9uZW50KHRoaXMucmdiYS5iKTtcclxuICAgICAgICBjb25zdCBsdW1pbmFuY2UgPSAwLjIxMjYgKiBSICsgMC43MTUyICogRyArIDAuMDcyMiAqIEI7XHJcbiAgICAgICAgcmV0dXJuIHJvdW5kRmxvYXQobHVtaW5hbmNlLCA0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfcmVsYXRpdmVMdW1pbmFuY2VGb3JDb21wb25lbnQoY29sb3IpIHtcclxuICAgICAgICBjb25zdCBjID0gY29sb3IgLyAyNTU7XHJcbiAgICAgICAgcmV0dXJuIChjIDw9IDAuMDM5MjgpID8gYyAvIDEyLjkyIDogTWF0aC5wb3coKChjICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlx0aHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxyXG4gICAgICogIFJldHVybiAndHJ1ZScgaWYgbGlnaHRlciBjb2xvciBvdGhlcndpc2UgJ2ZhbHNlJ1xyXG4gICAgICovXHJcbiAgICBpc0xpZ2h0ZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeWlxID0gKHRoaXMucmdiYS5yICogMjk5ICsgdGhpcy5yZ2JhLmcgKiA1ODcgKyB0aGlzLnJnYmEuYiAqIDExNCkgLyAxMDAwO1xyXG4gICAgICAgIHJldHVybiB5aXEgPj0gMTI4O1xyXG4gICAgfVxyXG4gICAgaXNMaWdodGVyVGhhbihhbm90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgbHVtMSA9IHRoaXMuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcclxuICAgICAgICBjb25zdCBsdW0yID0gYW5vdGhlci5nZXRSZWxhdGl2ZUx1bWluYW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBsdW0xID4gbHVtMjtcclxuICAgIH1cclxuICAgIGlzRGFya2VyVGhhbihhbm90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgbHVtMSA9IHRoaXMuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcclxuICAgICAgICBjb25zdCBsdW0yID0gYW5vdGhlci5nZXRSZWxhdGl2ZUx1bWluYW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBsdW0xIDwgbHVtMjtcclxuICAgIH1cclxuICAgIGxpZ2h0ZW4oZmFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgSFNMQSh0aGlzLmhzbGEuaCwgdGhpcy5oc2xhLnMsIHRoaXMuaHNsYS5sICsgdGhpcy5oc2xhLmwgKiBmYWN0b3IsIHRoaXMuaHNsYS5hKSk7XHJcbiAgICB9XHJcbiAgICBkYXJrZW4oZmFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgSFNMQSh0aGlzLmhzbGEuaCwgdGhpcy5oc2xhLnMsIHRoaXMuaHNsYS5sIC0gdGhpcy5oc2xhLmwgKiBmYWN0b3IsIHRoaXMuaHNsYS5hKSk7XHJcbiAgICB9XHJcbiAgICB0cmFuc3BhcmVudChmYWN0b3IpIHtcclxuICAgICAgICBjb25zdCB7IHIsIGcsIGIsIGEgfSA9IHRoaXMucmdiYTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKHIsIGcsIGIsIGEgKiBmYWN0b3IpKTtcclxuICAgIH1cclxuICAgIGlzVHJhbnNwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmdiYS5hID09PSAwO1xyXG4gICAgfVxyXG4gICAgaXNPcGFxdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmdiYS5hID09PSAxO1xyXG4gICAgfVxyXG4gICAgb3Bwb3NpdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgUkdCQSgyNTUgLSB0aGlzLnJnYmEuciwgMjU1IC0gdGhpcy5yZ2JhLmcsIDI1NSAtIHRoaXMucmdiYS5iLCB0aGlzLnJnYmEuYSkpO1xyXG4gICAgfVxyXG4gICAgbWFrZU9wYXF1ZShvcGFxdWVCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNPcGFxdWUoKSB8fCBvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuYSAhPT0gMSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGFsbG93IHRvIGJsZW5kIG9udG8gYSBub24tb3BhcXVlIGNvbG9yIG9udG8gYSBvcGFxdWUgY29sb3JcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgciwgZywgYiwgYSB9ID0gdGhpcy5yZ2JhO1xyXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMjI4NTQ4L2ZpbmRpbmctZXF1aXZhbGVudC1jb2xvci13aXRoLW9wYWNpdHlcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKG9wYXF1ZUJhY2tncm91bmQucmdiYS5yIC0gYSAqIChvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuciAtIHIpLCBvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuZyAtIGEgKiAob3BhcXVlQmFja2dyb3VuZC5yZ2JhLmcgLSBnKSwgb3BhcXVlQmFja2dyb3VuZC5yZ2JhLmIgLSBhICogKG9wYXF1ZUJhY2tncm91bmQucmdiYS5iIC0gYiksIDEpKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdG9TdHJpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG9TdHJpbmcgPSBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldExpZ2h0ZXJDb2xvcihvZiwgcmVsYXRpdmUsIGZhY3Rvcikge1xyXG4gICAgICAgIGlmIChvZi5pc0xpZ2h0ZXJUaGFuKHJlbGF0aXZlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZhY3RvciA9IGZhY3RvciA/IGZhY3RvciA6IDAuNTtcclxuICAgICAgICBjb25zdCBsdW0xID0gb2YuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcclxuICAgICAgICBjb25zdCBsdW0yID0gcmVsYXRpdmUuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcclxuICAgICAgICBmYWN0b3IgPSBmYWN0b3IgKiAobHVtMiAtIGx1bTEpIC8gbHVtMjtcclxuICAgICAgICByZXR1cm4gb2YubGlnaHRlbihmYWN0b3IpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldERhcmtlckNvbG9yKG9mLCByZWxhdGl2ZSwgZmFjdG9yKSB7XHJcbiAgICAgICAgaWYgKG9mLmlzRGFya2VyVGhhbihyZWxhdGl2ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9mO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmYWN0b3IgPSBmYWN0b3IgPyBmYWN0b3IgOiAwLjU7XHJcbiAgICAgICAgY29uc3QgbHVtMSA9IG9mLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XHJcbiAgICAgICAgY29uc3QgbHVtMiA9IHJlbGF0aXZlLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XHJcbiAgICAgICAgZmFjdG9yID0gZmFjdG9yICogKGx1bTEgLSBsdW0yKSAvIGx1bTE7XHJcbiAgICAgICAgcmV0dXJuIG9mLmRhcmtlbihmYWN0b3IpO1xyXG4gICAgfVxyXG59XHJcbkNvbG9yLndoaXRlID0gbmV3IENvbG9yKG5ldyBSR0JBKDI1NSwgMjU1LCAyNTUsIDEpKTtcclxuQ29sb3IuYmxhY2sgPSBuZXcgQ29sb3IobmV3IFJHQkEoMCwgMCwgMCwgMSkpO1xyXG5Db2xvci5yZWQgPSBuZXcgQ29sb3IobmV3IFJHQkEoMjU1LCAwLCAwLCAxKSk7XHJcbkNvbG9yLmJsdWUgPSBuZXcgQ29sb3IobmV3IFJHQkEoMCwgMCwgMjU1LCAxKSk7XHJcbkNvbG9yLmdyZWVuID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDI1NSwgMCwgMSkpO1xyXG5Db2xvci5jeWFuID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDI1NSwgMjU1LCAxKSk7XHJcbkNvbG9yLmxpZ2h0Z3JleSA9IG5ldyBDb2xvcihuZXcgUkdCQSgyMTEsIDIxMSwgMjExLCAxKSk7XHJcbkNvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDAsIDAsIDApKTtcclxuKGZ1bmN0aW9uIChDb2xvcikge1xyXG4gICAgbGV0IEZvcm1hdDtcclxuICAgIChmdW5jdGlvbiAoRm9ybWF0KSB7XHJcbiAgICAgICAgbGV0IENTUztcclxuICAgICAgICAoZnVuY3Rpb24gKENTUykge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSR0IoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xvci5yZ2JhLmEgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHJnYigke2NvbG9yLnJnYmEucn0sICR7Y29sb3IucmdiYS5nfSwgJHtjb2xvci5yZ2JhLmJ9KWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3IuRm9ybWF0LkNTUy5mb3JtYXRSR0JBKGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDU1MuZm9ybWF0UkdCID0gZm9ybWF0UkdCO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSR0JBKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYHJnYmEoJHtjb2xvci5yZ2JhLnJ9LCAke2NvbG9yLnJnYmEuZ30sICR7Y29sb3IucmdiYS5ifSwgJHsrKGNvbG9yLnJnYmEuYSkudG9GaXhlZCgyKX0pYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDU1MuZm9ybWF0UkdCQSA9IGZvcm1hdFJHQkE7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdEhTTChjb2xvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yLmhzbGEuYSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgaHNsKCR7Y29sb3IuaHNsYS5ofSwgJHsoY29sb3IuaHNsYS5zICogMTAwKS50b0ZpeGVkKDIpfSUsICR7KGNvbG9yLmhzbGEubCAqIDEwMCkudG9GaXhlZCgyKX0lKWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3IuRm9ybWF0LkNTUy5mb3JtYXRIU0xBKGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDU1MuZm9ybWF0SFNMID0gZm9ybWF0SFNMO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRIU0xBKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYGhzbGEoJHtjb2xvci5oc2xhLmh9LCAkeyhjb2xvci5oc2xhLnMgKiAxMDApLnRvRml4ZWQoMil9JSwgJHsoY29sb3IuaHNsYS5sICogMTAwKS50b0ZpeGVkKDIpfSUsICR7Y29sb3IuaHNsYS5hLnRvRml4ZWQoMil9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhTTEEgPSBmb3JtYXRIU0xBO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBfdG9Ud29EaWdpdEhleChuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gbi50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gci5sZW5ndGggIT09IDIgPyAnMCcgKyByIDogcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRm9ybWF0cyB0aGUgY29sb3IgYXMgI1JSR0dCQlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0SGV4KGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCMke190b1R3b0RpZ2l0SGV4KGNvbG9yLnJnYmEucil9JHtfdG9Ud29EaWdpdEhleChjb2xvci5yZ2JhLmcpfSR7X3RvVHdvRGlnaXRIZXgoY29sb3IucmdiYS5iKX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENTUy5mb3JtYXRIZXggPSBmb3JtYXRIZXg7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGb3JtYXRzIHRoZSBjb2xvciBhcyAjUlJHR0JCQUFcclxuICAgICAgICAgICAgICogSWYgJ2NvbXBhY3QnIGlzIHNldCwgY29sb3JzIHdpdGhvdXQgdHJhbnNwYXJhbmN5IHdpbGwgYmUgcHJpbnRlZCBhcyAjUlJHR0JCXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRIZXhBKGNvbG9yLCBjb21wYWN0ID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYWN0ICYmIGNvbG9yLnJnYmEuYSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdEhleChjb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCMke190b1R3b0RpZ2l0SGV4KGNvbG9yLnJnYmEucil9JHtfdG9Ud29EaWdpdEhleChjb2xvci5yZ2JhLmcpfSR7X3RvVHdvRGlnaXRIZXgoY29sb3IucmdiYS5iKX0ke190b1R3b0RpZ2l0SGV4KE1hdGgucm91bmQoY29sb3IucmdiYS5hICogMjU1KSl9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDU1MuZm9ybWF0SGV4QSA9IGZvcm1hdEhleEE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgd2lsbCB1c2UgSEVYIGlmIG9wYXF1ZSBhbmQgUkdCQSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXQoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xvci5pc09wYXF1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yLkZvcm1hdC5DU1MuZm9ybWF0SGV4KGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdFJHQkEoY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENTUy5mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhbiBIZXggY29sb3IgdmFsdWUgdG8gYSBDb2xvci5cclxuICAgICAgICAgICAgICogcmV0dXJucyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV1cclxuICAgICAgICAgICAgICogQHBhcmFtIGhleCBzdHJpbmcgKCNSR0IsICNSR0JBLCAjUlJHR0JCIG9yICNSUkdHQkJBQSkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZUhleChoZXgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGhleC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhleC5jaGFyQ29kZUF0KDApICE9PSAzNSAvKiBDaGFyQ29kZS5IYXNoICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9lcyBub3QgYmVnaW4gd2l0aCBhICNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjUlJHR0JCIGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAxNiAqIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDEpKSArIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDIpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgzKSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IDE2ICogX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNSkpICsgX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEociwgZywgYiwgMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICNSUkdHQkJBQSBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgxKSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZyA9IDE2ICogX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMykpICsgX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSAxNiAqIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDUpKSArIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDYpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg3KSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgUkdCQShyLCBnLCBiLCBhIC8gMjU1KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gI1JHQiBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDMpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKDE2ICogciArIHIsIDE2ICogZyArIGcsIDE2ICogYiArIGIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjUkdCQSBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDMpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEoMTYgKiByICsgciwgMTYgKiBnICsgZywgMTYgKiBiICsgYiwgKDE2ICogYSArIGEpIC8gMjU1KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbG9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDU1MucGFyc2VIZXggPSBwYXJzZUhleDtcclxuICAgICAgICAgICAgZnVuY3Rpb24gX3BhcnNlSGV4RGlnaXQoY2hhckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLzogcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OSAvKiBDaGFyQ29kZS5EaWdpdDEgKi86IHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTAgLyogQ2hhckNvZGUuRGlnaXQyICovOiByZXR1cm4gMjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUxIC8qIENoYXJDb2RlLkRpZ2l0MyAqLzogcmV0dXJuIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MiAvKiBDaGFyQ29kZS5EaWdpdDQgKi86IHJldHVybiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTMgLyogQ2hhckNvZGUuRGlnaXQ1ICovOiByZXR1cm4gNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU0IC8qIENoYXJDb2RlLkRpZ2l0NiAqLzogcmV0dXJuIDY7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1NSAvKiBDaGFyQ29kZS5EaWdpdDcgKi86IHJldHVybiA3O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTYgLyogQ2hhckNvZGUuRGlnaXQ4ICovOiByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU3IC8qIENoYXJDb2RlLkRpZ2l0OSAqLzogcmV0dXJuIDk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5NyAvKiBDaGFyQ29kZS5hICovOiByZXR1cm4gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2NSAvKiBDaGFyQ29kZS5BICovOiByZXR1cm4gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OCAvKiBDaGFyQ29kZS5iICovOiByZXR1cm4gMTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2NiAvKiBDaGFyQ29kZS5CICovOiByZXR1cm4gMTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OSAvKiBDaGFyQ29kZS5jICovOiByZXR1cm4gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2NyAvKiBDaGFyQ29kZS5DICovOiByZXR1cm4gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDAgLyogQ2hhckNvZGUuZCAqLzogcmV0dXJuIDEzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjggLyogQ2hhckNvZGUuRCAqLzogcmV0dXJuIDEzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAxIC8qIENoYXJDb2RlLmUgKi86IHJldHVybiAxNDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY5IC8qIENoYXJDb2RlLkUgKi86IHJldHVybiAxNDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMiAvKiBDaGFyQ29kZS5mICovOiByZXR1cm4gMTU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3MCAvKiBDaGFyQ29kZS5GICovOiByZXR1cm4gMTU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKENTUyA9IEZvcm1hdC5DU1MgfHwgKEZvcm1hdC5DU1MgPSB7fSkpO1xyXG4gICAgfSkoRm9ybWF0ID0gQ29sb3IuRm9ybWF0IHx8IChDb2xvci5Gb3JtYXQgPSB7fSkpO1xyXG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/color.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LcsDiff: () => (/* binding */ LcsDiff),\n/* harmony export */   StringDiffSequence: () => (/* binding */ StringDiffSequence),\n/* harmony export */   stringDiff: () => (/* binding */ stringDiff)\n/* harmony export */ });\n/* harmony import */ var _diffChange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffChange.js */ \"./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hash.js */ \"./node_modules/monaco-editor/esm/vs/base/common/hash.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass StringDiffSequence {\r\n    constructor(source) {\r\n        this.source = source;\r\n    }\r\n    getElements() {\r\n        const source = this.source;\r\n        const characters = new Int32Array(source.length);\r\n        for (let i = 0, len = source.length; i < len; i++) {\r\n            characters[i] = source.charCodeAt(i);\r\n        }\r\n        return characters;\r\n    }\r\n}\r\nfunction stringDiff(original, modified, pretty) {\r\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\r\n}\r\n//\r\n// The code below has been ported from a C# implementation in VS\r\n//\r\nclass Debug {\r\n    static Assert(condition, message) {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n}\r\nclass MyArray {\r\n    /**\r\n     * Copies a range of elements from an Array starting at the specified source index and pastes\r\n     * them to another Array starting at the specified destination index. The length and the indexes\r\n     * are specified as 64-bit integers.\r\n     * sourceArray:\r\n     *\t\tThe Array that contains the data to copy.\r\n     * sourceIndex:\r\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n     * destinationArray:\r\n     *\t\tThe Array that receives the data.\r\n     * destinationIndex:\r\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n     * length:\r\n     *\t\tA 64-bit integer that represents the number of elements to copy.\r\n     */\r\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n}\r\n/**\r\n * A utility class which helps to create the set of DiffChanges from\r\n * a difference operation. This class accepts original DiffElements and\r\n * modified DiffElements that are involved in a particular change. The\r\n * MarkNextChange() method can be called to mark the separation between\r\n * distinct changes. At the end, the Changes property can be called to retrieve\r\n * the constructed changes.\r\n */\r\nclass DiffChangeHelper {\r\n    /**\r\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n     */\r\n    constructor() {\r\n        this.m_changes = [];\r\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n    }\r\n    /**\r\n     * Marks the beginning of the next change in the set of differences.\r\n     */\r\n    MarkNextChange() {\r\n        // Only add to the list if there is something to add\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Add the new change to our list\r\n            this.m_changes.push(new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\r\n        }\r\n        // Reset for the next change\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\r\n    }\r\n    /**\r\n     * Adds the original element at the given position to the elements\r\n     * affected by the current change. The modified index gives context\r\n     * to the change position with respect to the original sequence.\r\n     * @param originalIndex The index of the original element to add.\r\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n     */\r\n    AddOriginalElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_originalCount++;\r\n    }\r\n    /**\r\n     * Adds the modified element at the given position to the elements\r\n     * affected by the current change. The original index gives context\r\n     * to the change position with respect to the modified sequence.\r\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n     * @param modifiedIndex The index of the modified element to add.\r\n     */\r\n    AddModifiedElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_modifiedCount++;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class.\r\n     */\r\n    getChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        return this.m_changes;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class in the reverse order\r\n     */\r\n    getReverseChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        this.m_changes.reverse();\r\n        return this.m_changes;\r\n    }\r\n}\r\n/**\r\n * An implementation of the difference algorithm described in\r\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\r\n */\r\nclass LcsDiff {\r\n    /**\r\n     * Constructs the DiffFinder\r\n     */\r\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\r\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\r\n        this._originalSequence = originalSequence;\r\n        this._modifiedSequence = modifiedSequence;\r\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\r\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\r\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\r\n        this._originalStringElements = originalStringElements;\r\n        this._originalElementsOrHash = originalElementsOrHash;\r\n        this._modifiedStringElements = modifiedStringElements;\r\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n    }\r\n    static _isStringArray(arr) {\r\n        return (arr.length > 0 && typeof arr[0] === 'string');\r\n    }\r\n    static _getElements(sequence) {\r\n        const elements = sequence.getElements();\r\n        if (LcsDiff._isStringArray(elements)) {\r\n            const hashes = new Int32Array(elements.length);\r\n            for (let i = 0, len = elements.length; i < len; i++) {\r\n                hashes[i] = (0,_hash_js__WEBPACK_IMPORTED_MODULE_1__.stringHash)(elements[i], 0);\r\n            }\r\n            return [elements, hashes, true];\r\n        }\r\n        if (elements instanceof Int32Array) {\r\n            return [[], elements, false];\r\n        }\r\n        return [[], new Int32Array(elements), false];\r\n    }\r\n    ElementsAreEqual(originalIndex, newIndex) {\r\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\r\n    }\r\n    ElementsAreStrictEqual(originalIndex, newIndex) {\r\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\r\n            return false;\r\n        }\r\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\r\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\r\n        return (originalElement === modifiedElement);\r\n    }\r\n    static _getStrictElement(sequence, index) {\r\n        if (typeof sequence.getStrictElement === 'function') {\r\n            return sequence.getStrictElement(index);\r\n        }\r\n        return null;\r\n    }\r\n    OriginalElementsAreEqual(index1, index2) {\r\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\r\n    }\r\n    ModifiedElementsAreEqual(index1, index2) {\r\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\r\n    }\r\n    ComputeDiff(pretty) {\r\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\r\n    }\r\n    /**\r\n     * Computes the differences between the original and modified input\r\n     * sequences on the bounded range.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\r\n        const quitEarlyArr = [false];\r\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\r\n        if (pretty) {\r\n            // We have to clean up the computed diff to be more intuitive\r\n            // but it turns out this cannot be done correctly until the entire set\r\n            // of diffs have been computed\r\n            changes = this.PrettifyChanges(changes);\r\n        }\r\n        return {\r\n            quitEarly: quitEarlyArr[0],\r\n            changes: changes\r\n        };\r\n    }\r\n    /**\r\n     * Private helper method which computes the differences on the bounded range\r\n     * recursively.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\r\n        quitEarlyArr[0] = false;\r\n        // Find the start of the differences\r\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\r\n            originalStart++;\r\n            modifiedStart++;\r\n        }\r\n        // Find the end of the differences\r\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\r\n            originalEnd--;\r\n            modifiedEnd--;\r\n        }\r\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\r\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\r\n            let changes;\r\n            if (modifiedStart <= modifiedEnd) {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                // All insertions\r\n                changes = [\r\n                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                ];\r\n            }\r\n            else if (originalStart <= originalEnd) {\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // All deletions\r\n                changes = [\r\n                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\r\n                ];\r\n            }\r\n            else {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // Identical sequences - No differences\r\n                changes = [];\r\n            }\r\n            return changes;\r\n        }\r\n        // This problem can be solved using the Divide-And-Conquer technique.\r\n        const midOriginalArr = [0];\r\n        const midModifiedArr = [0];\r\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\r\n        const midOriginal = midOriginalArr[0];\r\n        const midModified = midModifiedArr[0];\r\n        if (result !== null) {\r\n            // Result is not-null when there was enough memory to compute the changes while\r\n            // searching for the recursion point\r\n            return result;\r\n        }\r\n        else if (!quitEarlyArr[0]) {\r\n            // We can break the problem down recursively by finding the changes in the\r\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\r\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\r\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\r\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\r\n            let rightChanges = [];\r\n            if (!quitEarlyArr[0]) {\r\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\r\n            }\r\n            else {\r\n                // We didn't have time to finish the first half, so we don't have time to compute this half.\r\n                // Consider the entire rest of the sequence different.\r\n                rightChanges = [\r\n                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\r\n                ];\r\n            }\r\n            return this.ConcatenateChanges(leftChanges, rightChanges);\r\n        }\r\n        // If we hit here, we quit early, and so can't return anything meaningful\r\n        return [\r\n            new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n        ];\r\n    }\r\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\r\n        let forwardChanges = null;\r\n        let reverseChanges = null;\r\n        // First, walk backward through the forward diagonals history\r\n        let changeHelper = new DiffChangeHelper();\r\n        let diagonalMin = diagonalForwardStart;\r\n        let diagonalMax = diagonalForwardEnd;\r\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\r\n        let lastOriginalIndex = -1073741824 /* Constants.MIN_SAFE_SMALL_INTEGER */;\r\n        let historyIndex = this.m_forwardHistory.length - 1;\r\n        do {\r\n            // Get the diagonal index from the relative diagonal number\r\n            const diagonal = diagonalRelative + diagonalForwardBase;\r\n            // Figure out where we came from\r\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                // Vertical line (the element is an insert)\r\n                originalIndex = forwardPoints[diagonal + 1];\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex;\r\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\r\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            else {\r\n                // Horizontal line (the element is a deletion)\r\n                originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex - 1;\r\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\r\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            if (historyIndex >= 0) {\r\n                forwardPoints = this.m_forwardHistory[historyIndex];\r\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\r\n                diagonalMin = 1;\r\n                diagonalMax = forwardPoints.length - 1;\r\n            }\r\n        } while (--historyIndex >= -1);\r\n        // Ironically, we get the forward changes as the reverse of the\r\n        // order we added them since we technically added them backwards\r\n        forwardChanges = changeHelper.getReverseChanges();\r\n        if (quitEarlyArr[0]) {\r\n            // TODO: Calculate a partial from the reverse diagonals.\r\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\r\n            let originalStartPoint = midOriginalArr[0] + 1;\r\n            let modifiedStartPoint = midModifiedArr[0] + 1;\r\n            if (forwardChanges !== null && forwardChanges.length > 0) {\r\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\r\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\r\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\r\n            }\r\n            reverseChanges = [\r\n                new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\r\n            ];\r\n        }\r\n        else {\r\n            // Now walk backward through the reverse diagonals history\r\n            changeHelper = new DiffChangeHelper();\r\n            diagonalMin = diagonalReverseStart;\r\n            diagonalMax = diagonalReverseEnd;\r\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\r\n            lastOriginalIndex = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\r\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\r\n            do {\r\n                // Get the diagonal index from the relative diagonal number\r\n                const diagonal = diagonalRelative + diagonalReverseBase;\r\n                // Figure out where we came from\r\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    // Horizontal line (the element is a deletion))\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex + 1;\r\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                else {\r\n                    // Vertical line (the element is an insertion)\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex;\r\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                if (historyIndex >= 0) {\r\n                    reversePoints = this.m_reverseHistory[historyIndex];\r\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\r\n                    diagonalMin = 1;\r\n                    diagonalMax = reversePoints.length - 1;\r\n                }\r\n            } while (--historyIndex >= -1);\r\n            // There are cases where the reverse history will find diffs that\r\n            // are correct, but not intuitive, so we need shift them.\r\n            reverseChanges = changeHelper.getChanges();\r\n        }\r\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\r\n    }\r\n    /**\r\n     * Given the range to compute the diff on, this method finds the point:\r\n     * (midOriginal, midModified)\r\n     * that exists in the middle of the LCS of the two sequences and\r\n     * is the point at which the LCS problem may be broken down recursively.\r\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n     * point is calculated and the full trace is available in memory, then this method\r\n     * will return the change list.\r\n     * @param originalStart The start bound of the original sequence range\r\n     * @param originalEnd The end bound of the original sequence range\r\n     * @param modifiedStart The start bound of the modified sequence range\r\n     * @param modifiedEnd The end bound of the modified sequence range\r\n     * @param midOriginal The middle point of the original sequence range\r\n     * @param midModified The middle point of the modified sequence range\r\n     * @returns The diff changes, if available, otherwise null\r\n     */\r\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\r\n        let originalIndex = 0, modifiedIndex = 0;\r\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\r\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\r\n        // To traverse the edit graph and produce the proper LCS, our actual\r\n        // start position is just outside the given boundary\r\n        originalStart--;\r\n        modifiedStart--;\r\n        // We set these up to make the compiler happy, but they will\r\n        // be replaced before we return with the actual recursion point\r\n        midOriginalArr[0] = 0;\r\n        midModifiedArr[0] = 0;\r\n        // Clear out the history\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\r\n        // The integer value in the cell represents the originalIndex of the furthest\r\n        // reaching point found so far that ends in that diagonal.\r\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\r\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\r\n        const numDiagonals = maxDifferences + 1;\r\n        const forwardPoints = new Int32Array(numDiagonals);\r\n        const reversePoints = new Int32Array(numDiagonals);\r\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\r\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\r\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\r\n        const diagonalReverseBase = (originalEnd - originalStart);\r\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalForwardBase)\r\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalReverseBase)\r\n        const diagonalForwardOffset = (originalStart - modifiedStart);\r\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\r\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\r\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\r\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\r\n        const delta = diagonalReverseBase - diagonalForwardBase;\r\n        const deltaIsEven = (delta % 2 === 0);\r\n        // Here we set up the start and end points as the furthest points found so far\r\n        // in both the forward and reverse directions, respectively\r\n        forwardPoints[diagonalForwardBase] = originalStart;\r\n        reversePoints[diagonalReverseBase] = originalEnd;\r\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\r\n        quitEarlyArr[0] = false;\r\n        // A couple of points:\r\n        // --With this method, we iterate on the number of differences between the two sequences.\r\n        //   The more differences there actually are, the longer this will take.\r\n        // --Also, as the number of differences increases, we have to search on diagonals further\r\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\r\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\r\n        //   is even and odd diagonals only when numDifferences is odd.\r\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\r\n            let furthestOriginalIndex = 0;\r\n            let furthestModifiedIndex = 0;\r\n            // Run the algorithm in the forward direction\r\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalStart, modifiedStart)\r\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                    originalIndex = forwardPoints[diagonal + 1];\r\n                }\r\n                else {\r\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\r\n                // Save the current originalIndex so we can test for false overlap in step 3\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // so long as the elements are equal.\r\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\r\n                    originalIndex++;\r\n                    modifiedIndex++;\r\n                }\r\n                forwardPoints[diagonal] = originalIndex;\r\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\r\n                    furthestOriginalIndex = originalIndex;\r\n                    furthestModifiedIndex = modifiedIndex;\r\n                }\r\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\r\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\r\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\r\n                // then check for overlap.\r\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\r\n                    if (originalIndex >= reversePoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Check to see if we should be quitting early, before moving on to the next iteration.\r\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\r\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\r\n                // We can't finish, so skip ahead to generating a result from what we have.\r\n                quitEarlyArr[0] = true;\r\n                // Use the furthest distance we got in the forward direction.\r\n                midOriginalArr[0] = furthestOriginalIndex;\r\n                midModifiedArr[0] = furthestModifiedIndex;\r\n                if (matchLengthOfLongest > 0 && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\r\n                    // Enough of the history is in memory to walk it backwards\r\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                }\r\n                else {\r\n                    // We didn't actually remember enough of the history.\r\n                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start\r\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\r\n                    originalStart++;\r\n                    modifiedStart++;\r\n                    return [\r\n                        new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                    ];\r\n                }\r\n            }\r\n            // Run the algorithm in the reverse direction\r\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalEnd, modifiedEnd)\r\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                }\r\n                else {\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\r\n                // Save the current originalIndex so we can test for false overlap\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // as long as the elements are equal.\r\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\r\n                    originalIndex--;\r\n                    modifiedIndex--;\r\n                }\r\n                reversePoints[diagonal] = originalIndex;\r\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\r\n                // and diagonal is in the range of forward diagonals computed for numDifferences\r\n                // then check for overlap.\r\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\r\n                    if (originalIndex <= forwardPoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Save current vectors to history before the next iteration\r\n            if (numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */) {\r\n                // We are allocating space for one extra int, which we fill with\r\n                // the index of the diagonal base index\r\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\r\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\r\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\r\n                this.m_forwardHistory.push(temp);\r\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\r\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\r\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\r\n                this.m_reverseHistory.push(temp);\r\n            }\r\n        }\r\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\r\n        // NOTE: This part is a bit messy\r\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n    }\r\n    /**\r\n     * Shifts the given changes to provide a more intuitive diff.\r\n     * While the first element in a diff matches the first element after the diff,\r\n     * we shift the diff down.\r\n     *\r\n     * @param changes The list of changes to shift\r\n     * @returns The shifted changes\r\n     */\r\n    PrettifyChanges(changes) {\r\n        // Shift all the changes down first\r\n        for (let i = 0; i < changes.length; i++) {\r\n            const change = changes[i];\r\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\r\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            while (change.originalStart + change.originalLength < originalStop\r\n                && change.modifiedStart + change.modifiedLength < modifiedStop\r\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\r\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\r\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\r\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\r\n                if (endStrictEqual && !startStrictEqual) {\r\n                    // moving the change down would create an equal change, but the elements are not strict equal\r\n                    break;\r\n                }\r\n                change.originalStart++;\r\n                change.modifiedStart++;\r\n            }\r\n            const mergedChangeArr = [null];\r\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\r\n                changes[i] = mergedChangeArr[0];\r\n                changes.splice(i + 1, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n        }\r\n        // Shift changes back up until we hit empty or whitespace-only lines\r\n        for (let i = changes.length - 1; i >= 0; i--) {\r\n            const change = changes[i];\r\n            let originalStop = 0;\r\n            let modifiedStop = 0;\r\n            if (i > 0) {\r\n                const prevChange = changes[i - 1];\r\n                originalStop = prevChange.originalStart + prevChange.originalLength;\r\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\r\n            }\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            let bestDelta = 0;\r\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\r\n            for (let delta = 1;; delta++) {\r\n                const originalStart = change.originalStart - delta;\r\n                const modifiedStart = change.modifiedStart - delta;\r\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\r\n                    break;\r\n                }\r\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\r\n                    break;\r\n                }\r\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\r\n                    break;\r\n                }\r\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\r\n                const score = ((touchingPreviousChange ? 5 : 0)\r\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\r\n                if (score > bestScore) {\r\n                    bestScore = score;\r\n                    bestDelta = delta;\r\n                }\r\n            }\r\n            change.originalStart -= bestDelta;\r\n            change.modifiedStart -= bestDelta;\r\n            const mergedChangeArr = [null];\r\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\r\n                changes[i - 1] = mergedChangeArr[0];\r\n                changes.splice(i, 1);\r\n                i++;\r\n                continue;\r\n            }\r\n        }\r\n        // There could be multiple longest common substrings.\r\n        // Give preference to the ones containing longer lines\r\n        if (this._hasStrings) {\r\n            for (let i = 1, len = changes.length; i < len; i++) {\r\n                const aChange = changes[i - 1];\r\n                const bChange = changes[i];\r\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\r\n                const aOriginalStart = aChange.originalStart;\r\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\r\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\r\n                const aModifiedStart = aChange.modifiedStart;\r\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\r\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\r\n                // Avoid wasting a lot of time with these searches\r\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\r\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\r\n                    if (t) {\r\n                        const [originalMatchStart, modifiedMatchStart] = t;\r\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\r\n                            // switch to another sequence that has a better score\r\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\r\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\r\n                            bChange.originalStart = originalMatchStart + matchedLength;\r\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\r\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\r\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return changes;\r\n    }\r\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\r\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\r\n            return null;\r\n        }\r\n        const originalMax = originalStart + originalLength - desiredLength + 1;\r\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\r\n        let bestScore = 0;\r\n        let bestOriginalStart = 0;\r\n        let bestModifiedStart = 0;\r\n        for (let i = originalStart; i < originalMax; i++) {\r\n            for (let j = modifiedStart; j < modifiedMax; j++) {\r\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\r\n                if (score > 0 && score > bestScore) {\r\n                    bestScore = score;\r\n                    bestOriginalStart = i;\r\n                    bestModifiedStart = j;\r\n                }\r\n            }\r\n        }\r\n        if (bestScore > 0) {\r\n            return [bestOriginalStart, bestModifiedStart];\r\n        }\r\n        return null;\r\n    }\r\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\r\n        let score = 0;\r\n        for (let l = 0; l < length; l++) {\r\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\r\n                return 0;\r\n            }\r\n            score += this._originalStringElements[originalStart + l].length;\r\n        }\r\n        return score;\r\n    }\r\n    _OriginalIsBoundary(index) {\r\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\r\n    }\r\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\r\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\r\n            return true;\r\n        }\r\n        if (originalLength > 0) {\r\n            const originalEnd = originalStart + originalLength;\r\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _ModifiedIsBoundary(index) {\r\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\r\n    }\r\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\r\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\r\n            return true;\r\n        }\r\n        if (modifiedLength > 0) {\r\n            const modifiedEnd = modifiedStart + modifiedLength;\r\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\r\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\r\n        return (originalScore + modifiedScore);\r\n    }\r\n    /**\r\n     * Concatenates the two input DiffChange lists and returns the resulting\r\n     * list.\r\n     * @param The left changes\r\n     * @param The right changes\r\n     * @returns The concatenated list\r\n     */\r\n    ConcatenateChanges(left, right) {\r\n        const mergedChangeArr = [];\r\n        if (left.length === 0 || right.length === 0) {\r\n            return (right.length > 0) ? right : left;\r\n        }\r\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\r\n            // Since we break the problem down recursively, it is possible that we\r\n            // might recurse in the middle of a change thereby splitting it into\r\n            // two changes. Here in the combining stage, we detect and fuse those\r\n            // changes back together\r\n            const result = new Array(left.length + right.length - 1);\r\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\r\n            result[left.length - 1] = mergedChangeArr[0];\r\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new Array(left.length + right.length);\r\n            MyArray.Copy(left, 0, result, 0, left.length);\r\n            MyArray.Copy(right, 0, result, left.length, right.length);\r\n            return result;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the two changes overlap and can be merged into a single\r\n     * change\r\n     * @param left The left change\r\n     * @param right The right change\r\n     * @param mergedChange The merged change if the two overlap, null otherwise\r\n     * @returns True if the two changes overlap\r\n     */\r\n    ChangesOverlap(left, right, mergedChangeArr) {\r\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\r\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\r\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n            const originalStart = left.originalStart;\r\n            let originalLength = left.originalLength;\r\n            const modifiedStart = left.modifiedStart;\r\n            let modifiedLength = left.modifiedLength;\r\n            if (left.originalStart + left.originalLength >= right.originalStart) {\r\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\r\n            }\r\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\r\n            }\r\n            mergedChangeArr[0] = new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\r\n            return true;\r\n        }\r\n        else {\r\n            mergedChangeArr[0] = null;\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Helper method used to clip a diagonal index to the range of valid\r\n     * diagonals. This also decides whether or not the diagonal index,\r\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n     * one inside the boundary depending on the Even/Odd status of the boundary\r\n     * and numDifferences.\r\n     * @param diagonal The index of the diagonal to clip.\r\n     * @param numDifferences The current number of differences being iterated upon.\r\n     * @param diagonalBaseIndex The base reference diagonal.\r\n     * @param numDiagonals The total number of diagonals.\r\n     * @returns The clipped diagonal index.\r\n     */\r\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\r\n        if (diagonal >= 0 && diagonal < numDiagonals) {\r\n            // Nothing to clip, its in range\r\n            return diagonal;\r\n        }\r\n        // diagonalsBelow: The number of diagonals below the reference diagonal\r\n        // diagonalsAbove: The number of diagonals above the reference diagonal\r\n        const diagonalsBelow = diagonalBaseIndex;\r\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\r\n        const diffEven = (numDifferences % 2 === 0);\r\n        if (diagonal < 0) {\r\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\r\n            return (diffEven === lowerBoundEven) ? 0 : 1;\r\n        }\r\n        else {\r\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\r\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDTDtBQUNqQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RCw0QkFBNEIsb0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JELHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0RBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZi5qcz8xYjBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBEaWZmQ2hhbmdlIH0gZnJvbSAnLi9kaWZmQ2hhbmdlLmpzJztcclxuaW1wb3J0IHsgc3RyaW5nSGFzaCB9IGZyb20gJy4uL2hhc2guanMnO1xyXG5leHBvcnQgY2xhc3MgU3RyaW5nRGlmZlNlcXVlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5ldyBJbnQzMkFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY2hhcmFjdGVyc1tpXSA9IHNvdXJjZS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhcmFjdGVycztcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRGlmZihvcmlnaW5hbCwgbW9kaWZpZWQsIHByZXR0eSkge1xyXG4gICAgcmV0dXJuIG5ldyBMY3NEaWZmKG5ldyBTdHJpbmdEaWZmU2VxdWVuY2Uob3JpZ2luYWwpLCBuZXcgU3RyaW5nRGlmZlNlcXVlbmNlKG1vZGlmaWVkKSkuQ29tcHV0ZURpZmYocHJldHR5KS5jaGFuZ2VzO1xyXG59XHJcbi8vXHJcbi8vIFRoZSBjb2RlIGJlbG93IGhhcyBiZWVuIHBvcnRlZCBmcm9tIGEgQyMgaW1wbGVtZW50YXRpb24gaW4gVlNcclxuLy9cclxuY2xhc3MgRGVidWcge1xyXG4gICAgc3RhdGljIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIE15QXJyYXkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgYSByYW5nZSBvZiBlbGVtZW50cyBmcm9tIGFuIEFycmF5IHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgc291cmNlIGluZGV4IGFuZCBwYXN0ZXNcclxuICAgICAqIHRoZW0gdG8gYW5vdGhlciBBcnJheSBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIGluZGV4LiBUaGUgbGVuZ3RoIGFuZCB0aGUgaW5kZXhlc1xyXG4gICAgICogYXJlIHNwZWNpZmllZCBhcyA2NC1iaXQgaW50ZWdlcnMuXHJcbiAgICAgKiBzb3VyY2VBcnJheTpcclxuICAgICAqXHRcdFRoZSBBcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHRvIGNvcHkuXHJcbiAgICAgKiBzb3VyY2VJbmRleDpcclxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgc291cmNlQXJyYXkgYXQgd2hpY2ggY29weWluZyBiZWdpbnMuXHJcbiAgICAgKiBkZXN0aW5hdGlvbkFycmF5OlxyXG4gICAgICpcdFx0VGhlIEFycmF5IHRoYXQgcmVjZWl2ZXMgdGhlIGRhdGEuXHJcbiAgICAgKiBkZXN0aW5hdGlvbkluZGV4OlxyXG4gICAgICpcdFx0QSA2NC1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIGluZGV4IGluIHRoZSBkZXN0aW5hdGlvbkFycmF5IGF0IHdoaWNoIHN0b3JpbmcgYmVnaW5zLlxyXG4gICAgICogbGVuZ3RoOlxyXG4gICAgICpcdFx0QSA2NC1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgQ29weShzb3VyY2VBcnJheSwgc291cmNlSW5kZXgsIGRlc3RpbmF0aW9uQXJyYXksIGRlc3RpbmF0aW9uSW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVzdGluYXRpb25BcnJheVtkZXN0aW5hdGlvbkluZGV4ICsgaV0gPSBzb3VyY2VBcnJheVtzb3VyY2VJbmRleCArIGldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBDb3B5Mihzb3VyY2VBcnJheSwgc291cmNlSW5kZXgsIGRlc3RpbmF0aW9uQXJyYXksIGRlc3RpbmF0aW9uSW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVzdGluYXRpb25BcnJheVtkZXN0aW5hdGlvbkluZGV4ICsgaV0gPSBzb3VyY2VBcnJheVtzb3VyY2VJbmRleCArIGldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIHdoaWNoIGhlbHBzIHRvIGNyZWF0ZSB0aGUgc2V0IG9mIERpZmZDaGFuZ2VzIGZyb21cclxuICogYSBkaWZmZXJlbmNlIG9wZXJhdGlvbi4gVGhpcyBjbGFzcyBhY2NlcHRzIG9yaWdpbmFsIERpZmZFbGVtZW50cyBhbmRcclxuICogbW9kaWZpZWQgRGlmZkVsZW1lbnRzIHRoYXQgYXJlIGludm9sdmVkIGluIGEgcGFydGljdWxhciBjaGFuZ2UuIFRoZVxyXG4gKiBNYXJrTmV4dENoYW5nZSgpIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIG1hcmsgdGhlIHNlcGFyYXRpb24gYmV0d2VlblxyXG4gKiBkaXN0aW5jdCBjaGFuZ2VzLiBBdCB0aGUgZW5kLCB0aGUgQ2hhbmdlcyBwcm9wZXJ0eSBjYW4gYmUgY2FsbGVkIHRvIHJldHJpZXZlXHJcbiAqIHRoZSBjb25zdHJ1Y3RlZCBjaGFuZ2VzLlxyXG4gKi9cclxuY2xhc3MgRGlmZkNoYW5nZUhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZUhlbHBlciBmb3IgdGhlIGdpdmVuIERpZmZTZXF1ZW5jZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubV9jaGFuZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGNoYW5nZSBpbiB0aGUgc2V0IG9mIGRpZmZlcmVuY2VzLlxyXG4gICAgICovXHJcbiAgICBNYXJrTmV4dENoYW5nZSgpIHtcclxuICAgICAgICAvLyBPbmx5IGFkZCB0byB0aGUgbGlzdCBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gYWRkXHJcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgY2hhbmdlIHRvIG91ciBsaXN0XHJcbiAgICAgICAgICAgIHRoaXMubV9jaGFuZ2VzLnB1c2gobmV3IERpZmZDaGFuZ2UodGhpcy5tX29yaWdpbmFsU3RhcnQsIHRoaXMubV9vcmlnaW5hbENvdW50LCB0aGlzLm1fbW9kaWZpZWRTdGFydCwgdGhpcy5tX21vZGlmaWVkQ291bnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGNoYW5nZVxyXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLm1fbW9kaWZpZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgb3JpZ2luYWwgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdG8gdGhlIGVsZW1lbnRzXHJcbiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBtb2RpZmllZCBpbmRleCBnaXZlcyBjb250ZXh0XHJcbiAgICAgKiB0byB0aGUgY2hhbmdlIHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdG8gYWRkLlxyXG4gICAgICogQHBhcmFtIG1vZGlmaWVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBtb2RpZmllZCBlbGVtZW50IHRoYXQgcHJvdmlkZXMgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIEFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4KSB7XHJcbiAgICAgICAgLy8gVGhlICd0cnVlJyBzdGFydCBpbmRleCBpcyB0aGUgc21hbGxlc3Qgb2YgdGhlIG9uZXMgd2UndmUgc2VlblxyXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX29yaWdpbmFsU3RhcnQsIG9yaWdpbmFsSW5kZXgpO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX21vZGlmaWVkU3RhcnQsIG1vZGlmaWVkSW5kZXgpO1xyXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50Kys7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIG1vZGlmaWVkIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50c1xyXG4gICAgICogYWZmZWN0ZWQgYnkgdGhlIGN1cnJlbnQgY2hhbmdlLiBUaGUgb3JpZ2luYWwgaW5kZXggZ2l2ZXMgY29udGV4dFxyXG4gICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoYXQgcHJvdmlkZXMgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRJbmRleCBUaGUgaW5kZXggb2YgdGhlIG1vZGlmaWVkIGVsZW1lbnQgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBBZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkge1xyXG4gICAgICAgIC8vIFRoZSAndHJ1ZScgc3RhcnQgaW5kZXggaXMgdGhlIHNtYWxsZXN0IG9mIHRoZSBvbmVzIHdlJ3ZlIHNlZW5cclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IE1hdGgubWluKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEluZGV4KTtcclxuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IE1hdGgubWluKHRoaXMubV9tb2RpZmllZFN0YXJ0LCBtb2RpZmllZEluZGV4KTtcclxuICAgICAgICB0aGlzLm1fbW9kaWZpZWRDb3VudCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIG1hcmtlZCBieSB0aGUgY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIGdldENoYW5nZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgLy8gRmluaXNoIHVwIG9uIHdoYXRldmVyIGlzIGxlZnRcclxuICAgICAgICAgICAgdGhpcy5NYXJrTmV4dENoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tX2NoYW5nZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbGwgb2YgdGhlIGNoYW5nZXMgbWFya2VkIGJ5IHRoZSBjbGFzcyBpbiB0aGUgcmV2ZXJzZSBvcmRlclxyXG4gICAgICovXHJcbiAgICBnZXRSZXZlcnNlQ2hhbmdlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAvLyBGaW5pc2ggdXAgb24gd2hhdGV2ZXIgaXMgbGVmdFxyXG4gICAgICAgICAgICB0aGlzLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubV9jaGFuZ2VzLnJldmVyc2UoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX2NoYW5nZXM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIGFsZ29yaXRobSBkZXNjcmliZWQgaW5cclxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIHZhcmlhdGlvbnNcIiBieSBFdWdlbmUgVy4gTXllcnNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMY3NEaWZmIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyB0aGUgRGlmZkZpbmRlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFNlcXVlbmNlLCBtb2RpZmllZFNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgPSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGU7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxTZXF1ZW5jZSA9IG9yaWdpbmFsU2VxdWVuY2U7XHJcbiAgICAgICAgdGhpcy5fbW9kaWZpZWRTZXF1ZW5jZSA9IG1vZGlmaWVkU2VxdWVuY2U7XHJcbiAgICAgICAgY29uc3QgW29yaWdpbmFsU3RyaW5nRWxlbWVudHMsIG9yaWdpbmFsRWxlbWVudHNPckhhc2gsIG9yaWdpbmFsSGFzU3RyaW5nc10gPSBMY3NEaWZmLl9nZXRFbGVtZW50cyhvcmlnaW5hbFNlcXVlbmNlKTtcclxuICAgICAgICBjb25zdCBbbW9kaWZpZWRTdHJpbmdFbGVtZW50cywgbW9kaWZpZWRFbGVtZW50c09ySGFzaCwgbW9kaWZpZWRIYXNTdHJpbmdzXSA9IExjc0RpZmYuX2dldEVsZW1lbnRzKG1vZGlmaWVkU2VxdWVuY2UpO1xyXG4gICAgICAgIHRoaXMuX2hhc1N0cmluZ3MgPSAob3JpZ2luYWxIYXNTdHJpbmdzICYmIG1vZGlmaWVkSGFzU3RyaW5ncyk7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50cyA9IG9yaWdpbmFsU3RyaW5nRWxlbWVudHM7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaCA9IG9yaWdpbmFsRWxlbWVudHNPckhhc2g7XHJcbiAgICAgICAgdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50cyA9IG1vZGlmaWVkU3RyaW5nRWxlbWVudHM7XHJcbiAgICAgICAgdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaCA9IG1vZGlmaWVkRWxlbWVudHNPckhhc2g7XHJcbiAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107XHJcbiAgICAgICAgdGhpcy5tX3JldmVyc2VIaXN0b3J5ID0gW107XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2lzU3RyaW5nQXJyYXkoYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIChhcnIubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2dldEVsZW1lbnRzKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBzZXF1ZW5jZS5nZXRFbGVtZW50cygpO1xyXG4gICAgICAgIGlmIChMY3NEaWZmLl9pc1N0cmluZ0FycmF5KGVsZW1lbnRzKSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNoZXMgPSBuZXcgSW50MzJBcnJheShlbGVtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGhhc2hlc1tpXSA9IHN0cmluZ0hhc2goZWxlbWVudHNbaV0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMsIGhhc2hlcywgdHJ1ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbGVtZW50cyBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtbXSwgZWxlbWVudHMsIGZhbHNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtbXSwgbmV3IEludDMyQXJyYXkoZWxlbWVudHMpLCBmYWxzZV07XHJcbiAgICB9XHJcbiAgICBFbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbb3JpZ2luYWxJbmRleF0gIT09IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbbmV3SW5kZXhdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tvcmlnaW5hbEluZGV4XSA9PT0gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tuZXdJbmRleF0gOiB0cnVlKTtcclxuICAgIH1cclxuICAgIEVsZW1lbnRzQXJlU3RyaWN0RXF1YWwob3JpZ2luYWxJbmRleCwgbmV3SW5kZXgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4LCBuZXdJbmRleCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcmlnaW5hbEVsZW1lbnQgPSBMY3NEaWZmLl9nZXRTdHJpY3RFbGVtZW50KHRoaXMuX29yaWdpbmFsU2VxdWVuY2UsIG9yaWdpbmFsSW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkRWxlbWVudCA9IExjc0RpZmYuX2dldFN0cmljdEVsZW1lbnQodGhpcy5fbW9kaWZpZWRTZXF1ZW5jZSwgbmV3SW5kZXgpO1xyXG4gICAgICAgIHJldHVybiAob3JpZ2luYWxFbGVtZW50ID09PSBtb2RpZmllZEVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9nZXRTdHJpY3RFbGVtZW50KHNlcXVlbmNlLCBpbmRleCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VxdWVuY2UuZ2V0U3RyaWN0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VxdWVuY2UuZ2V0U3RyaWN0RWxlbWVudChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKGluZGV4MSwgaW5kZXgyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbaW5kZXgxXSAhPT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtpbmRleDJdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleDFdID09PSB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4Ml0gOiB0cnVlKTtcclxuICAgIH1cclxuICAgIE1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbChpbmRleDEsIGluZGV4Mikge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW2luZGV4MV0gIT09IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbaW5kZXgyXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXgxXSA9PT0gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleDJdIDogdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBDb21wdXRlRGlmZihwcmV0dHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fQ29tcHV0ZURpZmYoMCwgdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxLCAwLCB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEsIHByZXR0eSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBhbmQgbW9kaWZpZWQgaW5wdXRcclxuICAgICAqIHNlcXVlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBfQ29tcHV0ZURpZmYob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBwcmV0dHkpIHtcclxuICAgICAgICBjb25zdCBxdWl0RWFybHlBcnIgPSBbZmFsc2VdO1xyXG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgaWYgKHByZXR0eSkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGNsZWFuIHVwIHRoZSBjb21wdXRlZCBkaWZmIHRvIGJlIG1vcmUgaW50dWl0aXZlXHJcbiAgICAgICAgICAgIC8vIGJ1dCBpdCB0dXJucyBvdXQgdGhpcyBjYW5ub3QgYmUgZG9uZSBjb3JyZWN0bHkgdW50aWwgdGhlIGVudGlyZSBzZXRcclxuICAgICAgICAgICAgLy8gb2YgZGlmZnMgaGF2ZSBiZWVuIGNvbXB1dGVkXHJcbiAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLlByZXR0aWZ5Q2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHlBcnJbMF0sXHJcbiAgICAgICAgICAgIGNoYW5nZXM6IGNoYW5nZXNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2Qgd2hpY2ggY29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIG9uIHRoZSBib3VuZGVkIHJhbmdlXHJcbiAgICAgKiByZWN1cnNpdmVseS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBDb21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycikge1xyXG4gICAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBkaWZmZXJlbmNlc1xyXG4gICAgICAgIHdoaWxlIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkU3RhcnQgPD0gbW9kaWZpZWRFbmQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kID49IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRFbmQgPj0gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKSkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVuZC0tO1xyXG4gICAgICAgICAgICBtb2RpZmllZEVuZC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbiB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGVpdGhlciBoYXZlIGFsbCBpbnNlcnRpb25zIG9yIGFsbCBkZWxldGlvbnMgb3IgdGhlIHNlcXVlbmNlcyBhcmUgaWRlbnRpY2FsXHJcbiAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnQgPiBvcmlnaW5hbEVuZCB8fCBtb2RpZmllZFN0YXJ0ID4gbW9kaWZpZWRFbmQpIHtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZXM7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZFN0YXJ0IDw9IG1vZGlmaWVkRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgaW5zZXJ0aW9uc1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCAwLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQobW9kaWZpZWRTdGFydCA9PT0gbW9kaWZpZWRFbmQgKyAxLCAnbW9kaWZpZWRTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG1vZGlmaWVkRW5kJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgZGVsZXRpb25zXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIDApXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsRW5kICsgMSwgJ29yaWdpbmFsU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBvcmlnaW5hbEVuZCcpO1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWRlbnRpY2FsIHNlcXVlbmNlcyAtIE5vIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoaXMgcHJvYmxlbSBjYW4gYmUgc29sdmVkIHVzaW5nIHRoZSBEaXZpZGUtQW5kLUNvbnF1ZXIgdGVjaG5pcXVlLlxyXG4gICAgICAgIGNvbnN0IG1pZE9yaWdpbmFsQXJyID0gWzBdO1xyXG4gICAgICAgIGNvbnN0IG1pZE1vZGlmaWVkQXJyID0gWzBdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuQ29tcHV0ZVJlY3Vyc2lvblBvaW50KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1pZE1vZGlmaWVkQXJyLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgICAgIGNvbnN0IG1pZE9yaWdpbmFsID0gbWlkT3JpZ2luYWxBcnJbMF07XHJcbiAgICAgICAgY29uc3QgbWlkTW9kaWZpZWQgPSBtaWRNb2RpZmllZEFyclswXTtcclxuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc3VsdCBpcyBub3QtbnVsbCB3aGVuIHRoZXJlIHdhcyBlbm91Z2ggbWVtb3J5IHRvIGNvbXB1dGUgdGhlIGNoYW5nZXMgd2hpbGVcclxuICAgICAgICAgICAgLy8gc2VhcmNoaW5nIGZvciB0aGUgcmVjdXJzaW9uIHBvaW50XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHtcclxuICAgICAgICAgICAgLy8gV2UgY2FuIGJyZWFrIHRoZSBwcm9ibGVtIGRvd24gcmVjdXJzaXZlbHkgYnkgZmluZGluZyB0aGUgY2hhbmdlcyBpbiB0aGVcclxuICAgICAgICAgICAgLy8gRmlyc3QgSGFsZjogICAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCkgdG8gKG1pZE9yaWdpbmFsLCBtaWRNb2RpZmllZClcclxuICAgICAgICAgICAgLy8gU2Vjb25kIEhhbGY6ICAobWlkT3JpZ2luYWwgKyAxLCBtaW5Nb2RpZmllZCArIDEpIHRvIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IENvbXB1dGVEaWZmKCkgaXMgaW5jbHVzaXZlLCB0aGVyZWZvcmUgdGhlIHNlY29uZCByYW5nZSBzdGFydHMgb24gdGhlIG5leHQgcG9pbnRcclxuICAgICAgICAgICAgY29uc3QgbGVmdENoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG1pZE9yaWdpbmFsLCBtb2RpZmllZFN0YXJ0LCBtaWRNb2RpZmllZCwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgbGV0IHJpZ2h0Q2hhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoIXF1aXRFYXJseUFyclswXSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShtaWRPcmlnaW5hbCArIDEsIG9yaWdpbmFsRW5kLCBtaWRNb2RpZmllZCArIDEsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZGlkbid0IGhhdmUgdGltZSB0byBmaW5pc2ggdGhlIGZpcnN0IGhhbGYsIHNvIHdlIGRvbid0IGhhdmUgdGltZSB0byBjb21wdXRlIHRoaXMgaGFsZi5cclxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZSBlbnRpcmUgcmVzdCBvZiB0aGUgc2VxdWVuY2UgZGlmZmVyZW50LlxyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG1pZE9yaWdpbmFsICsgMSwgb3JpZ2luYWxFbmQgLSAobWlkT3JpZ2luYWwgKyAxKSArIDEsIG1pZE1vZGlmaWVkICsgMSwgbW9kaWZpZWRFbmQgLSAobWlkTW9kaWZpZWQgKyAxKSArIDEpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhsZWZ0Q2hhbmdlcywgcmlnaHRDaGFuZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgaGl0IGhlcmUsIHdlIHF1aXQgZWFybHksIGFuZCBzbyBjYW4ndCByZXR1cm4gYW55dGhpbmcgbWVhbmluZ2Z1bFxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIFdBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpIHtcclxuICAgICAgICBsZXQgZm9yd2FyZENoYW5nZXMgPSBudWxsO1xyXG4gICAgICAgIGxldCByZXZlcnNlQ2hhbmdlcyA9IG51bGw7XHJcbiAgICAgICAgLy8gRmlyc3QsIHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgZm9yd2FyZCBkaWFnb25hbHMgaGlzdG9yeVxyXG4gICAgICAgIGxldCBjaGFuZ2VIZWxwZXIgPSBuZXcgRGlmZkNoYW5nZUhlbHBlcigpO1xyXG4gICAgICAgIGxldCBkaWFnb25hbE1pbiA9IGRpYWdvbmFsRm9yd2FyZFN0YXJ0O1xyXG4gICAgICAgIGxldCBkaWFnb25hbE1heCA9IGRpYWdvbmFsRm9yd2FyZEVuZDtcclxuICAgICAgICBsZXQgZGlhZ29uYWxSZWxhdGl2ZSA9IChtaWRPcmlnaW5hbEFyclswXSAtIG1pZE1vZGlmaWVkQXJyWzBdKSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcclxuICAgICAgICBsZXQgbGFzdE9yaWdpbmFsSW5kZXggPSAtMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUlOX1NBRkVfU01BTExfSU5URUdFUiAqLztcclxuICAgICAgICBsZXQgaGlzdG9yeUluZGV4ID0gdGhpcy5tX2ZvcndhcmRIaXN0b3J5Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRpYWdvbmFsIGluZGV4IGZyb20gdGhlIHJlbGF0aXZlIGRpYWdvbmFsIG51bWJlclxyXG4gICAgICAgICAgICBjb25zdCBkaWFnb25hbCA9IGRpYWdvbmFsUmVsYXRpdmUgKyBkaWFnb25hbEZvcndhcmRCYXNlO1xyXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsTWluIHx8IChkaWFnb25hbCA8IGRpYWdvbmFsTWF4ICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGFuIGluc2VydClcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV07XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8IGxhc3RPcmlnaW5hbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgKyAxKSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhIGRlbGV0aW9uKVxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSArIDE7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8IGxhc3RPcmlnaW5hbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAxO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsIC0gMSkgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGlzdG9yeUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGZvcndhcmRQb2ludHMgPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnlbaGlzdG9yeUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZEJhc2UgPSBmb3J3YXJkUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90XHJcbiAgICAgICAgICAgICAgICBkaWFnb25hbE1pbiA9IDE7XHJcbiAgICAgICAgICAgICAgICBkaWFnb25hbE1heCA9IGZvcndhcmRQb2ludHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKC0taGlzdG9yeUluZGV4ID49IC0xKTtcclxuICAgICAgICAvLyBJcm9uaWNhbGx5LCB3ZSBnZXQgdGhlIGZvcndhcmQgY2hhbmdlcyBhcyB0aGUgcmV2ZXJzZSBvZiB0aGVcclxuICAgICAgICAvLyBvcmRlciB3ZSBhZGRlZCB0aGVtIHNpbmNlIHdlIHRlY2huaWNhbGx5IGFkZGVkIHRoZW0gYmFja3dhcmRzXHJcbiAgICAgICAgZm9yd2FyZENoYW5nZXMgPSBjaGFuZ2VIZWxwZXIuZ2V0UmV2ZXJzZUNoYW5nZXMoKTtcclxuICAgICAgICBpZiAocXVpdEVhcmx5QXJyWzBdKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IENhbGN1bGF0ZSBhIHBhcnRpYWwgZnJvbSB0aGUgcmV2ZXJzZSBkaWFnb25hbHMuXHJcbiAgICAgICAgICAgIC8vICAgICAgIEZvciBub3csIGp1c3QgYXNzdW1lIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIG1pZE9yaWdpbmFsL21pZE1vZGlmaWVkIHBvaW50IGlzIGEgZGlmZlxyXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdGFydFBvaW50ID0gbWlkT3JpZ2luYWxBcnJbMF0gKyAxO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRTdGFydFBvaW50ID0gbWlkTW9kaWZpZWRBcnJbMF0gKyAxO1xyXG4gICAgICAgICAgICBpZiAoZm9yd2FyZENoYW5nZXMgIT09IG51bGwgJiYgZm9yd2FyZENoYW5nZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEZvcndhcmRDaGFuZ2UgPSBmb3J3YXJkQ2hhbmdlc1tmb3J3YXJkQ2hhbmdlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRQb2ludCA9IE1hdGgubWF4KG9yaWdpbmFsU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0T3JpZ2luYWxFbmQoKSk7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0UG9pbnQgPSBNYXRoLm1heChtb2RpZmllZFN0YXJ0UG9pbnQsIGxhc3RGb3J3YXJkQ2hhbmdlLmdldE1vZGlmaWVkRW5kKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldmVyc2VDaGFuZ2VzID0gW1xyXG4gICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydFBvaW50LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnRQb2ludCArIDEsIG1vZGlmaWVkU3RhcnRQb2ludCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0UG9pbnQgKyAxKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm93IHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgcmV2ZXJzZSBkaWFnb25hbHMgaGlzdG9yeVxyXG4gICAgICAgICAgICBjaGFuZ2VIZWxwZXIgPSBuZXcgRGlmZkNoYW5nZUhlbHBlcigpO1xyXG4gICAgICAgICAgICBkaWFnb25hbE1pbiA9IGRpYWdvbmFsUmV2ZXJzZVN0YXJ0O1xyXG4gICAgICAgICAgICBkaWFnb25hbE1heCA9IGRpYWdvbmFsUmV2ZXJzZUVuZDtcclxuICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChtaWRPcmlnaW5hbEFyclswXSAtIG1pZE1vZGlmaWVkQXJyWzBdKSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcclxuICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgICAgICAgICBoaXN0b3J5SW5kZXggPSAoZGVsdGFJc0V2ZW4pID8gdGhpcy5tX3JldmVyc2VIaXN0b3J5Lmxlbmd0aCAtIDEgOiB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMjtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBkaWFnb25hbCBpbmRleCBmcm9tIHRoZSByZWxhdGl2ZSBkaWFnb25hbCBudW1iZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsUmV2ZXJzZUJhc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbE1pbiB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbE1heCAmJiByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV0gPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID4gbGFzdE9yaWdpbmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgKyAxKSAtIGRpYWdvbmFsUmV2ZXJzZUJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYW4gaW5zZXJ0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID4gbGFzdE9yaWdpbmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCAtIDEpIC0gZGlhZ29uYWxSZXZlcnNlQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlUG9pbnRzID0gdGhpcy5tX3JldmVyc2VIaXN0b3J5W2hpc3RvcnlJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZXZlcnNlQmFzZSA9IHJldmVyc2VQb2ludHNbMF07IC8vV2Ugc3RvcmVkIHRoaXMgaW4gdGhlIGZpcnN0IHNwb3RcclxuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbE1pbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxNYXggPSByZXZlcnNlUG9pbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKC0taGlzdG9yeUluZGV4ID49IC0xKTtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSByZXZlcnNlIGhpc3Rvcnkgd2lsbCBmaW5kIGRpZmZzIHRoYXRcclxuICAgICAgICAgICAgLy8gYXJlIGNvcnJlY3QsIGJ1dCBub3QgaW50dWl0aXZlLCBzbyB3ZSBuZWVkIHNoaWZ0IHRoZW0uXHJcbiAgICAgICAgICAgIHJldmVyc2VDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldENoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29uY2F0ZW5hdGVDaGFuZ2VzKGZvcndhcmRDaGFuZ2VzLCByZXZlcnNlQ2hhbmdlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIHRoZSByYW5nZSB0byBjb21wdXRlIHRoZSBkaWZmIG9uLCB0aGlzIG1ldGhvZCBmaW5kcyB0aGUgcG9pbnQ6XHJcbiAgICAgKiAobWlkT3JpZ2luYWwsIG1pZE1vZGlmaWVkKVxyXG4gICAgICogdGhhdCBleGlzdHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgTENTIG9mIHRoZSB0d28gc2VxdWVuY2VzIGFuZFxyXG4gICAgICogaXMgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBMQ1MgcHJvYmxlbSBtYXkgYmUgYnJva2VuIGRvd24gcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRyeSB0byBrZWVwIHRoZSBMQ1MgdHJhY2UgaW4gbWVtb3J5LiBJZiB0aGUgTENTIHJlY3Vyc2lvblxyXG4gICAgICogcG9pbnQgaXMgY2FsY3VsYXRlZCBhbmQgdGhlIGZ1bGwgdHJhY2UgaXMgYXZhaWxhYmxlIGluIG1lbW9yeSwgdGhlbiB0aGlzIG1ldGhvZFxyXG4gICAgICogd2lsbCByZXR1cm4gdGhlIGNoYW5nZSBsaXN0LlxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRTdGFydCBUaGUgc3RhcnQgYm91bmQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRFbmQgVGhlIGVuZCBib3VuZCBvZiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UgcmFuZ2VcclxuICAgICAqIEBwYXJhbSBtaWRPcmlnaW5hbCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHBhcmFtIG1pZE1vZGlmaWVkIFRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZiBjaGFuZ2VzLCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBudWxsXHJcbiAgICAgKi9cclxuICAgIENvbXB1dGVSZWN1cnNpb25Qb2ludChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIG1pZE9yaWdpbmFsQXJyLCBtaWRNb2RpZmllZEFyciwgcXVpdEVhcmx5QXJyKSB7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsSW5kZXggPSAwLCBtb2RpZmllZEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgZGlhZ29uYWxGb3J3YXJkU3RhcnQgPSAwLCBkaWFnb25hbEZvcndhcmRFbmQgPSAwO1xyXG4gICAgICAgIGxldCBkaWFnb25hbFJldmVyc2VTdGFydCA9IDAsIGRpYWdvbmFsUmV2ZXJzZUVuZCA9IDA7XHJcbiAgICAgICAgLy8gVG8gdHJhdmVyc2UgdGhlIGVkaXQgZ3JhcGggYW5kIHByb2R1Y2UgdGhlIHByb3BlciBMQ1MsIG91ciBhY3R1YWxcclxuICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBpcyBqdXN0IG91dHNpZGUgdGhlIGdpdmVuIGJvdW5kYXJ5XHJcbiAgICAgICAgb3JpZ2luYWxTdGFydC0tO1xyXG4gICAgICAgIG1vZGlmaWVkU3RhcnQtLTtcclxuICAgICAgICAvLyBXZSBzZXQgdGhlc2UgdXAgdG8gbWFrZSB0aGUgY29tcGlsZXIgaGFwcHksIGJ1dCB0aGV5IHdpbGxcclxuICAgICAgICAvLyBiZSByZXBsYWNlZCBiZWZvcmUgd2UgcmV0dXJuIHdpdGggdGhlIGFjdHVhbCByZWN1cnNpb24gcG9pbnRcclxuICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IDA7XHJcbiAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSAwO1xyXG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgaGlzdG9yeVxyXG4gICAgICAgIHRoaXMubV9mb3J3YXJkSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIC8vIEVhY2ggY2VsbCBpbiB0aGUgdHdvIGFycmF5cyBjb3JyZXNwb25kcyB0byBhIGRpYWdvbmFsIGluIHRoZSBlZGl0IGdyYXBoLlxyXG4gICAgICAgIC8vIFRoZSBpbnRlZ2VyIHZhbHVlIGluIHRoZSBjZWxsIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsSW5kZXggb2YgdGhlIGZ1cnRoZXN0XHJcbiAgICAgICAgLy8gcmVhY2hpbmcgcG9pbnQgZm91bmQgc28gZmFyIHRoYXQgZW5kcyBpbiB0aGF0IGRpYWdvbmFsLlxyXG4gICAgICAgIC8vIFRoZSBtb2RpZmllZEluZGV4IGNhbiBiZSBjb21wdXRlZCBtYXRoZW1hdGljYWxseSBmcm9tIHRoZSBvcmlnaW5hbEluZGV4IGFuZCB0aGUgZGlhZ29uYWwgbnVtYmVyLlxyXG4gICAgICAgIGNvbnN0IG1heERpZmZlcmVuY2VzID0gKG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCkgKyAobW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0KTtcclxuICAgICAgICBjb25zdCBudW1EaWFnb25hbHMgPSBtYXhEaWZmZXJlbmNlcyArIDE7XHJcbiAgICAgICAgY29uc3QgZm9yd2FyZFBvaW50cyA9IG5ldyBJbnQzMkFycmF5KG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZVBvaW50cyA9IG5ldyBJbnQzMkFycmF5KG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkQmFzZTogSW5kZXggaW50byBmb3J3YXJkUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydClcclxuICAgICAgICAvLyBkaWFnb25hbFJldmVyc2VCYXNlOiBJbmRleCBpbnRvIHJldmVyc2VQb2ludHMgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXHJcbiAgICAgICAgY29uc3QgZGlhZ29uYWxGb3J3YXJkQmFzZSA9IChtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KTtcclxuICAgICAgICAvLyBkaWFnb25hbEZvcndhcmRPZmZzZXQ6IEdlb21ldHJpYyBvZmZzZXQgd2hpY2ggYWxsb3dzIG1vZGlmaWVkSW5kZXggdG8gYmUgY29tcHV0ZWQgZnJvbSBvcmlnaW5hbEluZGV4IGFuZCB0aGVcclxuICAgICAgICAvLyAgICBkaWFnb25hbCBudW1iZXIgKHJlbGF0aXZlIHRvIGRpYWdvbmFsRm9yd2FyZEJhc2UpXHJcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXHJcbiAgICAgICAgLy8gICAgZGlhZ29uYWwgbnVtYmVyIChyZWxhdGl2ZSB0byBkaWFnb25hbFJldmVyc2VCYXNlKVxyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsRm9yd2FyZE9mZnNldCA9IChvcmlnaW5hbFN0YXJ0IC0gbW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0ID0gKG9yaWdpbmFsRW5kIC0gbW9kaWZpZWRFbmQpO1xyXG4gICAgICAgIC8vIGRlbHRhOiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBlbmQgZGlhZ29uYWwgYW5kIHRoZSBzdGFydCBkaWFnb25hbC4gVGhpcyBpcyB1c2VkIHRvIHJlbGF0ZSBkaWFnb25hbCBudW1iZXJzXHJcbiAgICAgICAgLy8gICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgZGlhZ29uYWwgd2l0aCBkaWFnb25hbCBudW1iZXJzIHJlbGF0aXZlIHRvIHRoZSBlbmQgZGlhZ29uYWwuXHJcbiAgICAgICAgLy8gVGhlIEV2ZW4vT2Rkbi1uZXNzIG9mIHRoaXMgZGVsdGEgaXMgaW1wb3J0YW50IGZvciBkZXRlcm1pbmluZyB3aGVuIHdlIHNob3VsZCBjaGVjayBmb3Igb3ZlcmxhcFxyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGlhZ29uYWxSZXZlcnNlQmFzZSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7XHJcbiAgICAgICAgY29uc3QgZGVsdGFJc0V2ZW4gPSAoZGVsdGEgJSAyID09PSAwKTtcclxuICAgICAgICAvLyBIZXJlIHdlIHNldCB1cCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXMgdGhlIGZ1cnRoZXN0IHBvaW50cyBmb3VuZCBzbyBmYXJcclxuICAgICAgICAvLyBpbiBib3RoIHRoZSBmb3J3YXJkIGFuZCByZXZlcnNlIGRpcmVjdGlvbnMsIHJlc3BlY3RpdmVseVxyXG4gICAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxGb3J3YXJkQmFzZV0gPSBvcmlnaW5hbFN0YXJ0O1xyXG4gICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxSZXZlcnNlQmFzZV0gPSBvcmlnaW5hbEVuZDtcclxuICAgICAgICAvLyBSZW1lbWJlciBpZiB3ZSBxdWl0IGVhcmx5LCBhbmQgdGh1cyBuZWVkIHRvIGRvIGEgYmVzdC1lZmZvcnQgcmVzdWx0IGluc3RlYWQgb2YgYSByZWFsIHJlc3VsdC5cclxuICAgICAgICBxdWl0RWFybHlBcnJbMF0gPSBmYWxzZTtcclxuICAgICAgICAvLyBBIGNvdXBsZSBvZiBwb2ludHM6XHJcbiAgICAgICAgLy8gLS1XaXRoIHRoaXMgbWV0aG9kLCB3ZSBpdGVyYXRlIG9uIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIHNlcXVlbmNlcy5cclxuICAgICAgICAvLyAgIFRoZSBtb3JlIGRpZmZlcmVuY2VzIHRoZXJlIGFjdHVhbGx5IGFyZSwgdGhlIGxvbmdlciB0aGlzIHdpbGwgdGFrZS5cclxuICAgICAgICAvLyAtLUFsc28sIGFzIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgaW5jcmVhc2VzLCB3ZSBoYXZlIHRvIHNlYXJjaCBvbiBkaWFnb25hbHMgZnVydGhlclxyXG4gICAgICAgIC8vICAgYXdheSBmcm9tIHRoZSByZWZlcmVuY2UgZGlhZ29uYWwgKHdoaWNoIGlzIGRpYWdvbmFsRm9yd2FyZEJhc2UgZm9yIGZvcndhcmQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UgZm9yIHJldmVyc2UpLlxyXG4gICAgICAgIC8vIC0tV2UgZXh0ZW5kIG9uIGV2ZW4gZGlhZ29uYWxzIChyZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsKSBvbmx5IHdoZW4gbnVtRGlmZmVyZW5jZXNcclxuICAgICAgICAvLyAgIGlzIGV2ZW4gYW5kIG9kZCBkaWFnb25hbHMgb25seSB3aGVuIG51bURpZmZlcmVuY2VzIGlzIG9kZC5cclxuICAgICAgICBmb3IgKGxldCBudW1EaWZmZXJlbmNlcyA9IDE7IG51bURpZmZlcmVuY2VzIDw9IChtYXhEaWZmZXJlbmNlcyAvIDIpICsgMTsgbnVtRGlmZmVyZW5jZXMrKykge1xyXG4gICAgICAgICAgICBsZXQgZnVydGhlc3RPcmlnaW5hbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgbGV0IGZ1cnRoZXN0TW9kaWZpZWRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYWxnb3JpdGhtIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvblxyXG4gICAgICAgICAgICBkaWFnb25hbEZvcndhcmRTdGFydCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSAtIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcclxuICAgICAgICAgICAgZGlhZ29uYWxGb3J3YXJkRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkaWFnb25hbCA9IGRpYWdvbmFsRm9yd2FyZFN0YXJ0OyBkaWFnb25hbCA8PSBkaWFnb25hbEZvcndhcmRFbmQ7IGRpYWdvbmFsICs9IDIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMTogV2UgZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxyXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XHJcbiAgICAgICAgICAgICAgICAvLyBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgc3RhcnQgcG9pbnQgKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsRm9yd2FyZFN0YXJ0IHx8IChkaWFnb25hbCA8IGRpYWdvbmFsRm9yd2FyZEVuZCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAoZGlhZ29uYWwgLSBkaWFnb25hbEZvcndhcmRCYXNlKSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcCBpbiBzdGVwIDNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMjogV2UgY2FuIGNvbnRpbnVlIHRvIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4IDwgb3JpZ2luYWxFbmQgJiYgbW9kaWZpZWRJbmRleCA8IG1vZGlmaWVkRW5kICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ICsgbW9kaWZpZWRJbmRleCA+IGZ1cnRoZXN0T3JpZ2luYWxJbmRleCArIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1cnRoZXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVydGhlc3RNb2RpZmllZEluZGV4ID0gbW9kaWZpZWRJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMzogSWYgZGVsdGEgaXMgb2RkIChvdmVybGFwIGZpcnN0IGhhcHBlbnMgb24gZm9yd2FyZCB3aGVuIGRlbHRhIGlzIG9kZClcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBkaWFnb25hbCBpcyBpbiB0aGUgcmFuZ2Ugb2YgcmV2ZXJzZSBkaWFnb25hbHMgY29tcHV0ZWQgZm9yIG51bURpZmZlcmVuY2VzLTFcclxuICAgICAgICAgICAgICAgIC8vICh0aGUgcHJldmlvdXMgaXRlcmF0aW9uOyB3ZSBoYXZlbid0IGNvbXB1dGVkIHJldmVyc2UgZGlhZ29uYWxzIGZvciBudW1EaWZmZXJlbmNlcyB5ZXQpXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIGZvciBvdmVybGFwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YUlzRXZlbiAmJiBNYXRoLmFicyhkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIDw9IChudW1EaWZmZXJlbmNlcyAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSBvcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IG1vZGlmaWVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA8PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJJTkdPISBXZSBvdmVybGFwcGVkLCBhbmQgd2UgaGF2ZSB0aGUgZnVsbCB0cmFjZSBpbiBtZW1vcnkhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBiZSBxdWl0dGluZyBlYXJseSwgYmVmb3JlIG1vdmluZyBvbiB0byB0aGUgbmV4dCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoT2ZMb25nZXN0ID0gKChmdXJ0aGVzdE9yaWdpbmFsSW5kZXggLSBvcmlnaW5hbFN0YXJ0KSArIChmdXJ0aGVzdE1vZGlmaWVkSW5kZXggLSBtb2RpZmllZFN0YXJ0KSAtIG51bURpZmZlcmVuY2VzKSAvIDI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSAhPT0gbnVsbCAmJiAhdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUoZnVydGhlc3RPcmlnaW5hbEluZGV4LCBtYXRjaExlbmd0aE9mTG9uZ2VzdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGZpbmlzaCwgc28gc2tpcCBhaGVhZCB0byBnZW5lcmF0aW5nIGEgcmVzdWx0IGZyb20gd2hhdCB3ZSBoYXZlLlxyXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5QXJyWzBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZnVydGhlc3QgZGlzdGFuY2Ugd2UgZ290IGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gZnVydGhlc3RPcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBmdXJ0aGVzdE1vZGlmaWVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGhPZkxvbmdlc3QgPiAwICYmIDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovID4gMCAmJiBudW1EaWZmZXJlbmNlcyA8PSAoMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVub3VnaCBvZiB0aGUgaGlzdG9yeSBpcyBpbiBtZW1vcnkgdG8gd2FsayBpdCBiYWNrd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCBhY3R1YWxseSByZW1lbWJlciBlbm91Z2ggb2YgdGhlIGhpc3RvcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9TaW5jZSB3ZSBhcmUgcXVpdHRpbmcgdGhlIGRpZmYgZWFybHksIHdlIG5lZWQgdG8gc2hpZnQgYmFjayB0aGUgb3JpZ2luYWxTdGFydCBhbmQgbW9kaWZpZWQgc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAvL2JhY2sgaW50byB0aGUgYm91bmRhcnkgbGltaXRzIHNpbmNlIHdlIGRlY3JlbWVudGVkIHRoZWlyIHZhbHVlIGFib3ZlIGJleW9uZCB0aGUgYm91bmRhcnkgbGltaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnQrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQgKyAxLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbGdvcml0aG0gaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xyXG4gICAgICAgICAgICBkaWFnb25hbFJldmVyc2VFbmQgPSB0aGlzLkNsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsUmV2ZXJzZUJhc2UgKyBudW1EaWZmZXJlbmNlcywgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRpYWdvbmFsID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7IGRpYWdvbmFsIDw9IGRpYWdvbmFsUmV2ZXJzZUVuZDsgZGlhZ29uYWwgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICAvLyBieSBsb29raW5nIGF0IHRoZSBkaWFnb25hbHMgYWJvdmUgYW5kIGJlbG93IGFuZCBwaWNraW5nIHRoZSBvbmUgd2hvc2UgcG9pbnRcclxuICAgICAgICAgICAgICAgIC8vIGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBzdGFydCBwb2ludCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbFJldmVyc2VTdGFydCB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbFJldmVyc2VFbmQgJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBvcmlnaW5hbEluZGV4IHNvIHdlIGNhbiB0ZXN0IGZvciBmYWxzZSBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDI6IFdlIGNhbiBjb250aW51ZSB0byBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyBsb25nIGFzIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA+IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRJbmRleCA+IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgNDogSWYgZGVsdGEgaXMgZXZlbiAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIHJldmVyc2Ugd2hlbiBkZWx0YSBpcyBldmVuKVxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpYWdvbmFsIGlzIGluIHRoZSByYW5nZSBvZiBmb3J3YXJkIGRpYWdvbmFscyBjb21wdXRlZCBmb3IgbnVtRGlmZmVyZW5jZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgZm9yIG92ZXJsYXAuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFJc0V2ZW4gJiYgTWF0aC5hYnMoZGlhZ29uYWwgLSBkaWFnb25hbEZvcndhcmRCYXNlKSA8PSBudW1EaWZmZXJlbmNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDw9IGZvcndhcmRQb2ludHNbZGlhZ29uYWxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBtb2RpZmllZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcE9yaWdpbmFsSW5kZXggPj0gZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gJiYgMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgZmFsc2Ugb3ZlcmxhcCwgb3Igd2UgZGlkbid0IGhhdmUgZW5vdWdoIG1lbW9yeSBmb3IgdGhlIGZ1bGwgdHJhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhdmUgY3VycmVudCB2ZWN0b3JzIHRvIGhpc3RvcnkgYmVmb3JlIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAobnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhbGxvY2F0aW5nIHNwYWNlIGZvciBvbmUgZXh0cmEgaW50LCB3aGljaCB3ZSBmaWxsIHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgYmFzZSBpbmRleFxyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDIpO1xyXG4gICAgICAgICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsRm9yd2FyZEJhc2UgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICBNeUFycmF5LkNvcHkyKGZvcndhcmRQb2ludHMsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCB0ZW1wLCAxLCBkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5LnB1c2godGVtcCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gbmV3IEludDMyQXJyYXkoZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAyKTtcclxuICAgICAgICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbFJldmVyc2VCYXNlIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgTXlBcnJheS5Db3B5MihyZXZlcnNlUG9pbnRzLCBkaWFnb25hbFJldmVyc2VTdGFydCwgdGVtcCwgMSwgZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeS5wdXNoKHRlbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gaGlzdG9yeS4gV2UganVzdCBoYXZlIHRvIGNvbnZlcnQgaXQgdG8gYSBjaGFuZ2UgbGlzdFxyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgcGFydCBpcyBhIGJpdCBtZXNzeVxyXG4gICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGlmdHMgdGhlIGdpdmVuIGNoYW5nZXMgdG8gcHJvdmlkZSBhIG1vcmUgaW50dWl0aXZlIGRpZmYuXHJcbiAgICAgKiBXaGlsZSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIGRpZmYgbWF0Y2hlcyB0aGUgZmlyc3QgZWxlbWVudCBhZnRlciB0aGUgZGlmZixcclxuICAgICAqIHdlIHNoaWZ0IHRoZSBkaWZmIGRvd24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgVGhlIGxpc3Qgb2YgY2hhbmdlcyB0byBzaGlmdFxyXG4gICAgICogQHJldHVybnMgVGhlIHNoaWZ0ZWQgY2hhbmdlc1xyXG4gICAgICovXHJcbiAgICBQcmV0dGlmeUNoYW5nZXMoY2hhbmdlcykge1xyXG4gICAgICAgIC8vIFNoaWZ0IGFsbCB0aGUgY2hhbmdlcyBkb3duIGZpcnN0XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IChpIDwgY2hhbmdlcy5sZW5ndGggLSAxKSA/IGNoYW5nZXNbaSArIDFdLm9yaWdpbmFsU3RhcnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ubW9kaWZpZWRTdGFydCA6IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja09yaWdpbmFsID0gY2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCA8IG9yaWdpbmFsU3RvcFxyXG4gICAgICAgICAgICAgICAgJiYgY2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGggPCBtb2RpZmllZFN0b3BcclxuICAgICAgICAgICAgICAgICYmICghY2hlY2tPcmlnaW5hbCB8fCB0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpKVxyXG4gICAgICAgICAgICAgICAgJiYgKCFjaGVja01vZGlmaWVkIHx8IHRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFN0cmljdEVxdWFsID0gdGhpcy5FbGVtZW50c0FyZVN0cmljdEVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRTdHJpY3RFcXVhbCA9IHRoaXMuRWxlbWVudHNBcmVTdHJpY3RFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZFN0cmljdEVxdWFsICYmICFzdGFydFN0cmljdEVxdWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92aW5nIHRoZSBjaGFuZ2UgZG93biB3b3VsZCBjcmVhdGUgYW4gZXF1YWwgY2hhbmdlLCBidXQgdGhlIGVsZW1lbnRzIGFyZSBub3Qgc3RyaWN0IGVxdWFsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2Uub3JpZ2luYWxTdGFydCsrO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWRDaGFuZ2VBcnIgPSBbbnVsbF07XHJcbiAgICAgICAgICAgIGlmIChpIDwgY2hhbmdlcy5sZW5ndGggLSAxICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tpXSwgY2hhbmdlc1tpICsgMV0sIG1lcmdlZENoYW5nZUFycikpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXNbaV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnNwbGljZShpICsgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaGlmdCBjaGFuZ2VzIGJhY2sgdXAgdW50aWwgd2UgaGl0IGVtcHR5IG9yIHdoaXRlc3BhY2Utb25seSBsaW5lc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0b3AgPSAwO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRTdG9wID0gMDtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hhbmdlID0gY2hhbmdlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0b3AgPSBwcmV2Q2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBwcmV2Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRTdG9wID0gcHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGVja09yaWdpbmFsID0gY2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGxldCBiZXN0RGVsdGEgPSAwO1xyXG4gICAgICAgICAgICBsZXQgYmVzdFNjb3JlID0gdGhpcy5fYm91bmRhcnlTY29yZShjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGVsdGEgPSAxOzsgZGVsdGErKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IGNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0YXJ0ID0gY2hhbmdlLm1vZGlmaWVkU3RhcnQgLSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0IDwgb3JpZ2luYWxTdG9wIHx8IG1vZGlmaWVkU3RhcnQgPCBtb2RpZmllZFN0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGVja09yaWdpbmFsICYmICF0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZWQgJiYgIXRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID0gKG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsU3RvcCAmJiBtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSAoKHRvdWNoaW5nUHJldmlvdXNDaGFuZ2UgPyA1IDogMClcclxuICAgICAgICAgICAgICAgICAgICArIHRoaXMuX2JvdW5kYXJ5U2NvcmUob3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3REZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoYW5nZS5vcmlnaW5hbFN0YXJ0IC09IGJlc3REZWx0YTtcclxuICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQgLT0gYmVzdERlbHRhO1xyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWRDaGFuZ2VBcnIgPSBbbnVsbF07XHJcbiAgICAgICAgICAgIGlmIChpID4gMCAmJiB0aGlzLkNoYW5nZXNPdmVybGFwKGNoYW5nZXNbaSAtIDFdLCBjaGFuZ2VzW2ldLCBtZXJnZWRDaGFuZ2VBcnIpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2kgLSAxXSA9IG1lcmdlZENoYW5nZUFyclswXTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlcmUgY291bGQgYmUgbXVsdGlwbGUgbG9uZ2VzdCBjb21tb24gc3Vic3RyaW5ncy5cclxuICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gdGhlIG9uZXMgY29udGFpbmluZyBsb25nZXIgbGluZXNcclxuICAgICAgICBpZiAodGhpcy5faGFzU3RyaW5ncykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYUNoYW5nZSA9IGNoYW5nZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYkNoYW5nZSA9IGNoYW5nZXNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkTGVuZ3RoID0gYkNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbExlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFPcmlnaW5hbFN0YXJ0ID0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYk9yaWdpbmFsRW5kID0gYkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgYkNoYW5nZS5vcmlnaW5hbExlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFiT3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBhT3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFNb2RpZmllZFN0YXJ0ID0gYUNoYW5nZS5tb2RpZmllZFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYk1vZGlmaWVkRW5kID0gYkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgYkNoYW5nZS5tb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFiTW9kaWZpZWRMZW5ndGggPSBiTW9kaWZpZWRFbmQgLSBhTW9kaWZpZWRTdGFydDtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdhc3RpbmcgYSBsb3Qgb2YgdGltZSB3aXRoIHRoZXNlIHNlYXJjaGVzXHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZExlbmd0aCA8IDUgJiYgYWJPcmlnaW5hbExlbmd0aCA8IDIwICYmIGFiTW9kaWZpZWRMZW5ndGggPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9maW5kQmV0dGVyQ29udGlndW91c1NlcXVlbmNlKGFPcmlnaW5hbFN0YXJ0LCBhYk9yaWdpbmFsTGVuZ3RoLCBhTW9kaWZpZWRTdGFydCwgYWJNb2RpZmllZExlbmd0aCwgbWF0Y2hlZExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29yaWdpbmFsTWF0Y2hTdGFydCwgbW9kaWZpZWRNYXRjaFN0YXJ0XSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE1hdGNoU3RhcnQgIT09IGFDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGFDaGFuZ2Uub3JpZ2luYWxMZW5ndGggfHwgbW9kaWZpZWRNYXRjaFN0YXJ0ICE9PSBhQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBhQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gYW5vdGhlciBzZXF1ZW5jZSB0aGF0IGhhcyBhIGJldHRlciBzY29yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNoYW5nZS5vcmlnaW5hbExlbmd0aCA9IG9yaWdpbmFsTWF0Y2hTdGFydCAtIGFDaGFuZ2Uub3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDaGFuZ2UubW9kaWZpZWRMZW5ndGggPSBtb2RpZmllZE1hdGNoU3RhcnQgLSBhQ2hhbmdlLm1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQgPSBvcmlnaW5hbE1hdGNoU3RhcnQgKyBtYXRjaGVkTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5tb2RpZmllZFN0YXJ0ID0gbW9kaWZpZWRNYXRjaFN0YXJ0ICsgbWF0Y2hlZExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID0gYk1vZGlmaWVkRW5kIC0gYkNoYW5nZS5tb2RpZmllZFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgX2ZpbmRCZXR0ZXJDb250aWd1b3VzU2VxdWVuY2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoLCBkZXNpcmVkTGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoIDwgZGVzaXJlZExlbmd0aCB8fCBtb2RpZmllZExlbmd0aCA8IGRlc2lyZWRMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWF4ID0gb3JpZ2luYWxTdGFydCArIG9yaWdpbmFsTGVuZ3RoIC0gZGVzaXJlZExlbmd0aCArIDE7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRNYXggPSBtb2RpZmllZFN0YXJ0ICsgbW9kaWZpZWRMZW5ndGggLSBkZXNpcmVkTGVuZ3RoICsgMTtcclxuICAgICAgICBsZXQgYmVzdFNjb3JlID0gMDtcclxuICAgICAgICBsZXQgYmVzdE9yaWdpbmFsU3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBiZXN0TW9kaWZpZWRTdGFydCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9yaWdpbmFsU3RhcnQ7IGkgPCBvcmlnaW5hbE1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBtb2RpZmllZFN0YXJ0OyBqIDwgbW9kaWZpZWRNYXg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSB0aGlzLl9jb250aWd1b3VzU2VxdWVuY2VTY29yZShpLCBqLCBkZXNpcmVkTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IDAgJiYgc2NvcmUgPiBiZXN0U2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0T3JpZ2luYWxTdGFydCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vZGlmaWVkU3RhcnQgPSBqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZXN0U2NvcmUgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbYmVzdE9yaWdpbmFsU3RhcnQsIGJlc3RNb2RpZmllZFN0YXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBfY29udGlndW91c1NlcXVlbmNlU2NvcmUob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHNjb3JlID0gMDtcclxuICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQgKyBsLCBtb2RpZmllZFN0YXJ0ICsgbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNjb3JlICs9IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxTdGFydCArIGxdLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgfVxyXG4gICAgX09yaWdpbmFsSXNCb3VuZGFyeShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID49IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzICYmIC9eXFxzKiQvLnRlc3QodGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleF0pKTtcclxuICAgIH1cclxuICAgIF9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQpIHx8IHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0IC0gMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnaW5hbExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmQgPSBvcmlnaW5hbFN0YXJ0ICsgb3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxFbmQgLSAxKSB8fCB0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxFbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfTW9kaWZpZWRJc0JvdW5kYXJ5KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDw9IDAgfHwgaW5kZXggPj0gdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgJiYgL15cXHMqJC8udGVzdCh0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW2luZGV4XSkpO1xyXG4gICAgfVxyXG4gICAgX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRTdGFydCkgfHwgdGhpcy5fTW9kaWZpZWRJc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQgLSAxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGlmaWVkTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZEVuZCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZEVuZCAtIDEpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZEVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9ib3VuZGFyeVNjb3JlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2NvcmUgPSAodGhpcy5fT3JpZ2luYWxSZWdpb25Jc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoKSA/IDEgOiAwKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllZFNjb3JlID0gKHRoaXMuX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkgPyAxIDogMCk7XHJcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbFNjb3JlICsgbW9kaWZpZWRTY29yZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyB0aGUgdHdvIGlucHV0IERpZmZDaGFuZ2UgbGlzdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZ1xyXG4gICAgICogbGlzdC5cclxuICAgICAqIEBwYXJhbSBUaGUgbGVmdCBjaGFuZ2VzXHJcbiAgICAgKiBAcGFyYW0gVGhlIHJpZ2h0IGNoYW5nZXNcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgbGlzdFxyXG4gICAgICovXHJcbiAgICBDb25jYXRlbmF0ZUNoYW5nZXMobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICBjb25zdCBtZXJnZWRDaGFuZ2VBcnIgPSBbXTtcclxuICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDAgfHwgcmlnaHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocmlnaHQubGVuZ3RoID4gMCkgPyByaWdodCA6IGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuQ2hhbmdlc092ZXJsYXAobGVmdFtsZWZ0Lmxlbmd0aCAtIDFdLCByaWdodFswXSwgbWVyZ2VkQ2hhbmdlQXJyKSkge1xyXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBicmVhayB0aGUgcHJvYmxlbSBkb3duIHJlY3Vyc2l2ZWx5LCBpdCBpcyBwb3NzaWJsZSB0aGF0IHdlXHJcbiAgICAgICAgICAgIC8vIG1pZ2h0IHJlY3Vyc2UgaW4gdGhlIG1pZGRsZSBvZiBhIGNoYW5nZSB0aGVyZWJ5IHNwbGl0dGluZyBpdCBpbnRvXHJcbiAgICAgICAgICAgIC8vIHR3byBjaGFuZ2VzLiBIZXJlIGluIHRoZSBjb21iaW5pbmcgc3RhZ2UsIHdlIGRldGVjdCBhbmQgZnVzZSB0aG9zZVxyXG4gICAgICAgICAgICAvLyBjaGFuZ2VzIGJhY2sgdG9nZXRoZXJcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFtsZWZ0Lmxlbmd0aCAtIDFdID0gbWVyZ2VkQ2hhbmdlQXJyWzBdO1xyXG4gICAgICAgICAgICBNeUFycmF5LkNvcHkocmlnaHQsIDEsIHJlc3VsdCwgbGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgTXlBcnJheS5Db3B5KGxlZnQsIDAsIHJlc3VsdCwgMCwgbGVmdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBNeUFycmF5LkNvcHkocmlnaHQsIDAsIHJlc3VsdCwgbGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBjaGFuZ2VzIG92ZXJsYXAgYW5kIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZVxyXG4gICAgICogY2hhbmdlXHJcbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjaGFuZ2VcclxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgY2hhbmdlXHJcbiAgICAgKiBAcGFyYW0gbWVyZ2VkQ2hhbmdlIFRoZSBtZXJnZWQgY2hhbmdlIGlmIHRoZSB0d28gb3ZlcmxhcCwgbnVsbCBvdGhlcndpc2VcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHR3byBjaGFuZ2VzIG92ZXJsYXBcclxuICAgICAqL1xyXG4gICAgQ2hhbmdlc092ZXJsYXAobGVmdCwgcmlnaHQsIG1lcmdlZENoYW5nZUFycikge1xyXG4gICAgICAgIERlYnVnLkFzc2VydChsZWZ0Lm9yaWdpbmFsU3RhcnQgPD0gcmlnaHQub3JpZ2luYWxTdGFydCwgJ0xlZnQgY2hhbmdlIGlzIG5vdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gcmlnaHQgY2hhbmdlJyk7XHJcbiAgICAgICAgRGVidWcuQXNzZXJ0KGxlZnQubW9kaWZpZWRTdGFydCA8PSByaWdodC5tb2RpZmllZFN0YXJ0LCAnTGVmdCBjaGFuZ2UgaXMgbm90IGxlc3MgdGhhbiBvciBlcXVhbCB0byByaWdodCBjaGFuZ2UnKTtcclxuICAgICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0IHx8IGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXJ0ID0gbGVmdC5vcmlnaW5hbFN0YXJ0O1xyXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxMZW5ndGggPSBsZWZ0Lm9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0YXJ0ID0gbGVmdC5tb2RpZmllZFN0YXJ0O1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRMZW5ndGggPSBsZWZ0Lm1vZGlmaWVkTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExlbmd0aCA9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQgKyByaWdodC5vcmlnaW5hbExlbmd0aCAtIGxlZnQub3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVmdC5tb2RpZmllZFN0YXJ0ICsgbGVmdC5tb2RpZmllZExlbmd0aCA+PSByaWdodC5tb2RpZmllZFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZExlbmd0aCA9IHJpZ2h0Lm1vZGlmaWVkU3RhcnQgKyByaWdodC5tb2RpZmllZExlbmd0aCAtIGxlZnQubW9kaWZpZWRTdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXJnZWRDaGFuZ2VBcnJbMF0gPSBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lcmdlZENoYW5nZUFyclswXSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBtZXRob2QgdXNlZCB0byBjbGlwIGEgZGlhZ29uYWwgaW5kZXggdG8gdGhlIHJhbmdlIG9mIHZhbGlkXHJcbiAgICAgKiBkaWFnb25hbHMuIFRoaXMgYWxzbyBkZWNpZGVzIHdoZXRoZXIgb3Igbm90IHRoZSBkaWFnb25hbCBpbmRleCxcclxuICAgICAqIGlmIGl0IGV4Y2VlZHMgdGhlIGJvdW5kYXJ5LCBzaG91bGQgYmUgY2xpcHBlZCB0byB0aGUgYm91bmRhcnkgb3IgY2xpcHBlZFxyXG4gICAgICogb25lIGluc2lkZSB0aGUgYm91bmRhcnkgZGVwZW5kaW5nIG9uIHRoZSBFdmVuL09kZCBzdGF0dXMgb2YgdGhlIGJvdW5kYXJ5XHJcbiAgICAgKiBhbmQgbnVtRGlmZmVyZW5jZXMuXHJcbiAgICAgKiBAcGFyYW0gZGlhZ29uYWwgVGhlIGluZGV4IG9mIHRoZSBkaWFnb25hbCB0byBjbGlwLlxyXG4gICAgICogQHBhcmFtIG51bURpZmZlcmVuY2VzIFRoZSBjdXJyZW50IG51bWJlciBvZiBkaWZmZXJlbmNlcyBiZWluZyBpdGVyYXRlZCB1cG9uLlxyXG4gICAgICogQHBhcmFtIGRpYWdvbmFsQmFzZUluZGV4IFRoZSBiYXNlIHJlZmVyZW5jZSBkaWFnb25hbC5cclxuICAgICAqIEBwYXJhbSBudW1EaWFnb25hbHMgVGhlIHRvdGFsIG51bWJlciBvZiBkaWFnb25hbHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2xpcHBlZCBkaWFnb25hbCBpbmRleC5cclxuICAgICAqL1xyXG4gICAgQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWwsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEJhc2VJbmRleCwgbnVtRGlhZ29uYWxzKSB7XHJcbiAgICAgICAgaWYgKGRpYWdvbmFsID49IDAgJiYgZGlhZ29uYWwgPCBudW1EaWFnb25hbHMpIHtcclxuICAgICAgICAgICAgLy8gTm90aGluZyB0byBjbGlwLCBpdHMgaW4gcmFuZ2VcclxuICAgICAgICAgICAgcmV0dXJuIGRpYWdvbmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaWFnb25hbHNCZWxvdzogVGhlIG51bWJlciBvZiBkaWFnb25hbHMgYmVsb3cgdGhlIHJlZmVyZW5jZSBkaWFnb25hbFxyXG4gICAgICAgIC8vIGRpYWdvbmFsc0Fib3ZlOiBUaGUgbnVtYmVyIG9mIGRpYWdvbmFscyBhYm92ZSB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsXHJcbiAgICAgICAgY29uc3QgZGlhZ29uYWxzQmVsb3cgPSBkaWFnb25hbEJhc2VJbmRleDtcclxuICAgICAgICBjb25zdCBkaWFnb25hbHNBYm92ZSA9IG51bURpYWdvbmFscyAtIGRpYWdvbmFsQmFzZUluZGV4IC0gMTtcclxuICAgICAgICBjb25zdCBkaWZmRXZlbiA9IChudW1EaWZmZXJlbmNlcyAlIDIgPT09IDApO1xyXG4gICAgICAgIGlmIChkaWFnb25hbCA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZEV2ZW4gPSAoZGlhZ29uYWxzQmVsb3cgJSAyID09PSAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIChkaWZmRXZlbiA9PT0gbG93ZXJCb3VuZEV2ZW4pID8gMCA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRXZlbiA9IChkaWFnb25hbHNBYm92ZSAlIDIgPT09IDApO1xyXG4gICAgICAgICAgICByZXR1cm4gKGRpZmZFdmVuID09PSB1cHBlckJvdW5kRXZlbikgPyBudW1EaWFnb25hbHMgLSAxIDogbnVtRGlhZ29uYWxzIC0gMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiffChange: () => (/* binding */ DiffChange)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * Represents information about a specific difference between two sequences.\r\n */\r\nclass DiffChange {\r\n    /**\r\n     * Constructs a new DiffChange with the given sequence information\r\n     * and content.\r\n     */\r\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\r\n        this.originalStart = originalStart;\r\n        this.originalLength = originalLength;\r\n        this.modifiedStart = modifiedStart;\r\n        this.modifiedLength = modifiedLength;\r\n    }\r\n    /**\r\n     * The end point (exclusive) of the change in the original sequence.\r\n     */\r\n    getOriginalEnd() {\r\n        return this.originalStart + this.originalLength;\r\n    }\r\n    /**\r\n     * The end point (exclusive) of the change in the modified sequence.\r\n     */\r\n    getModifiedEnd() {\r\n        return this.modifiedStart + this.modifiedLength;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmQ2hhbmdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZkNoYW5nZS5qcz8xNWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gc2VxdWVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERpZmZDaGFuZ2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IERpZmZDaGFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gc2VxdWVuY2UgaW5mb3JtYXRpb25cclxuICAgICAqIGFuZCBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcclxuICAgICAgICAvL0RlYnVnLkFzc2VydChvcmlnaW5hbExlbmd0aCA+IDAgfHwgbW9kaWZpZWRMZW5ndGggPiAwLCBcIm9yaWdpbmFsTGVuZ3RoIGFuZCBtb2RpZmllZExlbmd0aCBjYW5ub3QgYm90aCBiZSA8PSAwXCIpO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydCA9IG9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbExlbmd0aCA9IG9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydCA9IG1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZExlbmd0aCA9IG1vZGlmaWVkTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5kIHBvaW50IChleGNsdXNpdmUpIG9mIHRoZSBjaGFuZ2UgaW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXRPcmlnaW5hbEVuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFN0YXJ0ICsgdGhpcy5vcmlnaW5hbExlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGVuZCBwb2ludCAoZXhjbHVzaXZlKSBvZiB0aGUgY2hhbmdlIGluIHRoZSBtb2RpZmllZCBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0TW9kaWZpZWRFbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZpZWRTdGFydCArIHRoaXMubW9kaWZpZWRMZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/errors.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BugIndicatingError: () => (/* binding */ BugIndicatingError),\n/* harmony export */   CancellationError: () => (/* binding */ CancellationError),\n/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler),\n/* harmony export */   ErrorNoTelemetry: () => (/* binding */ ErrorNoTelemetry),\n/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),\n/* harmony export */   canceled: () => (/* binding */ canceled),\n/* harmony export */   errorHandler: () => (/* binding */ errorHandler),\n/* harmony export */   illegalArgument: () => (/* binding */ illegalArgument),\n/* harmony export */   illegalState: () => (/* binding */ illegalState),\n/* harmony export */   isCancellationError: () => (/* binding */ isCancellationError),\n/* harmony export */   onUnexpectedError: () => (/* binding */ onUnexpectedError),\n/* harmony export */   onUnexpectedExternalError: () => (/* binding */ onUnexpectedExternalError),\n/* harmony export */   transformErrorForSerialization: () => (/* binding */ transformErrorForSerialization)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\r\nclass ErrorHandler {\r\n    constructor() {\r\n        this.listeners = [];\r\n        this.unexpectedErrorHandler = function (e) {\r\n            setTimeout(() => {\r\n                if (e.stack) {\r\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\r\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\r\n                    }\r\n                    throw new Error(e.message + '\\n\\n' + e.stack);\r\n                }\r\n                throw e;\r\n            }, 0);\r\n        };\r\n    }\r\n    emit(e) {\r\n        this.listeners.forEach((listener) => {\r\n            listener(e);\r\n        });\r\n    }\r\n    onUnexpectedError(e) {\r\n        this.unexpectedErrorHandler(e);\r\n        this.emit(e);\r\n    }\r\n    // For external errors, we don't want the listeners to be called\r\n    onUnexpectedExternalError(e) {\r\n        this.unexpectedErrorHandler(e);\r\n    }\r\n}\r\nconst errorHandler = new ErrorHandler();\r\nfunction onUnexpectedError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isCancellationError(e)) {\r\n        errorHandler.onUnexpectedError(e);\r\n    }\r\n    return undefined;\r\n}\r\nfunction onUnexpectedExternalError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isCancellationError(e)) {\r\n        errorHandler.onUnexpectedExternalError(e);\r\n    }\r\n    return undefined;\r\n}\r\nfunction transformErrorForSerialization(error) {\r\n    if (error instanceof Error) {\r\n        const { name, message } = error;\r\n        const stack = error.stacktrace || error.stack;\r\n        return {\r\n            $isError: true,\r\n            name,\r\n            message,\r\n            stack,\r\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\r\n        };\r\n    }\r\n    // return as is\r\n    return error;\r\n}\r\nconst canceledName = 'Canceled';\r\n/**\r\n * Checks if the given error is a promise in canceled state\r\n */\r\nfunction isCancellationError(error) {\r\n    if (error instanceof CancellationError) {\r\n        return true;\r\n    }\r\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\r\n}\r\n// !!!IMPORTANT!!!\r\n// Do NOT change this class because it is also used as an API-type.\r\nclass CancellationError extends Error {\r\n    constructor() {\r\n        super(canceledName);\r\n        this.name = this.message;\r\n    }\r\n}\r\n/**\r\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\r\n */\r\nfunction canceled() {\r\n    const error = new Error(canceledName);\r\n    error.name = error.message;\r\n    return error;\r\n}\r\nfunction illegalArgument(name) {\r\n    if (name) {\r\n        return new Error(`Illegal argument: ${name}`);\r\n    }\r\n    else {\r\n        return new Error('Illegal argument');\r\n    }\r\n}\r\nfunction illegalState(name) {\r\n    if (name) {\r\n        return new Error(`Illegal state: ${name}`);\r\n    }\r\n    else {\r\n        return new Error('Illegal state');\r\n    }\r\n}\r\nclass NotSupportedError extends Error {\r\n    constructor(message) {\r\n        super('NotSupported');\r\n        if (message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Error that when thrown won't be logged in telemetry as an unhandled error.\r\n */\r\nclass ErrorNoTelemetry extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        this.name = 'CodeExpectedError';\r\n    }\r\n    static fromError(err) {\r\n        if (err instanceof ErrorNoTelemetry) {\r\n            return err;\r\n        }\r\n        const result = new ErrorNoTelemetry();\r\n        result.message = err.message;\r\n        result.stack = err.stack;\r\n        return result;\r\n    }\r\n    static isErrorNoTelemetry(err) {\r\n        return err.name === 'CodeExpectedError';\r\n    }\r\n}\r\n/**\r\n * This error indicates a bug.\r\n * Do not throw this for invalid user input.\r\n * Only catch this error to recover gracefully from bugs.\r\n */\r\nclass BugIndicatingError extends Error {\r\n    constructor(message) {\r\n        super(message || 'An unexpected bug occurred.');\r\n        Object.setPrototypeOf(this, BugIndicatingError.prototype);\r\n        // Because we know for sure only buggy code throws this,\r\n        // we definitely want to break here and fix the bug.\r\n        // eslint-disable-next-line no-debugger\r\n        // debugger;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXJyb3JzLmpzP2ZkY2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgb24gRXZlbnRFbWl0dGVyIGJ5IGltcGxlbWVudGluZyBhIHN1YnNldCBvZiB0aGUgaW50ZXJmYWNlLlxyXG5leHBvcnQgY2xhc3MgRXJyb3JIYW5kbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdGFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChFcnJvck5vVGVsZW1ldHJ5LmlzRXJyb3JOb1RlbGVtZXRyeShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JOb1RlbGVtZXRyeShlLm1lc3NhZ2UgKyAnXFxuXFxuJyArIGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlICsgJ1xcblxcbicgKyBlLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbWl0KGUpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcclxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWRFcnJvckhhbmRsZXIoZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KGUpO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIGV4dGVybmFsIGVycm9ycywgd2UgZG9uJ3Qgd2FudCB0aGUgbGlzdGVuZXJzIHRvIGJlIGNhbGxlZFxyXG4gICAgb25VbmV4cGVjdGVkRXh0ZXJuYWxFcnJvcihlKSB7XHJcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyKGUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBlcnJvckhhbmRsZXIgPSBuZXcgRXJyb3JIYW5kbGVyKCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBvblVuZXhwZWN0ZWRFcnJvcihlKSB7XHJcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXHJcbiAgICBpZiAoIWlzQ2FuY2VsbGF0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICBlcnJvckhhbmRsZXIub25VbmV4cGVjdGVkRXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcclxuICAgIC8vIGlnbm9yZSBlcnJvcnMgZnJvbSBjYW5jZWxsZWQgcHJvbWlzZXNcclxuICAgIGlmICghaXNDYW5jZWxsYXRpb25FcnJvcihlKSkge1xyXG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgbWVzc2FnZSB9ID0gZXJyb3I7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBlcnJvci5zdGFja3RyYWNlIHx8IGVycm9yLnN0YWNrO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICRpc0Vycm9yOiB0cnVlLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICBzdGFjayxcclxuICAgICAgICAgICAgbm9UZWxlbWV0cnk6IEVycm9yTm9UZWxlbWV0cnkuaXNFcnJvck5vVGVsZW1ldHJ5KGVycm9yKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gYXMgaXNcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBjYW5jZWxlZE5hbWUgPSAnQ2FuY2VsZWQnO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhIHByb21pc2UgaW4gY2FuY2VsZWQgc3RhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0NhbmNlbGxhdGlvbkVycm9yKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxsYXRpb25FcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gY2FuY2VsZWROYW1lICYmIGVycm9yLm1lc3NhZ2UgPT09IGNhbmNlbGVkTmFtZTtcclxufVxyXG4vLyAhISFJTVBPUlRBTlQhISFcclxuLy8gRG8gTk9UIGNoYW5nZSB0aGlzIGNsYXNzIGJlY2F1c2UgaXQgaXMgYWxzbyB1c2VkIGFzIGFuIEFQSS10eXBlLlxyXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihjYW5jZWxlZE5hbWUpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMubWVzc2FnZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBDYW5jZWxsYXRpb25FcnJvciBgbmV3IENhbmNlbGxhdGlvbkVycm9yKClgfSBpbnN0ZWFkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsZWQoKSB7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjYW5jZWxlZE5hbWUpO1xyXG4gICAgZXJyb3IubmFtZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlsbGVnYWxBcmd1bWVudChuYW1lKSB7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYElsbGVnYWwgYXJndW1lbnQ6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaWxsZWdhbFN0YXRlKG5hbWUpIHtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSWxsZWdhbCBzdGF0ZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSWxsZWdhbCBzdGF0ZScpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcignTm90U3VwcG9ydGVkJyk7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEVycm9yIHRoYXQgd2hlbiB0aHJvd24gd29uJ3QgYmUgbG9nZ2VkIGluIHRlbGVtZXRyeSBhcyBhbiB1bmhhbmRsZWQgZXJyb3IuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXJyb3JOb1RlbGVtZXRyeSBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1zZykge1xyXG4gICAgICAgIHN1cGVyKG1zZyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvZGVFeHBlY3RlZEVycm9yJztcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tRXJyb3IoZXJyKSB7XHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yTm9UZWxlbWV0cnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVycm9yTm9UZWxlbWV0cnkoKTtcclxuICAgICAgICByZXN1bHQubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xyXG4gICAgICAgIHJlc3VsdC5zdGFjayA9IGVyci5zdGFjaztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzRXJyb3JOb1RlbGVtZXRyeShlcnIpIHtcclxuICAgICAgICByZXR1cm4gZXJyLm5hbWUgPT09ICdDb2RlRXhwZWN0ZWRFcnJvcic7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZXJyb3IgaW5kaWNhdGVzIGEgYnVnLlxyXG4gKiBEbyBub3QgdGhyb3cgdGhpcyBmb3IgaW52YWxpZCB1c2VyIGlucHV0LlxyXG4gKiBPbmx5IGNhdGNoIHRoaXMgZXJyb3IgdG8gcmVjb3ZlciBncmFjZWZ1bGx5IGZyb20gYnVncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCdWdJbmRpY2F0aW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSB8fCAnQW4gdW5leHBlY3RlZCBidWcgb2NjdXJyZWQuJyk7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEJ1Z0luZGljYXRpbmdFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIC8vIEJlY2F1c2Ugd2Uga25vdyBmb3Igc3VyZSBvbmx5IGJ1Z2d5IGNvZGUgdGhyb3dzIHRoaXMsXHJcbiAgICAgICAgLy8gd2UgZGVmaW5pdGVseSB3YW50IHRvIGJyZWFrIGhlcmUgYW5kIGZpeCB0aGUgYnVnLlxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxyXG4gICAgICAgIC8vIGRlYnVnZ2VyO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/errors.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/event.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/event.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DebounceEmitter: () => (/* binding */ DebounceEmitter),\n/* harmony export */   Emitter: () => (/* binding */ Emitter),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   EventBufferer: () => (/* binding */ EventBufferer),\n/* harmony export */   EventMultiplexer: () => (/* binding */ EventMultiplexer),\n/* harmony export */   EventProfiling: () => (/* binding */ EventProfiling),\n/* harmony export */   ListenerLeakError: () => (/* binding */ ListenerLeakError),\n/* harmony export */   ListenerRefusalError: () => (/* binding */ ListenerRefusalError),\n/* harmony export */   MicrotaskEmitter: () => (/* binding */ MicrotaskEmitter),\n/* harmony export */   PauseableEmitter: () => (/* binding */ PauseableEmitter),\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   createEventDeliveryQueue: () => (/* binding */ createEventDeliveryQueue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional.js */ \"./node_modules/monaco-editor/esm/vs/base/common/functional.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _linkedList_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./linkedList.js */ \"./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\");\n/* harmony import */ var _stopwatch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stopwatch.js */ \"./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\");\n\r\n\r\n\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------------\r\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\r\n// -----------------------------------------------------------------------------------------------------------------------\r\nconst _enableListenerGCedWarning = false;\r\n// -----------------------------------------------------------------------------------------------------------------------\r\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\r\n// -----------------------------------------------------------------------------------------------------------------------\r\nconst _enableDisposeWithListenerWarning = false;\r\n// -----------------------------------------------------------------------------------------------------------------------\r\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\r\n// See https://github.com/microsoft/vscode/issues/142851\r\n// -----------------------------------------------------------------------------------------------------------------------\r\nconst _enableSnapshotPotentialLeakWarning = false;\r\nvar Event;\r\n(function (Event) {\r\n    Event.None = () => _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;\r\n    function _addLeakageTraceLogic(options) {\r\n        if (_enableSnapshotPotentialLeakWarning) {\r\n            const { onDidAddListener: origListenerDidAdd } = options;\r\n            const stack = Stacktrace.create();\r\n            let count = 0;\r\n            options.onDidAddListener = () => {\r\n                if (++count === 2) {\r\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\r\n                    stack.print();\r\n                }\r\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\r\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\r\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\r\n     * non-deferred events.\r\n     *\r\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\r\n     * (eg. latency of keypress to text rendered).\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     *\r\n     * @param event The event source for the new event.\r\n     * @param disposable A disposable store to add the new EventEmitter to.\r\n     */\r\n    function defer(event, disposable) {\r\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\r\n    }\r\n    Event.defer = defer;\r\n    /**\r\n     * Given an event, returns another event which only fires once.\r\n     *\r\n     * @param event The event source for the new event.\r\n     */\r\n    function once(event) {\r\n        return (listener, thisArgs = null, disposables) => {\r\n            // we need this, in case the event fires during the listener call\r\n            let didFire = false;\r\n            let result = undefined;\r\n            result = event(e => {\r\n                if (didFire) {\r\n                    return;\r\n                }\r\n                else if (result) {\r\n                    result.dispose();\r\n                }\r\n                else {\r\n                    didFire = true;\r\n                }\r\n                return listener.call(thisArgs, e);\r\n            }, null, disposables);\r\n            if (didFire) {\r\n                result.dispose();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    Event.once = once;\r\n    /**\r\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\r\n     * `Array.prototype.map` works.\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     *\r\n     * @param event The event source for the new event.\r\n     * @param map The mapping function.\r\n     * @param disposable A disposable store to add the new EventEmitter to.\r\n     */\r\n    function map(event, map, disposable) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\r\n    }\r\n    Event.map = map;\r\n    /**\r\n     * Wraps an event in another event that performs some function on the event object before firing.\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     *\r\n     * @param event The event source for the new event.\r\n     * @param each The function to perform on the event object.\r\n     * @param disposable A disposable store to add the new EventEmitter to.\r\n     */\r\n    function forEach(event, each, disposable) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\r\n    }\r\n    Event.forEach = forEach;\r\n    function filter(event, filter, disposable) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\r\n    }\r\n    Event.filter = filter;\r\n    /**\r\n     * Given an event, returns the same event but typed as `Event<void>`.\r\n     */\r\n    function signal(event) {\r\n        return event;\r\n    }\r\n    Event.signal = signal;\r\n    function any(...events) {\r\n        return (listener, thisArgs = null, disposables) => {\r\n            const disposable = (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e))));\r\n            return addAndReturnDisposable(disposable, disposables);\r\n        };\r\n    }\r\n    Event.any = any;\r\n    /**\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     */\r\n    function reduce(event, merge, initial, disposable) {\r\n        let output = initial;\r\n        return map(event, e => {\r\n            output = merge(output, e);\r\n            return output;\r\n        }, disposable);\r\n    }\r\n    Event.reduce = reduce;\r\n    function snapshot(event, disposable) {\r\n        let listener;\r\n        const options = {\r\n            onWillAddFirstListener() {\r\n                listener = event(emitter.fire, emitter);\r\n            },\r\n            onDidRemoveLastListener() {\r\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\r\n            }\r\n        };\r\n        if (!disposable) {\r\n            _addLeakageTraceLogic(options);\r\n        }\r\n        const emitter = new Emitter(options);\r\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\r\n        return emitter.event;\r\n    }\r\n    /**\r\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\r\n     * Event function implementation.\r\n     */\r\n    function addAndReturnDisposable(d, store) {\r\n        if (store instanceof Array) {\r\n            store.push(d);\r\n        }\r\n        else if (store) {\r\n            store.add(d);\r\n        }\r\n        return d;\r\n    }\r\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\r\n        let subscription;\r\n        let output = undefined;\r\n        let handle = undefined;\r\n        let numDebouncedCalls = 0;\r\n        let doFire;\r\n        const options = {\r\n            leakWarningThreshold,\r\n            onWillAddFirstListener() {\r\n                subscription = event(cur => {\r\n                    numDebouncedCalls++;\r\n                    output = merge(output, cur);\r\n                    if (leading && !handle) {\r\n                        emitter.fire(output);\r\n                        output = undefined;\r\n                    }\r\n                    doFire = () => {\r\n                        const _output = output;\r\n                        output = undefined;\r\n                        handle = undefined;\r\n                        if (!leading || numDebouncedCalls > 1) {\r\n                            emitter.fire(_output);\r\n                        }\r\n                        numDebouncedCalls = 0;\r\n                    };\r\n                    if (typeof delay === 'number') {\r\n                        clearTimeout(handle);\r\n                        handle = setTimeout(doFire, delay);\r\n                    }\r\n                    else {\r\n                        if (handle === undefined) {\r\n                            handle = 0;\r\n                            queueMicrotask(doFire);\r\n                        }\r\n                    }\r\n                });\r\n            },\r\n            onWillRemoveListener() {\r\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\r\n                    doFire === null || doFire === void 0 ? void 0 : doFire();\r\n                }\r\n            },\r\n            onDidRemoveLastListener() {\r\n                doFire = undefined;\r\n                subscription.dispose();\r\n            }\r\n        };\r\n        if (!disposable) {\r\n            _addLeakageTraceLogic(options);\r\n        }\r\n        const emitter = new Emitter(options);\r\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\r\n        return emitter.event;\r\n    }\r\n    Event.debounce = debounce;\r\n    /**\r\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     */\r\n    function accumulate(event, delay = 0, disposable) {\r\n        return Event.debounce(event, (last, e) => {\r\n            if (!last) {\r\n                return [e];\r\n            }\r\n            last.push(e);\r\n            return last;\r\n        }, delay, undefined, true, undefined, disposable);\r\n    }\r\n    Event.accumulate = accumulate;\r\n    /**\r\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\r\n     * event objects from different sources do not fire the same event object.\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     *\r\n     * @param event The event source for the new event.\r\n     * @param equals The equality condition.\r\n     * @param disposable A disposable store to add the new EventEmitter to.\r\n     *\r\n     * @example\r\n     * ```\r\n     * // Fire only one time when a single window is opened or focused\r\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\r\n     * ```\r\n     */\r\n    function latch(event, equals = (a, b) => a === b, disposable) {\r\n        let firstCall = true;\r\n        let cache;\r\n        return filter(event, value => {\r\n            const shouldEmit = firstCall || !equals(value, cache);\r\n            firstCall = false;\r\n            cache = value;\r\n            return shouldEmit;\r\n        }, disposable);\r\n    }\r\n    Event.latch = latch;\r\n    /**\r\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     *\r\n     * @example\r\n     * ```\r\n     * const event = new EventEmitter<number | undefined>().event;\r\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\r\n     * ```\r\n     *\r\n     * @param event The event source for the new event.\r\n     * @param isT A function that determines what event is of the first type.\r\n     * @param disposable A disposable store to add the new EventEmitter to.\r\n     */\r\n    function split(event, isT, disposable) {\r\n        return [\r\n            Event.filter(event, isT, disposable),\r\n            Event.filter(event, e => !isT(e), disposable),\r\n        ];\r\n    }\r\n    Event.split = split;\r\n    /**\r\n     * Buffers an event until it has a listener attached.\r\n     *\r\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\r\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\r\n     * returned event causes this utility to leak a listener on the original event.\r\n     *\r\n     * @param event The event source for the new event.\r\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\r\n     * `setTimeout` when the first event listener is added.\r\n     * @param _buffer Internal: A source event array used for tests.\r\n     *\r\n     * @example\r\n     * ```\r\n     * // Start accumulating events, when the first listener is attached, flush\r\n     * // the event after a timeout such that multiple listeners attached before\r\n     * // the timeout would receive the event\r\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\r\n     * ```\r\n     */\r\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\r\n        let buffer = _buffer.slice();\r\n        let listener = event(e => {\r\n            if (buffer) {\r\n                buffer.push(e);\r\n            }\r\n            else {\r\n                emitter.fire(e);\r\n            }\r\n        });\r\n        if (disposable) {\r\n            disposable.add(listener);\r\n        }\r\n        const flush = () => {\r\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\r\n            buffer = null;\r\n        };\r\n        const emitter = new Emitter({\r\n            onWillAddFirstListener() {\r\n                if (!listener) {\r\n                    listener = event(e => emitter.fire(e));\r\n                    if (disposable) {\r\n                        disposable.add(listener);\r\n                    }\r\n                }\r\n            },\r\n            onDidAddFirstListener() {\r\n                if (buffer) {\r\n                    if (flushAfterTimeout) {\r\n                        setTimeout(flush);\r\n                    }\r\n                    else {\r\n                        flush();\r\n                    }\r\n                }\r\n            },\r\n            onDidRemoveLastListener() {\r\n                if (listener) {\r\n                    listener.dispose();\r\n                }\r\n                listener = null;\r\n            }\r\n        });\r\n        if (disposable) {\r\n            disposable.add(emitter);\r\n        }\r\n        return emitter.event;\r\n    }\r\n    Event.buffer = buffer;\r\n    /**\r\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\r\n     *\r\n     * @example\r\n     * ```\r\n     * // Normal\r\n     * const onEnterPressNormal = Event.filter(\r\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\r\n     *   e.keyCode === KeyCode.Enter\r\n     * ).event;\r\n     *\r\n     * // Using chain\r\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\r\n     *   .map(e => new StandardKeyboardEvent(e))\r\n     *   .filter(e => e.keyCode === KeyCode.Enter)\r\n     * );\r\n     * ```\r\n     */\r\n    function chain(event, sythensize) {\r\n        const fn = (listener, thisArgs, disposables) => {\r\n            const cs = sythensize(new ChainableSynthesis());\r\n            return event(function (value) {\r\n                const result = cs.evaluate(value);\r\n                if (result !== HaltChainable) {\r\n                    listener.call(thisArgs, result);\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n        return fn;\r\n    }\r\n    Event.chain = chain;\r\n    const HaltChainable = Symbol('HaltChainable');\r\n    class ChainableSynthesis {\r\n        constructor() {\r\n            this.steps = [];\r\n        }\r\n        map(fn) {\r\n            this.steps.push(fn);\r\n            return this;\r\n        }\r\n        forEach(fn) {\r\n            this.steps.push(v => {\r\n                fn(v);\r\n                return v;\r\n            });\r\n            return this;\r\n        }\r\n        filter(fn) {\r\n            this.steps.push(v => fn(v) ? v : HaltChainable);\r\n            return this;\r\n        }\r\n        reduce(merge, initial) {\r\n            let last = initial;\r\n            this.steps.push(v => {\r\n                last = merge(last, v);\r\n                return last;\r\n            });\r\n            return this;\r\n        }\r\n        latch(equals = (a, b) => a === b) {\r\n            let firstCall = true;\r\n            let cache;\r\n            this.steps.push(value => {\r\n                const shouldEmit = firstCall || !equals(value, cache);\r\n                firstCall = false;\r\n                cache = value;\r\n                return shouldEmit ? value : HaltChainable;\r\n            });\r\n            return this;\r\n        }\r\n        evaluate(value) {\r\n            for (const step of this.steps) {\r\n                value = step(value);\r\n                if (value === HaltChainable) {\r\n                    break;\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n    }\r\n    /**\r\n     * Creates an {@link Event} from a node event emitter.\r\n     */\r\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\r\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\r\n    /**\r\n     * Creates an {@link Event} from a DOM event emitter.\r\n     */\r\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\r\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\r\n    /**\r\n     * Creates a promise out of an event, using the {@link Event.once} helper.\r\n     */\r\n    function toPromise(event) {\r\n        return new Promise(resolve => once(event)(resolve));\r\n    }\r\n    Event.toPromise = toPromise;\r\n    /**\r\n     * Creates an event out of a promise that fires once when the promise is\r\n     * resolved with the result of the promise or `undefined`.\r\n     */\r\n    function fromPromise(promise) {\r\n        const result = new Emitter();\r\n        promise.then(res => {\r\n            result.fire(res);\r\n        }, () => {\r\n            result.fire(undefined);\r\n        }).finally(() => {\r\n            result.dispose();\r\n        });\r\n        return result.event;\r\n    }\r\n    Event.fromPromise = fromPromise;\r\n    function runAndSubscribe(event, handler, initial) {\r\n        handler(initial);\r\n        return event(e => handler(e));\r\n    }\r\n    Event.runAndSubscribe = runAndSubscribe;\r\n    class EmitterObserver {\r\n        constructor(_observable, store) {\r\n            this._observable = _observable;\r\n            this._counter = 0;\r\n            this._hasChanged = false;\r\n            const options = {\r\n                onWillAddFirstListener: () => {\r\n                    _observable.addObserver(this);\r\n                },\r\n                onDidRemoveLastListener: () => {\r\n                    _observable.removeObserver(this);\r\n                }\r\n            };\r\n            if (!store) {\r\n                _addLeakageTraceLogic(options);\r\n            }\r\n            this.emitter = new Emitter(options);\r\n            if (store) {\r\n                store.add(this.emitter);\r\n            }\r\n        }\r\n        beginUpdate(_observable) {\r\n            // assert(_observable === this.obs);\r\n            this._counter++;\r\n        }\r\n        handlePossibleChange(_observable) {\r\n            // assert(_observable === this.obs);\r\n        }\r\n        handleChange(_observable, _change) {\r\n            // assert(_observable === this.obs);\r\n            this._hasChanged = true;\r\n        }\r\n        endUpdate(_observable) {\r\n            // assert(_observable === this.obs);\r\n            this._counter--;\r\n            if (this._counter === 0) {\r\n                this._observable.reportChanges();\r\n                if (this._hasChanged) {\r\n                    this._hasChanged = false;\r\n                    this.emitter.fire(this._observable.get());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates an event emitter that is fired when the observable changes.\r\n     * Each listeners subscribes to the emitter.\r\n     */\r\n    function fromObservable(obs, store) {\r\n        const observer = new EmitterObserver(obs, store);\r\n        return observer.emitter.event;\r\n    }\r\n    Event.fromObservable = fromObservable;\r\n    /**\r\n     * Each listener is attached to the observable directly.\r\n     */\r\n    function fromObservableLight(observable) {\r\n        return (listener, thisArgs, disposables) => {\r\n            let count = 0;\r\n            let didChange = false;\r\n            const observer = {\r\n                beginUpdate() {\r\n                    count++;\r\n                },\r\n                endUpdate() {\r\n                    count--;\r\n                    if (count === 0) {\r\n                        observable.reportChanges();\r\n                        if (didChange) {\r\n                            didChange = false;\r\n                            listener.call(thisArgs);\r\n                        }\r\n                    }\r\n                },\r\n                handlePossibleChange() {\r\n                    // noop\r\n                },\r\n                handleChange() {\r\n                    didChange = true;\r\n                }\r\n            };\r\n            observable.addObserver(observer);\r\n            observable.reportChanges();\r\n            const disposable = {\r\n                dispose() {\r\n                    observable.removeObserver(observer);\r\n                }\r\n            };\r\n            if (disposables instanceof _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore) {\r\n                disposables.add(disposable);\r\n            }\r\n            else if (Array.isArray(disposables)) {\r\n                disposables.push(disposable);\r\n            }\r\n            return disposable;\r\n        };\r\n    }\r\n    Event.fromObservableLight = fromObservableLight;\r\n})(Event || (Event = {}));\r\nclass EventProfiling {\r\n    constructor(name) {\r\n        this.listenerCount = 0;\r\n        this.invocationCount = 0;\r\n        this.elapsedOverall = 0;\r\n        this.durations = [];\r\n        this.name = `${name}_${EventProfiling._idPool++}`;\r\n        EventProfiling.all.add(this);\r\n    }\r\n    start(listenerCount) {\r\n        this._stopWatch = new _stopwatch_js__WEBPACK_IMPORTED_MODULE_4__.StopWatch();\r\n        this.listenerCount = listenerCount;\r\n    }\r\n    stop() {\r\n        if (this._stopWatch) {\r\n            const elapsed = this._stopWatch.elapsed();\r\n            this.durations.push(elapsed);\r\n            this.elapsedOverall += elapsed;\r\n            this.invocationCount += 1;\r\n            this._stopWatch = undefined;\r\n        }\r\n    }\r\n}\r\nEventProfiling.all = new Set();\r\nEventProfiling._idPool = 0;\r\nlet _globalLeakWarningThreshold = -1;\r\nclass LeakageMonitor {\r\n    constructor(_errorHandler, threshold, name = Math.random().toString(18).slice(2, 5)) {\r\n        this._errorHandler = _errorHandler;\r\n        this.threshold = threshold;\r\n        this.name = name;\r\n        this._warnCountdown = 0;\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\r\n    }\r\n    check(stack, listenerCount) {\r\n        const threshold = this.threshold;\r\n        if (threshold <= 0 || listenerCount < threshold) {\r\n            return undefined;\r\n        }\r\n        if (!this._stacks) {\r\n            this._stacks = new Map();\r\n        }\r\n        const count = (this._stacks.get(stack.value) || 0);\r\n        this._stacks.set(stack.value, count + 1);\r\n        this._warnCountdown -= 1;\r\n        if (this._warnCountdown <= 0) {\r\n            // only warn on first exceed and then every time the limit\r\n            // is exceeded by 50% again\r\n            this._warnCountdown = threshold * 0.5;\r\n            const [topStack, topCount] = this.getMostFrequentStack();\r\n            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\r\n            console.warn(message);\r\n            console.warn(topStack);\r\n            const error = new ListenerLeakError(message, topStack);\r\n            this._errorHandler(error);\r\n        }\r\n        return () => {\r\n            const count = (this._stacks.get(stack.value) || 0);\r\n            this._stacks.set(stack.value, count - 1);\r\n        };\r\n    }\r\n    getMostFrequentStack() {\r\n        if (!this._stacks) {\r\n            return undefined;\r\n        }\r\n        let topStack;\r\n        let topCount = 0;\r\n        for (const [stack, count] of this._stacks) {\r\n            if (!topStack || topCount < count) {\r\n                topStack = [stack, count];\r\n                topCount = count;\r\n            }\r\n        }\r\n        return topStack;\r\n    }\r\n}\r\nclass Stacktrace {\r\n    static create() {\r\n        var _a;\r\n        const err = new Error();\r\n        return new Stacktrace((_a = err.stack) !== null && _a !== void 0 ? _a : '');\r\n    }\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    print() {\r\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\r\n    }\r\n}\r\n// error that is logged when going over the configured listener threshold\r\nclass ListenerLeakError extends Error {\r\n    constructor(message, stack) {\r\n        super(message);\r\n        this.name = 'ListenerLeakError';\r\n        this.stack = stack;\r\n    }\r\n}\r\n// SEVERE error that is logged when having gone way over the configured listener\r\n// threshold so that the emitter refuses to accept more listeners\r\nclass ListenerRefusalError extends Error {\r\n    constructor(message, stack) {\r\n        super(message);\r\n        this.name = 'ListenerRefusalError';\r\n        this.stack = stack;\r\n    }\r\n}\r\nclass UniqueContainer {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n}\r\nconst compactionThreshold = 2;\r\nconst forEachListener = (listeners, fn) => {\r\n    if (listeners instanceof UniqueContainer) {\r\n        fn(listeners);\r\n    }\r\n    else {\r\n        for (let i = 0; i < listeners.length; i++) {\r\n            const l = listeners[i];\r\n            if (l) {\r\n                fn(l);\r\n            }\r\n        }\r\n    }\r\n};\r\nconst _listenerFinalizers = _enableListenerGCedWarning\r\n    ? new FinalizationRegistry(heldValue => {\r\n        if (typeof heldValue === 'string') {\r\n            console.warn('[LEAKING LISTENER] GC\\'ed a listener that was NOT yet disposed. This is where is was created:');\r\n            console.warn(heldValue);\r\n        }\r\n    })\r\n    : undefined;\r\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\r\nclass Emitter {\r\n    constructor(options) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        this._size = 0;\r\n        this._options = options;\r\n        this._leakageMon = (_globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold))\r\n            ? new LeakageMonitor((_b = options === null || options === void 0 ? void 0 : options.onListenerError) !== null && _b !== void 0 ? _b : _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError, (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.leakWarningThreshold) !== null && _d !== void 0 ? _d : _globalLeakWarningThreshold) :\r\n            undefined;\r\n        this._perfMon = ((_e = this._options) === null || _e === void 0 ? void 0 : _e._profName) ? new EventProfiling(this._options._profName) : undefined;\r\n        this._deliveryQueue = (_f = this._options) === null || _f === void 0 ? void 0 : _f.deliveryQueue;\r\n    }\r\n    dispose() {\r\n        var _a, _b, _c, _d;\r\n        if (!this._disposed) {\r\n            this._disposed = true;\r\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\r\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\r\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\r\n            // the following programming pattern is very popular:\r\n            //\r\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\r\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\r\n            // ...later...\r\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\r\n            if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\r\n                this._deliveryQueue.reset();\r\n            }\r\n            if (this._listeners) {\r\n                if (_enableDisposeWithListenerWarning) {\r\n                    const listeners = this._listeners;\r\n                    queueMicrotask(() => {\r\n                        forEachListener(listeners, l => { var _a; return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print(); });\r\n                    });\r\n                }\r\n                this._listeners = undefined;\r\n                this._size = 0;\r\n            }\r\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\r\n        }\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        var _a;\r\n        (_a = this._event) !== null && _a !== void 0 ? _a : (this._event = (callback, thisArgs, disposables) => {\r\n            var _a, _b, _c, _d, _e, _f, _g;\r\n            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\r\n                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\r\n                console.warn(message);\r\n                const tuple = (_a = this._leakageMon.getMostFrequentStack()) !== null && _a !== void 0 ? _a : ['UNKNOWN stack', -1];\r\n                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\r\n                const errorHandler = ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onListenerError) || _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError;\r\n                errorHandler(error);\r\n                return _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;\r\n            }\r\n            if (this._disposed) {\r\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\r\n                return _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;\r\n            }\r\n            if (thisArgs) {\r\n                callback = callback.bind(thisArgs);\r\n            }\r\n            const contained = new UniqueContainer(callback);\r\n            let removeMonitor;\r\n            let stack;\r\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\r\n                // check and record this emitter for potential leakage\r\n                contained.stack = Stacktrace.create();\r\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\r\n            }\r\n            if (_enableDisposeWithListenerWarning) {\r\n                contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\r\n            }\r\n            if (!this._listeners) {\r\n                (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onWillAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\r\n                this._listeners = contained;\r\n                (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.onDidAddFirstListener) === null || _f === void 0 ? void 0 : _f.call(_e, this);\r\n            }\r\n            else if (this._listeners instanceof UniqueContainer) {\r\n                (_g = this._deliveryQueue) !== null && _g !== void 0 ? _g : (this._deliveryQueue = new EventDeliveryQueuePrivate());\r\n                this._listeners = [this._listeners, contained];\r\n            }\r\n            else {\r\n                this._listeners.push(contained);\r\n            }\r\n            this._size++;\r\n            const result = (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.toDisposable)(() => {\r\n                _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);\r\n                removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\r\n                this._removeListener(contained);\r\n            });\r\n            if (disposables instanceof _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStore) {\r\n                disposables.add(result);\r\n            }\r\n            else if (Array.isArray(disposables)) {\r\n                disposables.push(result);\r\n            }\r\n            if (_listenerFinalizers) {\r\n                const stack = new Error().stack.split('\\n').slice(2).join('\\n').trim();\r\n                _listenerFinalizers.register(result, stack, result);\r\n            }\r\n            return result;\r\n        });\r\n        return this._event;\r\n    }\r\n    _removeListener(listener) {\r\n        var _a, _b, _c, _d;\r\n        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\r\n        if (!this._listeners) {\r\n            return; // expected if a listener gets disposed\r\n        }\r\n        if (this._size === 1) {\r\n            this._listeners = undefined;\r\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\r\n            this._size = 0;\r\n            return;\r\n        }\r\n        // size > 1 which requires that listeners be a list:\r\n        const listeners = this._listeners;\r\n        const index = listeners.indexOf(listener);\r\n        if (index === -1) {\r\n            console.log('disposed?', this._disposed);\r\n            console.log('size?', this._size);\r\n            console.log('arr?', JSON.stringify(this._listeners));\r\n            throw new Error('Attempted to dispose unknown listener');\r\n        }\r\n        this._size--;\r\n        listeners[index] = undefined;\r\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\r\n        if (this._size * compactionThreshold <= listeners.length) {\r\n            let n = 0;\r\n            for (let i = 0; i < listeners.length; i++) {\r\n                if (listeners[i]) {\r\n                    listeners[n++] = listeners[i];\r\n                }\r\n                else if (adjustDeliveryQueue) {\r\n                    this._deliveryQueue.end--;\r\n                    if (n < this._deliveryQueue.i) {\r\n                        this._deliveryQueue.i--;\r\n                    }\r\n                }\r\n            }\r\n            listeners.length = n;\r\n        }\r\n    }\r\n    _deliver(listener, value) {\r\n        var _a;\r\n        if (!listener) {\r\n            return;\r\n        }\r\n        const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || _errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError;\r\n        if (!errorHandler) {\r\n            listener.value(value);\r\n            return;\r\n        }\r\n        try {\r\n            listener.value(value);\r\n        }\r\n        catch (e) {\r\n            errorHandler(e);\r\n        }\r\n    }\r\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\r\n    _deliverQueue(dq) {\r\n        const listeners = dq.current._listeners;\r\n        while (dq.i < dq.end) {\r\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\r\n            this._deliver(listeners[dq.i++], dq.value);\r\n        }\r\n        dq.reset();\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        var _a, _b, _c, _d;\r\n        if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\r\n            this._deliverQueue(this._deliveryQueue);\r\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\r\n        }\r\n        (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\r\n        if (!this._listeners) {\r\n            // no-op\r\n        }\r\n        else if (this._listeners instanceof UniqueContainer) {\r\n            this._deliver(this._listeners, event);\r\n        }\r\n        else {\r\n            const dq = this._deliveryQueue;\r\n            dq.enqueue(this, event, this._listeners.length);\r\n            this._deliverQueue(dq);\r\n        }\r\n        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\r\n    }\r\n    hasListeners() {\r\n        return this._size > 0;\r\n    }\r\n}\r\nconst createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\r\nclass EventDeliveryQueuePrivate {\r\n    constructor() {\r\n        /**\r\n         * Index in current's listener list.\r\n         */\r\n        this.i = -1;\r\n        /**\r\n         * The last index in the listener's list to deliver.\r\n         */\r\n        this.end = 0;\r\n    }\r\n    enqueue(emitter, value, end) {\r\n        this.i = 0;\r\n        this.end = end;\r\n        this.current = emitter;\r\n        this.value = value;\r\n    }\r\n    reset() {\r\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\r\n        this.current = undefined;\r\n        this.value = undefined;\r\n    }\r\n}\r\nclass PauseableEmitter extends Emitter {\r\n    constructor(options) {\r\n        super(options);\r\n        this._isPaused = 0;\r\n        this._eventQueue = new _linkedList_js__WEBPACK_IMPORTED_MODULE_3__.LinkedList();\r\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\r\n    }\r\n    pause() {\r\n        this._isPaused++;\r\n    }\r\n    resume() {\r\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\r\n            if (this._mergeFn) {\r\n                // use the merge function to create a single composite\r\n                // event. make a copy in case firing pauses this emitter\r\n                if (this._eventQueue.size > 0) {\r\n                    const events = Array.from(this._eventQueue);\r\n                    this._eventQueue.clear();\r\n                    super.fire(this._mergeFn(events));\r\n                }\r\n            }\r\n            else {\r\n                // no merging, fire each event individually and test\r\n                // that this emitter isn't paused halfway through\r\n                while (!this._isPaused && this._eventQueue.size !== 0) {\r\n                    super.fire(this._eventQueue.shift());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    fire(event) {\r\n        if (this._size) {\r\n            if (this._isPaused !== 0) {\r\n                this._eventQueue.push(event);\r\n            }\r\n            else {\r\n                super.fire(event);\r\n            }\r\n        }\r\n    }\r\n}\r\nclass DebounceEmitter extends PauseableEmitter {\r\n    constructor(options) {\r\n        var _a;\r\n        super(options);\r\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\r\n    }\r\n    fire(event) {\r\n        if (!this._handle) {\r\n            this.pause();\r\n            this._handle = setTimeout(() => {\r\n                this._handle = undefined;\r\n                this.resume();\r\n            }, this._delay);\r\n        }\r\n        super.fire(event);\r\n    }\r\n}\r\n/**\r\n * An emitter which queue all events and then process them at the\r\n * end of the event loop.\r\n */\r\nclass MicrotaskEmitter extends Emitter {\r\n    constructor(options) {\r\n        super(options);\r\n        this._queuedEvents = [];\r\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\r\n    }\r\n    fire(event) {\r\n        if (!this.hasListeners()) {\r\n            return;\r\n        }\r\n        this._queuedEvents.push(event);\r\n        if (this._queuedEvents.length === 1) {\r\n            queueMicrotask(() => {\r\n                if (this._mergeFn) {\r\n                    super.fire(this._mergeFn(this._queuedEvents));\r\n                }\r\n                else {\r\n                    this._queuedEvents.forEach(e => super.fire(e));\r\n                }\r\n                this._queuedEvents = [];\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * An event emitter that multiplexes many events into a single event.\r\n *\r\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\r\n * to the multiplexer as needed.\r\n *\r\n * ```typescript\r\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\r\n *\r\n * const thingListeners = DisposableMap<Thing, IDisposable>();\r\n *\r\n * thingService.onDidAddThing(thing => {\r\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\r\n * });\r\n * thingService.onDidRemoveThing(thing => {\r\n *   thingListeners.deleteAndDispose(thing);\r\n * });\r\n *\r\n * anythingDataMultiplexer.event(e => {\r\n *   console.log('Something fired data ' + e.data)\r\n * });\r\n * ```\r\n */\r\nclass EventMultiplexer {\r\n    constructor() {\r\n        this.hasListeners = false;\r\n        this.events = [];\r\n        this.emitter = new Emitter({\r\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\r\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\r\n        });\r\n    }\r\n    get event() {\r\n        return this.emitter.event;\r\n    }\r\n    add(event) {\r\n        const e = { event: event, listener: null };\r\n        this.events.push(e);\r\n        if (this.hasListeners) {\r\n            this.hook(e);\r\n        }\r\n        const dispose = () => {\r\n            if (this.hasListeners) {\r\n                this.unhook(e);\r\n            }\r\n            const idx = this.events.indexOf(e);\r\n            this.events.splice(idx, 1);\r\n        };\r\n        return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.toDisposable)((0,_functional_js__WEBPACK_IMPORTED_MODULE_1__.createSingleCallFunction)(dispose));\r\n    }\r\n    onFirstListenerAdd() {\r\n        this.hasListeners = true;\r\n        this.events.forEach(e => this.hook(e));\r\n    }\r\n    onLastListenerRemove() {\r\n        this.hasListeners = false;\r\n        this.events.forEach(e => this.unhook(e));\r\n    }\r\n    hook(e) {\r\n        e.listener = e.event(r => this.emitter.fire(r));\r\n    }\r\n    unhook(e) {\r\n        var _a;\r\n        (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        e.listener = null;\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        this.emitter.dispose();\r\n        for (const e of this.events) {\r\n            (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        }\r\n        this.events = [];\r\n    }\r\n}\r\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\r\nclass EventBufferer {\r\n    constructor() {\r\n        this.data = [];\r\n    }\r\n    wrapEvent(event, reduce, initial) {\r\n        return (listener, thisArgs, disposables) => {\r\n            return event(i => {\r\n                var _a;\r\n                const data = this.data[this.data.length - 1];\r\n                // Non-reduce scenario\r\n                if (!reduce) {\r\n                    // Buffering case\r\n                    if (data) {\r\n                        data.buffers.push(() => listener.call(thisArgs, i));\r\n                    }\r\n                    else {\r\n                        // Not buffering case\r\n                        listener.call(thisArgs, i);\r\n                    }\r\n                    return;\r\n                }\r\n                // Reduce scenario\r\n                const reduceData = data;\r\n                // Not buffering case\r\n                if (!reduceData) {\r\n                    // TODO: Is there a way to cache this reduce call for all listeners?\r\n                    listener.call(thisArgs, reduce(initial, i));\r\n                    return;\r\n                }\r\n                // Buffering case\r\n                (_a = reduceData.items) !== null && _a !== void 0 ? _a : (reduceData.items = []);\r\n                reduceData.items.push(i);\r\n                if (reduceData.buffers.length === 0) {\r\n                    // Include a single buffered function that will reduce all events when we're done buffering events\r\n                    data.buffers.push(() => {\r\n                        var _a;\r\n                        // cache the reduced result so that the value can be shared across all listeners\r\n                        (_a = reduceData.reducedResult) !== null && _a !== void 0 ? _a : (reduceData.reducedResult = initial\r\n                            ? reduceData.items.reduce(reduce, initial)\r\n                            : reduceData.items.reduce(reduce));\r\n                        listener.call(thisArgs, reduceData.reducedResult);\r\n                    });\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n    }\r\n    bufferEvents(fn) {\r\n        const data = { buffers: new Array() };\r\n        this.data.push(data);\r\n        const r = fn();\r\n        this.data.pop();\r\n        data.buffers.forEach(flush => flush());\r\n        return r;\r\n    }\r\n}\r\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\r\nclass Relay {\r\n    constructor() {\r\n        this.listening = false;\r\n        this.inputEvent = Event.None;\r\n        this.inputEventListener = _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;\r\n        this.emitter = new Emitter({\r\n            onDidAddFirstListener: () => {\r\n                this.listening = true;\r\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\r\n            },\r\n            onDidRemoveLastListener: () => {\r\n                this.listening = false;\r\n                this.inputEventListener.dispose();\r\n            }\r\n        });\r\n        this.event = this.emitter.event;\r\n    }\r\n    set input(event) {\r\n        this.inputEvent = event;\r\n        if (this.listening) {\r\n            this.inputEventListener.dispose();\r\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\r\n        }\r\n    }\r\n    dispose() {\r\n        this.inputEventListener.dispose();\r\n        this.emitter.dispose();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDVztBQUNvQztBQUNsRDtBQUNGO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixxREFBVTtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFNBQVMsNkJBQTZCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJGQUEyRjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkZBQTJGO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwREFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUNoQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsNkNBQTZDLGVBQWUsNkNBQTZDLFNBQVM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1KQUFtSix5REFBaUI7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsbUVBQW1FLEtBQUssR0FBRztBQUMzRTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRLHdFQUF3RTtBQUMxSSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0IsOEVBQThFLFlBQVksS0FBSywyQkFBMkI7QUFDcEw7QUFDQTtBQUNBLDBEQUEwRCxRQUFRLDhDQUE4QyxTQUFTO0FBQ3pILHVIQUF1SCx5REFBaUI7QUFDeEk7QUFDQSx1QkFBdUIscURBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1Q0FBdUMsMERBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLHlEQUFpQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBWSxDQUFDLHdFQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFEQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXZlbnQuanM/MzA4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvblVuZXhwZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlU2luZ2xlQ2FsbEZ1bmN0aW9uIH0gZnJvbSAnLi9mdW5jdGlvbmFsLmpzJztcclxuaW1wb3J0IHsgY29tYmluZWREaXNwb3NhYmxlLCBEaXNwb3NhYmxlLCBEaXNwb3NhYmxlU3RvcmUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcclxuaW1wb3J0IHsgTGlua2VkTGlzdCB9IGZyb20gJy4vbGlua2VkTGlzdC5qcyc7XHJcbmltcG9ydCB7IFN0b3BXYXRjaCB9IGZyb20gJy4vc3RvcHdhdGNoLmpzJztcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVW5jb21tZW50IHRoZSBuZXh0IGxpbmUgdG8gcHJpbnQgd2FybmluZ3Mgd2hlbmV2ZXIgYSBsaXN0ZW5lciBpcyBHQydlZCB3aXRob3V0IGhhdmluZyBiZWVuIGRpc3Bvc2VkLiBUaGlzIGlzIGEgTEVBSy5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgX2VuYWJsZUxpc3RlbmVyR0NlZFdhcm5pbmcgPSBmYWxzZTtcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVW5jb21tZW50IHRoZSBuZXh0IGxpbmUgdG8gcHJpbnQgd2FybmluZ3Mgd2hlbmV2ZXIgYW4gZW1pdHRlciB3aXRoIGxpc3RlbmVycyBpcyBkaXNwb3NlZC4gVGhhdCBpcyBhIHNpZ24gb2YgY29kZSBzbWVsbC5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgX2VuYWJsZURpc3Bvc2VXaXRoTGlzdGVuZXJXYXJuaW5nID0gZmFsc2U7XHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGEgc25hcHNob3R0ZWQgZXZlbnQgaXMgdXNlZCByZXBlYXRlZGx5IHdpdGhvdXQgY2xlYW51cC5cclxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvdnNjb2RlL2lzc3Vlcy8xNDI4NTFcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgX2VuYWJsZVNuYXBzaG90UG90ZW50aWFsTGVha1dhcm5pbmcgPSBmYWxzZTtcclxuZXhwb3J0IHZhciBFdmVudDtcclxuKGZ1bmN0aW9uIChFdmVudCkge1xyXG4gICAgRXZlbnQuTm9uZSA9ICgpID0+IERpc3Bvc2FibGUuTm9uZTtcclxuICAgIGZ1bmN0aW9uIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKF9lbmFibGVTbmFwc2hvdFBvdGVudGlhbExlYWtXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb25EaWRBZGRMaXN0ZW5lcjogb3JpZ0xpc3RlbmVyRGlkQWRkIH0gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IFN0YWNrdHJhY2UuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIG9wdGlvbnMub25EaWRBZGRMaXN0ZW5lciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzbmFwc2hvdHRlZCBlbWl0dGVyIExJS0VMWSB1c2VkIHB1YmxpYyBhbmQgU0hPVUxEIEhBVkUgQkVFTiBjcmVhdGVkIHdpdGggRGlzcG9zYWJsZVN0b3JlLiBzbmFwc2hvdHRlZCBoZXJlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHJpbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9yaWdMaXN0ZW5lckRpZEFkZCA9PT0gbnVsbCB8fCBvcmlnTGlzdGVuZXJEaWRBZGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdMaXN0ZW5lckRpZEFkZCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gZXZlbnQsIHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBkZWJvdW5jZXMgY2FsbHMgYW5kIGRlZmVycyB0aGUgbGlzdGVuZXJzIHRvIGEgbGF0ZXIgdGFzayB2aWEgYSBzaGFyZWRcclxuICAgICAqIGBzZXRUaW1lb3V0YC4gVGhlIGV2ZW50IGlzIGNvbnZlcnRlZCBpbnRvIGEgc2lnbmFsIChgRXZlbnQ8dm9pZD5gKSB0byBhdm9pZCBhZGRpdGlvbmFsIG9iamVjdCBjcmVhdGlvbiBhcyBhXHJcbiAgICAgKiByZXN1bHQgb2YgbWVyZ2luZyBldmVudHMgYW5kIHRvIHRyeSBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyB0aGF0IGNvdWxkIGFyaXNlIHdoZW4gdXNpbmcgcmVsYXRlZCBkZWZlcnJlZCBhbmRcclxuICAgICAqIG5vbi1kZWZlcnJlZCBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGRlZmVycmluZyBub24tY3JpdGljYWwgd29yayAoZWcuIGdlbmVyYWwgVUkgdXBkYXRlcykgdG8gZW5zdXJlIGl0IGRvZXMgbm90IGJsb2NrIGNyaXRpY2FsIHdvcmtcclxuICAgICAqIChlZy4gbGF0ZW5jeSBvZiBrZXlwcmVzcyB0byB0ZXh0IHJlbmRlcmVkKS5cclxuICAgICAqXHJcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxyXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxyXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgQSBkaXNwb3NhYmxlIHN0b3JlIHRvIGFkZCB0aGUgbmV3IEV2ZW50RW1pdHRlciB0by5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVmZXIoZXZlbnQsIGRpc3Bvc2FibGUpIHtcclxuICAgICAgICByZXR1cm4gZGVib3VuY2UoZXZlbnQsICgpID0+IHZvaWQgMCwgMCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGRpc3Bvc2FibGUpO1xyXG4gICAgfVxyXG4gICAgRXZlbnQuZGVmZXIgPSBkZWZlcjtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gZXZlbnQsIHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBvbmx5IGZpcmVzIG9uY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uY2UoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcywgaW4gY2FzZSB0aGUgZXZlbnQgZmlyZXMgZHVyaW5nIHRoZSBsaXN0ZW5lciBjYWxsXHJcbiAgICAgICAgICAgIGxldCBkaWRGaXJlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50KGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZEZpcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlkRmlyZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSk7XHJcbiAgICAgICAgICAgIH0sIG51bGwsIGRpc3Bvc2FibGVzKTtcclxuICAgICAgICAgICAgaWYgKGRpZEZpcmUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgRXZlbnQub25jZSA9IG9uY2U7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gZXZlbnQgb2Ygb25lIHR5cGUgaW50byBhbiBldmVudCBvZiBhbm90aGVyIHR5cGUgdXNpbmcgYSBtYXBwaW5nIGZ1bmN0aW9uLCBzaW1pbGFyIHRvIGhvd1xyXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5tYXBgIHdvcmtzLlxyXG4gICAgICpcclxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXHJcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXHJcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gbWFwIFRoZSBtYXBwaW5nIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgQSBkaXNwb3NhYmxlIHN0b3JlIHRvIGFkZCB0aGUgbmV3IEV2ZW50RW1pdHRlciB0by5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWFwKGV2ZW50LCBtYXAsIGRpc3Bvc2FibGUpIHtcclxuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChpID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIG1hcChpKSksIG51bGwsIGRpc3Bvc2FibGVzKSwgZGlzcG9zYWJsZSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5tYXAgPSBtYXA7XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBzIGFuIGV2ZW50IGluIGFub3RoZXIgZXZlbnQgdGhhdCBwZXJmb3JtcyBzb21lIGZ1bmN0aW9uIG9uIHRoZSBldmVudCBvYmplY3QgYmVmb3JlIGZpcmluZy5cclxuICAgICAqXHJcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxyXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxyXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGVhY2ggVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGV2ZW50IG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBkaXNwb3NhYmxlIEEgZGlzcG9zYWJsZSBzdG9yZSB0byBhZGQgdGhlIG5ldyBFdmVudEVtaXR0ZXIgdG8uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvckVhY2goZXZlbnQsIGVhY2gsIGRpc3Bvc2FibGUpIHtcclxuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChpID0+IHsgZWFjaChpKTsgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgaSk7IH0sIG51bGwsIGRpc3Bvc2FibGVzKSwgZGlzcG9zYWJsZSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5mb3JFYWNoID0gZm9yRWFjaDtcclxuICAgIGZ1bmN0aW9uIGZpbHRlcihldmVudCwgZmlsdGVyLCBkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoZSA9PiBmaWx0ZXIoZSkgJiYgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSksIG51bGwsIGRpc3Bvc2FibGVzKSwgZGlzcG9zYWJsZSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCByZXR1cm5zIHRoZSBzYW1lIGV2ZW50IGJ1dCB0eXBlZCBhcyBgRXZlbnQ8dm9pZD5gLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaWduYWwoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5zaWduYWwgPSBzaWduYWw7XHJcbiAgICBmdW5jdGlvbiBhbnkoLi4uZXZlbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNwb3NhYmxlID0gY29tYmluZWREaXNwb3NhYmxlKC4uLmV2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQoZSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZEFuZFJldHVybkRpc3Bvc2FibGUoZGlzcG9zYWJsZSwgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBFdmVudC5hbnkgPSBhbnk7XHJcbiAgICAvKipcclxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXHJcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXHJcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlZHVjZShldmVudCwgbWVyZ2UsIGluaXRpYWwsIGRpc3Bvc2FibGUpIHtcclxuICAgICAgICBsZXQgb3V0cHV0ID0gaW5pdGlhbDtcclxuICAgICAgICByZXR1cm4gbWFwKGV2ZW50LCBlID0+IHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9LCBkaXNwb3NhYmxlKTtcclxuICAgIH1cclxuICAgIEV2ZW50LnJlZHVjZSA9IHJlZHVjZTtcclxuICAgIGZ1bmN0aW9uIHNuYXBzaG90KGV2ZW50LCBkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgbGV0IGxpc3RlbmVyO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGVtaXR0ZXIuZmlyZSwgZW1pdHRlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIGRpc3Bvc2FibGUgPT09IG51bGwgfHwgZGlzcG9zYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZS5hZGQoZW1pdHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIElEaXNwb3NhYmxlIHRvIHRoZSBzdG9yZSBpZiBpdCdzIHNldCwgYW5kIHJldHVybnMgaXQuIFVzZWZ1bCB0b1xyXG4gICAgICogRXZlbnQgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEFuZFJldHVybkRpc3Bvc2FibGUoZCwgc3RvcmUpIHtcclxuICAgICAgICBpZiAoc3RvcmUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBzdG9yZS5wdXNoKGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdG9yZSkge1xyXG4gICAgICAgICAgICBzdG9yZS5hZGQoZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZXZlbnQsIG1lcmdlLCBkZWxheSA9IDEwMCwgbGVhZGluZyA9IGZhbHNlLCBmbHVzaE9uTGlzdGVuZXJSZW1vdmUgPSBmYWxzZSwgbGVha1dhcm5pbmdUaHJlc2hvbGQsIGRpc3Bvc2FibGUpIHtcclxuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgIGxldCBvdXRwdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgbnVtRGVib3VuY2VkQ2FsbHMgPSAwO1xyXG4gICAgICAgIGxldCBkb0ZpcmU7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbGVha1dhcm5pbmdUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBldmVudChjdXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bURlYm91bmNlZENhbGxzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWFkaW5nICYmICFoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG9GaXJlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfb3V0cHV0ID0gb3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFkaW5nIHx8IG51bURlYm91bmNlZENhbGxzID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKF9vdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bURlYm91bmNlZENhbGxzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGRvRmlyZSwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZG9GaXJlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbldpbGxSZW1vdmVMaXN0ZW5lcigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbHVzaE9uTGlzdGVuZXJSZW1vdmUgJiYgbnVtRGVib3VuY2VkQ2FsbHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9GaXJlID09PSBudWxsIHx8IGRvRmlyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9GaXJlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKCkge1xyXG4gICAgICAgICAgICAgICAgZG9GaXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIGRpc3Bvc2FibGUgPT09IG51bGwgfHwgZGlzcG9zYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZS5hZGQoZW1pdHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5kZWJvdW5jZSA9IGRlYm91bmNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWJvdW5jZXMgYW4gZXZlbnQsIGZpcmluZyBhZnRlciBzb21lIGRlbGF5IChkZWZhdWx0PTApIHdpdGggYW4gYXJyYXkgb2YgYWxsIGV2ZW50IG9yaWdpbmFsIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcclxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcclxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZShldmVudCwgZGVsYXkgPSAwLCBkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIEV2ZW50LmRlYm91bmNlKGV2ZW50LCAobGFzdCwgZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdC5wdXNoKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcclxuICAgICAgICB9LCBkZWxheSwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGRpc3Bvc2FibGUpO1xyXG4gICAgfVxyXG4gICAgRXZlbnQuYWNjdW11bGF0ZSA9IGFjY3VtdWxhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlcnMgYW4gZXZlbnQgc3VjaCB0aGF0IHNvbWUgY29uZGl0aW9uIGlzIF9ub3RfIG1ldCBtb3JlIHRoYW4gb25jZSBpbiBhIHJvdywgZWZmZWN0aXZlbHkgZW5zdXJpbmcgZHVwbGljYXRlXHJcbiAgICAgKiBldmVudCBvYmplY3RzIGZyb20gZGlmZmVyZW50IHNvdXJjZXMgZG8gbm90IGZpcmUgdGhlIHNhbWUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXHJcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXHJcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZXF1YWxzIFRoZSBlcXVhbGl0eSBjb25kaXRpb24uXHJcbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSBBIGRpc3Bvc2FibGUgc3RvcmUgdG8gYWRkIHRoZSBuZXcgRXZlbnRFbWl0dGVyIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIC8vIEZpcmUgb25seSBvbmUgdGltZSB3aGVuIGEgc2luZ2xlIHdpbmRvdyBpcyBvcGVuZWQgb3IgZm9jdXNlZFxyXG4gICAgICogRXZlbnQubGF0Y2goRXZlbnQuYW55KG9uRGlkT3BlbldpbmRvdywgb25EaWRGb2N1c1dpbmRvdykpXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGF0Y2goZXZlbnQsIGVxdWFscyA9IChhLCBiKSA9PiBhID09PSBiLCBkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgbGV0IGZpcnN0Q2FsbCA9IHRydWU7XHJcbiAgICAgICAgbGV0IGNhY2hlO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXIoZXZlbnQsIHZhbHVlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IGZpcnN0Q2FsbCB8fCAhZXF1YWxzKHZhbHVlLCBjYWNoZSk7XHJcbiAgICAgICAgICAgIGZpcnN0Q2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYWNoZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkRW1pdDtcclxuICAgICAgICB9LCBkaXNwb3NhYmxlKTtcclxuICAgIH1cclxuICAgIEV2ZW50LmxhdGNoID0gbGF0Y2g7XHJcbiAgICAvKipcclxuICAgICAqIFNwbGl0cyBhbiBldmVudCB3aG9zZSBwYXJhbWV0ZXIgaXMgYSB1bmlvbiB0eXBlIGludG8gMiBzZXBhcmF0ZSBldmVudHMgZm9yIGVhY2ggdHlwZSBpbiB0aGUgdW5pb24uXHJcbiAgICAgKlxyXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcclxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcclxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBjb25zdCBldmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyIHwgdW5kZWZpbmVkPigpLmV2ZW50O1xyXG4gICAgICogY29uc3QgW251bWJlckV2ZW50LCB1bmRlZmluZWRFdmVudF0gPSBFdmVudC5zcGxpdChldmVudCwgaXNVbmRlZmluZWQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gaXNUIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoYXQgZXZlbnQgaXMgb2YgdGhlIGZpcnN0IHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSBBIGRpc3Bvc2FibGUgc3RvcmUgdG8gYWRkIHRoZSBuZXcgRXZlbnRFbWl0dGVyIHRvLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzcGxpdChldmVudCwgaXNULCBkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgRXZlbnQuZmlsdGVyKGV2ZW50LCBpc1QsIGRpc3Bvc2FibGUpLFxyXG4gICAgICAgICAgICBFdmVudC5maWx0ZXIoZXZlbnQsIGUgPT4gIWlzVChlKSwgZGlzcG9zYWJsZSksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIEV2ZW50LnNwbGl0ID0gc3BsaXQ7XHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlcnMgYW4gZXZlbnQgdW50aWwgaXQgaGFzIGEgbGlzdGVuZXIgYXR0YWNoZWQuXHJcbiAgICAgKlxyXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcclxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcclxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbHVzaEFmdGVyVGltZW91dCBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlciBhZnRlciBhIHRpbWVvdXQgaW1tZWRpYXRlbHkgb3IgYWZ0ZXIgYVxyXG4gICAgICogYHNldFRpbWVvdXRgIHdoZW4gdGhlIGZpcnN0IGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkLlxyXG4gICAgICogQHBhcmFtIF9idWZmZXIgSW50ZXJuYWw6IEEgc291cmNlIGV2ZW50IGFycmF5IHVzZWQgZm9yIHRlc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIC8vIFN0YXJ0IGFjY3VtdWxhdGluZyBldmVudHMsIHdoZW4gdGhlIGZpcnN0IGxpc3RlbmVyIGlzIGF0dGFjaGVkLCBmbHVzaFxyXG4gICAgICogLy8gdGhlIGV2ZW50IGFmdGVyIGEgdGltZW91dCBzdWNoIHRoYXQgbXVsdGlwbGUgbGlzdGVuZXJzIGF0dGFjaGVkIGJlZm9yZVxyXG4gICAgICogLy8gdGhlIHRpbWVvdXQgd291bGQgcmVjZWl2ZSB0aGUgZXZlbnRcclxuICAgICAqIHRoaXMub25JbnN0YWxsRXh0ZW5zaW9uID0gRXZlbnQuYnVmZmVyKHNlcnZpY2Uub25JbnN0YWxsRXh0ZW5zaW9uLCB0cnVlKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWZmZXIoZXZlbnQsIGZsdXNoQWZ0ZXJUaW1lb3V0ID0gZmFsc2UsIF9idWZmZXIgPSBbXSwgZGlzcG9zYWJsZSkge1xyXG4gICAgICAgIGxldCBidWZmZXIgPSBfYnVmZmVyLnNsaWNlKCk7XHJcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZXZlbnQoZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpc3Bvc2FibGUpIHtcclxuICAgICAgICAgICAgZGlzcG9zYWJsZS5hZGQobGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmbHVzaCA9ICgpID0+IHtcclxuICAgICAgICAgICAgYnVmZmVyID09PSBudWxsIHx8IGJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyLmZvckVhY2goZSA9PiBlbWl0dGVyLmZpcmUoZSkpO1xyXG4gICAgICAgICAgICBidWZmZXIgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcclxuICAgICAgICAgICAgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcigpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGUgPT4gZW1pdHRlci5maXJlKGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcG9zYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlLmFkZChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkRpZEFkZEZpcnN0TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoQWZ0ZXJUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpc3Bvc2FibGUpIHtcclxuICAgICAgICAgICAgZGlzcG9zYWJsZS5hZGQoZW1pdHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgRXZlbnQuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcyB0aGUgZXZlbnQgaW4gYW4ge0BsaW5rIElDaGFpbmFibGVFdmVudH0sIGFsbG93aW5nIGEgbW9yZSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIHN0eWxlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIC8vIE5vcm1hbFxyXG4gICAgICogY29uc3Qgb25FbnRlclByZXNzTm9ybWFsID0gRXZlbnQuZmlsdGVyKFxyXG4gICAgICogICBFdmVudC5tYXAob25LZXlQcmVzcy5ldmVudCwgZSA9PiBuZXcgU3RhbmRhcmRLZXlib2FyZEV2ZW50KGUpKSxcclxuICAgICAqICAgZS5rZXlDb2RlID09PSBLZXlDb2RlLkVudGVyXHJcbiAgICAgKiApLmV2ZW50O1xyXG4gICAgICpcclxuICAgICAqIC8vIFVzaW5nIGNoYWluXHJcbiAgICAgKiBjb25zdCBvbkVudGVyUHJlc3NDaGFpbiA9IEV2ZW50LmNoYWluKG9uS2V5UHJlc3MuZXZlbnQsICQgPT4gJFxyXG4gICAgICogICAubWFwKGUgPT4gbmV3IFN0YW5kYXJkS2V5Ym9hcmRFdmVudChlKSlcclxuICAgICAqICAgLmZpbHRlcihlID0+IGUua2V5Q29kZSA9PT0gS2V5Q29kZS5FbnRlcilcclxuICAgICAqICk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hhaW4oZXZlbnQsIHN5dGhlbnNpemUpIHtcclxuICAgICAgICBjb25zdCBmbiA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzID0gc3l0aGVuc2l6ZShuZXcgQ2hhaW5hYmxlU3ludGhlc2lzKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjcy5ldmFsdWF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBIYWx0Q2hhaW5hYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBkaXNwb3NhYmxlcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcbiAgICBFdmVudC5jaGFpbiA9IGNoYWluO1xyXG4gICAgY29uc3QgSGFsdENoYWluYWJsZSA9IFN5bWJvbCgnSGFsdENoYWluYWJsZScpO1xyXG4gICAgY2xhc3MgQ2hhaW5hYmxlU3ludGhlc2lzIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXAoZm4pIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKGZuKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm4odik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaWx0ZXIoZm4pIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHYgPT4gZm4odikgPyB2IDogSGFsdENoYWluYWJsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWR1Y2UobWVyZ2UsIGluaXRpYWwpIHtcclxuICAgICAgICAgICAgbGV0IGxhc3QgPSBpbml0aWFsO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBzLnB1c2godiA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gbWVyZ2UobGFzdCwgdik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXRjaChlcXVhbHMgPSAoYSwgYikgPT4gYSA9PT0gYikge1xyXG4gICAgICAgICAgICBsZXQgZmlyc3RDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGV0IGNhY2hlO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBzLnB1c2godmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IGZpcnN0Q2FsbCB8fCAhZXF1YWxzKHZhbHVlLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNhY2hlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkRW1pdCA/IHZhbHVlIDogSGFsdENoYWluYWJsZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmFsdWF0ZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgdGhpcy5zdGVwcykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdGVwKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSGFsdENoYWluYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4ge0BsaW5rIEV2ZW50fSBmcm9tIGEgbm9kZSBldmVudCBlbWl0dGVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tTm9kZUV2ZW50RW1pdHRlcihlbWl0dGVyLCBldmVudE5hbWUsIG1hcCA9IGlkID0+IGlkKSB7XHJcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4gcmVzdWx0LmZpcmUobWFwKC4uLmFyZ3MpKTtcclxuICAgICAgICBjb25zdCBvbkZpcnN0TGlzdGVuZXJBZGQgPSAoKSA9PiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgZm4pO1xyXG4gICAgICAgIGNvbnN0IG9uTGFzdExpc3RlbmVyUmVtb3ZlID0gKCkgPT4gZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRW1pdHRlcih7IG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6IG9uRmlyc3RMaXN0ZW5lckFkZCwgb25EaWRSZW1vdmVMYXN0TGlzdGVuZXI6IG9uTGFzdExpc3RlbmVyUmVtb3ZlIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5mcm9tTm9kZUV2ZW50RW1pdHRlciA9IGZyb21Ob2RlRXZlbnRFbWl0dGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIHtAbGluayBFdmVudH0gZnJvbSBhIERPTSBldmVudCBlbWl0dGVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tRE9NRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbWFwID0gaWQgPT4gaWQpIHtcclxuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiByZXN1bHQuZmlyZShtYXAoLi4uYXJncykpO1xyXG4gICAgICAgIGNvbnN0IG9uRmlyc3RMaXN0ZW5lckFkZCA9ICgpID0+IGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcclxuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRW1pdHRlcih7IG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6IG9uRmlyc3RMaXN0ZW5lckFkZCwgb25EaWRSZW1vdmVMYXN0TGlzdGVuZXI6IG9uTGFzdExpc3RlbmVyUmVtb3ZlIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5mcm9tRE9NRXZlbnRFbWl0dGVyID0gZnJvbURPTUV2ZW50RW1pdHRlcjtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHByb21pc2Ugb3V0IG9mIGFuIGV2ZW50LCB1c2luZyB0aGUge0BsaW5rIEV2ZW50Lm9uY2V9IGhlbHBlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9Qcm9taXNlKGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gb25jZShldmVudCkocmVzb2x2ZSkpO1xyXG4gICAgfVxyXG4gICAgRXZlbnQudG9Qcm9taXNlID0gdG9Qcm9taXNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IG91dCBvZiBhIHByb21pc2UgdGhhdCBmaXJlcyBvbmNlIHdoZW4gdGhlIHByb21pc2UgaXNcclxuICAgICAqIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSBvciBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5maXJlKHJlcyk7XHJcbiAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHQuZmlyZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHQuZGlzcG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5mcm9tUHJvbWlzZSA9IGZyb21Qcm9taXNlO1xyXG4gICAgZnVuY3Rpb24gcnVuQW5kU3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyLCBpbml0aWFsKSB7XHJcbiAgICAgICAgaGFuZGxlcihpbml0aWFsKTtcclxuICAgICAgICByZXR1cm4gZXZlbnQoZSA9PiBoYW5kbGVyKGUpKTtcclxuICAgIH1cclxuICAgIEV2ZW50LnJ1bkFuZFN1YnNjcmliZSA9IHJ1bkFuZFN1YnNjcmliZTtcclxuICAgIGNsYXNzIEVtaXR0ZXJPYnNlcnZlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoX29ic2VydmFibGUsIHN0b3JlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmFibGUgPSBfb2JzZXJ2YWJsZTtcclxuICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBfb2JzZXJ2YWJsZS5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9vYnNlcnZhYmxlLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIXN0b3JlKSB7XHJcbiAgICAgICAgICAgICAgICBfYWRkTGVha2FnZVRyYWNlTG9naWMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChzdG9yZSkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmUuYWRkKHRoaXMuZW1pdHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYmVnaW5VcGRhdGUoX29ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9vYnNlcnZhYmxlID09PSB0aGlzLm9icyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlUG9zc2libGVDaGFuZ2UoX29ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9vYnNlcnZhYmxlID09PSB0aGlzLm9icyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZUNoYW5nZShfb2JzZXJ2YWJsZSwgX2NoYW5nZSkge1xyXG4gICAgICAgICAgICAvLyBhc3NlcnQoX29ic2VydmFibGUgPT09IHRoaXMub2JzKTtcclxuICAgICAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZFVwZGF0ZShfb2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAvLyBhc3NlcnQoX29ic2VydmFibGUgPT09IHRoaXMub2JzKTtcclxuICAgICAgICAgICAgdGhpcy5fY291bnRlci0tO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZS5yZXBvcnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZSh0aGlzLl9vYnNlcnZhYmxlLmdldCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgb2JzZXJ2YWJsZSBjaGFuZ2VzLlxyXG4gICAgICogRWFjaCBsaXN0ZW5lcnMgc3Vic2NyaWJlcyB0byB0aGUgZW1pdHRlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbU9ic2VydmFibGUob2JzLCBzdG9yZSkge1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEVtaXR0ZXJPYnNlcnZlcihvYnMsIHN0b3JlKTtcclxuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZW1pdHRlci5ldmVudDtcclxuICAgIH1cclxuICAgIEV2ZW50LmZyb21PYnNlcnZhYmxlID0gZnJvbU9ic2VydmFibGU7XHJcbiAgICAvKipcclxuICAgICAqIEVhY2ggbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gdGhlIG9ic2VydmFibGUgZGlyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21PYnNlcnZhYmxlTGlnaHQob2JzZXJ2YWJsZSkge1xyXG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgZGlkQ2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICAgICAgYmVnaW5VcGRhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbmRVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5yZXBvcnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZENoYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlUG9zc2libGVDaGFuZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGhhbmRsZUNoYW5nZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWRDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBvYnNlcnZhYmxlLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgb2JzZXJ2YWJsZS5yZXBvcnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUucmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZGlzcG9zYWJsZXMgaW5zdGFuY2VvZiBEaXNwb3NhYmxlU3RvcmUpIHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLmFkZChkaXNwb3NhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgRXZlbnQuZnJvbU9ic2VydmFibGVMaWdodCA9IGZyb21PYnNlcnZhYmxlTGlnaHQ7XHJcbn0pKEV2ZW50IHx8IChFdmVudCA9IHt9KSk7XHJcbmV4cG9ydCBjbGFzcyBFdmVudFByb2ZpbGluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmludm9jYXRpb25Db3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkT3ZlcmFsbCA9IDA7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBgJHtuYW1lfV8ke0V2ZW50UHJvZmlsaW5nLl9pZFBvb2wrK31gO1xyXG4gICAgICAgIEV2ZW50UHJvZmlsaW5nLmFsbC5hZGQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBzdGFydChsaXN0ZW5lckNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcFdhdGNoID0gbmV3IFN0b3BXYXRjaCgpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdG9wV2F0Y2gpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuX3N0b3BXYXRjaC5lbGFwc2VkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb25zLnB1c2goZWxhcHNlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZE92ZXJhbGwgKz0gZWxhcHNlZDtcclxuICAgICAgICAgICAgdGhpcy5pbnZvY2F0aW9uQ291bnQgKz0gMTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcFdhdGNoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5FdmVudFByb2ZpbGluZy5hbGwgPSBuZXcgU2V0KCk7XHJcbkV2ZW50UHJvZmlsaW5nLl9pZFBvb2wgPSAwO1xyXG5sZXQgX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkID0gLTE7XHJcbmNsYXNzIExlYWthZ2VNb25pdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKF9lcnJvckhhbmRsZXIsIHRocmVzaG9sZCwgbmFtZSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTgpLnNsaWNlKDIsIDUpKSB7XHJcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVyID0gX2Vycm9ySGFuZGxlcjtcclxuICAgICAgICB0aGlzLnRocmVzaG9sZCA9IHRocmVzaG9sZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gPSAwO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5fc3RhY2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIGNoZWNrKHN0YWNrLCBsaXN0ZW5lckNvdW50KSB7XHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQ7XHJcbiAgICAgICAgaWYgKHRocmVzaG9sZCA8PSAwIHx8IGxpc3RlbmVyQ291bnQgPCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb3VudCA9ICh0aGlzLl9zdGFja3MuZ2V0KHN0YWNrLnZhbHVlKSB8fCAwKTtcclxuICAgICAgICB0aGlzLl9zdGFja3Muc2V0KHN0YWNrLnZhbHVlLCBjb3VudCArIDEpO1xyXG4gICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5fd2FybkNvdW50ZG93biA8PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgd2FybiBvbiBmaXJzdCBleGNlZWQgYW5kIHRoZW4gZXZlcnkgdGltZSB0aGUgbGltaXRcclxuICAgICAgICAgICAgLy8gaXMgZXhjZWVkZWQgYnkgNTAlIGFnYWluXHJcbiAgICAgICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gPSB0aHJlc2hvbGQgKiAwLjU7XHJcbiAgICAgICAgICAgIGNvbnN0IFt0b3BTdGFjaywgdG9wQ291bnRdID0gdGhpcy5nZXRNb3N0RnJlcXVlbnRTdGFjaygpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFske3RoaXMubmFtZX1dIHBvdGVudGlhbCBsaXN0ZW5lciBMRUFLIGRldGVjdGVkLCBoYXZpbmcgJHtsaXN0ZW5lckNvdW50fSBsaXN0ZW5lcnMgYWxyZWFkeS4gTU9TVCBmcmVxdWVudCBsaXN0ZW5lciAoJHt0b3BDb3VudH0pOmA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKHRvcFN0YWNrKTtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTGlzdGVuZXJMZWFrRXJyb3IobWVzc2FnZSwgdG9wU3RhY2spO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9ICh0aGlzLl9zdGFja3MuZ2V0KHN0YWNrLnZhbHVlKSB8fCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tzLnNldChzdGFjay52YWx1ZSwgY291bnQgLSAxKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0TW9zdEZyZXF1ZW50U3RhY2soKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFja3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRvcFN0YWNrO1xyXG4gICAgICAgIGxldCB0b3BDb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBbc3RhY2ssIGNvdW50XSBvZiB0aGlzLl9zdGFja3MpIHtcclxuICAgICAgICAgICAgaWYgKCF0b3BTdGFjayB8fCB0b3BDb3VudCA8IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0b3BTdGFjayA9IFtzdGFjaywgY291bnRdO1xyXG4gICAgICAgICAgICAgICAgdG9wQ291bnQgPSBjb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9wU3RhY2s7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU3RhY2t0cmFjZSB7XHJcbiAgICBzdGF0aWMgY3JlYXRlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFN0YWNrdHJhY2UoKF9hID0gZXJyLnN0YWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHByaW50KCkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnZhbHVlLnNwbGl0KCdcXG4nKS5zbGljZSgyKS5qb2luKCdcXG4nKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZXJyb3IgdGhhdCBpcyBsb2dnZWQgd2hlbiBnb2luZyBvdmVyIHRoZSBjb25maWd1cmVkIGxpc3RlbmVyIHRocmVzaG9sZFxyXG5leHBvcnQgY2xhc3MgTGlzdGVuZXJMZWFrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFjaykge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdMaXN0ZW5lckxlYWtFcnJvcic7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xyXG4gICAgfVxyXG59XHJcbi8vIFNFVkVSRSBlcnJvciB0aGF0IGlzIGxvZ2dlZCB3aGVuIGhhdmluZyBnb25lIHdheSBvdmVyIHRoZSBjb25maWd1cmVkIGxpc3RlbmVyXHJcbi8vIHRocmVzaG9sZCBzbyB0aGF0IHRoZSBlbWl0dGVyIHJlZnVzZXMgdG8gYWNjZXB0IG1vcmUgbGlzdGVuZXJzXHJcbmV4cG9ydCBjbGFzcyBMaXN0ZW5lclJlZnVzYWxFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0xpc3RlbmVyUmVmdXNhbEVycm9yJztcclxuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVW5pcXVlQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNvbXBhY3Rpb25UaHJlc2hvbGQgPSAyO1xyXG5jb25zdCBmb3JFYWNoTGlzdGVuZXIgPSAobGlzdGVuZXJzLCBmbikgPT4ge1xyXG4gICAgaWYgKGxpc3RlbmVycyBpbnN0YW5jZW9mIFVuaXF1ZUNvbnRhaW5lcikge1xyXG4gICAgICAgIGZuKGxpc3RlbmVycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAobCkge1xyXG4gICAgICAgICAgICAgICAgZm4obCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IF9saXN0ZW5lckZpbmFsaXplcnMgPSBfZW5hYmxlTGlzdGVuZXJHQ2VkV2FybmluZ1xyXG4gICAgPyBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoaGVsZFZhbHVlID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIGhlbGRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbTEVBS0lORyBMSVNURU5FUl0gR0NcXCdlZCBhIGxpc3RlbmVyIHRoYXQgd2FzIE5PVCB5ZXQgZGlzcG9zZWQuIFRoaXMgaXMgd2hlcmUgaXMgd2FzIGNyZWF0ZWQ6Jyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihoZWxkVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuLyoqXHJcbiAqIFRoZSBFbWl0dGVyIGNhbiBiZSB1c2VkIHRvIGV4cG9zZSBhbiBFdmVudCB0byB0aGUgcHVibGljXHJcbiAqIHRvIGZpcmUgaXQgZnJvbSB0aGUgaW5zaWRlcy5cclxuICogU2FtcGxlOlxyXG4gICAgY2xhc3MgRG9jdW1lbnQge1xyXG5cclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9vbkRpZENoYW5nZSA9IG5ldyBFbWl0dGVyPCh2YWx1ZTpzdHJpbmcpPT5hbnk+KCk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBvbkRpZENoYW5nZSA9IHRoaXMuX29uRGlkQ2hhbmdlLmV2ZW50O1xyXG5cclxuICAgICAgICAvLyBnZXR0ZXItc3R5bGVcclxuICAgICAgICAvLyBnZXQgb25EaWRDaGFuZ2UoKTogRXZlbnQ8KHZhbHVlOnN0cmluZyk9PmFueT4ge1xyXG4gICAgICAgIC8vIFx0cmV0dXJuIHRoaXMuX29uRGlkQ2hhbmdlLmV2ZW50O1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBfZG9JdCgpIHtcclxuICAgICAgICAgICAgLy8uLi5cclxuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UuZmlyZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX2xlYWthZ2VNb24gPSAoX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkID4gMCB8fCAoKF9hID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlYWtXYXJuaW5nVGhyZXNob2xkKSlcclxuICAgICAgICAgICAgPyBuZXcgTGVha2FnZU1vbml0b3IoKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uTGlzdGVuZXJFcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogb25VbmV4cGVjdGVkRXJyb3IsIChfZCA9IChfYyA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZWFrV2FybmluZ1RocmVzaG9sZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkKSA6XHJcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wZXJmTW9uID0gKChfZSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5fcHJvZk5hbWUpID8gbmV3IEV2ZW50UHJvZmlsaW5nKHRoaXMuX29wdGlvbnMuX3Byb2ZOYW1lKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kZWxpdmVyeVF1ZXVlID0gKF9mID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmRlbGl2ZXJ5UXVldWU7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gSXQgaXMgYmFkIHRvIGhhdmUgbGlzdGVuZXJzIGF0IHRoZSB0aW1lIG9mIGRpc3Bvc2luZyBhbiBlbWl0dGVyLCBpdCBpcyB3b3JzdCB0byBoYXZlIGxpc3RlbmVycyBrZWVwIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICAgIC8vIGFsaXZlIHZpYSB0aGUgcmVmZXJlbmNlIHRoYXQncyBlbWJlZGRlZCBpbiB0aGVpciBkaXNwb3NhYmxlcy4gVGhlcmVmb3JlIHdlIGxvb3Agb3ZlciBhbGwgcmVtYWluaW5nIGxpc3RlbmVycyBhbmRcclxuICAgICAgICAgICAgLy8gdW5zZXQgdGhlaXIgc3Vic2NyaXB0aW9ucy9kaXNwb3NhYmxlcy4gTG9vcGluZyBhbmQgYmxhbWluZyByZW1haW5pbmcgbGlzdGVuZXJzIGlzIGRvbmUgb24gbmV4dCB0aWNrIGJlY2F1c2UgdGhlXHJcbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgcHJvZ3JhbW1pbmcgcGF0dGVybiBpcyB2ZXJ5IHBvcHVsYXI6XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IHNvbWVNb2RlbCA9IHRoaXMuX2Rpc3Bvc2FibGVzLmFkZChuZXcgTW9kZWxPYmplY3QoKSk7IC8vICgxKSBjcmVhdGUgYW5kIHJlZ2lzdGVyIG1vZGVsXHJcbiAgICAgICAgICAgIC8vIHRoaXMuX2Rpc3Bvc2FibGVzLmFkZChzb21lTW9kZWwub25EaWRDaGFuZ2UoKCkgPT4geyAuLi4gfSk7IC8vICgyKSBzdWJzY3JpYmUgYW5kIHJlZ2lzdGVyIG1vZGVsLWV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgICAgIC8vIC4uLmxhdGVyLi4uXHJcbiAgICAgICAgICAgIC8vIHRoaXMuX2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTsgZGlzcG9zZXMgKDEpIHRoZW4gKDIpOiBkb24ndCB3YXJuIGFmdGVyICgxKSBidXQgYWZ0ZXIgdGhlIFwib3ZlcmFsbCBkaXNwb3NlXCIgaXMgZG9uZVxyXG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2RlbGl2ZXJ5UXVldWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50KSA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZW5hYmxlRGlzcG9zZVdpdGhMaXN0ZW5lcldhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoTGlzdGVuZXIobGlzdGVuZXJzLCBsID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gbC5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByaW50KCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKF9jID0gKF9iID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYik7XHJcbiAgICAgICAgICAgIChfZCA9IHRoaXMuX2xlYWthZ2VNb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcclxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnQoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX2V2ZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fZXZlbnQgPSAoY2FsbGJhY2ssIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZWFrYWdlTW9uICYmIHRoaXMuX3NpemUgPiB0aGlzLl9sZWFrYWdlTW9uLnRocmVzaG9sZCAqKiAyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFske3RoaXMuX2xlYWthZ2VNb24ubmFtZX1dIFJFRlVTRVMgdG8gYWNjZXB0IG5ldyBsaXN0ZW5lcnMgYmVjYXVzZSBpdCBleGNlZWRlZCBpdHMgdGhyZXNob2xkIGJ5IGZhciAoJHt0aGlzLl9zaXplfSB2cyAke3RoaXMuX2xlYWthZ2VNb24udGhyZXNob2xkfSlgO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGUgPSAoX2EgPSB0aGlzLl9sZWFrYWdlTW9uLmdldE1vc3RGcmVxdWVudFN0YWNrKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFsnVU5LTk9XTiBzdGFjaycsIC0xXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IExpc3RlbmVyUmVmdXNhbEVycm9yKGAke21lc3NhZ2V9LiBISU5UOiBTdGFjayBzaG93cyBtb3N0IGZyZXF1ZW50IGxpc3RlbmVyICgke3R1cGxlWzFdfS10aW1lcylgLCB0dXBsZVswXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoKF9iID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uTGlzdGVuZXJFcnJvcikgfHwgb25VbmV4cGVjdGVkRXJyb3I7XHJcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuTm9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZG86IHNob3VsZCB3ZSB3YXJuIGlmIGEgbGlzdGVuZXIgaXMgYWRkZWQgdG8gYSBkaXNwb3NlZCBlbWl0dGVyPyBUaGlzIGhhcHBlbnMgb2Z0ZW5cclxuICAgICAgICAgICAgICAgIHJldHVybiBEaXNwb3NhYmxlLk5vbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXNBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrLmJpbmQodGhpc0FyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lZCA9IG5ldyBVbmlxdWVDb250YWluZXIoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICBsZXQgcmVtb3ZlTW9uaXRvcjtcclxuICAgICAgICAgICAgbGV0IHN0YWNrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVha2FnZU1vbiAmJiB0aGlzLl9zaXplID49IE1hdGguY2VpbCh0aGlzLl9sZWFrYWdlTW9uLnRocmVzaG9sZCAqIDAuMikpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGFuZCByZWNvcmQgdGhpcyBlbWl0dGVyIGZvciBwb3RlbnRpYWwgbGVha2FnZVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVkLnN0YWNrID0gU3RhY2t0cmFjZS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZU1vbml0b3IgPSB0aGlzLl9sZWFrYWdlTW9uLmNoZWNrKGNvbnRhaW5lZC5zdGFjaywgdGhpcy5fc2l6ZSArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlRGlzcG9zZVdpdGhMaXN0ZW5lcldhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lZC5zdGFjayA9IHN0YWNrICE9PSBudWxsICYmIHN0YWNrICE9PSB2b2lkIDAgPyBzdGFjayA6IFN0YWNrdHJhY2UuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vbldpbGxBZGRGaXJzdExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBjb250YWluZWQ7XHJcbiAgICAgICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uub25EaWRBZGRGaXJzdExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fbGlzdGVuZXJzIGluc3RhbmNlb2YgVW5pcXVlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAoX2cgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAodGhpcy5fZGVsaXZlcnlRdWV1ZSA9IG5ldyBFdmVudERlbGl2ZXJ5UXVldWVQcml2YXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW3RoaXMuX2xpc3RlbmVycywgY29udGFpbmVkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGNvbnRhaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0b0Rpc3Bvc2FibGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2xpc3RlbmVyRmluYWxpemVycyA9PT0gbnVsbCB8fCBfbGlzdGVuZXJGaW5hbGl6ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGlzdGVuZXJGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZU1vbml0b3IgPT09IG51bGwgfHwgcmVtb3ZlTW9uaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVtb3ZlTW9uaXRvcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIoY29udGFpbmVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChkaXNwb3NhYmxlcyBpbnN0YW5jZW9mIERpc3Bvc2FibGVTdG9yZSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVyRmluYWxpemVycykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMikuam9pbignXFxuJykudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgX2xpc3RlbmVyRmluYWxpemVycy5yZWdpc3RlcihyZXN1bHQsIHN0YWNrLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbldpbGxSZW1vdmVMaXN0ZW5lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gZXhwZWN0ZWQgaWYgYSBsaXN0ZW5lciBnZXRzIGRpc3Bvc2VkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9zaXplID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNpemUgPiAxIHdoaWNoIHJlcXVpcmVzIHRoYXQgbGlzdGVuZXJzIGJlIGEgbGlzdDpcclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGlzcG9zZWQ/JywgdGhpcy5fZGlzcG9zZWQpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc2l6ZT8nLCB0aGlzLl9zaXplKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Fycj8nLCBKU09OLnN0cmluZ2lmeSh0aGlzLl9saXN0ZW5lcnMpKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gZGlzcG9zZSB1bmtub3duIGxpc3RlbmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGFkanVzdERlbGl2ZXJ5UXVldWUgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlLmN1cnJlbnQgPT09IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemUgKiBjb21wYWN0aW9uVGhyZXNob2xkIDw9IGxpc3RlbmVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tuKytdID0gbGlzdGVuZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWRqdXN0RGVsaXZlcnlRdWV1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUuZW5kLS07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPCB0aGlzLl9kZWxpdmVyeVF1ZXVlLmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5pLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5sZW5ndGggPSBuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kZWxpdmVyKGxpc3RlbmVyLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkxpc3RlbmVyRXJyb3IpIHx8IG9uVW5leHBlY3RlZEVycm9yO1xyXG4gICAgICAgIGlmICghZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyLnZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lci52YWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogRGVsaXZlcnMgaXRlbXMgaW4gdGhlIHF1ZXVlLiBBc3N1bWVzIHRoZSBxdWV1ZSBpcyByZWFkeSB0byBnby4gKi9cclxuICAgIF9kZWxpdmVyUXVldWUoZHEpIHtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBkcS5jdXJyZW50Ll9saXN0ZW5lcnM7XHJcbiAgICAgICAgd2hpbGUgKGRxLmkgPCBkcS5lbmQpIHtcclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBkcS5pIGlzIGluY3JlbWVudGVkIGJlZm9yZSBjYWxsaW5nIGRlbGl2ZXIoKSBiZWNhdXNlIGl0IG1pZ2h0IHJlZW50ZXIgZGVsaXZlclF1ZXVlKClcclxuICAgICAgICAgICAgdGhpcy5fZGVsaXZlcihsaXN0ZW5lcnNbZHEuaSsrXSwgZHEudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcS5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xyXG4gICAgICogc3Vic2NyaWJlcnNcclxuICAgICAqL1xyXG4gICAgZmlyZShldmVudCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5fZGVsaXZlcnlRdWV1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsaXZlclF1ZXVlKHRoaXMuX2RlbGl2ZXJ5UXVldWUpO1xyXG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpOyAvLyBsYXN0IGZpcmUoKSB3aWxsIGhhdmUgc3RhcnRpbmcgcGVyZm1vbiwgc3RvcCBpdCBiZWZvcmUgc3RhcnRpbmcgdGhlIG5leHQgZGlzcGF0Y2hcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9jID0gdGhpcy5fcGVyZk1vbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXJ0KHRoaXMuX3NpemUpO1xyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIC8vIG5vLW9wXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2xpc3RlbmVycyBpbnN0YW5jZW9mIFVuaXF1ZUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxpdmVyKHRoaXMuX2xpc3RlbmVycywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZHEgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlO1xyXG4gICAgICAgICAgICBkcS5lbnF1ZXVlKHRoaXMsIGV2ZW50LCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVsaXZlclF1ZXVlKGRxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9kID0gdGhpcy5fcGVyZk1vbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnN0b3AoKTtcclxuICAgIH1cclxuICAgIGhhc0xpc3RlbmVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSA+IDA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUV2ZW50RGVsaXZlcnlRdWV1ZSA9ICgpID0+IG5ldyBFdmVudERlbGl2ZXJ5UXVldWVQcml2YXRlKCk7XHJcbmNsYXNzIEV2ZW50RGVsaXZlcnlRdWV1ZVByaXZhdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kZXggaW4gY3VycmVudCdzIGxpc3RlbmVyIGxpc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxhc3QgaW5kZXggaW4gdGhlIGxpc3RlbmVyJ3MgbGlzdCB0byBkZWxpdmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW5kID0gMDtcclxuICAgIH1cclxuICAgIGVucXVldWUoZW1pdHRlciwgdmFsdWUsIGVuZCkge1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gZW1pdHRlcjtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmkgPSB0aGlzLmVuZDsgLy8gZm9yY2UgYW55IGN1cnJlbnQgZW1pc3Npb24gbG9vcCB0byBzdG9wLCBtYWlubHkgZm9yIGR1cmluZyBkaXNwb3NlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFBhdXNlYWJsZUVtaXR0ZXIgZXh0ZW5kcyBFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbiAgICAgICAgdGhpcy5fbWVyZ2VGbiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXJnZTtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkKys7XHJcbiAgICB9XHJcbiAgICByZXN1bWUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkICE9PSAwICYmIC0tdGhpcy5faXNQYXVzZWQgPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21lcmdlRm4pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgbWVyZ2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2luZ2xlIGNvbXBvc2l0ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQuIG1ha2UgYSBjb3B5IGluIGNhc2UgZmlyaW5nIHBhdXNlcyB0aGlzIGVtaXR0ZXJcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudFF1ZXVlLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh0aGlzLl9ldmVudFF1ZXVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudFF1ZXVlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZmlyZSh0aGlzLl9tZXJnZUZuKGV2ZW50cykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbWVyZ2luZywgZmlyZSBlYWNoIGV2ZW50IGluZGl2aWR1YWxseSBhbmQgdGVzdFxyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGVtaXR0ZXIgaXNuJ3QgcGF1c2VkIGhhbGZ3YXkgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLl9pc1BhdXNlZCAmJiB0aGlzLl9ldmVudFF1ZXVlLnNpemUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBlci5maXJlKHRoaXMuX2V2ZW50UXVldWUuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaXJlKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VwZXIuZmlyZShldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIERlYm91bmNlRW1pdHRlciBleHRlbmRzIFBhdXNlYWJsZUVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9kZWxheSA9IChfYSA9IG9wdGlvbnMuZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwMDtcclxuICAgIH1cclxuICAgIGZpcmUoZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5maXJlKGV2ZW50KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gZW1pdHRlciB3aGljaCBxdWV1ZSBhbGwgZXZlbnRzIGFuZCB0aGVuIHByb2Nlc3MgdGhlbSBhdCB0aGVcclxuICogZW5kIG9mIHRoZSBldmVudCBsb29wLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1pY3JvdGFza0VtaXR0ZXIgZXh0ZW5kcyBFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9xdWV1ZWRFdmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9tZXJnZUZuID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lcmdlO1xyXG4gICAgfVxyXG4gICAgZmlyZShldmVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgICAgICBpZiAodGhpcy5fcXVldWVkRXZlbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWVyZ2VGbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmZpcmUodGhpcy5fbWVyZ2VGbih0aGlzLl9xdWV1ZWRFdmVudHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cy5mb3JFYWNoKGUgPT4gc3VwZXIuZmlyZShlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZWRFdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBldmVudCBlbWl0dGVyIHRoYXQgbXVsdGlwbGV4ZXMgbWFueSBldmVudHMgaW50byBhIHNpbmdsZSBldmVudC5cclxuICpcclxuICogQGV4YW1wbGUgTGlzdGVuIHRvIHRoZSBgb25EYXRhYCBldmVudCBvZiBhbGwgYFRoaW5nYHMsIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgYFRoaW5nYHNcclxuICogdG8gdGhlIG11bHRpcGxleGVyIGFzIG5lZWRlZC5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBhbnl0aGluZ0RhdGFNdWx0aXBsZXhlciA9IG5ldyBFdmVudE11bHRpcGxleGVyPHsgZGF0YTogc3RyaW5nIH0+KCk7XHJcbiAqXHJcbiAqIGNvbnN0IHRoaW5nTGlzdGVuZXJzID0gRGlzcG9zYWJsZU1hcDxUaGluZywgSURpc3Bvc2FibGU+KCk7XHJcbiAqXHJcbiAqIHRoaW5nU2VydmljZS5vbkRpZEFkZFRoaW5nKHRoaW5nID0+IHtcclxuICogICB0aGluZ0xpc3RlbmVycy5zZXQodGhpbmcsIGFueXRoaW5nRGF0YU11bHRpcGxleGVyLmFkZCh0aGluZy5vbkRhdGEpO1xyXG4gKiB9KTtcclxuICogdGhpbmdTZXJ2aWNlLm9uRGlkUmVtb3ZlVGhpbmcodGhpbmcgPT4ge1xyXG4gKiAgIHRoaW5nTGlzdGVuZXJzLmRlbGV0ZUFuZERpc3Bvc2UodGhpbmcpO1xyXG4gKiB9KTtcclxuICpcclxuICogYW55dGhpbmdEYXRhTXVsdGlwbGV4ZXIuZXZlbnQoZSA9PiB7XHJcbiAqICAgY29uc29sZS5sb2coJ1NvbWV0aGluZyBmaXJlZCBkYXRhICcgKyBlLmRhdGEpXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudE11bHRpcGxleGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaGFzTGlzdGVuZXJzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcih7XHJcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6ICgpID0+IHRoaXMub25GaXJzdExpc3RlbmVyQWRkKCksXHJcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiAoKSA9PiB0aGlzLm9uTGFzdExpc3RlbmVyUmVtb3ZlKClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBldmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgYWRkKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgZSA9IHsgZXZlbnQ6IGV2ZW50LCBsaXN0ZW5lcjogbnVsbCB9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG9vayhlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaG9vayhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmV2ZW50cy5pbmRleE9mKGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0b0Rpc3Bvc2FibGUoY3JlYXRlU2luZ2xlQ2FsbEZ1bmN0aW9uKGRpc3Bvc2UpKTtcclxuICAgIH1cclxuICAgIG9uRmlyc3RMaXN0ZW5lckFkZCgpIHtcclxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVycyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChlID0+IHRoaXMuaG9vayhlKSk7XHJcbiAgICB9XHJcbiAgICBvbkxhc3RMaXN0ZW5lclJlbW92ZSgpIHtcclxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVycyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZSA9PiB0aGlzLnVuaG9vayhlKSk7XHJcbiAgICB9XHJcbiAgICBob29rKGUpIHtcclxuICAgICAgICBlLmxpc3RlbmVyID0gZS5ldmVudChyID0+IHRoaXMuZW1pdHRlci5maXJlKHIpKTtcclxuICAgIH1cclxuICAgIHVuaG9vayhlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IGUubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XHJcbiAgICAgICAgZS5saXN0ZW5lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmV2ZW50cykge1xyXG4gICAgICAgICAgICAoX2EgPSBlLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgRXZlbnRCdWZmZXJlciBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyBpbiB3aGljaCB5b3Ugd2FudFxyXG4gKiB0byBkZWxheSBmaXJpbmcgeW91ciBldmVudHMgZHVyaW5nIHNvbWUgY29kZS5cclxuICogWW91IGNhbiB3cmFwIHRoYXQgY29kZSBhbmQgYmUgc3VyZSB0aGF0IHRoZSBldmVudCB3aWxsIG5vdFxyXG4gKiBiZSBmaXJlZCBkdXJpbmcgdGhhdCB3cmFwLlxyXG4gKlxyXG4gKiBgYGBcclxuICogY29uc3QgZW1pdHRlcjogRW1pdHRlcjtcclxuICogY29uc3QgZGVsYXllciA9IG5ldyBFdmVudERlbGF5ZXIoKTtcclxuICogY29uc3QgZGVsYXllZEV2ZW50ID0gZGVsYXllci53cmFwRXZlbnQoZW1pdHRlci5ldmVudCk7XHJcbiAqXHJcbiAqIGRlbGF5ZWRFdmVudChjb25zb2xlLmxvZyk7XHJcbiAqXHJcbiAqIGRlbGF5ZXIuYnVmZmVyRXZlbnRzKCgpID0+IHtcclxuICogICBlbWl0dGVyLmZpcmUoKTsgLy8gZXZlbnQgd2lsbCBub3QgYmUgZmlyZWQgeWV0XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyBldmVudCB3aWxsIG9ubHkgYmUgZmlyZWQgYXQgdGhpcyBwb2ludFxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudEJ1ZmZlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgfVxyXG4gICAgd3JhcEV2ZW50KGV2ZW50LCByZWR1Y2UsIGluaXRpYWwpIHtcclxuICAgICAgICByZXR1cm4gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50KGkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAvLyBOb24tcmVkdWNlIHNjZW5hcmlvXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZHVjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1ZmZlcmluZyBjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5idWZmZXJzLnB1c2goKCkgPT4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGJ1ZmZlcmluZyBjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZWR1Y2Ugc2NlbmFyaW9cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZHVjZURhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IGJ1ZmZlcmluZyBjYXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZHVjZURhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIHdheSB0byBjYWNoZSB0aGlzIHJlZHVjZSBjYWxsIGZvciBhbGwgbGlzdGVuZXJzP1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIHJlZHVjZShpbml0aWFsLCBpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQnVmZmVyaW5nIGNhc2VcclxuICAgICAgICAgICAgICAgIChfYSA9IHJlZHVjZURhdGEuaXRlbXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChyZWR1Y2VEYXRhLml0ZW1zID0gW10pO1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlRGF0YS5pdGVtcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZURhdGEuYnVmZmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIGEgc2luZ2xlIGJ1ZmZlcmVkIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWR1Y2UgYWxsIGV2ZW50cyB3aGVuIHdlJ3JlIGRvbmUgYnVmZmVyaW5nIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYnVmZmVycy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSB0aGUgcmVkdWNlZCByZXN1bHQgc28gdGhhdCB0aGUgdmFsdWUgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgYWxsIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSByZWR1Y2VEYXRhLnJlZHVjZWRSZXN1bHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChyZWR1Y2VEYXRhLnJlZHVjZWRSZXN1bHQgPSBpbml0aWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlZHVjZURhdGEuaXRlbXMucmVkdWNlKHJlZHVjZSwgaW5pdGlhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVkdWNlRGF0YS5pdGVtcy5yZWR1Y2UocmVkdWNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIHJlZHVjZURhdGEucmVkdWNlZFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBidWZmZXJFdmVudHMoZm4pIHtcclxuICAgICAgICBjb25zdCBkYXRhID0geyBidWZmZXJzOiBuZXcgQXJyYXkoKSB9O1xyXG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHIgPSBmbigpO1xyXG4gICAgICAgIHRoaXMuZGF0YS5wb3AoKTtcclxuICAgICAgICBkYXRhLmJ1ZmZlcnMuZm9yRWFjaChmbHVzaCA9PiBmbHVzaCgpKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBSZWxheSBpcyBhbiBldmVudCBmb3J3YXJkZXIgd2hpY2ggZnVuY3Rpb25zIGFzIGEgcmVwbHVnYWJibGUgZXZlbnQgcGlwZS5cclxuICogT25jZSBjcmVhdGVkLCB5b3UgY2FuIGNvbm5lY3QgYW4gaW5wdXQgZXZlbnQgdG8gaXQgYW5kIGl0IHdpbGwgc2ltcGx5IGZvcndhcmRcclxuICogZXZlbnRzIGZyb20gdGhhdCBpbnB1dCBldmVudCB0aHJvdWdoIGl0cyBvd24gYGV2ZW50YCBwcm9wZXJ0eS4gVGhlIGBpbnB1dGBcclxuICogY2FuIGJlIGNoYW5nZWQgYXQgYW55IHBvaW50IGluIHRpbWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVsYXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlucHV0RXZlbnQgPSBFdmVudC5Ob25lO1xyXG4gICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyID0gRGlzcG9zYWJsZS5Ob25lO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcclxuICAgICAgICAgICAgb25EaWRBZGRGaXJzdExpc3RlbmVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lciA9IHRoaXMuaW5wdXRFdmVudCh0aGlzLmVtaXR0ZXIuZmlyZSwgdGhpcy5lbWl0dGVyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25EaWRSZW1vdmVMYXN0TGlzdGVuZXI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdGhpcy5lbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgc2V0IGlucHV0KGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIgPSBldmVudCh0aGlzLmVtaXR0ZXIuZmlyZSwgdGhpcy5lbWl0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/event.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/functional.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/functional.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSingleCallFunction: () => (/* binding */ createSingleCallFunction)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * Given a function, returns a function that is only calling that function once.\r\n */\r\nfunction createSingleCallFunction(fn, fnDidRunCallback) {\r\n    const _this = this;\r\n    let didCall = false;\r\n    let result;\r\n    return function () {\r\n        if (didCall) {\r\n            return result;\r\n        }\r\n        didCall = true;\r\n        if (fnDidRunCallback) {\r\n            try {\r\n                result = fn.apply(_this, arguments);\r\n            }\r\n            finally {\r\n                fnDidRunCallback();\r\n            }\r\n        }\r\n        else {\r\n            result = fn.apply(_this, arguments);\r\n        }\r\n        return result;\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZnVuY3Rpb25hbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2Z1bmN0aW9uYWwuanM/MGJmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLyoqXHJcbiAqIEdpdmVuIGEgZnVuY3Rpb24sIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIG9ubHkgY2FsbGluZyB0aGF0IGZ1bmN0aW9uIG9uY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2luZ2xlQ2FsbEZ1bmN0aW9uKGZuLCBmbkRpZFJ1bkNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XHJcbiAgICBsZXQgZGlkQ2FsbCA9IGZhbHNlO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGRpZENhbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGZuRGlkUnVuQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgZm5EaWRSdW5DYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/functional.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/hash.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringSHA1: () => (/* binding */ StringSHA1),\n/* harmony export */   doHash: () => (/* binding */ doHash),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   numberHash: () => (/* binding */ numberHash),\n/* harmony export */   stringHash: () => (/* binding */ stringHash),\n/* harmony export */   toHexString: () => (/* binding */ toHexString)\n/* harmony export */ });\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Return a hash value for an object.\r\n */\r\nfunction hash(obj) {\r\n    return doHash(obj, 0);\r\n}\r\nfunction doHash(obj, hashVal) {\r\n    switch (typeof obj) {\r\n        case 'object':\r\n            if (obj === null) {\r\n                return numberHash(349, hashVal);\r\n            }\r\n            else if (Array.isArray(obj)) {\r\n                return arrayHash(obj, hashVal);\r\n            }\r\n            return objectHash(obj, hashVal);\r\n        case 'string':\r\n            return stringHash(obj, hashVal);\r\n        case 'boolean':\r\n            return booleanHash(obj, hashVal);\r\n        case 'number':\r\n            return numberHash(obj, hashVal);\r\n        case 'undefined':\r\n            return numberHash(937, hashVal);\r\n        default:\r\n            return numberHash(617, hashVal);\r\n    }\r\n}\r\nfunction numberHash(val, initialHashVal) {\r\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\r\n}\r\nfunction booleanHash(b, initialHashVal) {\r\n    return numberHash(b ? 433 : 863, initialHashVal);\r\n}\r\nfunction stringHash(s, hashVal) {\r\n    hashVal = numberHash(149417, hashVal);\r\n    for (let i = 0, length = s.length; i < length; i++) {\r\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\r\n    }\r\n    return hashVal;\r\n}\r\nfunction arrayHash(arr, initialHashVal) {\r\n    initialHashVal = numberHash(104579, initialHashVal);\r\n    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\r\n}\r\nfunction objectHash(obj, initialHashVal) {\r\n    initialHashVal = numberHash(181387, initialHashVal);\r\n    return Object.keys(obj).sort().reduce((hashVal, key) => {\r\n        hashVal = stringHash(key, hashVal);\r\n        return doHash(obj[key], hashVal);\r\n    }, initialHashVal);\r\n}\r\nfunction leftRotate(value, bits, totalBits = 32) {\r\n    // delta + bits = totalBits\r\n    const delta = totalBits - bits;\r\n    // All ones, expect `delta` zeros aligned to the right\r\n    const mask = ~((1 << delta) - 1);\r\n    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\r\n    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;\r\n}\r\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\r\n    for (let i = 0; i < count; i++) {\r\n        dest[index + i] = value;\r\n    }\r\n}\r\nfunction leftPad(value, length, char = '0') {\r\n    while (value.length < length) {\r\n        value = char + value;\r\n    }\r\n    return value;\r\n}\r\nfunction toHexString(bufferOrValue, bitsize = 32) {\r\n    if (bufferOrValue instanceof ArrayBuffer) {\r\n        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\r\n    }\r\n    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\r\n}\r\n/**\r\n * A SHA1 implementation that works with strings and does not allocate.\r\n */\r\nclass StringSHA1 {\r\n    constructor() {\r\n        this._h0 = 0x67452301;\r\n        this._h1 = 0xEFCDAB89;\r\n        this._h2 = 0x98BADCFE;\r\n        this._h3 = 0x10325476;\r\n        this._h4 = 0xC3D2E1F0;\r\n        this._buff = new Uint8Array(64 /* SHA1Constant.BLOCK_SIZE */ + 3 /* to fit any utf-8 */);\r\n        this._buffDV = new DataView(this._buff.buffer);\r\n        this._buffLen = 0;\r\n        this._totalLen = 0;\r\n        this._leftoverHighSurrogate = 0;\r\n        this._finished = false;\r\n    }\r\n    update(str) {\r\n        const strLen = str.length;\r\n        if (strLen === 0) {\r\n            return;\r\n        }\r\n        const buff = this._buff;\r\n        let buffLen = this._buffLen;\r\n        let leftoverHighSurrogate = this._leftoverHighSurrogate;\r\n        let charCode;\r\n        let offset;\r\n        if (leftoverHighSurrogate !== 0) {\r\n            charCode = leftoverHighSurrogate;\r\n            offset = -1;\r\n            leftoverHighSurrogate = 0;\r\n        }\r\n        else {\r\n            charCode = str.charCodeAt(0);\r\n            offset = 0;\r\n        }\r\n        while (true) {\r\n            let codePoint = charCode;\r\n            if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isHighSurrogate(charCode)) {\r\n                if (offset + 1 < strLen) {\r\n                    const nextCharCode = str.charCodeAt(offset + 1);\r\n                    if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(nextCharCode)) {\r\n                        offset++;\r\n                        codePoint = _strings_js__WEBPACK_IMPORTED_MODULE_0__.computeCodePoint(charCode, nextCharCode);\r\n                    }\r\n                    else {\r\n                        // illegal => unicode replacement character\r\n                        codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;\r\n                    }\r\n                }\r\n                else {\r\n                    // last character is a surrogate pair\r\n                    leftoverHighSurrogate = charCode;\r\n                    break;\r\n                }\r\n            }\r\n            else if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(charCode)) {\r\n                // illegal => unicode replacement character\r\n                codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;\r\n            }\r\n            buffLen = this._push(buff, buffLen, codePoint);\r\n            offset++;\r\n            if (offset < strLen) {\r\n                charCode = str.charCodeAt(offset);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        this._buffLen = buffLen;\r\n        this._leftoverHighSurrogate = leftoverHighSurrogate;\r\n    }\r\n    _push(buff, buffLen, codePoint) {\r\n        if (codePoint < 0x0080) {\r\n            buff[buffLen++] = codePoint;\r\n        }\r\n        else if (codePoint < 0x0800) {\r\n            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\r\n        }\r\n        else if (codePoint < 0x10000) {\r\n            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\r\n        }\r\n        else {\r\n            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\r\n        }\r\n        if (buffLen >= 64 /* SHA1Constant.BLOCK_SIZE */) {\r\n            this._step();\r\n            buffLen -= 64 /* SHA1Constant.BLOCK_SIZE */;\r\n            this._totalLen += 64 /* SHA1Constant.BLOCK_SIZE */;\r\n            // take last 3 in case of UTF8 overflow\r\n            buff[0] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 0];\r\n            buff[1] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 1];\r\n            buff[2] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 2];\r\n        }\r\n        return buffLen;\r\n    }\r\n    digest() {\r\n        if (!this._finished) {\r\n            this._finished = true;\r\n            if (this._leftoverHighSurrogate) {\r\n                // illegal => unicode replacement character\r\n                this._leftoverHighSurrogate = 0;\r\n                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* SHA1Constant.UNICODE_REPLACEMENT */);\r\n            }\r\n            this._totalLen += this._buffLen;\r\n            this._wrapUp();\r\n        }\r\n        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\r\n    }\r\n    _wrapUp() {\r\n        this._buff[this._buffLen++] = 0x80;\r\n        fill(this._buff, this._buffLen);\r\n        if (this._buffLen > 56) {\r\n            this._step();\r\n            fill(this._buff);\r\n        }\r\n        // this will fit because the mantissa can cover up to 52 bits\r\n        const ml = 8 * this._totalLen;\r\n        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\r\n        this._buffDV.setUint32(60, ml % 4294967296, false);\r\n        this._step();\r\n    }\r\n    _step() {\r\n        const bigBlock32 = StringSHA1._bigBlock32;\r\n        const data = this._buffDV;\r\n        for (let j = 0; j < 64 /* 16*4 */; j += 4) {\r\n            bigBlock32.setUint32(j, data.getUint32(j, false), false);\r\n        }\r\n        for (let j = 64; j < 320 /* 80*4 */; j += 4) {\r\n            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\r\n        }\r\n        let a = this._h0;\r\n        let b = this._h1;\r\n        let c = this._h2;\r\n        let d = this._h3;\r\n        let e = this._h4;\r\n        let f, k;\r\n        let temp;\r\n        for (let j = 0; j < 80; j++) {\r\n            if (j < 20) {\r\n                f = (b & c) | ((~b) & d);\r\n                k = 0x5A827999;\r\n            }\r\n            else if (j < 40) {\r\n                f = b ^ c ^ d;\r\n                k = 0x6ED9EBA1;\r\n            }\r\n            else if (j < 60) {\r\n                f = (b & c) | (b & d) | (c & d);\r\n                k = 0x8F1BBCDC;\r\n            }\r\n            else {\r\n                f = b ^ c ^ d;\r\n                k = 0xCA62C1D6;\r\n            }\r\n            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = leftRotate(b, 30);\r\n            b = a;\r\n            a = temp;\r\n        }\r\n        this._h0 = (this._h0 + a) & 0xffffffff;\r\n        this._h1 = (this._h1 + b) & 0xffffffff;\r\n        this._h2 = (this._h2 + c) & 0xffffffff;\r\n        this._h3 = (this._h3 + d) & 0xffffffff;\r\n        this._h4 = (this._h4 + e) & 0xffffffff;\r\n    }\r\n}\r\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0IsdURBQXNCO0FBQzlDO0FBQ0Esb0NBQW9DLHlEQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdURBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9oYXNoLmpzP2VkYTciXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi9zdHJpbmdzLmpzJztcclxuLyoqXHJcbiAqIFJldHVybiBhIGhhc2ggdmFsdWUgZm9yIGFuIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNoKG9iaikge1xyXG4gICAgcmV0dXJuIGRvSGFzaChvYmosIDApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkb0hhc2gob2JqLCBoYXNoVmFsKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcclxuICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCgzNDksIGhhc2hWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5SGFzaChvYmosIGhhc2hWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RIYXNoKG9iaiwgaGFzaFZhbCk7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0hhc2gob2JqLCBoYXNoVmFsKTtcclxuICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5IYXNoKG9iaiwgaGFzaFZhbCk7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2gob2JqLCBoYXNoVmFsKTtcclxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCg5MzcsIGhhc2hWYWwpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKDYxNywgaGFzaFZhbCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckhhc2godmFsLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgcmV0dXJuICgoKGluaXRpYWxIYXNoVmFsIDw8IDUpIC0gaW5pdGlhbEhhc2hWYWwpICsgdmFsKSB8IDA7IC8vIGhhc2hWYWwgKiAzMSArIGNoLCBrZWVwIGFzIGludDMyXHJcbn1cclxuZnVuY3Rpb24gYm9vbGVhbkhhc2goYiwgaW5pdGlhbEhhc2hWYWwpIHtcclxuICAgIHJldHVybiBudW1iZXJIYXNoKGIgPyA0MzMgOiA4NjMsIGluaXRpYWxIYXNoVmFsKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nSGFzaChzLCBoYXNoVmFsKSB7XHJcbiAgICBoYXNoVmFsID0gbnVtYmVySGFzaCgxNDk0MTcsIGhhc2hWYWwpO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBoYXNoVmFsID0gbnVtYmVySGFzaChzLmNoYXJDb2RlQXQoaSksIGhhc2hWYWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc2hWYWw7XHJcbn1cclxuZnVuY3Rpb24gYXJyYXlIYXNoKGFyciwgaW5pdGlhbEhhc2hWYWwpIHtcclxuICAgIGluaXRpYWxIYXNoVmFsID0gbnVtYmVySGFzaCgxMDQ1NzksIGluaXRpYWxIYXNoVmFsKTtcclxuICAgIHJldHVybiBhcnIucmVkdWNlKChoYXNoVmFsLCBpdGVtKSA9PiBkb0hhc2goaXRlbSwgaGFzaFZhbCksIGluaXRpYWxIYXNoVmFsKTtcclxufVxyXG5mdW5jdGlvbiBvYmplY3RIYXNoKG9iaiwgaW5pdGlhbEhhc2hWYWwpIHtcclxuICAgIGluaXRpYWxIYXNoVmFsID0gbnVtYmVySGFzaCgxODEzODcsIGluaXRpYWxIYXNoVmFsKTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5yZWR1Y2UoKGhhc2hWYWwsIGtleSkgPT4ge1xyXG4gICAgICAgIGhhc2hWYWwgPSBzdHJpbmdIYXNoKGtleSwgaGFzaFZhbCk7XHJcbiAgICAgICAgcmV0dXJuIGRvSGFzaChvYmpba2V5XSwgaGFzaFZhbCk7XHJcbiAgICB9LCBpbml0aWFsSGFzaFZhbCk7XHJcbn1cclxuZnVuY3Rpb24gbGVmdFJvdGF0ZSh2YWx1ZSwgYml0cywgdG90YWxCaXRzID0gMzIpIHtcclxuICAgIC8vIGRlbHRhICsgYml0cyA9IHRvdGFsQml0c1xyXG4gICAgY29uc3QgZGVsdGEgPSB0b3RhbEJpdHMgLSBiaXRzO1xyXG4gICAgLy8gQWxsIG9uZXMsIGV4cGVjdCBgZGVsdGFgIHplcm9zIGFsaWduZWQgdG8gdGhlIHJpZ2h0XHJcbiAgICBjb25zdCBtYXNrID0gfigoMSA8PCBkZWx0YSkgLSAxKTtcclxuICAgIC8vIEpvaW4gKHZhbHVlIGxlZnQtc2hpZnRlZCBgYml0c2AgYml0cykgd2l0aCAobWFza2VkIHZhbHVlIHJpZ2h0LXNoaWZ0ZWQgYGRlbHRhYCBiaXRzKVxyXG4gICAgcmV0dXJuICgodmFsdWUgPDwgYml0cykgfCAoKG1hc2sgJiB2YWx1ZSkgPj4+IGRlbHRhKSkgPj4+IDA7XHJcbn1cclxuZnVuY3Rpb24gZmlsbChkZXN0LCBpbmRleCA9IDAsIGNvdW50ID0gZGVzdC5ieXRlTGVuZ3RoLCB2YWx1ZSA9IDApIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgIGRlc3RbaW5kZXggKyBpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxlZnRQYWQodmFsdWUsIGxlbmd0aCwgY2hhciA9ICcwJykge1xyXG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhbHVlID0gY2hhciArIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0b0hleFN0cmluZyhidWZmZXJPclZhbHVlLCBiaXRzaXplID0gMzIpIHtcclxuICAgIGlmIChidWZmZXJPclZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShidWZmZXJPclZhbHVlKSkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdFBhZCgoYnVmZmVyT3JWYWx1ZSA+Pj4gMCkudG9TdHJpbmcoMTYpLCBiaXRzaXplIC8gNCk7XHJcbn1cclxuLyoqXHJcbiAqIEEgU0hBMSBpbXBsZW1lbnRhdGlvbiB0aGF0IHdvcmtzIHdpdGggc3RyaW5ncyBhbmQgZG9lcyBub3QgYWxsb2NhdGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3RyaW5nU0hBMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9oMCA9IDB4Njc0NTIzMDE7XHJcbiAgICAgICAgdGhpcy5faDEgPSAweEVGQ0RBQjg5O1xyXG4gICAgICAgIHRoaXMuX2gyID0gMHg5OEJBRENGRTtcclxuICAgICAgICB0aGlzLl9oMyA9IDB4MTAzMjU0NzY7XHJcbiAgICAgICAgdGhpcy5faDQgPSAweEMzRDJFMUYwO1xyXG4gICAgICAgIHRoaXMuX2J1ZmYgPSBuZXcgVWludDhBcnJheSg2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLyArIDMgLyogdG8gZml0IGFueSB1dGYtOCAqLyk7XHJcbiAgICAgICAgdGhpcy5fYnVmZkRWID0gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmYuYnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9idWZmTGVuID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbExlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcclxuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHN0cikge1xyXG4gICAgICAgIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHN0ckxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSB0aGlzLl9idWZmO1xyXG4gICAgICAgIGxldCBidWZmTGVuID0gdGhpcy5fYnVmZkxlbjtcclxuICAgICAgICBsZXQgbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xyXG4gICAgICAgIGxldCBjaGFyQ29kZTtcclxuICAgICAgICBsZXQgb2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgIT09IDApIHtcclxuICAgICAgICAgICAgY2hhckNvZGUgPSBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IC0xO1xyXG4gICAgICAgICAgICBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgbGV0IGNvZGVQb2ludCA9IGNoYXJDb2RlO1xyXG4gICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgMSA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzLmlzTG93U3Vycm9nYXRlKG5leHRDaGFyQ29kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHN0cmluZ3MuY29tcHV0ZUNvZGVQb2ludChjaGFyQ29kZSwgbmV4dENoYXJDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsbGVnYWwgPT4gdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gNjU1MzMgLyogU0hBMUNvbnN0YW50LlVOSUNPREVfUkVQTEFDRU1FTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBjaGFyYWN0ZXIgaXMgYSBzdXJyb2dhdGUgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ3MuaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMyAvKiBTSEExQ29uc3RhbnQuVU5JQ09ERV9SRVBMQUNFTUVOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWZmTGVuID0gdGhpcy5fcHVzaChidWZmLCBidWZmTGVuLCBjb2RlUG9pbnQpO1xyXG4gICAgICAgICAgICBvZmZzZXQrKztcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYnVmZkxlbiA9IGJ1ZmZMZW47XHJcbiAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xyXG4gICAgfVxyXG4gICAgX3B1c2goYnVmZiwgYnVmZkxlbiwgY29kZVBvaW50KSB7XHJcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MDA4MCkge1xyXG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSBjb2RlUG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MDgwMCkge1xyXG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjExMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMDAwMDAwKSA+Pj4gNik7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEpID4+PiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjExMTAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAxMTExMDAwMDAwMDAwMDAwKSA+Pj4gMTIpO1xyXG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExMDAwMDAwKSA+Pj4gNik7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEpID4+PiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTExMTAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAxMTEwMDAwMDAwMDAwMDAwMDAwMDApID4+PiAxOCk7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDAwMDAwMDApID4+PiAxMik7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDApID4+PiA2KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZkxlbiA+PSA2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XHJcbiAgICAgICAgICAgIGJ1ZmZMZW4gLT0gNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi87XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IDY0IC8qIFNIQTFDb25zdGFudC5CTE9DS19TSVpFICovO1xyXG4gICAgICAgICAgICAvLyB0YWtlIGxhc3QgMyBpbiBjYXNlIG9mIFVURjggb3ZlcmZsb3dcclxuICAgICAgICAgICAgYnVmZlswXSA9IGJ1ZmZbNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8gKyAwXTtcclxuICAgICAgICAgICAgYnVmZlsxXSA9IGJ1ZmZbNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8gKyAxXTtcclxuICAgICAgICAgICAgYnVmZlsyXSA9IGJ1ZmZbNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8gKyAyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZMZW47XHJcbiAgICB9XHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlsbGVnYWwgPT4gdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmTGVuID0gdGhpcy5fcHVzaCh0aGlzLl9idWZmLCB0aGlzLl9idWZmTGVuLCA2NTUzMyAvKiBTSEExQ29uc3RhbnQuVU5JQ09ERV9SRVBMQUNFTUVOVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW4gKz0gdGhpcy5fYnVmZkxlbjtcclxuICAgICAgICAgICAgdGhpcy5fd3JhcFVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b0hleFN0cmluZyh0aGlzLl9oMCkgKyB0b0hleFN0cmluZyh0aGlzLl9oMSkgKyB0b0hleFN0cmluZyh0aGlzLl9oMikgKyB0b0hleFN0cmluZyh0aGlzLl9oMykgKyB0b0hleFN0cmluZyh0aGlzLl9oNCk7XHJcbiAgICB9XHJcbiAgICBfd3JhcFVwKCkge1xyXG4gICAgICAgIHRoaXMuX2J1ZmZbdGhpcy5fYnVmZkxlbisrXSA9IDB4ODA7XHJcbiAgICAgICAgZmlsbCh0aGlzLl9idWZmLCB0aGlzLl9idWZmTGVuKTtcclxuICAgICAgICBpZiAodGhpcy5fYnVmZkxlbiA+IDU2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAoKTtcclxuICAgICAgICAgICAgZmlsbCh0aGlzLl9idWZmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcyB3aWxsIGZpdCBiZWNhdXNlIHRoZSBtYW50aXNzYSBjYW4gY292ZXIgdXAgdG8gNTIgYml0c1xyXG4gICAgICAgIGNvbnN0IG1sID0gOCAqIHRoaXMuX3RvdGFsTGVuO1xyXG4gICAgICAgIHRoaXMuX2J1ZmZEVi5zZXRVaW50MzIoNTYsIE1hdGguZmxvb3IobWwgLyA0Mjk0OTY3Mjk2KSwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX2J1ZmZEVi5zZXRVaW50MzIoNjAsIG1sICUgNDI5NDk2NzI5NiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAoKTtcclxuICAgIH1cclxuICAgIF9zdGVwKCkge1xyXG4gICAgICAgIGNvbnN0IGJpZ0Jsb2NrMzIgPSBTdHJpbmdTSEExLl9iaWdCbG9jazMyO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9idWZmRFY7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2NCAvKiAxNio0ICovOyBqICs9IDQpIHtcclxuICAgICAgICAgICAgYmlnQmxvY2szMi5zZXRVaW50MzIoaiwgZGF0YS5nZXRVaW50MzIoaiwgZmFsc2UpLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGogPSA2NDsgaiA8IDMyMCAvKiA4MCo0ICovOyBqICs9IDQpIHtcclxuICAgICAgICAgICAgYmlnQmxvY2szMi5zZXRVaW50MzIoaiwgbGVmdFJvdGF0ZSgoYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDEyLCBmYWxzZSkgXiBiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gMzIsIGZhbHNlKSBeIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSA1NiwgZmFsc2UpIF4gYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDY0LCBmYWxzZSkpLCAxKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYSA9IHRoaXMuX2gwO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5faDE7XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLl9oMjtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuX2gzO1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5faDQ7XHJcbiAgICAgICAgbGV0IGYsIGs7XHJcbiAgICAgICAgbGV0IHRlbXA7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4MDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChqIDwgMjApIHtcclxuICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKCh+YikgJiBkKTtcclxuICAgICAgICAgICAgICAgIGsgPSAweDVBODI3OTk5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGogPCA0MCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgIGsgPSAweDZFRDlFQkExO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGogPCA2MCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcclxuICAgICAgICAgICAgICAgIGsgPSAweDhGMUJCQ0RDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgIGsgPSAweENBNjJDMUQ2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRlbXAgPSAobGVmdFJvdGF0ZShhLCA1KSArIGYgKyBlICsgayArIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogKiA0LCBmYWxzZSkpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgZSA9IGQ7XHJcbiAgICAgICAgICAgIGQgPSBjO1xyXG4gICAgICAgICAgICBjID0gbGVmdFJvdGF0ZShiLCAzMCk7XHJcbiAgICAgICAgICAgIGIgPSBhO1xyXG4gICAgICAgICAgICBhID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faDAgPSAodGhpcy5faDAgKyBhKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5faDEgPSAodGhpcy5faDEgKyBiKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5faDIgPSAodGhpcy5faDIgKyBjKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5faDMgPSAodGhpcy5faDMgKyBkKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5faDQgPSAodGhpcy5faDQgKyBlKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICB9XHJcbn1cclxuU3RyaW5nU0hBMS5fYmlnQmxvY2szMiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMzIwKSk7IC8vIDgwICogNCA9IDMyMFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/hash.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/iterator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Iterable: () => (/* binding */ Iterable)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar Iterable;\r\n(function (Iterable) {\r\n    function is(thing) {\r\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\r\n    }\r\n    Iterable.is = is;\r\n    const _empty = Object.freeze([]);\r\n    function empty() {\r\n        return _empty;\r\n    }\r\n    Iterable.empty = empty;\r\n    function* single(element) {\r\n        yield element;\r\n    }\r\n    Iterable.single = single;\r\n    function wrap(iterableOrElement) {\r\n        if (is(iterableOrElement)) {\r\n            return iterableOrElement;\r\n        }\r\n        else {\r\n            return single(iterableOrElement);\r\n        }\r\n    }\r\n    Iterable.wrap = wrap;\r\n    function from(iterable) {\r\n        return iterable || _empty;\r\n    }\r\n    Iterable.from = from;\r\n    function* reverse(array) {\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            yield array[i];\r\n        }\r\n    }\r\n    Iterable.reverse = reverse;\r\n    function isEmpty(iterable) {\r\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\r\n    }\r\n    Iterable.isEmpty = isEmpty;\r\n    function first(iterable) {\r\n        return iterable[Symbol.iterator]().next().value;\r\n    }\r\n    Iterable.first = first;\r\n    function some(iterable, predicate) {\r\n        for (const element of iterable) {\r\n            if (predicate(element)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    Iterable.some = some;\r\n    function find(iterable, predicate) {\r\n        for (const element of iterable) {\r\n            if (predicate(element)) {\r\n                return element;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    Iterable.find = find;\r\n    function* filter(iterable, predicate) {\r\n        for (const element of iterable) {\r\n            if (predicate(element)) {\r\n                yield element;\r\n            }\r\n        }\r\n    }\r\n    Iterable.filter = filter;\r\n    function* map(iterable, fn) {\r\n        let index = 0;\r\n        for (const element of iterable) {\r\n            yield fn(element, index++);\r\n        }\r\n    }\r\n    Iterable.map = map;\r\n    function* concat(...iterables) {\r\n        for (const iterable of iterables) {\r\n            yield* iterable;\r\n        }\r\n    }\r\n    Iterable.concat = concat;\r\n    function reduce(iterable, reducer, initialValue) {\r\n        let value = initialValue;\r\n        for (const element of iterable) {\r\n            value = reducer(value, element);\r\n        }\r\n        return value;\r\n    }\r\n    Iterable.reduce = reduce;\r\n    /**\r\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\r\n     */\r\n    function* slice(arr, from, to = arr.length) {\r\n        if (from < 0) {\r\n            from += arr.length;\r\n        }\r\n        if (to < 0) {\r\n            to += arr.length;\r\n        }\r\n        else if (to > arr.length) {\r\n            to = arr.length;\r\n        }\r\n        for (; from < to; from++) {\r\n            yield arr[from];\r\n        }\r\n    }\r\n    Iterable.slice = slice;\r\n    /**\r\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\r\n     * and an iterable for the rest of the elements.\r\n     */\r\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\r\n        const consumed = [];\r\n        if (atMost === 0) {\r\n            return [consumed, iterable];\r\n        }\r\n        const iterator = iterable[Symbol.iterator]();\r\n        for (let i = 0; i < atMost; i++) {\r\n            const next = iterator.next();\r\n            if (next.done) {\r\n                return [consumed, Iterable.empty()];\r\n            }\r\n            consumed.push(next.value);\r\n        }\r\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\r\n    }\r\n    Iterable.consume = consume;\r\n    async function asyncToArray(iterable) {\r\n        const result = [];\r\n        for await (const item of iterable) {\r\n            result.push(item);\r\n        }\r\n        return Promise.resolve(result);\r\n    }\r\n    Iterable.asyncToArray = asyncToArray;\r\n})(Iterable || (Iterable = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9pdGVyYXRvci5qcz8yNThhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgdmFyIEl0ZXJhYmxlO1xyXG4oZnVuY3Rpb24gKEl0ZXJhYmxlKSB7XHJcbiAgICBmdW5jdGlvbiBpcyh0aGluZykge1xyXG4gICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuaXMgPSBpcztcclxuICAgIGNvbnN0IF9lbXB0eSA9IE9iamVjdC5mcmVlemUoW10pO1xyXG4gICAgZnVuY3Rpb24gZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9lbXB0eTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmVtcHR5ID0gZW1wdHk7XHJcbiAgICBmdW5jdGlvbiogc2luZ2xlKGVsZW1lbnQpIHtcclxuICAgICAgICB5aWVsZCBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuc2luZ2xlID0gc2luZ2xlO1xyXG4gICAgZnVuY3Rpb24gd3JhcChpdGVyYWJsZU9yRWxlbWVudCkge1xyXG4gICAgICAgIGlmIChpcyhpdGVyYWJsZU9yRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlT3JFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZShpdGVyYWJsZU9yRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUud3JhcCA9IHdyYXA7XHJcbiAgICBmdW5jdGlvbiBmcm9tKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlIHx8IF9lbXB0eTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmZyb20gPSBmcm9tO1xyXG4gICAgZnVuY3Rpb24qIHJldmVyc2UoYXJyYXkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgeWllbGQgYXJyYXlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUucmV2ZXJzZSA9IHJldmVyc2U7XHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5KGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuICFpdGVyYWJsZSB8fCBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpLmRvbmUgPT09IHRydWU7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5pc0VtcHR5ID0gaXNFbXB0eTtcclxuICAgIGZ1bmN0aW9uIGZpcnN0KGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkudmFsdWU7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5maXJzdCA9IGZpcnN0O1xyXG4gICAgZnVuY3Rpb24gc29tZShpdGVyYWJsZSwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLnNvbWUgPSBzb21lO1xyXG4gICAgZnVuY3Rpb24gZmluZChpdGVyYWJsZSwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5maW5kID0gZmluZDtcclxuICAgIGZ1bmN0aW9uKiBmaWx0ZXIoaXRlcmFibGUsIHByZWRpY2F0ZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgZnVuY3Rpb24qIG1hcChpdGVyYWJsZSwgZm4pIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICB5aWVsZCBmbihlbGVtZW50LCBpbmRleCsrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5tYXAgPSBtYXA7XHJcbiAgICBmdW5jdGlvbiogY29uY2F0KC4uLml0ZXJhYmxlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKSB7XHJcbiAgICAgICAgICAgIHlpZWxkKiBpdGVyYWJsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5jb25jYXQgPSBjb25jYXQ7XHJcbiAgICBmdW5jdGlvbiByZWR1Y2UoaXRlcmFibGUsIHJlZHVjZXIsIGluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSByZWR1Y2VyKHZhbHVlLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUucmVkdWNlID0gcmVkdWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhYmxlIHNsaWNlIG9mIHRoZSBhcnJheSwgd2l0aCB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgYGFycmF5LnNsaWNlKClgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiogc2xpY2UoYXJyLCBmcm9tLCB0byA9IGFyci5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcclxuICAgICAgICAgICAgZnJvbSArPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG8gPCAwKSB7XHJcbiAgICAgICAgICAgIHRvICs9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRvID4gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0byA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBmcm9tIDwgdG87IGZyb20rKykge1xyXG4gICAgICAgICAgICB5aWVsZCBhcnJbZnJvbV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuc2xpY2UgPSBzbGljZTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3VtZXMgYGF0TW9zdGAgZWxlbWVudHMgZnJvbSBpdGVyYWJsZSBhbmQgcmV0dXJucyB0aGUgY29uc3VtZWQgZWxlbWVudHMsXHJcbiAgICAgKiBhbmQgYW4gaXRlcmFibGUgZm9yIHRoZSByZXN0IG9mIHRoZSBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29uc3VtZShpdGVyYWJsZSwgYXRNb3N0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XHJcbiAgICAgICAgY29uc3QgY29uc3VtZWQgPSBbXTtcclxuICAgICAgICBpZiAoYXRNb3N0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29uc3VtZWQsIGl0ZXJhYmxlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdE1vc3Q7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCBJdGVyYWJsZS5lbXB0eSgpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdW1lZC5wdXNoKG5leHQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCB7IFtTeW1ib2wuaXRlcmF0b3JdKCkgeyByZXR1cm4gaXRlcmF0b3I7IH0gfV07XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5jb25zdW1lID0gY29uc3VtZTtcclxuICAgIGFzeW5jIGZ1bmN0aW9uIGFzeW5jVG9BcnJheShpdGVyYWJsZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuYXN5bmNUb0FycmF5ID0gYXN5bmNUb0FycmF5O1xyXG59KShJdGVyYWJsZSB8fCAoSXRlcmFibGUgPSB7fSkpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/iterator.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EVENT_KEY_CODE_MAP: () => (/* binding */ EVENT_KEY_CODE_MAP),\n/* harmony export */   IMMUTABLE_CODE_TO_KEY_CODE: () => (/* binding */ IMMUTABLE_CODE_TO_KEY_CODE),\n/* harmony export */   IMMUTABLE_KEY_CODE_TO_CODE: () => (/* binding */ IMMUTABLE_KEY_CODE_TO_CODE),\n/* harmony export */   KeyChord: () => (/* binding */ KeyChord),\n/* harmony export */   KeyCodeUtils: () => (/* binding */ KeyCodeUtils),\n/* harmony export */   NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE: () => (/* binding */ NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass KeyCodeStrMap {\r\n    constructor() {\r\n        this._keyCodeToStr = [];\r\n        this._strToKeyCode = Object.create(null);\r\n    }\r\n    define(keyCode, str) {\r\n        this._keyCodeToStr[keyCode] = str;\r\n        this._strToKeyCode[str.toLowerCase()] = keyCode;\r\n    }\r\n    keyCodeToStr(keyCode) {\r\n        return this._keyCodeToStr[keyCode];\r\n    }\r\n    strToKeyCode(str) {\r\n        return this._strToKeyCode[str.toLowerCase()] || 0 /* KeyCode.Unknown */;\r\n    }\r\n}\r\nconst uiMap = new KeyCodeStrMap();\r\nconst userSettingsUSMap = new KeyCodeStrMap();\r\nconst userSettingsGeneralMap = new KeyCodeStrMap();\r\nconst EVENT_KEY_CODE_MAP = new Array(230);\r\nconst NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};\r\nconst scanCodeIntToStr = [];\r\nconst scanCodeStrToInt = Object.create(null);\r\nconst scanCodeLowerCaseStrToInt = Object.create(null);\r\n/**\r\n * -1 if a ScanCode => KeyCode mapping depends on kb layout.\r\n */\r\nconst IMMUTABLE_CODE_TO_KEY_CODE = [];\r\n/**\r\n * -1 if a KeyCode => ScanCode mapping depends on kb layout.\r\n */\r\nconst IMMUTABLE_KEY_CODE_TO_CODE = [];\r\nfor (let i = 0; i <= 193 /* ScanCode.MAX_VALUE */; i++) {\r\n    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1 /* KeyCode.DependsOnKbLayout */;\r\n}\r\nfor (let i = 0; i <= 132 /* KeyCode.MAX_VALUE */; i++) {\r\n    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1 /* ScanCode.DependsOnKbLayout */;\r\n}\r\n(function () {\r\n    // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n    // See https://github.com/microsoft/node-native-keymap/blob/88c0b0e5/deps/chromium/keyboard_codes_win.h\r\n    const empty = '';\r\n    const mappings = [\r\n        // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel\r\n        [1, 0 /* ScanCode.None */, 'None', 0 /* KeyCode.Unknown */, 'unknown', 0, 'VK_UNKNOWN', empty, empty],\r\n        [1, 1 /* ScanCode.Hyper */, 'Hyper', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 2 /* ScanCode.Super */, 'Super', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 3 /* ScanCode.Fn */, 'Fn', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 4 /* ScanCode.FnLock */, 'FnLock', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 5 /* ScanCode.Suspend */, 'Suspend', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 6 /* ScanCode.Resume */, 'Resume', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 7 /* ScanCode.Turbo */, 'Turbo', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 8 /* ScanCode.Sleep */, 'Sleep', 0 /* KeyCode.Unknown */, empty, 0, 'VK_SLEEP', empty, empty],\r\n        [1, 9 /* ScanCode.WakeUp */, 'WakeUp', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [0, 10 /* ScanCode.KeyA */, 'KeyA', 31 /* KeyCode.KeyA */, 'A', 65, 'VK_A', empty, empty],\r\n        [0, 11 /* ScanCode.KeyB */, 'KeyB', 32 /* KeyCode.KeyB */, 'B', 66, 'VK_B', empty, empty],\r\n        [0, 12 /* ScanCode.KeyC */, 'KeyC', 33 /* KeyCode.KeyC */, 'C', 67, 'VK_C', empty, empty],\r\n        [0, 13 /* ScanCode.KeyD */, 'KeyD', 34 /* KeyCode.KeyD */, 'D', 68, 'VK_D', empty, empty],\r\n        [0, 14 /* ScanCode.KeyE */, 'KeyE', 35 /* KeyCode.KeyE */, 'E', 69, 'VK_E', empty, empty],\r\n        [0, 15 /* ScanCode.KeyF */, 'KeyF', 36 /* KeyCode.KeyF */, 'F', 70, 'VK_F', empty, empty],\r\n        [0, 16 /* ScanCode.KeyG */, 'KeyG', 37 /* KeyCode.KeyG */, 'G', 71, 'VK_G', empty, empty],\r\n        [0, 17 /* ScanCode.KeyH */, 'KeyH', 38 /* KeyCode.KeyH */, 'H', 72, 'VK_H', empty, empty],\r\n        [0, 18 /* ScanCode.KeyI */, 'KeyI', 39 /* KeyCode.KeyI */, 'I', 73, 'VK_I', empty, empty],\r\n        [0, 19 /* ScanCode.KeyJ */, 'KeyJ', 40 /* KeyCode.KeyJ */, 'J', 74, 'VK_J', empty, empty],\r\n        [0, 20 /* ScanCode.KeyK */, 'KeyK', 41 /* KeyCode.KeyK */, 'K', 75, 'VK_K', empty, empty],\r\n        [0, 21 /* ScanCode.KeyL */, 'KeyL', 42 /* KeyCode.KeyL */, 'L', 76, 'VK_L', empty, empty],\r\n        [0, 22 /* ScanCode.KeyM */, 'KeyM', 43 /* KeyCode.KeyM */, 'M', 77, 'VK_M', empty, empty],\r\n        [0, 23 /* ScanCode.KeyN */, 'KeyN', 44 /* KeyCode.KeyN */, 'N', 78, 'VK_N', empty, empty],\r\n        [0, 24 /* ScanCode.KeyO */, 'KeyO', 45 /* KeyCode.KeyO */, 'O', 79, 'VK_O', empty, empty],\r\n        [0, 25 /* ScanCode.KeyP */, 'KeyP', 46 /* KeyCode.KeyP */, 'P', 80, 'VK_P', empty, empty],\r\n        [0, 26 /* ScanCode.KeyQ */, 'KeyQ', 47 /* KeyCode.KeyQ */, 'Q', 81, 'VK_Q', empty, empty],\r\n        [0, 27 /* ScanCode.KeyR */, 'KeyR', 48 /* KeyCode.KeyR */, 'R', 82, 'VK_R', empty, empty],\r\n        [0, 28 /* ScanCode.KeyS */, 'KeyS', 49 /* KeyCode.KeyS */, 'S', 83, 'VK_S', empty, empty],\r\n        [0, 29 /* ScanCode.KeyT */, 'KeyT', 50 /* KeyCode.KeyT */, 'T', 84, 'VK_T', empty, empty],\r\n        [0, 30 /* ScanCode.KeyU */, 'KeyU', 51 /* KeyCode.KeyU */, 'U', 85, 'VK_U', empty, empty],\r\n        [0, 31 /* ScanCode.KeyV */, 'KeyV', 52 /* KeyCode.KeyV */, 'V', 86, 'VK_V', empty, empty],\r\n        [0, 32 /* ScanCode.KeyW */, 'KeyW', 53 /* KeyCode.KeyW */, 'W', 87, 'VK_W', empty, empty],\r\n        [0, 33 /* ScanCode.KeyX */, 'KeyX', 54 /* KeyCode.KeyX */, 'X', 88, 'VK_X', empty, empty],\r\n        [0, 34 /* ScanCode.KeyY */, 'KeyY', 55 /* KeyCode.KeyY */, 'Y', 89, 'VK_Y', empty, empty],\r\n        [0, 35 /* ScanCode.KeyZ */, 'KeyZ', 56 /* KeyCode.KeyZ */, 'Z', 90, 'VK_Z', empty, empty],\r\n        [0, 36 /* ScanCode.Digit1 */, 'Digit1', 22 /* KeyCode.Digit1 */, '1', 49, 'VK_1', empty, empty],\r\n        [0, 37 /* ScanCode.Digit2 */, 'Digit2', 23 /* KeyCode.Digit2 */, '2', 50, 'VK_2', empty, empty],\r\n        [0, 38 /* ScanCode.Digit3 */, 'Digit3', 24 /* KeyCode.Digit3 */, '3', 51, 'VK_3', empty, empty],\r\n        [0, 39 /* ScanCode.Digit4 */, 'Digit4', 25 /* KeyCode.Digit4 */, '4', 52, 'VK_4', empty, empty],\r\n        [0, 40 /* ScanCode.Digit5 */, 'Digit5', 26 /* KeyCode.Digit5 */, '5', 53, 'VK_5', empty, empty],\r\n        [0, 41 /* ScanCode.Digit6 */, 'Digit6', 27 /* KeyCode.Digit6 */, '6', 54, 'VK_6', empty, empty],\r\n        [0, 42 /* ScanCode.Digit7 */, 'Digit7', 28 /* KeyCode.Digit7 */, '7', 55, 'VK_7', empty, empty],\r\n        [0, 43 /* ScanCode.Digit8 */, 'Digit8', 29 /* KeyCode.Digit8 */, '8', 56, 'VK_8', empty, empty],\r\n        [0, 44 /* ScanCode.Digit9 */, 'Digit9', 30 /* KeyCode.Digit9 */, '9', 57, 'VK_9', empty, empty],\r\n        [0, 45 /* ScanCode.Digit0 */, 'Digit0', 21 /* KeyCode.Digit0 */, '0', 48, 'VK_0', empty, empty],\r\n        [1, 46 /* ScanCode.Enter */, 'Enter', 3 /* KeyCode.Enter */, 'Enter', 13, 'VK_RETURN', empty, empty],\r\n        [1, 47 /* ScanCode.Escape */, 'Escape', 9 /* KeyCode.Escape */, 'Escape', 27, 'VK_ESCAPE', empty, empty],\r\n        [1, 48 /* ScanCode.Backspace */, 'Backspace', 1 /* KeyCode.Backspace */, 'Backspace', 8, 'VK_BACK', empty, empty],\r\n        [1, 49 /* ScanCode.Tab */, 'Tab', 2 /* KeyCode.Tab */, 'Tab', 9, 'VK_TAB', empty, empty],\r\n        [1, 50 /* ScanCode.Space */, 'Space', 10 /* KeyCode.Space */, 'Space', 32, 'VK_SPACE', empty, empty],\r\n        [0, 51 /* ScanCode.Minus */, 'Minus', 88 /* KeyCode.Minus */, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],\r\n        [0, 52 /* ScanCode.Equal */, 'Equal', 86 /* KeyCode.Equal */, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],\r\n        [0, 53 /* ScanCode.BracketLeft */, 'BracketLeft', 92 /* KeyCode.BracketLeft */, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],\r\n        [0, 54 /* ScanCode.BracketRight */, 'BracketRight', 94 /* KeyCode.BracketRight */, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],\r\n        [0, 55 /* ScanCode.Backslash */, 'Backslash', 93 /* KeyCode.Backslash */, '\\\\', 220, 'VK_OEM_5', '\\\\', 'OEM_5'],\r\n        [0, 56 /* ScanCode.IntlHash */, 'IntlHash', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty], // has been dropped from the w3c spec\r\n        [0, 57 /* ScanCode.Semicolon */, 'Semicolon', 85 /* KeyCode.Semicolon */, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],\r\n        [0, 58 /* ScanCode.Quote */, 'Quote', 95 /* KeyCode.Quote */, '\\'', 222, 'VK_OEM_7', '\\'', 'OEM_7'],\r\n        [0, 59 /* ScanCode.Backquote */, 'Backquote', 91 /* KeyCode.Backquote */, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],\r\n        [0, 60 /* ScanCode.Comma */, 'Comma', 87 /* KeyCode.Comma */, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],\r\n        [0, 61 /* ScanCode.Period */, 'Period', 89 /* KeyCode.Period */, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],\r\n        [0, 62 /* ScanCode.Slash */, 'Slash', 90 /* KeyCode.Slash */, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],\r\n        [1, 63 /* ScanCode.CapsLock */, 'CapsLock', 8 /* KeyCode.CapsLock */, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],\r\n        [1, 64 /* ScanCode.F1 */, 'F1', 59 /* KeyCode.F1 */, 'F1', 112, 'VK_F1', empty, empty],\r\n        [1, 65 /* ScanCode.F2 */, 'F2', 60 /* KeyCode.F2 */, 'F2', 113, 'VK_F2', empty, empty],\r\n        [1, 66 /* ScanCode.F3 */, 'F3', 61 /* KeyCode.F3 */, 'F3', 114, 'VK_F3', empty, empty],\r\n        [1, 67 /* ScanCode.F4 */, 'F4', 62 /* KeyCode.F4 */, 'F4', 115, 'VK_F4', empty, empty],\r\n        [1, 68 /* ScanCode.F5 */, 'F5', 63 /* KeyCode.F5 */, 'F5', 116, 'VK_F5', empty, empty],\r\n        [1, 69 /* ScanCode.F6 */, 'F6', 64 /* KeyCode.F6 */, 'F6', 117, 'VK_F6', empty, empty],\r\n        [1, 70 /* ScanCode.F7 */, 'F7', 65 /* KeyCode.F7 */, 'F7', 118, 'VK_F7', empty, empty],\r\n        [1, 71 /* ScanCode.F8 */, 'F8', 66 /* KeyCode.F8 */, 'F8', 119, 'VK_F8', empty, empty],\r\n        [1, 72 /* ScanCode.F9 */, 'F9', 67 /* KeyCode.F9 */, 'F9', 120, 'VK_F9', empty, empty],\r\n        [1, 73 /* ScanCode.F10 */, 'F10', 68 /* KeyCode.F10 */, 'F10', 121, 'VK_F10', empty, empty],\r\n        [1, 74 /* ScanCode.F11 */, 'F11', 69 /* KeyCode.F11 */, 'F11', 122, 'VK_F11', empty, empty],\r\n        [1, 75 /* ScanCode.F12 */, 'F12', 70 /* KeyCode.F12 */, 'F12', 123, 'VK_F12', empty, empty],\r\n        [1, 76 /* ScanCode.PrintScreen */, 'PrintScreen', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 77 /* ScanCode.ScrollLock */, 'ScrollLock', 84 /* KeyCode.ScrollLock */, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],\r\n        [1, 78 /* ScanCode.Pause */, 'Pause', 7 /* KeyCode.PauseBreak */, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],\r\n        [1, 79 /* ScanCode.Insert */, 'Insert', 19 /* KeyCode.Insert */, 'Insert', 45, 'VK_INSERT', empty, empty],\r\n        [1, 80 /* ScanCode.Home */, 'Home', 14 /* KeyCode.Home */, 'Home', 36, 'VK_HOME', empty, empty],\r\n        [1, 81 /* ScanCode.PageUp */, 'PageUp', 11 /* KeyCode.PageUp */, 'PageUp', 33, 'VK_PRIOR', empty, empty],\r\n        [1, 82 /* ScanCode.Delete */, 'Delete', 20 /* KeyCode.Delete */, 'Delete', 46, 'VK_DELETE', empty, empty],\r\n        [1, 83 /* ScanCode.End */, 'End', 13 /* KeyCode.End */, 'End', 35, 'VK_END', empty, empty],\r\n        [1, 84 /* ScanCode.PageDown */, 'PageDown', 12 /* KeyCode.PageDown */, 'PageDown', 34, 'VK_NEXT', empty, empty],\r\n        [1, 85 /* ScanCode.ArrowRight */, 'ArrowRight', 17 /* KeyCode.RightArrow */, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],\r\n        [1, 86 /* ScanCode.ArrowLeft */, 'ArrowLeft', 15 /* KeyCode.LeftArrow */, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],\r\n        [1, 87 /* ScanCode.ArrowDown */, 'ArrowDown', 18 /* KeyCode.DownArrow */, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],\r\n        [1, 88 /* ScanCode.ArrowUp */, 'ArrowUp', 16 /* KeyCode.UpArrow */, 'UpArrow', 38, 'VK_UP', 'Up', empty],\r\n        [1, 89 /* ScanCode.NumLock */, 'NumLock', 83 /* KeyCode.NumLock */, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],\r\n        [1, 90 /* ScanCode.NumpadDivide */, 'NumpadDivide', 113 /* KeyCode.NumpadDivide */, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],\r\n        [1, 91 /* ScanCode.NumpadMultiply */, 'NumpadMultiply', 108 /* KeyCode.NumpadMultiply */, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],\r\n        [1, 92 /* ScanCode.NumpadSubtract */, 'NumpadSubtract', 111 /* KeyCode.NumpadSubtract */, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],\r\n        [1, 93 /* ScanCode.NumpadAdd */, 'NumpadAdd', 109 /* KeyCode.NumpadAdd */, 'NumPad_Add', 107, 'VK_ADD', empty, empty],\r\n        [1, 94 /* ScanCode.NumpadEnter */, 'NumpadEnter', 3 /* KeyCode.Enter */, empty, 0, empty, empty, empty],\r\n        [1, 95 /* ScanCode.Numpad1 */, 'Numpad1', 99 /* KeyCode.Numpad1 */, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],\r\n        [1, 96 /* ScanCode.Numpad2 */, 'Numpad2', 100 /* KeyCode.Numpad2 */, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],\r\n        [1, 97 /* ScanCode.Numpad3 */, 'Numpad3', 101 /* KeyCode.Numpad3 */, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],\r\n        [1, 98 /* ScanCode.Numpad4 */, 'Numpad4', 102 /* KeyCode.Numpad4 */, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],\r\n        [1, 99 /* ScanCode.Numpad5 */, 'Numpad5', 103 /* KeyCode.Numpad5 */, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],\r\n        [1, 100 /* ScanCode.Numpad6 */, 'Numpad6', 104 /* KeyCode.Numpad6 */, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],\r\n        [1, 101 /* ScanCode.Numpad7 */, 'Numpad7', 105 /* KeyCode.Numpad7 */, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],\r\n        [1, 102 /* ScanCode.Numpad8 */, 'Numpad8', 106 /* KeyCode.Numpad8 */, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],\r\n        [1, 103 /* ScanCode.Numpad9 */, 'Numpad9', 107 /* KeyCode.Numpad9 */, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],\r\n        [1, 104 /* ScanCode.Numpad0 */, 'Numpad0', 98 /* KeyCode.Numpad0 */, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],\r\n        [1, 105 /* ScanCode.NumpadDecimal */, 'NumpadDecimal', 112 /* KeyCode.NumpadDecimal */, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],\r\n        [0, 106 /* ScanCode.IntlBackslash */, 'IntlBackslash', 97 /* KeyCode.IntlBackslash */, 'OEM_102', 226, 'VK_OEM_102', empty, empty],\r\n        [1, 107 /* ScanCode.ContextMenu */, 'ContextMenu', 58 /* KeyCode.ContextMenu */, 'ContextMenu', 93, empty, empty, empty],\r\n        [1, 108 /* ScanCode.Power */, 'Power', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 109 /* ScanCode.NumpadEqual */, 'NumpadEqual', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 110 /* ScanCode.F13 */, 'F13', 71 /* KeyCode.F13 */, 'F13', 124, 'VK_F13', empty, empty],\r\n        [1, 111 /* ScanCode.F14 */, 'F14', 72 /* KeyCode.F14 */, 'F14', 125, 'VK_F14', empty, empty],\r\n        [1, 112 /* ScanCode.F15 */, 'F15', 73 /* KeyCode.F15 */, 'F15', 126, 'VK_F15', empty, empty],\r\n        [1, 113 /* ScanCode.F16 */, 'F16', 74 /* KeyCode.F16 */, 'F16', 127, 'VK_F16', empty, empty],\r\n        [1, 114 /* ScanCode.F17 */, 'F17', 75 /* KeyCode.F17 */, 'F17', 128, 'VK_F17', empty, empty],\r\n        [1, 115 /* ScanCode.F18 */, 'F18', 76 /* KeyCode.F18 */, 'F18', 129, 'VK_F18', empty, empty],\r\n        [1, 116 /* ScanCode.F19 */, 'F19', 77 /* KeyCode.F19 */, 'F19', 130, 'VK_F19', empty, empty],\r\n        [1, 117 /* ScanCode.F20 */, 'F20', 78 /* KeyCode.F20 */, 'F20', 131, 'VK_F20', empty, empty],\r\n        [1, 118 /* ScanCode.F21 */, 'F21', 79 /* KeyCode.F21 */, 'F21', 132, 'VK_F21', empty, empty],\r\n        [1, 119 /* ScanCode.F22 */, 'F22', 80 /* KeyCode.F22 */, 'F22', 133, 'VK_F22', empty, empty],\r\n        [1, 120 /* ScanCode.F23 */, 'F23', 81 /* KeyCode.F23 */, 'F23', 134, 'VK_F23', empty, empty],\r\n        [1, 121 /* ScanCode.F24 */, 'F24', 82 /* KeyCode.F24 */, 'F24', 135, 'VK_F24', empty, empty],\r\n        [1, 122 /* ScanCode.Open */, 'Open', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 123 /* ScanCode.Help */, 'Help', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 124 /* ScanCode.Select */, 'Select', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 125 /* ScanCode.Again */, 'Again', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 126 /* ScanCode.Undo */, 'Undo', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 127 /* ScanCode.Cut */, 'Cut', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 128 /* ScanCode.Copy */, 'Copy', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 129 /* ScanCode.Paste */, 'Paste', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 130 /* ScanCode.Find */, 'Find', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 131 /* ScanCode.AudioVolumeMute */, 'AudioVolumeMute', 117 /* KeyCode.AudioVolumeMute */, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],\r\n        [1, 132 /* ScanCode.AudioVolumeUp */, 'AudioVolumeUp', 118 /* KeyCode.AudioVolumeUp */, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],\r\n        [1, 133 /* ScanCode.AudioVolumeDown */, 'AudioVolumeDown', 119 /* KeyCode.AudioVolumeDown */, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],\r\n        [1, 134 /* ScanCode.NumpadComma */, 'NumpadComma', 110 /* KeyCode.NUMPAD_SEPARATOR */, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],\r\n        [0, 135 /* ScanCode.IntlRo */, 'IntlRo', 115 /* KeyCode.ABNT_C1 */, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],\r\n        [1, 136 /* ScanCode.KanaMode */, 'KanaMode', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [0, 137 /* ScanCode.IntlYen */, 'IntlYen', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 138 /* ScanCode.Convert */, 'Convert', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 139 /* ScanCode.NonConvert */, 'NonConvert', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 140 /* ScanCode.Lang1 */, 'Lang1', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 141 /* ScanCode.Lang2 */, 'Lang2', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 142 /* ScanCode.Lang3 */, 'Lang3', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 143 /* ScanCode.Lang4 */, 'Lang4', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 144 /* ScanCode.Lang5 */, 'Lang5', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 145 /* ScanCode.Abort */, 'Abort', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 146 /* ScanCode.Props */, 'Props', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 147 /* ScanCode.NumpadParenLeft */, 'NumpadParenLeft', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 148 /* ScanCode.NumpadParenRight */, 'NumpadParenRight', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 149 /* ScanCode.NumpadBackspace */, 'NumpadBackspace', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 150 /* ScanCode.NumpadMemoryStore */, 'NumpadMemoryStore', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 151 /* ScanCode.NumpadMemoryRecall */, 'NumpadMemoryRecall', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 152 /* ScanCode.NumpadMemoryClear */, 'NumpadMemoryClear', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 153 /* ScanCode.NumpadMemoryAdd */, 'NumpadMemoryAdd', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 154 /* ScanCode.NumpadMemorySubtract */, 'NumpadMemorySubtract', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 155 /* ScanCode.NumpadClear */, 'NumpadClear', 131 /* KeyCode.Clear */, 'Clear', 12, 'VK_CLEAR', empty, empty],\r\n        [1, 156 /* ScanCode.NumpadClearEntry */, 'NumpadClearEntry', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 5 /* KeyCode.Ctrl */, 'Ctrl', 17, 'VK_CONTROL', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 4 /* KeyCode.Shift */, 'Shift', 16, 'VK_SHIFT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 6 /* KeyCode.Alt */, 'Alt', 18, 'VK_MENU', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 57 /* KeyCode.Meta */, 'Meta', 91, 'VK_COMMAND', empty, empty],\r\n        [1, 157 /* ScanCode.ControlLeft */, 'ControlLeft', 5 /* KeyCode.Ctrl */, empty, 0, 'VK_LCONTROL', empty, empty],\r\n        [1, 158 /* ScanCode.ShiftLeft */, 'ShiftLeft', 4 /* KeyCode.Shift */, empty, 0, 'VK_LSHIFT', empty, empty],\r\n        [1, 159 /* ScanCode.AltLeft */, 'AltLeft', 6 /* KeyCode.Alt */, empty, 0, 'VK_LMENU', empty, empty],\r\n        [1, 160 /* ScanCode.MetaLeft */, 'MetaLeft', 57 /* KeyCode.Meta */, empty, 0, 'VK_LWIN', empty, empty],\r\n        [1, 161 /* ScanCode.ControlRight */, 'ControlRight', 5 /* KeyCode.Ctrl */, empty, 0, 'VK_RCONTROL', empty, empty],\r\n        [1, 162 /* ScanCode.ShiftRight */, 'ShiftRight', 4 /* KeyCode.Shift */, empty, 0, 'VK_RSHIFT', empty, empty],\r\n        [1, 163 /* ScanCode.AltRight */, 'AltRight', 6 /* KeyCode.Alt */, empty, 0, 'VK_RMENU', empty, empty],\r\n        [1, 164 /* ScanCode.MetaRight */, 'MetaRight', 57 /* KeyCode.Meta */, empty, 0, 'VK_RWIN', empty, empty],\r\n        [1, 165 /* ScanCode.BrightnessUp */, 'BrightnessUp', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 166 /* ScanCode.BrightnessDown */, 'BrightnessDown', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 167 /* ScanCode.MediaPlay */, 'MediaPlay', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 168 /* ScanCode.MediaRecord */, 'MediaRecord', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 169 /* ScanCode.MediaFastForward */, 'MediaFastForward', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 170 /* ScanCode.MediaRewind */, 'MediaRewind', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 171 /* ScanCode.MediaTrackNext */, 'MediaTrackNext', 124 /* KeyCode.MediaTrackNext */, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],\r\n        [1, 172 /* ScanCode.MediaTrackPrevious */, 'MediaTrackPrevious', 125 /* KeyCode.MediaTrackPrevious */, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],\r\n        [1, 173 /* ScanCode.MediaStop */, 'MediaStop', 126 /* KeyCode.MediaStop */, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],\r\n        [1, 174 /* ScanCode.Eject */, 'Eject', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 175 /* ScanCode.MediaPlayPause */, 'MediaPlayPause', 127 /* KeyCode.MediaPlayPause */, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],\r\n        [1, 176 /* ScanCode.MediaSelect */, 'MediaSelect', 128 /* KeyCode.LaunchMediaPlayer */, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],\r\n        [1, 177 /* ScanCode.LaunchMail */, 'LaunchMail', 129 /* KeyCode.LaunchMail */, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],\r\n        [1, 178 /* ScanCode.LaunchApp2 */, 'LaunchApp2', 130 /* KeyCode.LaunchApp2 */, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],\r\n        [1, 179 /* ScanCode.LaunchApp1 */, 'LaunchApp1', 0 /* KeyCode.Unknown */, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],\r\n        [1, 180 /* ScanCode.SelectTask */, 'SelectTask', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 181 /* ScanCode.LaunchScreenSaver */, 'LaunchScreenSaver', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 182 /* ScanCode.BrowserSearch */, 'BrowserSearch', 120 /* KeyCode.BrowserSearch */, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],\r\n        [1, 183 /* ScanCode.BrowserHome */, 'BrowserHome', 121 /* KeyCode.BrowserHome */, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],\r\n        [1, 184 /* ScanCode.BrowserBack */, 'BrowserBack', 122 /* KeyCode.BrowserBack */, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],\r\n        [1, 185 /* ScanCode.BrowserForward */, 'BrowserForward', 123 /* KeyCode.BrowserForward */, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],\r\n        [1, 186 /* ScanCode.BrowserStop */, 'BrowserStop', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_STOP', empty, empty],\r\n        [1, 187 /* ScanCode.BrowserRefresh */, 'BrowserRefresh', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],\r\n        [1, 188 /* ScanCode.BrowserFavorites */, 'BrowserFavorites', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],\r\n        [1, 189 /* ScanCode.ZoomToggle */, 'ZoomToggle', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 190 /* ScanCode.MailReply */, 'MailReply', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 191 /* ScanCode.MailForward */, 'MailForward', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        [1, 192 /* ScanCode.MailSend */, 'MailSend', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\r\n        // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\r\n        // If an Input Method Editor is processing key input and the event is keydown, return 229.\r\n        [1, 0 /* ScanCode.None */, empty, 114 /* KeyCode.KEY_IN_COMPOSITION */, 'KeyInComposition', 229, empty, empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 116 /* KeyCode.ABNT_C2 */, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 96 /* KeyCode.OEM_8 */, 'OEM_8', 223, 'VK_OEM_8', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_KANA', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HANGUL', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_JUNJA', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_FINAL', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HANJA', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_KANJI', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_CONVERT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_NONCONVERT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ACCEPT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_MODECHANGE', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_SELECT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PRINT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EXECUTE', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_SNAPSHOT', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HELP', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_APPS', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PROCESSKEY', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PACKET', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ATTN', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_CRSEL', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EXSEL', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EREOF', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PLAY', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ZOOM', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_NONAME', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PA1', empty, empty],\r\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_OEM_CLEAR', empty, empty],\r\n    ];\r\n    const seenKeyCode = [];\r\n    const seenScanCode = [];\r\n    for (const mapping of mappings) {\r\n        const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\r\n        if (!seenScanCode[scanCode]) {\r\n            seenScanCode[scanCode] = true;\r\n            scanCodeIntToStr[scanCode] = scanCodeStr;\r\n            scanCodeStrToInt[scanCodeStr] = scanCode;\r\n            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\r\n            if (immutable) {\r\n                IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\r\n                if ((keyCode !== 0 /* KeyCode.Unknown */)\r\n                    && (keyCode !== 3 /* KeyCode.Enter */)\r\n                    && (keyCode !== 5 /* KeyCode.Ctrl */)\r\n                    && (keyCode !== 4 /* KeyCode.Shift */)\r\n                    && (keyCode !== 6 /* KeyCode.Alt */)\r\n                    && (keyCode !== 57 /* KeyCode.Meta */)) {\r\n                    IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\r\n                }\r\n            }\r\n        }\r\n        if (!seenKeyCode[keyCode]) {\r\n            seenKeyCode[keyCode] = true;\r\n            if (!keyCodeStr) {\r\n                throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);\r\n            }\r\n            uiMap.define(keyCode, keyCodeStr);\r\n            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\r\n            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\r\n        }\r\n        if (eventKeyCode) {\r\n            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\r\n        }\r\n        if (vkey) {\r\n            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\r\n        }\r\n    }\r\n    // Manually added due to the exclusion above (due to duplication with NumpadEnter)\r\n    IMMUTABLE_KEY_CODE_TO_CODE[3 /* KeyCode.Enter */] = 46 /* ScanCode.Enter */;\r\n})();\r\nvar KeyCodeUtils;\r\n(function (KeyCodeUtils) {\r\n    function toString(keyCode) {\r\n        return uiMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toString = toString;\r\n    function fromString(key) {\r\n        return uiMap.strToKeyCode(key);\r\n    }\r\n    KeyCodeUtils.fromString = fromString;\r\n    function toUserSettingsUS(keyCode) {\r\n        return userSettingsUSMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;\r\n    function toUserSettingsGeneral(keyCode) {\r\n        return userSettingsGeneralMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;\r\n    function fromUserSettings(key) {\r\n        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\r\n    }\r\n    KeyCodeUtils.fromUserSettings = fromUserSettings;\r\n    function toElectronAccelerator(keyCode) {\r\n        if (keyCode >= 98 /* KeyCode.Numpad0 */ && keyCode <= 113 /* KeyCode.NumpadDivide */) {\r\n            // [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it\r\n            // renders them just as regular keys in menus. For example, num0 is rendered as \"0\",\r\n            // numdiv is rendered as \"/\", numsub is rendered as \"-\".\r\n            //\r\n            // This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable\r\n            // from keybindings based on regular keys.\r\n            //\r\n            // We therefore need to fall back to custom rendering for numpad keys.\r\n            return null;\r\n        }\r\n        switch (keyCode) {\r\n            case 16 /* KeyCode.UpArrow */:\r\n                return 'Up';\r\n            case 18 /* KeyCode.DownArrow */:\r\n                return 'Down';\r\n            case 15 /* KeyCode.LeftArrow */:\r\n                return 'Left';\r\n            case 17 /* KeyCode.RightArrow */:\r\n                return 'Right';\r\n        }\r\n        return uiMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toElectronAccelerator = toElectronAccelerator;\r\n})(KeyCodeUtils || (KeyCodeUtils = {}));\r\nfunction KeyChord(firstPart, secondPart) {\r\n    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\r\n    return (firstPart | chordPart) >>> 0;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24va2V5Q29kZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHNCQUFzQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsU0FBUyxtQkFBbUIsWUFBWTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QjtBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9rZXlDb2Rlcy5qcz9mZTQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5jbGFzcyBLZXlDb2RlU3RyTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2tleUNvZGVUb1N0ciA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBkZWZpbmUoa2V5Q29kZSwgc3RyKSB7XHJcbiAgICAgICAgdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdID0gc3RyO1xyXG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZVtzdHIudG9Mb3dlckNhc2UoKV0gPSBrZXlDb2RlO1xyXG4gICAgfVxyXG4gICAga2V5Q29kZVRvU3RyKGtleUNvZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdO1xyXG4gICAgfVxyXG4gICAgc3RyVG9LZXlDb2RlKHN0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJUb0tleUNvZGVbc3RyLnRvTG93ZXJDYXNlKCldIHx8IDAgLyogS2V5Q29kZS5Vbmtub3duICovO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHVpTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcclxuY29uc3QgdXNlclNldHRpbmdzVVNNYXAgPSBuZXcgS2V5Q29kZVN0ck1hcCgpO1xyXG5jb25zdCB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcclxuZXhwb3J0IGNvbnN0IEVWRU5UX0tFWV9DT0RFX01BUCA9IG5ldyBBcnJheSgyMzApO1xyXG5leHBvcnQgY29uc3QgTkFUSVZFX1dJTkRPV1NfS0VZX0NPREVfVE9fS0VZX0NPREUgPSB7fTtcclxuY29uc3Qgc2NhbkNvZGVJbnRUb1N0ciA9IFtdO1xyXG5jb25zdCBzY2FuQ29kZVN0clRvSW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuY29uc3Qgc2NhbkNvZGVMb3dlckNhc2VTdHJUb0ludCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbi8qKlxyXG4gKiAtMSBpZiBhIFNjYW5Db2RlID0+IEtleUNvZGUgbWFwcGluZyBkZXBlbmRzIG9uIGtiIGxheW91dC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERSA9IFtdO1xyXG4vKipcclxuICogLTEgaWYgYSBLZXlDb2RlID0+IFNjYW5Db2RlIG1hcHBpbmcgZGVwZW5kcyBvbiBrYiBsYXlvdXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREUgPSBbXTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPD0gMTkzIC8qIFNjYW5Db2RlLk1BWF9WQUxVRSAqLzsgaSsrKSB7XHJcbiAgICBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERVtpXSA9IC0xIC8qIEtleUNvZGUuRGVwZW5kc09uS2JMYXlvdXQgKi87XHJcbn1cclxuZm9yIChsZXQgaSA9IDA7IGkgPD0gMTMyIC8qIEtleUNvZGUuTUFYX1ZBTFVFICovOyBpKyspIHtcclxuICAgIElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFW2ldID0gLTEgLyogU2NhbkNvZGUuRGVwZW5kc09uS2JMYXlvdXQgKi87XHJcbn1cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNlZSBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9kZDM3NTczMSh2PXZzLjg1KS5hc3B4XHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9ub2RlLW5hdGl2ZS1rZXltYXAvYmxvYi84OGMwYjBlNS9kZXBzL2Nocm9taXVtL2tleWJvYXJkX2NvZGVzX3dpbi5oXHJcbiAgICBjb25zdCBlbXB0eSA9ICcnO1xyXG4gICAgY29uc3QgbWFwcGluZ3MgPSBbXHJcbiAgICAgICAgLy8gaW1tdXRhYmxlLCBzY2FuQ29kZSwgc2NhbkNvZGVTdHIsIGtleUNvZGUsIGtleUNvZGVTdHIsIGV2ZW50S2V5Q29kZSwgdmtleSwgdXNVc2VyU2V0dGluZ3NMYWJlbCwgZ2VuZXJhbFVzZXJTZXR0aW5nc0xhYmVsXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgJ05vbmUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgJ3Vua25vd24nLCAwLCAnVktfVU5LTk9XTicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEgLyogU2NhbkNvZGUuSHlwZXIgKi8sICdIeXBlcicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDIgLyogU2NhbkNvZGUuU3VwZXIgKi8sICdTdXBlcicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDMgLyogU2NhbkNvZGUuRm4gKi8sICdGbicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDQgLyogU2NhbkNvZGUuRm5Mb2NrICovLCAnRm5Mb2NrJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNSAvKiBTY2FuQ29kZS5TdXNwZW5kICovLCAnU3VzcGVuZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDYgLyogU2NhbkNvZGUuUmVzdW1lICovLCAnUmVzdW1lJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNyAvKiBTY2FuQ29kZS5UdXJibyAqLywgJ1R1cmJvJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgOCAvKiBTY2FuQ29kZS5TbGVlcCAqLywgJ1NsZWVwJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfU0xFRVAnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA5IC8qIFNjYW5Db2RlLldha2VVcCAqLywgJ1dha2VVcCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDEwIC8qIFNjYW5Db2RlLktleUEgKi8sICdLZXlBJywgMzEgLyogS2V5Q29kZS5LZXlBICovLCAnQScsIDY1LCAnVktfQScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDExIC8qIFNjYW5Db2RlLktleUIgKi8sICdLZXlCJywgMzIgLyogS2V5Q29kZS5LZXlCICovLCAnQicsIDY2LCAnVktfQicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDEyIC8qIFNjYW5Db2RlLktleUMgKi8sICdLZXlDJywgMzMgLyogS2V5Q29kZS5LZXlDICovLCAnQycsIDY3LCAnVktfQycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDEzIC8qIFNjYW5Db2RlLktleUQgKi8sICdLZXlEJywgMzQgLyogS2V5Q29kZS5LZXlEICovLCAnRCcsIDY4LCAnVktfRCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDE0IC8qIFNjYW5Db2RlLktleUUgKi8sICdLZXlFJywgMzUgLyogS2V5Q29kZS5LZXlFICovLCAnRScsIDY5LCAnVktfRScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDE1IC8qIFNjYW5Db2RlLktleUYgKi8sICdLZXlGJywgMzYgLyogS2V5Q29kZS5LZXlGICovLCAnRicsIDcwLCAnVktfRicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDE2IC8qIFNjYW5Db2RlLktleUcgKi8sICdLZXlHJywgMzcgLyogS2V5Q29kZS5LZXlHICovLCAnRycsIDcxLCAnVktfRycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDE3IC8qIFNjYW5Db2RlLktleUggKi8sICdLZXlIJywgMzggLyogS2V5Q29kZS5LZXlIICovLCAnSCcsIDcyLCAnVktfSCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDE4IC8qIFNjYW5Db2RlLktleUkgKi8sICdLZXlJJywgMzkgLyogS2V5Q29kZS5LZXlJICovLCAnSScsIDczLCAnVktfSScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDE5IC8qIFNjYW5Db2RlLktleUogKi8sICdLZXlKJywgNDAgLyogS2V5Q29kZS5LZXlKICovLCAnSicsIDc0LCAnVktfSicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDIwIC8qIFNjYW5Db2RlLktleUsgKi8sICdLZXlLJywgNDEgLyogS2V5Q29kZS5LZXlLICovLCAnSycsIDc1LCAnVktfSycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDIxIC8qIFNjYW5Db2RlLktleUwgKi8sICdLZXlMJywgNDIgLyogS2V5Q29kZS5LZXlMICovLCAnTCcsIDc2LCAnVktfTCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDIyIC8qIFNjYW5Db2RlLktleU0gKi8sICdLZXlNJywgNDMgLyogS2V5Q29kZS5LZXlNICovLCAnTScsIDc3LCAnVktfTScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDIzIC8qIFNjYW5Db2RlLktleU4gKi8sICdLZXlOJywgNDQgLyogS2V5Q29kZS5LZXlOICovLCAnTicsIDc4LCAnVktfTicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDI0IC8qIFNjYW5Db2RlLktleU8gKi8sICdLZXlPJywgNDUgLyogS2V5Q29kZS5LZXlPICovLCAnTycsIDc5LCAnVktfTycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDI1IC8qIFNjYW5Db2RlLktleVAgKi8sICdLZXlQJywgNDYgLyogS2V5Q29kZS5LZXlQICovLCAnUCcsIDgwLCAnVktfUCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDI2IC8qIFNjYW5Db2RlLktleVEgKi8sICdLZXlRJywgNDcgLyogS2V5Q29kZS5LZXlRICovLCAnUScsIDgxLCAnVktfUScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDI3IC8qIFNjYW5Db2RlLktleVIgKi8sICdLZXlSJywgNDggLyogS2V5Q29kZS5LZXlSICovLCAnUicsIDgyLCAnVktfUicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDI4IC8qIFNjYW5Db2RlLktleVMgKi8sICdLZXlTJywgNDkgLyogS2V5Q29kZS5LZXlTICovLCAnUycsIDgzLCAnVktfUycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDI5IC8qIFNjYW5Db2RlLktleVQgKi8sICdLZXlUJywgNTAgLyogS2V5Q29kZS5LZXlUICovLCAnVCcsIDg0LCAnVktfVCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDMwIC8qIFNjYW5Db2RlLktleVUgKi8sICdLZXlVJywgNTEgLyogS2V5Q29kZS5LZXlVICovLCAnVScsIDg1LCAnVktfVScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDMxIC8qIFNjYW5Db2RlLktleVYgKi8sICdLZXlWJywgNTIgLyogS2V5Q29kZS5LZXlWICovLCAnVicsIDg2LCAnVktfVicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDMyIC8qIFNjYW5Db2RlLktleVcgKi8sICdLZXlXJywgNTMgLyogS2V5Q29kZS5LZXlXICovLCAnVycsIDg3LCAnVktfVycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDMzIC8qIFNjYW5Db2RlLktleVggKi8sICdLZXlYJywgNTQgLyogS2V5Q29kZS5LZXlYICovLCAnWCcsIDg4LCAnVktfWCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDM0IC8qIFNjYW5Db2RlLktleVkgKi8sICdLZXlZJywgNTUgLyogS2V5Q29kZS5LZXlZICovLCAnWScsIDg5LCAnVktfWScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDM1IC8qIFNjYW5Db2RlLktleVogKi8sICdLZXlaJywgNTYgLyogS2V5Q29kZS5LZXlaICovLCAnWicsIDkwLCAnVktfWicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDM2IC8qIFNjYW5Db2RlLkRpZ2l0MSAqLywgJ0RpZ2l0MScsIDIyIC8qIEtleUNvZGUuRGlnaXQxICovLCAnMScsIDQ5LCAnVktfMScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDM3IC8qIFNjYW5Db2RlLkRpZ2l0MiAqLywgJ0RpZ2l0MicsIDIzIC8qIEtleUNvZGUuRGlnaXQyICovLCAnMicsIDUwLCAnVktfMicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDM4IC8qIFNjYW5Db2RlLkRpZ2l0MyAqLywgJ0RpZ2l0MycsIDI0IC8qIEtleUNvZGUuRGlnaXQzICovLCAnMycsIDUxLCAnVktfMycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDM5IC8qIFNjYW5Db2RlLkRpZ2l0NCAqLywgJ0RpZ2l0NCcsIDI1IC8qIEtleUNvZGUuRGlnaXQ0ICovLCAnNCcsIDUyLCAnVktfNCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDQwIC8qIFNjYW5Db2RlLkRpZ2l0NSAqLywgJ0RpZ2l0NScsIDI2IC8qIEtleUNvZGUuRGlnaXQ1ICovLCAnNScsIDUzLCAnVktfNScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDQxIC8qIFNjYW5Db2RlLkRpZ2l0NiAqLywgJ0RpZ2l0NicsIDI3IC8qIEtleUNvZGUuRGlnaXQ2ICovLCAnNicsIDU0LCAnVktfNicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDQyIC8qIFNjYW5Db2RlLkRpZ2l0NyAqLywgJ0RpZ2l0NycsIDI4IC8qIEtleUNvZGUuRGlnaXQ3ICovLCAnNycsIDU1LCAnVktfNycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDQzIC8qIFNjYW5Db2RlLkRpZ2l0OCAqLywgJ0RpZ2l0OCcsIDI5IC8qIEtleUNvZGUuRGlnaXQ4ICovLCAnOCcsIDU2LCAnVktfOCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDQ0IC8qIFNjYW5Db2RlLkRpZ2l0OSAqLywgJ0RpZ2l0OScsIDMwIC8qIEtleUNvZGUuRGlnaXQ5ICovLCAnOScsIDU3LCAnVktfOScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDQ1IC8qIFNjYW5Db2RlLkRpZ2l0MCAqLywgJ0RpZ2l0MCcsIDIxIC8qIEtleUNvZGUuRGlnaXQwICovLCAnMCcsIDQ4LCAnVktfMCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDQ2IC8qIFNjYW5Db2RlLkVudGVyICovLCAnRW50ZXInLCAzIC8qIEtleUNvZGUuRW50ZXIgKi8sICdFbnRlcicsIDEzLCAnVktfUkVUVVJOJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNDcgLyogU2NhbkNvZGUuRXNjYXBlICovLCAnRXNjYXBlJywgOSAvKiBLZXlDb2RlLkVzY2FwZSAqLywgJ0VzY2FwZScsIDI3LCAnVktfRVNDQVBFJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNDggLyogU2NhbkNvZGUuQmFja3NwYWNlICovLCAnQmFja3NwYWNlJywgMSAvKiBLZXlDb2RlLkJhY2tzcGFjZSAqLywgJ0JhY2tzcGFjZScsIDgsICdWS19CQUNLJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNDkgLyogU2NhbkNvZGUuVGFiICovLCAnVGFiJywgMiAvKiBLZXlDb2RlLlRhYiAqLywgJ1RhYicsIDksICdWS19UQUInLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA1MCAvKiBTY2FuQ29kZS5TcGFjZSAqLywgJ1NwYWNlJywgMTAgLyogS2V5Q29kZS5TcGFjZSAqLywgJ1NwYWNlJywgMzIsICdWS19TUEFDRScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzAsIDUxIC8qIFNjYW5Db2RlLk1pbnVzICovLCAnTWludXMnLCA4OCAvKiBLZXlDb2RlLk1pbnVzICovLCAnLScsIDE4OSwgJ1ZLX09FTV9NSU5VUycsICctJywgJ09FTV9NSU5VUyddLFxyXG4gICAgICAgIFswLCA1MiAvKiBTY2FuQ29kZS5FcXVhbCAqLywgJ0VxdWFsJywgODYgLyogS2V5Q29kZS5FcXVhbCAqLywgJz0nLCAxODcsICdWS19PRU1fUExVUycsICc9JywgJ09FTV9QTFVTJ10sXHJcbiAgICAgICAgWzAsIDUzIC8qIFNjYW5Db2RlLkJyYWNrZXRMZWZ0ICovLCAnQnJhY2tldExlZnQnLCA5MiAvKiBLZXlDb2RlLkJyYWNrZXRMZWZ0ICovLCAnWycsIDIxOSwgJ1ZLX09FTV80JywgJ1snLCAnT0VNXzQnXSxcclxuICAgICAgICBbMCwgNTQgLyogU2NhbkNvZGUuQnJhY2tldFJpZ2h0ICovLCAnQnJhY2tldFJpZ2h0JywgOTQgLyogS2V5Q29kZS5CcmFja2V0UmlnaHQgKi8sICddJywgMjIxLCAnVktfT0VNXzYnLCAnXScsICdPRU1fNiddLFxyXG4gICAgICAgIFswLCA1NSAvKiBTY2FuQ29kZS5CYWNrc2xhc2ggKi8sICdCYWNrc2xhc2gnLCA5MyAvKiBLZXlDb2RlLkJhY2tzbGFzaCAqLywgJ1xcXFwnLCAyMjAsICdWS19PRU1fNScsICdcXFxcJywgJ09FTV81J10sXHJcbiAgICAgICAgWzAsIDU2IC8qIFNjYW5Db2RlLkludGxIYXNoICovLCAnSW50bEhhc2gnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLCAvLyBoYXMgYmVlbiBkcm9wcGVkIGZyb20gdGhlIHczYyBzcGVjXHJcbiAgICAgICAgWzAsIDU3IC8qIFNjYW5Db2RlLlNlbWljb2xvbiAqLywgJ1NlbWljb2xvbicsIDg1IC8qIEtleUNvZGUuU2VtaWNvbG9uICovLCAnOycsIDE4NiwgJ1ZLX09FTV8xJywgJzsnLCAnT0VNXzEnXSxcclxuICAgICAgICBbMCwgNTggLyogU2NhbkNvZGUuUXVvdGUgKi8sICdRdW90ZScsIDk1IC8qIEtleUNvZGUuUXVvdGUgKi8sICdcXCcnLCAyMjIsICdWS19PRU1fNycsICdcXCcnLCAnT0VNXzcnXSxcclxuICAgICAgICBbMCwgNTkgLyogU2NhbkNvZGUuQmFja3F1b3RlICovLCAnQmFja3F1b3RlJywgOTEgLyogS2V5Q29kZS5CYWNrcXVvdGUgKi8sICdgJywgMTkyLCAnVktfT0VNXzMnLCAnYCcsICdPRU1fMyddLFxyXG4gICAgICAgIFswLCA2MCAvKiBTY2FuQ29kZS5Db21tYSAqLywgJ0NvbW1hJywgODcgLyogS2V5Q29kZS5Db21tYSAqLywgJywnLCAxODgsICdWS19PRU1fQ09NTUEnLCAnLCcsICdPRU1fQ09NTUEnXSxcclxuICAgICAgICBbMCwgNjEgLyogU2NhbkNvZGUuUGVyaW9kICovLCAnUGVyaW9kJywgODkgLyogS2V5Q29kZS5QZXJpb2QgKi8sICcuJywgMTkwLCAnVktfT0VNX1BFUklPRCcsICcuJywgJ09FTV9QRVJJT0QnXSxcclxuICAgICAgICBbMCwgNjIgLyogU2NhbkNvZGUuU2xhc2ggKi8sICdTbGFzaCcsIDkwIC8qIEtleUNvZGUuU2xhc2ggKi8sICcvJywgMTkxLCAnVktfT0VNXzInLCAnLycsICdPRU1fMiddLFxyXG4gICAgICAgIFsxLCA2MyAvKiBTY2FuQ29kZS5DYXBzTG9jayAqLywgJ0NhcHNMb2NrJywgOCAvKiBLZXlDb2RlLkNhcHNMb2NrICovLCAnQ2Fwc0xvY2snLCAyMCwgJ1ZLX0NBUElUQUwnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA2NCAvKiBTY2FuQ29kZS5GMSAqLywgJ0YxJywgNTkgLyogS2V5Q29kZS5GMSAqLywgJ0YxJywgMTEyLCAnVktfRjEnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA2NSAvKiBTY2FuQ29kZS5GMiAqLywgJ0YyJywgNjAgLyogS2V5Q29kZS5GMiAqLywgJ0YyJywgMTEzLCAnVktfRjInLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA2NiAvKiBTY2FuQ29kZS5GMyAqLywgJ0YzJywgNjEgLyogS2V5Q29kZS5GMyAqLywgJ0YzJywgMTE0LCAnVktfRjMnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA2NyAvKiBTY2FuQ29kZS5GNCAqLywgJ0Y0JywgNjIgLyogS2V5Q29kZS5GNCAqLywgJ0Y0JywgMTE1LCAnVktfRjQnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA2OCAvKiBTY2FuQ29kZS5GNSAqLywgJ0Y1JywgNjMgLyogS2V5Q29kZS5GNSAqLywgJ0Y1JywgMTE2LCAnVktfRjUnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA2OSAvKiBTY2FuQ29kZS5GNiAqLywgJ0Y2JywgNjQgLyogS2V5Q29kZS5GNiAqLywgJ0Y2JywgMTE3LCAnVktfRjYnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA3MCAvKiBTY2FuQ29kZS5GNyAqLywgJ0Y3JywgNjUgLyogS2V5Q29kZS5GNyAqLywgJ0Y3JywgMTE4LCAnVktfRjcnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA3MSAvKiBTY2FuQ29kZS5GOCAqLywgJ0Y4JywgNjYgLyogS2V5Q29kZS5GOCAqLywgJ0Y4JywgMTE5LCAnVktfRjgnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA3MiAvKiBTY2FuQ29kZS5GOSAqLywgJ0Y5JywgNjcgLyogS2V5Q29kZS5GOSAqLywgJ0Y5JywgMTIwLCAnVktfRjknLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA3MyAvKiBTY2FuQ29kZS5GMTAgKi8sICdGMTAnLCA2OCAvKiBLZXlDb2RlLkYxMCAqLywgJ0YxMCcsIDEyMSwgJ1ZLX0YxMCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDc0IC8qIFNjYW5Db2RlLkYxMSAqLywgJ0YxMScsIDY5IC8qIEtleUNvZGUuRjExICovLCAnRjExJywgMTIyLCAnVktfRjExJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNzUgLyogU2NhbkNvZGUuRjEyICovLCAnRjEyJywgNzAgLyogS2V5Q29kZS5GMTIgKi8sICdGMTInLCAxMjMsICdWS19GMTInLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA3NiAvKiBTY2FuQ29kZS5QcmludFNjcmVlbiAqLywgJ1ByaW50U2NyZWVuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNzcgLyogU2NhbkNvZGUuU2Nyb2xsTG9jayAqLywgJ1Njcm9sbExvY2snLCA4NCAvKiBLZXlDb2RlLlNjcm9sbExvY2sgKi8sICdTY3JvbGxMb2NrJywgMTQ1LCAnVktfU0NST0xMJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgNzggLyogU2NhbkNvZGUuUGF1c2UgKi8sICdQYXVzZScsIDcgLyogS2V5Q29kZS5QYXVzZUJyZWFrICovLCAnUGF1c2VCcmVhaycsIDE5LCAnVktfUEFVU0UnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA3OSAvKiBTY2FuQ29kZS5JbnNlcnQgKi8sICdJbnNlcnQnLCAxOSAvKiBLZXlDb2RlLkluc2VydCAqLywgJ0luc2VydCcsIDQ1LCAnVktfSU5TRVJUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgODAgLyogU2NhbkNvZGUuSG9tZSAqLywgJ0hvbWUnLCAxNCAvKiBLZXlDb2RlLkhvbWUgKi8sICdIb21lJywgMzYsICdWS19IT01FJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgODEgLyogU2NhbkNvZGUuUGFnZVVwICovLCAnUGFnZVVwJywgMTEgLyogS2V5Q29kZS5QYWdlVXAgKi8sICdQYWdlVXAnLCAzMywgJ1ZLX1BSSU9SJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgODIgLyogU2NhbkNvZGUuRGVsZXRlICovLCAnRGVsZXRlJywgMjAgLyogS2V5Q29kZS5EZWxldGUgKi8sICdEZWxldGUnLCA0NiwgJ1ZLX0RFTEVURScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDgzIC8qIFNjYW5Db2RlLkVuZCAqLywgJ0VuZCcsIDEzIC8qIEtleUNvZGUuRW5kICovLCAnRW5kJywgMzUsICdWS19FTkQnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA4NCAvKiBTY2FuQ29kZS5QYWdlRG93biAqLywgJ1BhZ2VEb3duJywgMTIgLyogS2V5Q29kZS5QYWdlRG93biAqLywgJ1BhZ2VEb3duJywgMzQsICdWS19ORVhUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgODUgLyogU2NhbkNvZGUuQXJyb3dSaWdodCAqLywgJ0Fycm93UmlnaHQnLCAxNyAvKiBLZXlDb2RlLlJpZ2h0QXJyb3cgKi8sICdSaWdodEFycm93JywgMzksICdWS19SSUdIVCcsICdSaWdodCcsIGVtcHR5XSxcclxuICAgICAgICBbMSwgODYgLyogU2NhbkNvZGUuQXJyb3dMZWZ0ICovLCAnQXJyb3dMZWZ0JywgMTUgLyogS2V5Q29kZS5MZWZ0QXJyb3cgKi8sICdMZWZ0QXJyb3cnLCAzNywgJ1ZLX0xFRlQnLCAnTGVmdCcsIGVtcHR5XSxcclxuICAgICAgICBbMSwgODcgLyogU2NhbkNvZGUuQXJyb3dEb3duICovLCAnQXJyb3dEb3duJywgMTggLyogS2V5Q29kZS5Eb3duQXJyb3cgKi8sICdEb3duQXJyb3cnLCA0MCwgJ1ZLX0RPV04nLCAnRG93bicsIGVtcHR5XSxcclxuICAgICAgICBbMSwgODggLyogU2NhbkNvZGUuQXJyb3dVcCAqLywgJ0Fycm93VXAnLCAxNiAvKiBLZXlDb2RlLlVwQXJyb3cgKi8sICdVcEFycm93JywgMzgsICdWS19VUCcsICdVcCcsIGVtcHR5XSxcclxuICAgICAgICBbMSwgODkgLyogU2NhbkNvZGUuTnVtTG9jayAqLywgJ051bUxvY2snLCA4MyAvKiBLZXlDb2RlLk51bUxvY2sgKi8sICdOdW1Mb2NrJywgMTQ0LCAnVktfTlVNTE9DSycsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDkwIC8qIFNjYW5Db2RlLk51bXBhZERpdmlkZSAqLywgJ051bXBhZERpdmlkZScsIDExMyAvKiBLZXlDb2RlLk51bXBhZERpdmlkZSAqLywgJ051bVBhZF9EaXZpZGUnLCAxMTEsICdWS19ESVZJREUnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA5MSAvKiBTY2FuQ29kZS5OdW1wYWRNdWx0aXBseSAqLywgJ051bXBhZE11bHRpcGx5JywgMTA4IC8qIEtleUNvZGUuTnVtcGFkTXVsdGlwbHkgKi8sICdOdW1QYWRfTXVsdGlwbHknLCAxMDYsICdWS19NVUxUSVBMWScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDkyIC8qIFNjYW5Db2RlLk51bXBhZFN1YnRyYWN0ICovLCAnTnVtcGFkU3VidHJhY3QnLCAxMTEgLyogS2V5Q29kZS5OdW1wYWRTdWJ0cmFjdCAqLywgJ051bVBhZF9TdWJ0cmFjdCcsIDEwOSwgJ1ZLX1NVQlRSQUNUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgOTMgLyogU2NhbkNvZGUuTnVtcGFkQWRkICovLCAnTnVtcGFkQWRkJywgMTA5IC8qIEtleUNvZGUuTnVtcGFkQWRkICovLCAnTnVtUGFkX0FkZCcsIDEwNywgJ1ZLX0FERCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDk0IC8qIFNjYW5Db2RlLk51bXBhZEVudGVyICovLCAnTnVtcGFkRW50ZXInLCAzIC8qIEtleUNvZGUuRW50ZXIgKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgOTUgLyogU2NhbkNvZGUuTnVtcGFkMSAqLywgJ051bXBhZDEnLCA5OSAvKiBLZXlDb2RlLk51bXBhZDEgKi8sICdOdW1QYWQxJywgOTcsICdWS19OVU1QQUQxJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgOTYgLyogU2NhbkNvZGUuTnVtcGFkMiAqLywgJ051bXBhZDInLCAxMDAgLyogS2V5Q29kZS5OdW1wYWQyICovLCAnTnVtUGFkMicsIDk4LCAnVktfTlVNUEFEMicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDk3IC8qIFNjYW5Db2RlLk51bXBhZDMgKi8sICdOdW1wYWQzJywgMTAxIC8qIEtleUNvZGUuTnVtcGFkMyAqLywgJ051bVBhZDMnLCA5OSwgJ1ZLX05VTVBBRDMnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCA5OCAvKiBTY2FuQ29kZS5OdW1wYWQ0ICovLCAnTnVtcGFkNCcsIDEwMiAvKiBLZXlDb2RlLk51bXBhZDQgKi8sICdOdW1QYWQ0JywgMTAwLCAnVktfTlVNUEFENCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDk5IC8qIFNjYW5Db2RlLk51bXBhZDUgKi8sICdOdW1wYWQ1JywgMTAzIC8qIEtleUNvZGUuTnVtcGFkNSAqLywgJ051bVBhZDUnLCAxMDEsICdWS19OVU1QQUQ1JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTAwIC8qIFNjYW5Db2RlLk51bXBhZDYgKi8sICdOdW1wYWQ2JywgMTA0IC8qIEtleUNvZGUuTnVtcGFkNiAqLywgJ051bVBhZDYnLCAxMDIsICdWS19OVU1QQUQ2JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTAxIC8qIFNjYW5Db2RlLk51bXBhZDcgKi8sICdOdW1wYWQ3JywgMTA1IC8qIEtleUNvZGUuTnVtcGFkNyAqLywgJ051bVBhZDcnLCAxMDMsICdWS19OVU1QQUQ3JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTAyIC8qIFNjYW5Db2RlLk51bXBhZDggKi8sICdOdW1wYWQ4JywgMTA2IC8qIEtleUNvZGUuTnVtcGFkOCAqLywgJ051bVBhZDgnLCAxMDQsICdWS19OVU1QQUQ4JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTAzIC8qIFNjYW5Db2RlLk51bXBhZDkgKi8sICdOdW1wYWQ5JywgMTA3IC8qIEtleUNvZGUuTnVtcGFkOSAqLywgJ051bVBhZDknLCAxMDUsICdWS19OVU1QQUQ5JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTA0IC8qIFNjYW5Db2RlLk51bXBhZDAgKi8sICdOdW1wYWQwJywgOTggLyogS2V5Q29kZS5OdW1wYWQwICovLCAnTnVtUGFkMCcsIDk2LCAnVktfTlVNUEFEMCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEwNSAvKiBTY2FuQ29kZS5OdW1wYWREZWNpbWFsICovLCAnTnVtcGFkRGVjaW1hbCcsIDExMiAvKiBLZXlDb2RlLk51bXBhZERlY2ltYWwgKi8sICdOdW1QYWRfRGVjaW1hbCcsIDExMCwgJ1ZLX0RFQ0lNQUwnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFswLCAxMDYgLyogU2NhbkNvZGUuSW50bEJhY2tzbGFzaCAqLywgJ0ludGxCYWNrc2xhc2gnLCA5NyAvKiBLZXlDb2RlLkludGxCYWNrc2xhc2ggKi8sICdPRU1fMTAyJywgMjI2LCAnVktfT0VNXzEwMicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEwNyAvKiBTY2FuQ29kZS5Db250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51JywgNTggLyogS2V5Q29kZS5Db250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51JywgOTMsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxMDggLyogU2NhbkNvZGUuUG93ZXIgKi8sICdQb3dlcicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEwOSAvKiBTY2FuQ29kZS5OdW1wYWRFcXVhbCAqLywgJ051bXBhZEVxdWFsJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTEwIC8qIFNjYW5Db2RlLkYxMyAqLywgJ0YxMycsIDcxIC8qIEtleUNvZGUuRjEzICovLCAnRjEzJywgMTI0LCAnVktfRjEzJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTExIC8qIFNjYW5Db2RlLkYxNCAqLywgJ0YxNCcsIDcyIC8qIEtleUNvZGUuRjE0ICovLCAnRjE0JywgMTI1LCAnVktfRjE0JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTEyIC8qIFNjYW5Db2RlLkYxNSAqLywgJ0YxNScsIDczIC8qIEtleUNvZGUuRjE1ICovLCAnRjE1JywgMTI2LCAnVktfRjE1JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTEzIC8qIFNjYW5Db2RlLkYxNiAqLywgJ0YxNicsIDc0IC8qIEtleUNvZGUuRjE2ICovLCAnRjE2JywgMTI3LCAnVktfRjE2JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTE0IC8qIFNjYW5Db2RlLkYxNyAqLywgJ0YxNycsIDc1IC8qIEtleUNvZGUuRjE3ICovLCAnRjE3JywgMTI4LCAnVktfRjE3JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTE1IC8qIFNjYW5Db2RlLkYxOCAqLywgJ0YxOCcsIDc2IC8qIEtleUNvZGUuRjE4ICovLCAnRjE4JywgMTI5LCAnVktfRjE4JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTE2IC8qIFNjYW5Db2RlLkYxOSAqLywgJ0YxOScsIDc3IC8qIEtleUNvZGUuRjE5ICovLCAnRjE5JywgMTMwLCAnVktfRjE5JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTE3IC8qIFNjYW5Db2RlLkYyMCAqLywgJ0YyMCcsIDc4IC8qIEtleUNvZGUuRjIwICovLCAnRjIwJywgMTMxLCAnVktfRjIwJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTE4IC8qIFNjYW5Db2RlLkYyMSAqLywgJ0YyMScsIDc5IC8qIEtleUNvZGUuRjIxICovLCAnRjIxJywgMTMyLCAnVktfRjIxJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTE5IC8qIFNjYW5Db2RlLkYyMiAqLywgJ0YyMicsIDgwIC8qIEtleUNvZGUuRjIyICovLCAnRjIyJywgMTMzLCAnVktfRjIyJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTIwIC8qIFNjYW5Db2RlLkYyMyAqLywgJ0YyMycsIDgxIC8qIEtleUNvZGUuRjIzICovLCAnRjIzJywgMTM0LCAnVktfRjIzJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTIxIC8qIFNjYW5Db2RlLkYyNCAqLywgJ0YyNCcsIDgyIC8qIEtleUNvZGUuRjI0ICovLCAnRjI0JywgMTM1LCAnVktfRjI0JywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTIyIC8qIFNjYW5Db2RlLk9wZW4gKi8sICdPcGVuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTIzIC8qIFNjYW5Db2RlLkhlbHAgKi8sICdIZWxwJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTI0IC8qIFNjYW5Db2RlLlNlbGVjdCAqLywgJ1NlbGVjdCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEyNSAvKiBTY2FuQ29kZS5BZ2FpbiAqLywgJ0FnYWluJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTI2IC8qIFNjYW5Db2RlLlVuZG8gKi8sICdVbmRvJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTI3IC8qIFNjYW5Db2RlLkN1dCAqLywgJ0N1dCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEyOCAvKiBTY2FuQ29kZS5Db3B5ICovLCAnQ29weScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEyOSAvKiBTY2FuQ29kZS5QYXN0ZSAqLywgJ1Bhc3RlJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTMwIC8qIFNjYW5Db2RlLkZpbmQgKi8sICdGaW5kJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTMxIC8qIFNjYW5Db2RlLkF1ZGlvVm9sdW1lTXV0ZSAqLywgJ0F1ZGlvVm9sdW1lTXV0ZScsIDExNyAvKiBLZXlDb2RlLkF1ZGlvVm9sdW1lTXV0ZSAqLywgJ0F1ZGlvVm9sdW1lTXV0ZScsIDE3MywgJ1ZLX1ZPTFVNRV9NVVRFJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTMyIC8qIFNjYW5Db2RlLkF1ZGlvVm9sdW1lVXAgKi8sICdBdWRpb1ZvbHVtZVVwJywgMTE4IC8qIEtleUNvZGUuQXVkaW9Wb2x1bWVVcCAqLywgJ0F1ZGlvVm9sdW1lVXAnLCAxNzUsICdWS19WT0xVTUVfVVAnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxMzMgLyogU2NhbkNvZGUuQXVkaW9Wb2x1bWVEb3duICovLCAnQXVkaW9Wb2x1bWVEb3duJywgMTE5IC8qIEtleUNvZGUuQXVkaW9Wb2x1bWVEb3duICovLCAnQXVkaW9Wb2x1bWVEb3duJywgMTc0LCAnVktfVk9MVU1FX0RPV04nLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxMzQgLyogU2NhbkNvZGUuTnVtcGFkQ29tbWEgKi8sICdOdW1wYWRDb21tYScsIDExMCAvKiBLZXlDb2RlLk5VTVBBRF9TRVBBUkFUT1IgKi8sICdOdW1QYWRfU2VwYXJhdG9yJywgMTA4LCAnVktfU0VQQVJBVE9SJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMCwgMTM1IC8qIFNjYW5Db2RlLkludGxSbyAqLywgJ0ludGxSbycsIDExNSAvKiBLZXlDb2RlLkFCTlRfQzEgKi8sICdBQk5UX0MxJywgMTkzLCAnVktfQUJOVF9DMScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDEzNiAvKiBTY2FuQ29kZS5LYW5hTW9kZSAqLywgJ0thbmFNb2RlJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMCwgMTM3IC8qIFNjYW5Db2RlLkludGxZZW4gKi8sICdJbnRsWWVuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTM4IC8qIFNjYW5Db2RlLkNvbnZlcnQgKi8sICdDb252ZXJ0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTM5IC8qIFNjYW5Db2RlLk5vbkNvbnZlcnQgKi8sICdOb25Db252ZXJ0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTQwIC8qIFNjYW5Db2RlLkxhbmcxICovLCAnTGFuZzEnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNDEgLyogU2NhbkNvZGUuTGFuZzIgKi8sICdMYW5nMicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE0MiAvKiBTY2FuQ29kZS5MYW5nMyAqLywgJ0xhbmczJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTQzIC8qIFNjYW5Db2RlLkxhbmc0ICovLCAnTGFuZzQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNDQgLyogU2NhbkNvZGUuTGFuZzUgKi8sICdMYW5nNScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE0NSAvKiBTY2FuQ29kZS5BYm9ydCAqLywgJ0Fib3J0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTQ2IC8qIFNjYW5Db2RlLlByb3BzICovLCAnUHJvcHMnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNDcgLyogU2NhbkNvZGUuTnVtcGFkUGFyZW5MZWZ0ICovLCAnTnVtcGFkUGFyZW5MZWZ0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTQ4IC8qIFNjYW5Db2RlLk51bXBhZFBhcmVuUmlnaHQgKi8sICdOdW1wYWRQYXJlblJpZ2h0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTQ5IC8qIFNjYW5Db2RlLk51bXBhZEJhY2tzcGFjZSAqLywgJ051bXBhZEJhY2tzcGFjZScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE1MCAvKiBTY2FuQ29kZS5OdW1wYWRNZW1vcnlTdG9yZSAqLywgJ051bXBhZE1lbW9yeVN0b3JlJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTUxIC8qIFNjYW5Db2RlLk51bXBhZE1lbW9yeVJlY2FsbCAqLywgJ051bXBhZE1lbW9yeVJlY2FsbCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE1MiAvKiBTY2FuQ29kZS5OdW1wYWRNZW1vcnlDbGVhciAqLywgJ051bXBhZE1lbW9yeUNsZWFyJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTUzIC8qIFNjYW5Db2RlLk51bXBhZE1lbW9yeUFkZCAqLywgJ051bXBhZE1lbW9yeUFkZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE1NCAvKiBTY2FuQ29kZS5OdW1wYWRNZW1vcnlTdWJ0cmFjdCAqLywgJ051bXBhZE1lbW9yeVN1YnRyYWN0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTU1IC8qIFNjYW5Db2RlLk51bXBhZENsZWFyICovLCAnTnVtcGFkQ2xlYXInLCAxMzEgLyogS2V5Q29kZS5DbGVhciAqLywgJ0NsZWFyJywgMTIsICdWS19DTEVBUicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE1NiAvKiBTY2FuQ29kZS5OdW1wYWRDbGVhckVudHJ5ICovLCAnTnVtcGFkQ2xlYXJFbnRyeScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDUgLyogS2V5Q29kZS5DdHJsICovLCAnQ3RybCcsIDE3LCAnVktfQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDQgLyogS2V5Q29kZS5TaGlmdCAqLywgJ1NoaWZ0JywgMTYsICdWS19TSElGVCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDYgLyogS2V5Q29kZS5BbHQgKi8sICdBbHQnLCAxOCwgJ1ZLX01FTlUnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCA1NyAvKiBLZXlDb2RlLk1ldGEgKi8sICdNZXRhJywgOTEsICdWS19DT01NQU5EJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTU3IC8qIFNjYW5Db2RlLkNvbnRyb2xMZWZ0ICovLCAnQ29udHJvbExlZnQnLCA1IC8qIEtleUNvZGUuQ3RybCAqLywgZW1wdHksIDAsICdWS19MQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE1OCAvKiBTY2FuQ29kZS5TaGlmdExlZnQgKi8sICdTaGlmdExlZnQnLCA0IC8qIEtleUNvZGUuU2hpZnQgKi8sIGVtcHR5LCAwLCAnVktfTFNISUZUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTU5IC8qIFNjYW5Db2RlLkFsdExlZnQgKi8sICdBbHRMZWZ0JywgNiAvKiBLZXlDb2RlLkFsdCAqLywgZW1wdHksIDAsICdWS19MTUVOVScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE2MCAvKiBTY2FuQ29kZS5NZXRhTGVmdCAqLywgJ01ldGFMZWZ0JywgNTcgLyogS2V5Q29kZS5NZXRhICovLCBlbXB0eSwgMCwgJ1ZLX0xXSU4nLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNjEgLyogU2NhbkNvZGUuQ29udHJvbFJpZ2h0ICovLCAnQ29udHJvbFJpZ2h0JywgNSAvKiBLZXlDb2RlLkN0cmwgKi8sIGVtcHR5LCAwLCAnVktfUkNPTlRST0wnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNjIgLyogU2NhbkNvZGUuU2hpZnRSaWdodCAqLywgJ1NoaWZ0UmlnaHQnLCA0IC8qIEtleUNvZGUuU2hpZnQgKi8sIGVtcHR5LCAwLCAnVktfUlNISUZUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTYzIC8qIFNjYW5Db2RlLkFsdFJpZ2h0ICovLCAnQWx0UmlnaHQnLCA2IC8qIEtleUNvZGUuQWx0ICovLCBlbXB0eSwgMCwgJ1ZLX1JNRU5VJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTY0IC8qIFNjYW5Db2RlLk1ldGFSaWdodCAqLywgJ01ldGFSaWdodCcsIDU3IC8qIEtleUNvZGUuTWV0YSAqLywgZW1wdHksIDAsICdWS19SV0lOJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTY1IC8qIFNjYW5Db2RlLkJyaWdodG5lc3NVcCAqLywgJ0JyaWdodG5lc3NVcCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE2NiAvKiBTY2FuQ29kZS5CcmlnaHRuZXNzRG93biAqLywgJ0JyaWdodG5lc3NEb3duJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTY3IC8qIFNjYW5Db2RlLk1lZGlhUGxheSAqLywgJ01lZGlhUGxheScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE2OCAvKiBTY2FuQ29kZS5NZWRpYVJlY29yZCAqLywgJ01lZGlhUmVjb3JkJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTY5IC8qIFNjYW5Db2RlLk1lZGlhRmFzdEZvcndhcmQgKi8sICdNZWRpYUZhc3RGb3J3YXJkJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTcwIC8qIFNjYW5Db2RlLk1lZGlhUmV3aW5kICovLCAnTWVkaWFSZXdpbmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNzEgLyogU2NhbkNvZGUuTWVkaWFUcmFja05leHQgKi8sICdNZWRpYVRyYWNrTmV4dCcsIDEyNCAvKiBLZXlDb2RlLk1lZGlhVHJhY2tOZXh0ICovLCAnTWVkaWFUcmFja05leHQnLCAxNzYsICdWS19NRURJQV9ORVhUX1RSQUNLJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTcyIC8qIFNjYW5Db2RlLk1lZGlhVHJhY2tQcmV2aW91cyAqLywgJ01lZGlhVHJhY2tQcmV2aW91cycsIDEyNSAvKiBLZXlDb2RlLk1lZGlhVHJhY2tQcmV2aW91cyAqLywgJ01lZGlhVHJhY2tQcmV2aW91cycsIDE3NywgJ1ZLX01FRElBX1BSRVZfVFJBQ0snLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNzMgLyogU2NhbkNvZGUuTWVkaWFTdG9wICovLCAnTWVkaWFTdG9wJywgMTI2IC8qIEtleUNvZGUuTWVkaWFTdG9wICovLCAnTWVkaWFTdG9wJywgMTc4LCAnVktfTUVESUFfU1RPUCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE3NCAvKiBTY2FuQ29kZS5FamVjdCAqLywgJ0VqZWN0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTc1IC8qIFNjYW5Db2RlLk1lZGlhUGxheVBhdXNlICovLCAnTWVkaWFQbGF5UGF1c2UnLCAxMjcgLyogS2V5Q29kZS5NZWRpYVBsYXlQYXVzZSAqLywgJ01lZGlhUGxheVBhdXNlJywgMTc5LCAnVktfTUVESUFfUExBWV9QQVVTRScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE3NiAvKiBTY2FuQ29kZS5NZWRpYVNlbGVjdCAqLywgJ01lZGlhU2VsZWN0JywgMTI4IC8qIEtleUNvZGUuTGF1bmNoTWVkaWFQbGF5ZXIgKi8sICdMYXVuY2hNZWRpYVBsYXllcicsIDE4MSwgJ1ZLX01FRElBX0xBVU5DSF9NRURJQV9TRUxFQ1QnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxNzcgLyogU2NhbkNvZGUuTGF1bmNoTWFpbCAqLywgJ0xhdW5jaE1haWwnLCAxMjkgLyogS2V5Q29kZS5MYXVuY2hNYWlsICovLCAnTGF1bmNoTWFpbCcsIDE4MCwgJ1ZLX01FRElBX0xBVU5DSF9NQUlMJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTc4IC8qIFNjYW5Db2RlLkxhdW5jaEFwcDIgKi8sICdMYXVuY2hBcHAyJywgMTMwIC8qIEtleUNvZGUuTGF1bmNoQXBwMiAqLywgJ0xhdW5jaEFwcDInLCAxODMsICdWS19NRURJQV9MQVVOQ0hfQVBQMicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE3OSAvKiBTY2FuQ29kZS5MYXVuY2hBcHAxICovLCAnTGF1bmNoQXBwMScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX01FRElBX0xBVU5DSF9BUFAxJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTgwIC8qIFNjYW5Db2RlLlNlbGVjdFRhc2sgKi8sICdTZWxlY3RUYXNrJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTgxIC8qIFNjYW5Db2RlLkxhdW5jaFNjcmVlblNhdmVyICovLCAnTGF1bmNoU2NyZWVuU2F2ZXInLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxODIgLyogU2NhbkNvZGUuQnJvd3NlclNlYXJjaCAqLywgJ0Jyb3dzZXJTZWFyY2gnLCAxMjAgLyogS2V5Q29kZS5Ccm93c2VyU2VhcmNoICovLCAnQnJvd3NlclNlYXJjaCcsIDE3MCwgJ1ZLX0JST1dTRVJfU0VBUkNIJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTgzIC8qIFNjYW5Db2RlLkJyb3dzZXJIb21lICovLCAnQnJvd3NlckhvbWUnLCAxMjEgLyogS2V5Q29kZS5Ccm93c2VySG9tZSAqLywgJ0Jyb3dzZXJIb21lJywgMTcyLCAnVktfQlJPV1NFUl9IT01FJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTg0IC8qIFNjYW5Db2RlLkJyb3dzZXJCYWNrICovLCAnQnJvd3NlckJhY2snLCAxMjIgLyogS2V5Q29kZS5Ccm93c2VyQmFjayAqLywgJ0Jyb3dzZXJCYWNrJywgMTY2LCAnVktfQlJPV1NFUl9CQUNLJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTg1IC8qIFNjYW5Db2RlLkJyb3dzZXJGb3J3YXJkICovLCAnQnJvd3NlckZvcndhcmQnLCAxMjMgLyogS2V5Q29kZS5Ccm93c2VyRm9yd2FyZCAqLywgJ0Jyb3dzZXJGb3J3YXJkJywgMTY3LCAnVktfQlJPV1NFUl9GT1JXQVJEJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTg2IC8qIFNjYW5Db2RlLkJyb3dzZXJTdG9wICovLCAnQnJvd3NlclN0b3AnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19CUk9XU0VSX1NUT1AnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAxODcgLyogU2NhbkNvZGUuQnJvd3NlclJlZnJlc2ggKi8sICdCcm93c2VyUmVmcmVzaCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0JST1dTRVJfUkVGUkVTSCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE4OCAvKiBTY2FuQ29kZS5Ccm93c2VyRmF2b3JpdGVzICovLCAnQnJvd3NlckZhdm9yaXRlcycsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0JST1dTRVJfRkFWT1JJVEVTJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTg5IC8qIFNjYW5Db2RlLlpvb21Ub2dnbGUgKi8sICdab29tVG9nZ2xlJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTkwIC8qIFNjYW5Db2RlLk1haWxSZXBseSAqLywgJ01haWxSZXBseScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDE5MSAvKiBTY2FuQ29kZS5NYWlsRm9yd2FyZCAqLywgJ01haWxGb3J3YXJkJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMTkyIC8qIFNjYW5Db2RlLk1haWxTZW5kICovLCAnTWFpbFNlbmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LWRvbS8yMDEwSnVsU2VwL2F0dC0wMTgyL2tleUNvZGUtc3BlYy5odG1sXHJcbiAgICAgICAgLy8gSWYgYW4gSW5wdXQgTWV0aG9kIEVkaXRvciBpcyBwcm9jZXNzaW5nIGtleSBpbnB1dCBhbmQgdGhlIGV2ZW50IGlzIGtleWRvd24sIHJldHVybiAyMjkuXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDExNCAvKiBLZXlDb2RlLktFWV9JTl9DT01QT1NJVElPTiAqLywgJ0tleUluQ29tcG9zaXRpb24nLCAyMjksIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAxMTYgLyogS2V5Q29kZS5BQk5UX0MyICovLCAnQUJOVF9DMicsIDE5NCwgJ1ZLX0FCTlRfQzInLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCA5NiAvKiBLZXlDb2RlLk9FTV84ICovLCAnT0VNXzgnLCAyMjMsICdWS19PRU1fOCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0tBTkEnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19IQU5HVUwnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19KVU5KQScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0ZJTkFMJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSEFOSkEnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19LQU5KSScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0NPTlZFUlQnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19OT05DT05WRVJUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQUNDRVBUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTU9ERUNIQU5HRScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1NFTEVDVCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1BSSU5UJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRVhFQ1VURScsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1NOQVBTSE9UJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSEVMUCcsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0FQUFMnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19QUk9DRVNTS0VZJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUEFDS0VUJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfREJFX1NCQ1NDSEFSJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfREJFX0RCQ1NDSEFSJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQVRUTicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0NSU0VMJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRVhTRUwnLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19FUkVPRicsIGVtcHR5LCBlbXB0eV0sXHJcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1BMQVknLCBlbXB0eSwgZW1wdHldLFxyXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19aT09NJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTk9OQU1FJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUEExJywgZW1wdHksIGVtcHR5XSxcclxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfT0VNX0NMRUFSJywgZW1wdHksIGVtcHR5XSxcclxuICAgIF07XHJcbiAgICBjb25zdCBzZWVuS2V5Q29kZSA9IFtdO1xyXG4gICAgY29uc3Qgc2VlblNjYW5Db2RlID0gW107XHJcbiAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgbWFwcGluZ3MpIHtcclxuICAgICAgICBjb25zdCBbaW1tdXRhYmxlLCBzY2FuQ29kZSwgc2NhbkNvZGVTdHIsIGtleUNvZGUsIGtleUNvZGVTdHIsIGV2ZW50S2V5Q29kZSwgdmtleSwgdXNVc2VyU2V0dGluZ3NMYWJlbCwgZ2VuZXJhbFVzZXJTZXR0aW5nc0xhYmVsXSA9IG1hcHBpbmc7XHJcbiAgICAgICAgaWYgKCFzZWVuU2NhbkNvZGVbc2NhbkNvZGVdKSB7XHJcbiAgICAgICAgICAgIHNlZW5TY2FuQ29kZVtzY2FuQ29kZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBzY2FuQ29kZUludFRvU3RyW3NjYW5Db2RlXSA9IHNjYW5Db2RlU3RyO1xyXG4gICAgICAgICAgICBzY2FuQ29kZVN0clRvSW50W3NjYW5Db2RlU3RyXSA9IHNjYW5Db2RlO1xyXG4gICAgICAgICAgICBzY2FuQ29kZUxvd2VyQ2FzZVN0clRvSW50W3NjYW5Db2RlU3RyLnRvTG93ZXJDYXNlKCldID0gc2NhbkNvZGU7XHJcbiAgICAgICAgICAgIGlmIChpbW11dGFibGUpIHtcclxuICAgICAgICAgICAgICAgIElNTVVUQUJMRV9DT0RFX1RPX0tFWV9DT0RFW3NjYW5Db2RlXSA9IGtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGtleUNvZGUgIT09IDAgLyogS2V5Q29kZS5Vbmtub3duICovKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIChrZXlDb2RlICE9PSAzIC8qIEtleUNvZGUuRW50ZXIgKi8pXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDUgLyogS2V5Q29kZS5DdHJsICovKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIChrZXlDb2RlICE9PSA0IC8qIEtleUNvZGUuU2hpZnQgKi8pXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDYgLyogS2V5Q29kZS5BbHQgKi8pXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDU3IC8qIEtleUNvZGUuTWV0YSAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBJTU1VVEFCTEVfS0VZX0NPREVfVE9fQ09ERVtrZXlDb2RlXSA9IHNjYW5Db2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc2VlbktleUNvZGVba2V5Q29kZV0pIHtcclxuICAgICAgICAgICAgc2VlbktleUNvZGVba2V5Q29kZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIWtleUNvZGVTdHIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG1pc3NpbmcgZm9yIGtleSBjb2RlICR7a2V5Q29kZX0gYXJvdW5kIHNjYW4gY29kZSAke3NjYW5Db2RlU3RyfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVpTWFwLmRlZmluZShrZXlDb2RlLCBrZXlDb2RlU3RyKTtcclxuICAgICAgICAgICAgdXNlclNldHRpbmdzVVNNYXAuZGVmaW5lKGtleUNvZGUsIHVzVXNlclNldHRpbmdzTGFiZWwgfHwga2V5Q29kZVN0cik7XHJcbiAgICAgICAgICAgIHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAuZGVmaW5lKGtleUNvZGUsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbCB8fCB1c1VzZXJTZXR0aW5nc0xhYmVsIHx8IGtleUNvZGVTdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRLZXlDb2RlKSB7XHJcbiAgICAgICAgICAgIEVWRU5UX0tFWV9DT0RFX01BUFtldmVudEtleUNvZGVdID0ga2V5Q29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZrZXkpIHtcclxuICAgICAgICAgICAgTkFUSVZFX1dJTkRPV1NfS0VZX0NPREVfVE9fS0VZX0NPREVbdmtleV0gPSBrZXlDb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE1hbnVhbGx5IGFkZGVkIGR1ZSB0byB0aGUgZXhjbHVzaW9uIGFib3ZlIChkdWUgdG8gZHVwbGljYXRpb24gd2l0aCBOdW1wYWRFbnRlcilcclxuICAgIElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFWzMgLyogS2V5Q29kZS5FbnRlciAqL10gPSA0NiAvKiBTY2FuQ29kZS5FbnRlciAqLztcclxufSkoKTtcclxuZXhwb3J0IHZhciBLZXlDb2RlVXRpbHM7XHJcbihmdW5jdGlvbiAoS2V5Q29kZVV0aWxzKSB7XHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZyhrZXlDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVpTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcclxuICAgIH1cclxuICAgIEtleUNvZGVVdGlscy50b1N0cmluZyA9IHRvU3RyaW5nO1xyXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhrZXkpIHtcclxuICAgICAgICByZXR1cm4gdWlNYXAuc3RyVG9LZXlDb2RlKGtleSk7XHJcbiAgICB9XHJcbiAgICBLZXlDb2RlVXRpbHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcbiAgICBmdW5jdGlvbiB0b1VzZXJTZXR0aW5nc1VTKGtleUNvZGUpIHtcclxuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzVVNNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xyXG4gICAgfVxyXG4gICAgS2V5Q29kZVV0aWxzLnRvVXNlclNldHRpbmdzVVMgPSB0b1VzZXJTZXR0aW5nc1VTO1xyXG4gICAgZnVuY3Rpb24gdG9Vc2VyU2V0dGluZ3NHZW5lcmFsKGtleUNvZGUpIHtcclxuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzR2VuZXJhbE1hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XHJcbiAgICB9XHJcbiAgICBLZXlDb2RlVXRpbHMudG9Vc2VyU2V0dGluZ3NHZW5lcmFsID0gdG9Vc2VyU2V0dGluZ3NHZW5lcmFsO1xyXG4gICAgZnVuY3Rpb24gZnJvbVVzZXJTZXR0aW5ncyhrZXkpIHtcclxuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzVVNNYXAuc3RyVG9LZXlDb2RlKGtleSkgfHwgdXNlclNldHRpbmdzR2VuZXJhbE1hcC5zdHJUb0tleUNvZGUoa2V5KTtcclxuICAgIH1cclxuICAgIEtleUNvZGVVdGlscy5mcm9tVXNlclNldHRpbmdzID0gZnJvbVVzZXJTZXR0aW5ncztcclxuICAgIGZ1bmN0aW9uIHRvRWxlY3Ryb25BY2NlbGVyYXRvcihrZXlDb2RlKSB7XHJcbiAgICAgICAgaWYgKGtleUNvZGUgPj0gOTggLyogS2V5Q29kZS5OdW1wYWQwICovICYmIGtleUNvZGUgPD0gMTEzIC8qIEtleUNvZGUuTnVtcGFkRGl2aWRlICovKSB7XHJcbiAgICAgICAgICAgIC8vIFtFbGVjdHJvbiBBY2NlbGVyYXRvcnNdIEVsZWN0cm9uIGlzIGFibGUgdG8gcGFyc2UgbnVtcGFkIGtleXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0XHJcbiAgICAgICAgICAgIC8vIHJlbmRlcnMgdGhlbSBqdXN0IGFzIHJlZ3VsYXIga2V5cyBpbiBtZW51cy4gRm9yIGV4YW1wbGUsIG51bTAgaXMgcmVuZGVyZWQgYXMgXCIwXCIsXHJcbiAgICAgICAgICAgIC8vIG51bWRpdiBpcyByZW5kZXJlZCBhcyBcIi9cIiwgbnVtc3ViIGlzIHJlbmRlcmVkIGFzIFwiLVwiLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBsZWFkIHRvIGluY3JlZGlibGUgY29uZnVzaW9uLCBhcyBpdCBtYWtlcyBudW1wYWQgYmFzZWQga2V5YmluZGluZ3MgaW5kaXN0aW5ndWlzaGFibGVcclxuICAgICAgICAgICAgLy8gZnJvbSBrZXliaW5kaW5ncyBiYXNlZCBvbiByZWd1bGFyIGtleXMuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFdlIHRoZXJlZm9yZSBuZWVkIHRvIGZhbGwgYmFjayB0byBjdXN0b20gcmVuZGVyaW5nIGZvciBudW1wYWQga2V5cy5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xyXG4gICAgICAgICAgICBjYXNlIDE2IC8qIEtleUNvZGUuVXBBcnJvdyAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnVXAnO1xyXG4gICAgICAgICAgICBjYXNlIDE4IC8qIEtleUNvZGUuRG93bkFycm93ICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdEb3duJztcclxuICAgICAgICAgICAgY2FzZSAxNSAvKiBLZXlDb2RlLkxlZnRBcnJvdyAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnTGVmdCc7XHJcbiAgICAgICAgICAgIGNhc2UgMTcgLyogS2V5Q29kZS5SaWdodEFycm93ICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdSaWdodCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1aU1hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XHJcbiAgICB9XHJcbiAgICBLZXlDb2RlVXRpbHMudG9FbGVjdHJvbkFjY2VsZXJhdG9yID0gdG9FbGVjdHJvbkFjY2VsZXJhdG9yO1xyXG59KShLZXlDb2RlVXRpbHMgfHwgKEtleUNvZGVVdGlscyA9IHt9KSk7XHJcbmV4cG9ydCBmdW5jdGlvbiBLZXlDaG9yZChmaXJzdFBhcnQsIHNlY29uZFBhcnQpIHtcclxuICAgIGNvbnN0IGNob3JkUGFydCA9ICgoc2Vjb25kUGFydCAmIDB4MDAwMEZGRkYpIDw8IDE2KSA+Pj4gMDtcclxuICAgIHJldHVybiAoZmlyc3RQYXJ0IHwgY2hvcmRQYXJ0KSA+Pj4gMDtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/lazy.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/lazy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lazy: () => (/* binding */ Lazy)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Lazy {\r\n    constructor(executor) {\r\n        this.executor = executor;\r\n        this._didRun = false;\r\n    }\r\n    /**\r\n     * Get the wrapped value.\r\n     *\r\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\r\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\r\n     */\r\n    get value() {\r\n        if (!this._didRun) {\r\n            try {\r\n                this._value = this.executor();\r\n            }\r\n            catch (err) {\r\n                this._error = err;\r\n            }\r\n            finally {\r\n                this._didRun = true;\r\n            }\r\n        }\r\n        if (this._error) {\r\n            throw this._error;\r\n        }\r\n        return this._value;\r\n    }\r\n    /**\r\n     * Get the wrapped value without forcing evaluation.\r\n     */\r\n    get rawValue() { return this._value; }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGF6eS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9sYXp5LmpzPzQxZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydCBjbGFzcyBMYXp5IHtcclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XHJcbiAgICAgICAgdGhpcy5leGVjdXRvciA9IGV4ZWN1dG9yO1xyXG4gICAgICAgIHRoaXMuX2RpZFJ1biA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHdyYXBwZWQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB3aWxsIGZvcmNlIGV2YWx1YXRpb24gb2YgdGhlIGxhenkgdmFsdWUgaWYgaXQgaGFzIG5vdCBiZWVuIHJlc29sdmVkIHlldC4gTGF6eSB2YWx1ZXMgYXJlIG9ubHlcclxuICAgICAqIHJlc29sdmVkIG9uY2UuIGBnZXRWYWx1ZWAgd2lsbCByZS10aHJvdyBleGNlcHRpb25zIHRoYXQgYXJlIGhpdCB3aGlsZSByZXNvbHZpbmcgdGhlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RpZFJ1bikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmV4ZWN1dG9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRSdW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHdyYXBwZWQgdmFsdWUgd2l0aG91dCBmb3JjaW5nIGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCByYXdWYWx1ZSgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/lazy.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Disposable: () => (/* binding */ Disposable),\n/* harmony export */   DisposableMap: () => (/* binding */ DisposableMap),\n/* harmony export */   DisposableStore: () => (/* binding */ DisposableStore),\n/* harmony export */   ImmortalReference: () => (/* binding */ ImmortalReference),\n/* harmony export */   MutableDisposable: () => (/* binding */ MutableDisposable),\n/* harmony export */   RefCountedDisposable: () => (/* binding */ RefCountedDisposable),\n/* harmony export */   combinedDisposable: () => (/* binding */ combinedDisposable),\n/* harmony export */   dispose: () => (/* binding */ dispose),\n/* harmony export */   isDisposable: () => (/* binding */ isDisposable),\n/* harmony export */   markAsDisposed: () => (/* binding */ markAsDisposed),\n/* harmony export */   markAsSingleton: () => (/* binding */ markAsSingleton),\n/* harmony export */   setDisposableTracker: () => (/* binding */ setDisposableTracker),\n/* harmony export */   toDisposable: () => (/* binding */ toDisposable),\n/* harmony export */   trackDisposable: () => (/* binding */ trackDisposable)\n/* harmony export */ });\n/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional.js */ \"./node_modules/monaco-editor/esm/vs/base/common/functional.js\");\n/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterator.js */ \"./node_modules/monaco-editor/esm/vs/base/common/iterator.js\");\n\r\n\r\n// #region Disposable Tracking\r\n/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\r\nconst TRACK_DISPOSABLES = false;\r\nlet disposableTracker = null;\r\nfunction setDisposableTracker(tracker) {\r\n    disposableTracker = tracker;\r\n}\r\nif (TRACK_DISPOSABLES) {\r\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\r\n    setDisposableTracker(new class {\r\n        trackDisposable(x) {\r\n            const stack = new Error('Potentially leaked disposable').stack;\r\n            setTimeout(() => {\r\n                if (!x[__is_disposable_tracked__]) {\r\n                    console.log(stack);\r\n                }\r\n            }, 3000);\r\n        }\r\n        setParent(child, parent) {\r\n            if (child && child !== Disposable.None) {\r\n                try {\r\n                    child[__is_disposable_tracked__] = true;\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n            }\r\n        }\r\n        markAsDisposed(disposable) {\r\n            if (disposable && disposable !== Disposable.None) {\r\n                try {\r\n                    disposable[__is_disposable_tracked__] = true;\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n            }\r\n        }\r\n        markAsSingleton(disposable) { }\r\n    });\r\n}\r\nfunction trackDisposable(x) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\r\n    return x;\r\n}\r\nfunction markAsDisposed(disposable) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\r\n}\r\nfunction setParentOfDisposable(child, parent) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\r\n}\r\nfunction setParentOfDisposables(children, parent) {\r\n    if (!disposableTracker) {\r\n        return;\r\n    }\r\n    for (const child of children) {\r\n        disposableTracker.setParent(child, parent);\r\n    }\r\n}\r\n/**\r\n * Indicates that the given object is a singleton which does not need to be disposed.\r\n*/\r\nfunction markAsSingleton(singleton) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\r\n    return singleton;\r\n}\r\n/**\r\n * Check if `thing` is {@link IDisposable disposable}.\r\n */\r\nfunction isDisposable(thing) {\r\n    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\r\n}\r\nfunction dispose(arg) {\r\n    if (_iterator_js__WEBPACK_IMPORTED_MODULE_1__.Iterable.is(arg)) {\r\n        const errors = [];\r\n        for (const d of arg) {\r\n            if (d) {\r\n                try {\r\n                    d.dispose();\r\n                }\r\n                catch (e) {\r\n                    errors.push(e);\r\n                }\r\n            }\r\n        }\r\n        if (errors.length === 1) {\r\n            throw errors[0];\r\n        }\r\n        else if (errors.length > 1) {\r\n            throw new AggregateError(errors, 'Encountered errors while disposing of store');\r\n        }\r\n        return Array.isArray(arg) ? [] : arg;\r\n    }\r\n    else if (arg) {\r\n        arg.dispose();\r\n        return arg;\r\n    }\r\n}\r\n/**\r\n * Combine multiple disposable values into a single {@link IDisposable}.\r\n */\r\nfunction combinedDisposable(...disposables) {\r\n    const parent = toDisposable(() => dispose(disposables));\r\n    setParentOfDisposables(disposables, parent);\r\n    return parent;\r\n}\r\n/**\r\n * Turn a function that implements dispose into an {@link IDisposable}.\r\n *\r\n * @param fn Clean up function, guaranteed to be called only **once**.\r\n */\r\nfunction toDisposable(fn) {\r\n    const self = trackDisposable({\r\n        dispose: (0,_functional_js__WEBPACK_IMPORTED_MODULE_0__.createSingleCallFunction)(() => {\r\n            markAsDisposed(self);\r\n            fn();\r\n        })\r\n    });\r\n    return self;\r\n}\r\n/**\r\n * Manages a collection of disposable values.\r\n *\r\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\r\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\r\n * store that has already been disposed of.\r\n */\r\nclass DisposableStore {\r\n    constructor() {\r\n        this._toDispose = new Set();\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables and mark this object as disposed.\r\n     *\r\n     * Any future disposables added to this object will be disposed of on `add`.\r\n     */\r\n    dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        markAsDisposed(this);\r\n        this._isDisposed = true;\r\n        this.clear();\r\n    }\r\n    /**\r\n     * @return `true` if this object has been disposed of.\r\n     */\r\n    get isDisposed() {\r\n        return this._isDisposed;\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\r\n    clear() {\r\n        if (this._toDispose.size === 0) {\r\n            return;\r\n        }\r\n        try {\r\n            dispose(this._toDispose);\r\n        }\r\n        finally {\r\n            this._toDispose.clear();\r\n        }\r\n    }\r\n    /**\r\n     * Add a new {@link IDisposable disposable} to the collection.\r\n     */\r\n    add(o) {\r\n        if (!o) {\r\n            return o;\r\n        }\r\n        if (o === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        setParentOfDisposable(o, this);\r\n        if (this._isDisposed) {\r\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\r\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\r\n            }\r\n        }\r\n        else {\r\n            this._toDispose.add(o);\r\n        }\r\n        return o;\r\n    }\r\n    /**\r\n     * Deletes the value from the store, but does not dispose it.\r\n     */\r\n    deleteAndLeak(o) {\r\n        if (!o) {\r\n            return;\r\n        }\r\n        if (this._toDispose.has(o)) {\r\n            this._toDispose.delete(o);\r\n            setParentOfDisposable(o, null);\r\n        }\r\n    }\r\n}\r\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\r\n/**\r\n * Abstract base class for a {@link IDisposable disposable} object.\r\n *\r\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\r\n */\r\nclass Disposable {\r\n    constructor() {\r\n        this._store = new DisposableStore();\r\n        trackDisposable(this);\r\n        setParentOfDisposable(this._store, this);\r\n    }\r\n    dispose() {\r\n        markAsDisposed(this);\r\n        this._store.dispose();\r\n    }\r\n    /**\r\n     * Adds `o` to the collection of disposables managed by this object.\r\n     */\r\n    _register(o) {\r\n        if (o === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        return this._store.add(o);\r\n    }\r\n}\r\n/**\r\n * A disposable that does nothing when it is disposed of.\r\n *\r\n * TODO: This should not be a static property.\r\n */\r\nDisposable.None = Object.freeze({ dispose() { } });\r\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\r\nclass MutableDisposable {\r\n    constructor() {\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    get value() {\r\n        return this._isDisposed ? undefined : this._value;\r\n    }\r\n    set value(value) {\r\n        var _a;\r\n        if (this._isDisposed || value === this._value) {\r\n            return;\r\n        }\r\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        if (value) {\r\n            setParentOfDisposable(value, this);\r\n        }\r\n        this._value = value;\r\n    }\r\n    /**\r\n     * Resets the stored value and disposed of the previously stored value.\r\n     */\r\n    clear() {\r\n        this.value = undefined;\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        this._isDisposed = true;\r\n        markAsDisposed(this);\r\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._value = undefined;\r\n    }\r\n}\r\nclass RefCountedDisposable {\r\n    constructor(_disposable) {\r\n        this._disposable = _disposable;\r\n        this._counter = 1;\r\n    }\r\n    acquire() {\r\n        this._counter++;\r\n        return this;\r\n    }\r\n    release() {\r\n        if (--this._counter === 0) {\r\n            this._disposable.dispose();\r\n        }\r\n        return this;\r\n    }\r\n}\r\nclass ImmortalReference {\r\n    constructor(object) {\r\n        this.object = object;\r\n    }\r\n    dispose() { }\r\n}\r\n/**\r\n * A map the manages the lifecycle of the values that it stores.\r\n */\r\nclass DisposableMap {\r\n    constructor() {\r\n        this._store = new Map();\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    /**\r\n     * Disposes of all stored values and mark this object as disposed.\r\n     *\r\n     * Trying to use this object after it has been disposed of is an error.\r\n     */\r\n    dispose() {\r\n        markAsDisposed(this);\r\n        this._isDisposed = true;\r\n        this.clearAndDisposeAll();\r\n    }\r\n    /**\r\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\r\n     */\r\n    clearAndDisposeAll() {\r\n        if (!this._store.size) {\r\n            return;\r\n        }\r\n        try {\r\n            dispose(this._store.values());\r\n        }\r\n        finally {\r\n            this._store.clear();\r\n        }\r\n    }\r\n    get(key) {\r\n        return this._store.get(key);\r\n    }\r\n    set(key, value, skipDisposeOnOverwrite = false) {\r\n        var _a;\r\n        if (this._isDisposed) {\r\n            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\r\n        }\r\n        if (!skipDisposeOnOverwrite) {\r\n            (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        }\r\n        this._store.set(key, value);\r\n    }\r\n    /**\r\n     * Delete the value stored for `key` from this map and also dispose of it.\r\n     */\r\n    deleteAndDispose(key) {\r\n        var _a;\r\n        (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._store.delete(key);\r\n    }\r\n    [Symbol.iterator]() {\r\n        return this._store[Symbol.iterator]();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkQ7QUFDbEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsUUFBUSxrREFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsd0VBQXdCO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcz9hNjY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNpbmdsZUNhbGxGdW5jdGlvbiB9IGZyb20gJy4vZnVuY3Rpb25hbC5qcyc7XHJcbmltcG9ydCB7IEl0ZXJhYmxlIH0gZnJvbSAnLi9pdGVyYXRvci5qcyc7XHJcbi8vICNyZWdpb24gRGlzcG9zYWJsZSBUcmFja2luZ1xyXG4vKipcclxuICogRW5hYmxlcyBsb2dnaW5nIG9mIHBvdGVudGlhbGx5IGxlYWtlZCBkaXNwb3NhYmxlcy5cclxuICpcclxuICogQSBkaXNwb3NhYmxlIGlzIGNvbnNpZGVyZWQgbGVha2VkIGlmIGl0IGlzIG5vdCBkaXNwb3NlZCBvciBub3QgcmVnaXN0ZXJlZCBhcyB0aGUgY2hpbGQgb2ZcclxuICogYW5vdGhlciBkaXNwb3NhYmxlLiBUaGlzIHRyYWNraW5nIGlzIHZlcnkgc2ltcGxlIGFuIG9ubHkgd29ya3MgZm9yIGNsYXNzZXMgdGhhdCBlaXRoZXJcclxuICogZXh0ZW5kIERpc3Bvc2FibGUgb3IgdXNlIGEgRGlzcG9zYWJsZVN0b3JlLiBUaGlzIG1lYW5zIHRoZXJlIGFyZSBhIGxvdCBvZiBmYWxzZSBwb3NpdGl2ZXMuXHJcbiAqL1xyXG5jb25zdCBUUkFDS19ESVNQT1NBQkxFUyA9IGZhbHNlO1xyXG5sZXQgZGlzcG9zYWJsZVRyYWNrZXIgPSBudWxsO1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0RGlzcG9zYWJsZVRyYWNrZXIodHJhY2tlcikge1xyXG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPSB0cmFja2VyO1xyXG59XHJcbmlmIChUUkFDS19ESVNQT1NBQkxFUykge1xyXG4gICAgY29uc3QgX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfXyA9ICdfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fJztcclxuICAgIHNldERpc3Bvc2FibGVUcmFja2VyKG5ldyBjbGFzcyB7XHJcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoJ1BvdGVudGlhbGx5IGxlYWtlZCBkaXNwb3NhYmxlJykuc3RhY2s7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF4W19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAzMDAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0UGFyZW50KGNoaWxkLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSBEaXNwb3NhYmxlLk5vbmUpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfX10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtBc0Rpc3Bvc2VkKGRpc3Bvc2FibGUpIHtcclxuICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGUgJiYgZGlzcG9zYWJsZSAhPT0gRGlzcG9zYWJsZS5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVbX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfX10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtBc1NpbmdsZXRvbihkaXNwb3NhYmxlKSB7IH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFja0Rpc3Bvc2FibGUoeCkge1xyXG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLnRyYWNrRGlzcG9zYWJsZSh4KTtcclxuICAgIHJldHVybiB4O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKSB7XHJcbiAgICBkaXNwb3NhYmxlVHJhY2tlciA9PT0gbnVsbCB8fCBkaXNwb3NhYmxlVHJhY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZVRyYWNrZXIubWFya0FzRGlzcG9zZWQoZGlzcG9zYWJsZSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0UGFyZW50T2ZEaXNwb3NhYmxlKGNoaWxkLCBwYXJlbnQpIHtcclxuICAgIGRpc3Bvc2FibGVUcmFja2VyID09PSBudWxsIHx8IGRpc3Bvc2FibGVUcmFja2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXNwb3NhYmxlVHJhY2tlci5zZXRQYXJlbnQoY2hpbGQsIHBhcmVudCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0UGFyZW50T2ZEaXNwb3NhYmxlcyhjaGlsZHJlbiwgcGFyZW50KSB7XHJcbiAgICBpZiAoIWRpc3Bvc2FibGVUcmFja2VyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgIGRpc3Bvc2FibGVUcmFja2VyLnNldFBhcmVudChjaGlsZCwgcGFyZW50KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5kaWNhdGVzIHRoYXQgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHNpbmdsZXRvbiB3aGljaCBkb2VzIG5vdCBuZWVkIHRvIGJlIGRpc3Bvc2VkLlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFya0FzU2luZ2xldG9uKHNpbmdsZXRvbikge1xyXG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLm1hcmtBc1NpbmdsZXRvbihzaW5nbGV0b24pO1xyXG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYHRoaW5nYCBpcyB7QGxpbmsgSURpc3Bvc2FibGUgZGlzcG9zYWJsZX0uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEaXNwb3NhYmxlKHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JyAmJiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGluZy5kaXNwb3NlLmxlbmd0aCA9PT0gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZShhcmcpIHtcclxuICAgIGlmIChJdGVyYWJsZS5pcyhhcmcpKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIGFyZykge1xyXG4gICAgICAgICAgICBpZiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBkLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzLCAnRW5jb3VudGVyZWQgZXJyb3JzIHdoaWxlIGRpc3Bvc2luZyBvZiBzdG9yZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpID8gW10gOiBhcmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmcpIHtcclxuICAgICAgICBhcmcuZGlzcG9zZSgpO1xyXG4gICAgICAgIHJldHVybiBhcmc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbWJpbmUgbXVsdGlwbGUgZGlzcG9zYWJsZSB2YWx1ZXMgaW50byBhIHNpbmdsZSB7QGxpbmsgSURpc3Bvc2FibGV9LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkRGlzcG9zYWJsZSguLi5kaXNwb3NhYmxlcykge1xyXG4gICAgY29uc3QgcGFyZW50ID0gdG9EaXNwb3NhYmxlKCgpID0+IGRpc3Bvc2UoZGlzcG9zYWJsZXMpKTtcclxuICAgIHNldFBhcmVudE9mRGlzcG9zYWJsZXMoZGlzcG9zYWJsZXMsIHBhcmVudCk7XHJcbiAgICByZXR1cm4gcGFyZW50O1xyXG59XHJcbi8qKlxyXG4gKiBUdXJuIGEgZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIGRpc3Bvc2UgaW50byBhbiB7QGxpbmsgSURpc3Bvc2FibGV9LlxyXG4gKlxyXG4gKiBAcGFyYW0gZm4gQ2xlYW4gdXAgZnVuY3Rpb24sIGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIG9ubHkgKipvbmNlKiouXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9EaXNwb3NhYmxlKGZuKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdHJhY2tEaXNwb3NhYmxlKHtcclxuICAgICAgICBkaXNwb3NlOiBjcmVhdGVTaW5nbGVDYWxsRnVuY3Rpb24oKCkgPT4ge1xyXG4gICAgICAgICAgICBtYXJrQXNEaXNwb3NlZChzZWxmKTtcclxuICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc2VsZjtcclxufVxyXG4vKipcclxuICogTWFuYWdlcyBhIGNvbGxlY3Rpb24gb2YgZGlzcG9zYWJsZSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIHByZWZlcnJlZCB3YXkgdG8gbWFuYWdlIG11bHRpcGxlIGRpc3Bvc2FibGVzLiBBIGBEaXNwb3NhYmxlU3RvcmVgIGlzIHNhZmVyIHRvIHdvcmsgd2l0aCB0aGFuIGFuXHJcbiAqIGBJRGlzcG9zYWJsZVtdYCBhcyBpdCBjb25zaWRlcnMgZWRnZSBjYXNlcywgc3VjaCBhcyByZWdpc3RlcmluZyB0aGUgc2FtZSB2YWx1ZSBtdWx0aXBsZSB0aW1lcyBvciBhZGRpbmcgYW4gaXRlbSB0byBhXHJcbiAqIHN0b3JlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlU3RvcmUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fdG9EaXNwb3NlID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2Ugb2YgYWxsIHJlZ2lzdGVyZWQgZGlzcG9zYWJsZXMgYW5kIG1hcmsgdGhpcyBvYmplY3QgYXMgZGlzcG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQW55IGZ1dHVyZSBkaXNwb3NhYmxlcyBhZGRlZCB0byB0aGlzIG9iamVjdCB3aWxsIGJlIGRpc3Bvc2VkIG9mIG9uIGBhZGRgLlxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGlzIG9iamVjdCBoYXMgYmVlbiBkaXNwb3NlZCBvZi5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2Ugb2YgYWxsIHJlZ2lzdGVyZWQgZGlzcG9zYWJsZXMgYnV0IGRvIG5vdCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBpZiAodGhpcy5fdG9EaXNwb3NlLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkaXNwb3NlKHRoaXMuX3RvRGlzcG9zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIG5ldyB7QGxpbmsgSURpc3Bvc2FibGUgZGlzcG9zYWJsZX0gdG8gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGFkZChvKSB7XHJcbiAgICAgICAgaWYgKCFvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobyA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIGRpc3Bvc2FibGUgb24gaXRzZWxmIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUobywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFEaXNwb3NhYmxlU3RvcmUuRElTQUJMRV9ESVNQT1NFRF9XQVJOSU5HKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCdUcnlpbmcgdG8gYWRkIGEgZGlzcG9zYWJsZSB0byBhIERpc3Bvc2FibGVTdG9yZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgb2YuIFRoZSBhZGRlZCBvYmplY3Qgd2lsbCBiZSBsZWFrZWQhJykuc3RhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuYWRkKG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgdmFsdWUgZnJvbSB0aGUgc3RvcmUsIGJ1dCBkb2VzIG5vdCBkaXNwb3NlIGl0LlxyXG4gICAgICovXHJcbiAgICBkZWxldGVBbmRMZWFrKG8pIHtcclxuICAgICAgICBpZiAoIW8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fdG9EaXNwb3NlLmhhcyhvKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuZGVsZXRlKG8pO1xyXG4gICAgICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUobywgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkRpc3Bvc2FibGVTdG9yZS5ESVNBQkxFX0RJU1BPU0VEX1dBUk5JTkcgPSBmYWxzZTtcclxuLyoqXHJcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEge0BsaW5rIElEaXNwb3NhYmxlIGRpc3Bvc2FibGV9IG9iamVjdC5cclxuICpcclxuICogU3ViY2xhc3NlcyBjYW4ge0BsaW5rY29kZSBfcmVnaXN0ZXJ9IGRpc3Bvc2FibGVzIHRoYXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgd2hlbiB0aGlzIG9iamVjdCBpcyBkaXNwb3NlZCBvZi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3JlID0gbmV3IERpc3Bvc2FibGVTdG9yZSgpO1xyXG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcclxuICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUodGhpcy5fc3RvcmUsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdG9yZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYG9gIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGRpc3Bvc2FibGVzIG1hbmFnZWQgYnkgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIF9yZWdpc3RlcihvKSB7XHJcbiAgICAgICAgaWYgKG8gPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYSBkaXNwb3NhYmxlIG9uIGl0c2VsZiEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmFkZChvKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBkaXNwb3NhYmxlIHRoYXQgZG9lcyBub3RoaW5nIHdoZW4gaXQgaXMgZGlzcG9zZWQgb2YuXHJcbiAqXHJcbiAqIFRPRE86IFRoaXMgc2hvdWxkIG5vdCBiZSBhIHN0YXRpYyBwcm9wZXJ0eS5cclxuICovXHJcbkRpc3Bvc2FibGUuTm9uZSA9IE9iamVjdC5mcmVlemUoeyBkaXNwb3NlKCkgeyB9IH0pO1xyXG4vKipcclxuICogTWFuYWdlcyB0aGUgbGlmZWN5Y2xlIG9mIGEgZGlzcG9zYWJsZSB2YWx1ZSB0aGF0IG1heSBiZSBjaGFuZ2VkLlxyXG4gKlxyXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIHRoZSBkaXNwb3NhYmxlIHZhbHVlIGlzIGNoYW5nZWQsIHRoZSBwcmV2aW91c2x5IGhlbGQgZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBvZi4gWW91IGNhblxyXG4gKiBhbHNvIHJlZ2lzdGVyIGEgYE11dGFibGVEaXNwb3NhYmxlYCBvbiBhIGBEaXNwb3NhYmxlYCB0byBlbnN1cmUgaXQgaXMgYXV0b21hdGljYWxseSBjbGVhbmVkIHVwLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE11dGFibGVEaXNwb3NhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQgPyB1bmRlZmluZWQgOiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCB8fCB2YWx1ZSA9PT0gdGhpcy5fdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSB0aGlzLl92YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlKHZhbHVlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBzdG9yZWQgdmFsdWUgYW5kIGRpc3Bvc2VkIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIG1hcmtBc0Rpc3Bvc2VkKHRoaXMpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX3ZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBSZWZDb3VudGVkRGlzcG9zYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZGlzcG9zYWJsZSkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUgPSBfZGlzcG9zYWJsZTtcclxuICAgICAgICB0aGlzLl9jb3VudGVyID0gMTtcclxuICAgIH1cclxuICAgIGFjcXVpcmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY291bnRlcisrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmVsZWFzZSgpIHtcclxuICAgICAgICBpZiAoLS10aGlzLl9jb3VudGVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSW1tb3J0YWxSZWZlcmVuY2Uge1xyXG4gICAgY29uc3RydWN0b3Iob2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkgeyB9XHJcbn1cclxuLyoqXHJcbiAqIEEgbWFwIHRoZSBtYW5hZ2VzIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHZhbHVlcyB0aGF0IGl0IHN0b3Jlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3JlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2VzIG9mIGFsbCBzdG9yZWQgdmFsdWVzIGFuZCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIFRyeWluZyB0byB1c2UgdGhpcyBvYmplY3QgYWZ0ZXIgaXQgaGFzIGJlZW4gZGlzcG9zZWQgb2YgaXMgYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jbGVhckFuZERpc3Bvc2VBbGwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgb2YgYWxsIHN0b3JlZCB2YWx1ZXMgYW5kIGNsZWFyIHRoZSBtYXAsIGJ1dCBETyBOT1QgbWFyayB0aGlzIG9iamVjdCBhcyBkaXNwb3NlZC5cclxuICAgICAqL1xyXG4gICAgY2xlYXJBbmREaXNwb3NlQWxsKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RvcmUuc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2UodGhpcy5fc3RvcmUudmFsdWVzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcmUuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldChrZXkpO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUsIHNraXBEaXNwb3NlT25PdmVyd3JpdGUgPSBmYWxzZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCdUcnlpbmcgdG8gYWRkIGEgZGlzcG9zYWJsZSB0byBhIERpc3Bvc2FibGVNYXAgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLiBUaGUgYWRkZWQgb2JqZWN0IHdpbGwgYmUgbGVha2VkIScpLnN0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwRGlzcG9zZU9uT3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuX3N0b3JlLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSB0aGUgdmFsdWUgc3RvcmVkIGZvciBga2V5YCBmcm9tIHRoaXMgbWFwIGFuZCBhbHNvIGRpc3Bvc2Ugb2YgaXQuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZUFuZERpc3Bvc2Uoa2V5KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX3N0b3JlLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0b3JlLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinkedList: () => (/* binding */ LinkedList)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Node {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.next = Node.Undefined;\r\n        this.prev = Node.Undefined;\r\n    }\r\n}\r\nNode.Undefined = new Node(undefined);\r\nclass LinkedList {\r\n    constructor() {\r\n        this._first = Node.Undefined;\r\n        this._last = Node.Undefined;\r\n        this._size = 0;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    isEmpty() {\r\n        return this._first === Node.Undefined;\r\n    }\r\n    clear() {\r\n        let node = this._first;\r\n        while (node !== Node.Undefined) {\r\n            const next = node.next;\r\n            node.prev = Node.Undefined;\r\n            node.next = Node.Undefined;\r\n            node = next;\r\n        }\r\n        this._first = Node.Undefined;\r\n        this._last = Node.Undefined;\r\n        this._size = 0;\r\n    }\r\n    unshift(element) {\r\n        return this._insert(element, false);\r\n    }\r\n    push(element) {\r\n        return this._insert(element, true);\r\n    }\r\n    _insert(element, atTheEnd) {\r\n        const newNode = new Node(element);\r\n        if (this._first === Node.Undefined) {\r\n            this._first = newNode;\r\n            this._last = newNode;\r\n        }\r\n        else if (atTheEnd) {\r\n            // push\r\n            const oldLast = this._last;\r\n            this._last = newNode;\r\n            newNode.prev = oldLast;\r\n            oldLast.next = newNode;\r\n        }\r\n        else {\r\n            // unshift\r\n            const oldFirst = this._first;\r\n            this._first = newNode;\r\n            newNode.next = oldFirst;\r\n            oldFirst.prev = newNode;\r\n        }\r\n        this._size += 1;\r\n        let didRemove = false;\r\n        return () => {\r\n            if (!didRemove) {\r\n                didRemove = true;\r\n                this._remove(newNode);\r\n            }\r\n        };\r\n    }\r\n    shift() {\r\n        if (this._first === Node.Undefined) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            const res = this._first.element;\r\n            this._remove(this._first);\r\n            return res;\r\n        }\r\n    }\r\n    pop() {\r\n        if (this._last === Node.Undefined) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            const res = this._last.element;\r\n            this._remove(this._last);\r\n            return res;\r\n        }\r\n    }\r\n    _remove(node) {\r\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\r\n            // middle\r\n            const anchor = node.prev;\r\n            anchor.next = node.next;\r\n            node.next.prev = anchor;\r\n        }\r\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\r\n            // only node\r\n            this._first = Node.Undefined;\r\n            this._last = Node.Undefined;\r\n        }\r\n        else if (node.next === Node.Undefined) {\r\n            // last\r\n            this._last = this._last.prev;\r\n            this._last.next = Node.Undefined;\r\n        }\r\n        else if (node.prev === Node.Undefined) {\r\n            // first\r\n            this._first = this._first.next;\r\n            this._first.prev = Node.Undefined;\r\n        }\r\n        // done\r\n        this._size -= 1;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        let node = this._first;\r\n        while (node !== Node.Undefined) {\r\n            yield node.element;\r\n            node = node.next;\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcz9kYjg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5jbGFzcyBOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbk5vZGUuVW5kZWZpbmVkID0gbmV3IE5vZGUodW5kZWZpbmVkKTtcclxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyc3QgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZmlyc3Q7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgdW5zaGlmdChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChlbGVtZW50LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KGVsZW1lbnQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgX2luc2VydChlbGVtZW50LCBhdFRoZUVuZCkge1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZShlbGVtZW50KTtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF0VGhlRW5kKSB7XHJcbiAgICAgICAgICAgIC8vIHB1c2hcclxuICAgICAgICAgICAgY29uc3Qgb2xkTGFzdCA9IHRoaXMuX2xhc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBuZXdOb2RlLnByZXYgPSBvbGRMYXN0O1xyXG4gICAgICAgICAgICBvbGRMYXN0Lm5leHQgPSBuZXdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdW5zaGlmdFxyXG4gICAgICAgICAgICBjb25zdCBvbGRGaXJzdCA9IHRoaXMuX2ZpcnN0O1xyXG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IG9sZEZpcnN0O1xyXG4gICAgICAgICAgICBvbGRGaXJzdC5wcmV2ID0gbmV3Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2l6ZSArPSAxO1xyXG4gICAgICAgIGxldCBkaWRSZW1vdmUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRpZFJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgZGlkUmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShuZXdOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzaGlmdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9maXJzdC5lbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGhpcy5fZmlyc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGFzdCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX2xhc3QuZWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMuX2xhc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW1vdmUobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnByZXYgIT09IE5vZGUuVW5kZWZpbmVkICYmIG5vZGUubmV4dCAhPT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gbWlkZGxlXHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgYW5jaG9yLm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gYW5jaG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnByZXYgPT09IE5vZGUuVW5kZWZpbmVkICYmIG5vZGUubmV4dCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gb25seSBub2RlXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBsYXN0XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSB0aGlzLl9sYXN0LnByZXY7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnByZXYgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fZmlyc3QubmV4dDtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3QucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkb25lXHJcbiAgICAgICAgdGhpcy5fc2l6ZSAtPSAxO1xyXG4gICAgfVxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZmlyc3Q7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUuZWxlbWVudDtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/map.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/map.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidirectionalMap: () => (/* binding */ BidirectionalMap),\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache),\n/* harmony export */   LinkedMap: () => (/* binding */ LinkedMap),\n/* harmony export */   ResourceMap: () => (/* binding */ ResourceMap),\n/* harmony export */   SetMap: () => (/* binding */ SetMap)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar _a, _b;\r\nclass ResourceMapEntry {\r\n    constructor(uri, value) {\r\n        this.uri = uri;\r\n        this.value = value;\r\n    }\r\n}\r\nfunction isEntries(arg) {\r\n    return Array.isArray(arg);\r\n}\r\nclass ResourceMap {\r\n    constructor(arg, toKey) {\r\n        this[_a] = 'ResourceMap';\r\n        if (arg instanceof ResourceMap) {\r\n            this.map = new Map(arg.map);\r\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\r\n        }\r\n        else if (isEntries(arg)) {\r\n            this.map = new Map();\r\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\r\n            for (const [resource, value] of arg) {\r\n                this.set(resource, value);\r\n            }\r\n        }\r\n        else {\r\n            this.map = new Map();\r\n            this.toKey = arg !== null && arg !== void 0 ? arg : ResourceMap.defaultToKey;\r\n        }\r\n    }\r\n    set(resource, value) {\r\n        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\r\n        return this;\r\n    }\r\n    get(resource) {\r\n        var _c;\r\n        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\r\n    }\r\n    has(resource) {\r\n        return this.map.has(this.toKey(resource));\r\n    }\r\n    get size() {\r\n        return this.map.size;\r\n    }\r\n    clear() {\r\n        this.map.clear();\r\n    }\r\n    delete(resource) {\r\n        return this.map.delete(this.toKey(resource));\r\n    }\r\n    forEach(clb, thisArg) {\r\n        if (typeof thisArg !== 'undefined') {\r\n            clb = clb.bind(thisArg);\r\n        }\r\n        for (const [_, entry] of this.map) {\r\n            clb(entry.value, entry.uri, this);\r\n        }\r\n    }\r\n    *values() {\r\n        for (const entry of this.map.values()) {\r\n            yield entry.value;\r\n        }\r\n    }\r\n    *keys() {\r\n        for (const entry of this.map.values()) {\r\n            yield entry.uri;\r\n        }\r\n    }\r\n    *entries() {\r\n        for (const entry of this.map.values()) {\r\n            yield [entry.uri, entry.value];\r\n        }\r\n    }\r\n    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\r\n        for (const [, entry] of this.map) {\r\n            yield [entry.uri, entry.value];\r\n        }\r\n    }\r\n}\r\nResourceMap.defaultToKey = (resource) => resource.toString();\r\nclass LinkedMap {\r\n    constructor() {\r\n        this[_b] = 'LinkedMap';\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n        this._state = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n        this._state++;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    get first() {\r\n        var _c;\r\n        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\r\n    }\r\n    get last() {\r\n        var _c;\r\n        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key, touch = 0 /* Touch.None */) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        if (touch !== 0 /* Touch.None */) {\r\n            this.touch(item, touch);\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = 0 /* Touch.None */) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== 0 /* Touch.None */) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case 0 /* Touch.None */:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case 1 /* Touch.AsOld */:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case 2 /* Touch.AsNew */:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        return !!this.remove(key);\r\n    }\r\n    remove(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        const state = this._state;\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            if (this._state !== state) {\r\n                throw new Error(`LinkedMap got modified during iteration.`);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    keys() {\r\n        const map = this;\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next() {\r\n                if (map._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    values() {\r\n        const map = this;\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next() {\r\n                if (map._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    entries() {\r\n        const map = this;\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next() {\r\n                if (map._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: [current.key, current.value], done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\r\n        return this.entries();\r\n    }\r\n    trimOld(newSize) {\r\n        if (newSize >= this.size) {\r\n            return;\r\n        }\r\n        if (newSize === 0) {\r\n            this.clear();\r\n            return;\r\n        }\r\n        let current = this._head;\r\n        let currentSize = this.size;\r\n        while (current && currentSize > newSize) {\r\n            this._map.delete(current.key);\r\n            current = current.next;\r\n            currentSize--;\r\n        }\r\n        this._head = current;\r\n        this._size = currentSize;\r\n        if (current) {\r\n            current.previous = undefined;\r\n        }\r\n        this._state++;\r\n    }\r\n    trimNew(newSize) {\r\n        if (newSize >= this.size) {\r\n            return;\r\n        }\r\n        if (newSize === 0) {\r\n            this.clear();\r\n            return;\r\n        }\r\n        let current = this._tail;\r\n        let currentSize = this.size;\r\n        while (current && currentSize > newSize) {\r\n            this._map.delete(current.key);\r\n            current = current.previous;\r\n            currentSize--;\r\n        }\r\n        this._tail = current;\r\n        this._size = currentSize;\r\n        if (current) {\r\n            current.next = undefined;\r\n        }\r\n        this._state++;\r\n    }\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n        this._state++;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n        this._state++;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            // This can only happen if size === 1 which is handled\r\n            // by the case above.\r\n            if (!item.next) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            item.next.previous = undefined;\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            // This can only happen if size === 1 which is handled\r\n            // by the case above.\r\n            if (!item.previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            item.previous.next = undefined;\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n        item.next = undefined;\r\n        item.previous = undefined;\r\n        this._state++;\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */)) {\r\n            return;\r\n        }\r\n        if (touch === 1 /* Touch.AsOld */) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n            this._state++;\r\n        }\r\n        else if (touch === 2 /* Touch.AsNew */) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n            this._state++;\r\n        }\r\n    }\r\n    toJSON() {\r\n        const data = [];\r\n        this.forEach((value, key) => {\r\n            data.push([key, value]);\r\n        });\r\n        return data;\r\n    }\r\n    fromJSON(data) {\r\n        this.clear();\r\n        for (const [key, value] of data) {\r\n            this.set(key, value);\r\n        }\r\n    }\r\n}\r\nclass Cache extends LinkedMap {\r\n    constructor(limit, ratio = 1) {\r\n        super();\r\n        this._limit = limit;\r\n        this._ratio = Math.min(Math.max(0, ratio), 1);\r\n    }\r\n    get limit() {\r\n        return this._limit;\r\n    }\r\n    set limit(limit) {\r\n        this._limit = limit;\r\n        this.checkTrim();\r\n    }\r\n    get(key, touch = 2 /* Touch.AsNew */) {\r\n        return super.get(key, touch);\r\n    }\r\n    peek(key) {\r\n        return super.get(key, 0 /* Touch.None */);\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value, 2 /* Touch.AsNew */);\r\n        return this;\r\n    }\r\n    checkTrim() {\r\n        if (this.size > this._limit) {\r\n            this.trim(Math.round(this._limit * this._ratio));\r\n        }\r\n    }\r\n}\r\nclass LRUCache extends Cache {\r\n    constructor(limit, ratio = 1) {\r\n        super(limit, ratio);\r\n    }\r\n    trim(newSize) {\r\n        this.trimOld(newSize);\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value);\r\n        this.checkTrim();\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * A map that allows access both by keys and values.\r\n * **NOTE**: values need to be unique.\r\n */\r\nclass BidirectionalMap {\r\n    constructor(entries) {\r\n        this._m1 = new Map();\r\n        this._m2 = new Map();\r\n        if (entries) {\r\n            for (const [key, value] of entries) {\r\n                this.set(key, value);\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        this._m1.clear();\r\n        this._m2.clear();\r\n    }\r\n    set(key, value) {\r\n        this._m1.set(key, value);\r\n        this._m2.set(value, key);\r\n    }\r\n    get(key) {\r\n        return this._m1.get(key);\r\n    }\r\n    getKey(value) {\r\n        return this._m2.get(value);\r\n    }\r\n    delete(key) {\r\n        const value = this._m1.get(key);\r\n        if (value === undefined) {\r\n            return false;\r\n        }\r\n        this._m1.delete(key);\r\n        this._m2.delete(value);\r\n        return true;\r\n    }\r\n    keys() {\r\n        return this._m1.keys();\r\n    }\r\n    values() {\r\n        return this._m1.values();\r\n    }\r\n}\r\nclass SetMap {\r\n    constructor() {\r\n        this.map = new Map();\r\n    }\r\n    add(key, value) {\r\n        let values = this.map.get(key);\r\n        if (!values) {\r\n            values = new Set();\r\n            this.map.set(key, values);\r\n        }\r\n        values.add(value);\r\n    }\r\n    delete(key, value) {\r\n        const values = this.map.get(key);\r\n        if (!values) {\r\n            return;\r\n        }\r\n        values.delete(value);\r\n        if (values.size === 0) {\r\n            this.map.delete(key);\r\n        }\r\n    }\r\n    forEach(key, fn) {\r\n        const values = this.map.get(key);\r\n        if (!values) {\r\n            return;\r\n        }\r\n        values.forEach(fn);\r\n    }\r\n    get(key) {\r\n        const values = this.map.get(key);\r\n        if (!values) {\r\n            return new Set();\r\n        }\r\n        return values;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9tYXAuanM/NDAzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIF9hLCBfYjtcclxuY2xhc3MgUmVzb3VyY2VNYXBFbnRyeSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW50cmllcyhhcmcpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIFJlc291cmNlTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGFyZywgdG9LZXkpIHtcclxuICAgICAgICB0aGlzW19hXSA9ICdSZXNvdXJjZU1hcCc7XHJcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFJlc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcChhcmcubWFwKTtcclxuICAgICAgICAgICAgdGhpcy50b0tleSA9IHRvS2V5ICE9PSBudWxsICYmIHRvS2V5ICE9PSB2b2lkIDAgPyB0b0tleSA6IFJlc291cmNlTWFwLmRlZmF1bHRUb0tleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNFbnRyaWVzKGFyZykpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMudG9LZXkgPSB0b0tleSAhPT0gbnVsbCAmJiB0b0tleSAhPT0gdm9pZCAwID8gdG9LZXkgOiBSZXNvdXJjZU1hcC5kZWZhdWx0VG9LZXk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCB2YWx1ZV0gb2YgYXJnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChyZXNvdXJjZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy50b0tleSA9IGFyZyAhPT0gbnVsbCAmJiBhcmcgIT09IHZvaWQgMCA/IGFyZyA6IFJlc291cmNlTWFwLmRlZmF1bHRUb0tleTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQocmVzb3VyY2UsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5tYXAuc2V0KHRoaXMudG9LZXkocmVzb3VyY2UpLCBuZXcgUmVzb3VyY2VNYXBFbnRyeShyZXNvdXJjZSwgdmFsdWUpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldChyZXNvdXJjZSkge1xyXG4gICAgICAgIHZhciBfYztcclxuICAgICAgICByZXR1cm4gKF9jID0gdGhpcy5tYXAuZ2V0KHRoaXMudG9LZXkocmVzb3VyY2UpKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgaGFzKHJlc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyh0aGlzLnRvS2V5KHJlc291cmNlKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuc2l6ZTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMubWFwLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUocmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZGVsZXRlKHRoaXMudG9LZXkocmVzb3VyY2UpKTtcclxuICAgIH1cclxuICAgIGZvckVhY2goY2xiLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBjbGIgPSBjbGIuYmluZCh0aGlzQXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBbXywgZW50cnldIG9mIHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgIGNsYihlbnRyeS52YWx1ZSwgZW50cnkudXJpLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAqdmFsdWVzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXAudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgeWllbGQgZW50cnkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgKmtleXMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICB5aWVsZCBlbnRyeS51cmk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgKmVudHJpZXMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICB5aWVsZCBbZW50cnkudXJpLCBlbnRyeS52YWx1ZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgKlsoX2EgPSBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC5pdGVyYXRvcildKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgWywgZW50cnldIG9mIHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIFtlbnRyeS51cmksIGVudHJ5LnZhbHVlXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuUmVzb3VyY2VNYXAuZGVmYXVsdFRvS2V5ID0gKHJlc291cmNlKSA9PiByZXNvdXJjZS50b1N0cmluZygpO1xyXG5leHBvcnQgY2xhc3MgTGlua2VkTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXNbX2JdID0gJ0xpbmtlZE1hcCc7XHJcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICBnZXQgZmlyc3QoKSB7XHJcbiAgICAgICAgdmFyIF9jO1xyXG4gICAgICAgIHJldHVybiAoX2MgPSB0aGlzLl9oZWFkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgbGFzdCgpIHtcclxuICAgICAgICB2YXIgX2M7XHJcbiAgICAgICAgcmV0dXJuIChfYyA9IHRoaXMuX3RhaWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52YWx1ZTtcclxuICAgIH1cclxuICAgIGhhcyhrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrZXkpO1xyXG4gICAgfVxyXG4gICAgZ2V0KGtleSwgdG91Y2ggPSAwIC8qIFRvdWNoLk5vbmUgKi8pIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG91Y2ggIT09IDAgLyogVG91Y2guTm9uZSAqLykge1xyXG4gICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSAwIC8qIFRvdWNoLk5vbmUgKi8pIHtcclxuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gMCAvKiBUb3VjaC5Ob25lICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaXRlbSA9IHsga2V5LCB2YWx1ZSwgbmV4dDogdW5kZWZpbmVkLCBwcmV2aW91czogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBUb3VjaC5Ob25lICovOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogVG91Y2guQXNPbGQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtRmlyc3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogVG91Y2guQXNOZXcgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW1vdmUoa2V5KTtcclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcclxuICAgIH1cclxuICAgIHNoaWZ0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcclxuICAgIH1cclxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuLmJpbmQodGhpc0FyZykoY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbihjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBrZXlzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XHJcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5fc3RhdGUgIT09IHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgdmFsdWVzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XHJcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5fc3RhdGUgIT09IHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQudmFsdWUsIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICB9XHJcbiAgICBlbnRyaWVzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XHJcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5fc3RhdGUgIT09IHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IFtjdXJyZW50LmtleSwgY3VycmVudC52YWx1ZV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICB9XHJcbiAgICBbKF9iID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XHJcbiAgICB9XHJcbiAgICB0cmltT2xkKG5ld1NpemUpIHtcclxuICAgICAgICBpZiAobmV3U2l6ZSA+PSB0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50U2l6ZSA+IG5ld1NpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShjdXJyZW50LmtleSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRTaXplLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSBjdXJyZW50U2l6ZTtcclxuICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xyXG4gICAgfVxyXG4gICAgdHJpbU5ldyhuZXdTaXplKSB7XHJcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fdGFpbDtcclxuICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnNpemU7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoY3VycmVudC5rZXkpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wcmV2aW91cztcclxuICAgICAgICAgICAgY3VycmVudFNpemUtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGFpbCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IGN1cnJlbnRTaXplO1xyXG4gICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcclxuICAgIH1cclxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XHJcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcclxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9oZWFkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XHJcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcclxuICAgIH1cclxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcclxuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxyXG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQgJiYgaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlZFxyXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cclxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlZFxyXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cclxuICAgICAgICAgICAgaWYgKCFpdGVtLnByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW0ucHJldmlvdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XHJcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCAhcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xyXG4gICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcclxuICAgIH1cclxuICAgIHRvdWNoKGl0ZW0sIHRvdWNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodG91Y2ggIT09IDEgLyogVG91Y2guQXNPbGQgKi8gJiYgdG91Y2ggIT09IDIgLyogVG91Y2guQXNOZXcgKi8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvdWNoID09PSAxIC8qIFRvdWNoLkFzT2xkICovKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xyXG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW1cclxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgaGVhZCBidXQgaXMgdGFpbFxyXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cclxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCBoZWFkXHJcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IDIgLyogVG91Y2guQXNOZXcgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XHJcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cclxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5leHQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCB0YWlsIGJ1dCBpcyBoZWFkXHJcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxyXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXHJcbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ2FjaGUgZXh0ZW5kcyBMaW5rZWRNYXAge1xyXG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcclxuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbGltaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xyXG4gICAgfVxyXG4gICAgc2V0IGxpbWl0KGxpbWl0KSB7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcclxuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0KGtleSwgdG91Y2ggPSAyIC8qIFRvdWNoLkFzTmV3ICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcclxuICAgIH1cclxuICAgIHBlZWsoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIDAgLyogVG91Y2guTm9uZSAqLyk7XHJcbiAgICB9XHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlLCAyIC8qIFRvdWNoLkFzTmV3ICovKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGNoZWNrVHJpbSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zaXplID4gdGhpcy5fbGltaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmltKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTFJVQ2FjaGUgZXh0ZW5kcyBDYWNoZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsaW1pdCwgcmF0aW8gPSAxKSB7XHJcbiAgICAgICAgc3VwZXIobGltaXQsIHJhdGlvKTtcclxuICAgIH1cclxuICAgIHRyaW0obmV3U2l6ZSkge1xyXG4gICAgICAgIHRoaXMudHJpbU9sZChuZXdTaXplKTtcclxuICAgIH1cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgbWFwIHRoYXQgYWxsb3dzIGFjY2VzcyBib3RoIGJ5IGtleXMgYW5kIHZhbHVlcy5cclxuICogKipOT1RFKio6IHZhbHVlcyBuZWVkIHRvIGJlIHVuaXF1ZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCaWRpcmVjdGlvbmFsTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcclxuICAgICAgICB0aGlzLl9tMSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9tMiA9IG5ldyBNYXAoKTtcclxuICAgICAgICBpZiAoZW50cmllcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX20xLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fbTIuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbTEuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX20yLnNldCh2YWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbTEuZ2V0KGtleSk7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbTIuZ2V0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX20xLmdldChrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbTEuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgdGhpcy5fbTIuZGVsZXRlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX20xLmtleXMoKTtcclxuICAgIH1cclxuICAgIHZhbHVlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbTEudmFsdWVzKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFNldE1hcCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGFkZChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzLmFkZCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzLmRlbGV0ZSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlcy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2goa2V5LCBmbikge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzLmZvckVhY2goZm4pO1xyXG4gICAgfVxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/map.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/objects.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/objects.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneAndChange: () => (/* binding */ cloneAndChange),\n/* harmony export */   createProxyObject: () => (/* binding */ createProxyObject),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   getAllMethodNames: () => (/* binding */ getAllMethodNames),\n/* harmony export */   getAllPropertyNames: () => (/* binding */ getAllPropertyNames),\n/* harmony export */   mixin: () => (/* binding */ mixin)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/monaco-editor/esm/vs/base/common/types.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nfunction deepClone(obj) {\r\n    if (!obj || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n    if (obj instanceof RegExp) {\r\n        return obj;\r\n    }\r\n    const result = Array.isArray(obj) ? [] : {};\r\n    Object.entries(obj).forEach(([key, value]) => {\r\n        result[key] = value && typeof value === 'object' ? deepClone(value) : value;\r\n    });\r\n    return result;\r\n}\r\nfunction deepFreeze(obj) {\r\n    if (!obj || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n    const stack = [obj];\r\n    while (stack.length > 0) {\r\n        const obj = stack.shift();\r\n        Object.freeze(obj);\r\n        for (const key in obj) {\r\n            if (_hasOwnProperty.call(obj, key)) {\r\n                const prop = obj[key];\r\n                if (typeof prop === 'object' && !Object.isFrozen(prop) && !(0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray)(prop)) {\r\n                    stack.push(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction cloneAndChange(obj, changer) {\r\n    return _cloneAndChange(obj, changer, new Set());\r\n}\r\nfunction _cloneAndChange(obj, changer, seen) {\r\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isUndefinedOrNull)(obj)) {\r\n        return obj;\r\n    }\r\n    const changed = changer(obj);\r\n    if (typeof changed !== 'undefined') {\r\n        return changed;\r\n    }\r\n    if (Array.isArray(obj)) {\r\n        const r1 = [];\r\n        for (const e of obj) {\r\n            r1.push(_cloneAndChange(e, changer, seen));\r\n        }\r\n        return r1;\r\n    }\r\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(obj)) {\r\n        if (seen.has(obj)) {\r\n            throw new Error('Cannot clone recursive data-structure');\r\n        }\r\n        seen.add(obj);\r\n        const r2 = {};\r\n        for (const i2 in obj) {\r\n            if (_hasOwnProperty.call(obj, i2)) {\r\n                r2[i2] = _cloneAndChange(obj[i2], changer, seen);\r\n            }\r\n        }\r\n        seen.delete(obj);\r\n        return r2;\r\n    }\r\n    return obj;\r\n}\r\n/**\r\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\r\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\r\n */\r\nfunction mixin(destination, source, overwrite = true) {\r\n    if (!(0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination)) {\r\n        return source;\r\n    }\r\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {\r\n        Object.keys(source).forEach(key => {\r\n            if (key in destination) {\r\n                if (overwrite) {\r\n                    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination[key]) && (0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key])) {\r\n                        mixin(destination[key], source[key], overwrite);\r\n                    }\r\n                    else {\r\n                        destination[key] = source[key];\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                destination[key] = source[key];\r\n            }\r\n        });\r\n    }\r\n    return destination;\r\n}\r\nfunction equals(one, other) {\r\n    if (one === other) {\r\n        return true;\r\n    }\r\n    if (one === null || one === undefined || other === null || other === undefined) {\r\n        return false;\r\n    }\r\n    if (typeof one !== typeof other) {\r\n        return false;\r\n    }\r\n    if (typeof one !== 'object') {\r\n        return false;\r\n    }\r\n    if ((Array.isArray(one)) !== (Array.isArray(other))) {\r\n        return false;\r\n    }\r\n    let i;\r\n    let key;\r\n    if (Array.isArray(one)) {\r\n        if (one.length !== other.length) {\r\n            return false;\r\n        }\r\n        for (i = 0; i < one.length; i++) {\r\n            if (!equals(one[i], other[i])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const oneKeys = [];\r\n        for (key in one) {\r\n            oneKeys.push(key);\r\n        }\r\n        oneKeys.sort();\r\n        const otherKeys = [];\r\n        for (key in other) {\r\n            otherKeys.push(key);\r\n        }\r\n        otherKeys.sort();\r\n        if (!equals(oneKeys, otherKeys)) {\r\n            return false;\r\n        }\r\n        for (i = 0; i < oneKeys.length; i++) {\r\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getAllPropertyNames(obj) {\r\n    let res = [];\r\n    while (Object.prototype !== obj) {\r\n        res = res.concat(Object.getOwnPropertyNames(obj));\r\n        obj = Object.getPrototypeOf(obj);\r\n    }\r\n    return res;\r\n}\r\nfunction getAllMethodNames(obj) {\r\n    const methods = [];\r\n    for (const prop of getAllPropertyNames(obj)) {\r\n        if (typeof obj[prop] === 'function') {\r\n            methods.push(prop);\r\n        }\r\n    }\r\n    return methods;\r\n}\r\nfunction createProxyObject(methodNames, invoke) {\r\n    const createProxyMethod = (method) => {\r\n        return function () {\r\n            const args = Array.prototype.slice.call(arguments, 0);\r\n            return invoke(method, args);\r\n        };\r\n    };\r\n    const result = {};\r\n    for (const methodName of methodNames) {\r\n        result[methodName] = createProxyMethod(methodName);\r\n    }\r\n    return result;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vb2JqZWN0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RTtBQUNoRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1REFBWTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsbURBQVE7QUFDakI7QUFDQTtBQUNBLFFBQVEsbURBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1EQUFRLHNCQUFzQixtREFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL29iamVjdHMuanM/YWEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgaXNUeXBlZEFycmF5LCBpc09iamVjdCwgaXNVbmRlZmluZWRPck51bGwgfSBmcm9tICcuL3R5cGVzLmpzJztcclxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZShvYmopIHtcclxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcclxuICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gZGVlcENsb25lKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwRnJlZXplKG9iaikge1xyXG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhY2sgPSBbb2JqXTtcclxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gc3RhY2suc2hpZnQoKTtcclxuICAgICAgICBPYmplY3QuZnJlZXplKG9iaik7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgIU9iamVjdC5pc0Zyb3plbihwcm9wKSAmJiAhaXNUeXBlZEFycmF5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQW5kQ2hhbmdlKG9iaiwgY2hhbmdlcikge1xyXG4gICAgcmV0dXJuIF9jbG9uZUFuZENoYW5nZShvYmosIGNoYW5nZXIsIG5ldyBTZXQoKSk7XHJcbn1cclxuZnVuY3Rpb24gX2Nsb25lQW5kQ2hhbmdlKG9iaiwgY2hhbmdlciwgc2Vlbikge1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKG9iaikpIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2hhbmdlZCA9IGNoYW5nZXIob2JqKTtcclxuICAgIGlmICh0eXBlb2YgY2hhbmdlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICBjb25zdCByMSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmopIHtcclxuICAgICAgICAgICAgcjEucHVzaChfY2xvbmVBbmRDaGFuZ2UoZSwgY2hhbmdlciwgc2VlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjE7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhvYmopKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNsb25lIHJlY3Vyc2l2ZSBkYXRhLXN0cnVjdHVyZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChvYmopO1xyXG4gICAgICAgIGNvbnN0IHIyID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBpMiBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XHJcbiAgICAgICAgICAgICAgICByMltpMl0gPSBfY2xvbmVBbmRDaGFuZ2Uob2JqW2kyXSwgY2hhbmdlciwgc2Vlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vlbi5kZWxldGUob2JqKTtcclxuICAgICAgICByZXR1cm4gcjI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgb2Ygc291cmNlIGludG8gZGVzdGluYXRpb24uIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgXCJvdmVyd3JpdGVcIiBhbGxvd3MgdG8gY29udHJvbFxyXG4gKiBpZiBleGlzdGluZyBwcm9wZXJ0aWVzIG9uIHRoZSBkZXN0aW5hdGlvbiBzaG91bGQgYmUgb3ZlcndyaXR0ZW4gb3Igbm90LiBEZWZhdWx0cyB0byB0cnVlIChvdmVyd3JpdGUpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peGluKGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJ3cml0ZSA9IHRydWUpIHtcclxuICAgIGlmICghaXNPYmplY3QoZGVzdGluYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gZGVzdGluYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZGVzdGluYXRpb25ba2V5XSkgJiYgaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peGluKGRlc3RpbmF0aW9uW2tleV0sIHNvdXJjZVtrZXldLCBvdmVyd3JpdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xyXG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKEFycmF5LmlzQXJyYXkob25lKSkgIT09IChBcnJheS5pc0FycmF5KG90aGVyKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgaTtcclxuICAgIGxldCBrZXk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbmUpKSB7XHJcbiAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFlcXVhbHMob25lW2ldLCBvdGhlcltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG9uZUtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGtleSBpbiBvbmUpIHtcclxuICAgICAgICAgICAgb25lS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uZUtleXMuc29ydCgpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAoa2V5IGluIG90aGVyKSB7XHJcbiAgICAgICAgICAgIG90aGVyS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG90aGVyS2V5cy5zb3J0KCk7XHJcbiAgICAgICAgaWYgKCFlcXVhbHMob25lS2V5cywgb3RoZXJLZXlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsUHJvcGVydHlOYW1lcyhvYmopIHtcclxuICAgIGxldCByZXMgPSBbXTtcclxuICAgIHdoaWxlIChPYmplY3QucHJvdG90eXBlICE9PSBvYmopIHtcclxuICAgICAgICByZXMgPSByZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikpO1xyXG4gICAgICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWV0aG9kTmFtZXMob2JqKSB7XHJcbiAgICBjb25zdCBtZXRob2RzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgZ2V0QWxsUHJvcGVydHlOYW1lcyhvYmopKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbWV0aG9kcy5wdXNoKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZXRob2RzO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eU9iamVjdChtZXRob2ROYW1lcywgaW52b2tlKSB7XHJcbiAgICBjb25zdCBjcmVhdGVQcm94eU1ldGhvZCA9IChtZXRob2QpID0+IHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgbWV0aG9kTmFtZXMpIHtcclxuICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eU1ldGhvZChtZXRob2ROYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/objects.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/path.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/path.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   basename: () => (/* binding */ basename),\n/* harmony export */   dirname: () => (/* binding */ dirname),\n/* harmony export */   extname: () => (/* binding */ extname),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   posix: () => (/* binding */ posix),\n/* harmony export */   relative: () => (/* binding */ relative),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   sep: () => (/* binding */ sep),\n/* harmony export */   win32: () => (/* binding */ win32)\n/* harmony export */ });\n/* harmony import */ var _process_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process.js */ \"./node_modules/monaco-editor/esm/vs/base/common/process.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\r\n// Copied from: https://github.com/nodejs/node/blob/v16.14.2/lib/path.js\r\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nconst CHAR_UPPERCASE_A = 65; /* A */\r\nconst CHAR_LOWERCASE_A = 97; /* a */\r\nconst CHAR_UPPERCASE_Z = 90; /* Z */\r\nconst CHAR_LOWERCASE_Z = 122; /* z */\r\nconst CHAR_DOT = 46; /* . */\r\nconst CHAR_FORWARD_SLASH = 47; /* / */\r\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\r\nconst CHAR_COLON = 58; /* : */\r\nconst CHAR_QUESTION_MARK = 63; /* ? */\r\nclass ErrorInvalidArgType extends Error {\r\n    constructor(name, expected, actual) {\r\n        // determiner: 'must be' or 'must not be'\r\n        let determiner;\r\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\r\n            determiner = 'must not be';\r\n            expected = expected.replace(/^not /, '');\r\n        }\r\n        else {\r\n            determiner = 'must be';\r\n        }\r\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\r\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\r\n        msg += `. Received type ${typeof actual}`;\r\n        super(msg);\r\n        this.code = 'ERR_INVALID_ARG_TYPE';\r\n    }\r\n}\r\nfunction validateObject(pathObject, name) {\r\n    if (pathObject === null || typeof pathObject !== 'object') {\r\n        throw new ErrorInvalidArgType(name, 'Object', pathObject);\r\n    }\r\n}\r\nfunction validateString(value, name) {\r\n    if (typeof value !== 'string') {\r\n        throw new ErrorInvalidArgType(name, 'string', value);\r\n    }\r\n}\r\nconst platformIsWin32 = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32');\r\nfunction isPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\r\n        (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\r\n}\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    let res = '';\r\n    let lastSegmentLength = 0;\r\n    let lastSlash = -1;\r\n    let dots = 0;\r\n    let code = 0;\r\n    for (let i = 0; i <= path.length; ++i) {\r\n        if (i < path.length) {\r\n            code = path.charCodeAt(i);\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            break;\r\n        }\r\n        else {\r\n            code = CHAR_FORWARD_SLASH;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {\r\n                // NOOP\r\n            }\r\n            else if (dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 ||\r\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\r\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\r\n                    if (res.length > 2) {\r\n                        const lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = '';\r\n                            lastSegmentLength = 0;\r\n                        }\r\n                        else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                    else if (res.length !== 0) {\r\n                        res = '';\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    res += res.length > 0 ? `${separator}..` : '..';\r\n                    lastSegmentLength = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (res.length > 0) {\r\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\r\n                }\r\n                else {\r\n                    res = path.slice(lastSlash + 1, i);\r\n                }\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        }\r\n        else if (code === CHAR_DOT && dots !== -1) {\r\n            ++dots;\r\n        }\r\n        else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    validateObject(pathObject, 'pathObject');\r\n    const dir = pathObject.dir || pathObject.root;\r\n    const base = pathObject.base ||\r\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\r\n    if (!dir) {\r\n        return base;\r\n    }\r\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\r\n}\r\nconst win32 = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedDevice = '';\r\n        let resolvedTail = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\r\n            let path;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n                validateString(path, 'path');\r\n                // Skip empty entries\r\n                if (path.length === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (resolvedDevice.length === 0) {\r\n                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();\r\n            }\r\n            else {\r\n                // Windows has the concept of drive-specific current working\r\n                // directories. If we've resolved a drive letter but not yet an\r\n                // absolute path, get cwd for that drive, or the process cwd if\r\n                // the drive cwd is not available. We're sure the device is not\r\n                // a UNC path at this points, because UNC paths are always absolute.\r\n                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.env[`=${resolvedDevice}`] || _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();\r\n                // Verify that a cwd was found and that it actually points\r\n                // to our drive. If not, default to the drive's root.\r\n                if (path === undefined ||\r\n                    (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\r\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\r\n                    path = `${resolvedDevice}\\\\`;\r\n                }\r\n            }\r\n            const len = path.length;\r\n            let rootEnd = 0;\r\n            let device = '';\r\n            let isAbsolute = false;\r\n            const code = path.charCodeAt(0);\r\n            // Try to match a root\r\n            if (len === 1) {\r\n                if (isPathSeparator(code)) {\r\n                    // `path` contains just a path separator\r\n                    rootEnd = 1;\r\n                    isAbsolute = true;\r\n                }\r\n            }\r\n            else if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                // If we started with a separator, we know we at least have an\r\n                // absolute path of some kind (UNC or otherwise)\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    let j = 2;\r\n                    let last = j;\r\n                    // Match 1 or more non-path separators\r\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        const firstPart = path.slice(last, j);\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                                j++;\r\n                            }\r\n                            if (j === len || j !== last) {\r\n                                // We matched a UNC root\r\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rootEnd = 1;\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON) {\r\n                // Possible device root\r\n                device = path.slice(0, 2);\r\n                rootEnd = 2;\r\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                    // Treat separator following drive name as an absolute path\r\n                    // indicator\r\n                    isAbsolute = true;\r\n                    rootEnd = 3;\r\n                }\r\n            }\r\n            if (device.length > 0) {\r\n                if (resolvedDevice.length > 0) {\r\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n                        // This path points to another device so it is not applicable\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    resolvedDevice = device;\r\n                }\r\n            }\r\n            if (resolvedAbsolute) {\r\n                if (resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\r\n                resolvedAbsolute = isAbsolute;\r\n                if (isAbsolute && resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // At this point the path should be resolved to a full absolute path,\r\n        // but handle relative paths to be safe (might happen when process.cwd()\r\n        // fails)\r\n        // Normalize the tail path\r\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\r\n        return resolvedAbsolute ?\r\n            `${resolvedDevice}\\\\${resolvedTail}` :\r\n            `${resolvedDevice}${resolvedTail}` || '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = 0;\r\n        let device;\r\n        let isAbsolute = false;\r\n        const code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len === 1) {\r\n            // `path` contains just a single char, exit early to avoid\r\n            // unnecessary work\r\n            return isPosixPathSeparator(code) ? '\\\\' : path;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            // If we started with a separator, we know we at least have an absolute\r\n            // path of some kind (UNC or otherwise)\r\n            isAbsolute = true;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    const firstPart = path.slice(last, j);\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            // Return the normalized version of the UNC root since there\r\n                            // is nothing left to process\r\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                            rootEnd = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                rootEnd = 1;\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            device = path.slice(0, 2);\r\n            rootEnd = 2;\r\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                // Treat separator following drive name as an absolute path\r\n                // indicator\r\n                isAbsolute = true;\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        let tail = rootEnd < len ?\r\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\r\n            '';\r\n        if (tail.length === 0 && !isAbsolute) {\r\n            tail = '.';\r\n        }\r\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n            tail += '\\\\';\r\n        }\r\n        if (device === undefined) {\r\n            return isAbsolute ? `\\\\${tail}` : tail;\r\n        }\r\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const code = path.charCodeAt(0);\r\n        return isPathSeparator(code) ||\r\n            // Possible device root\r\n            (len > 2 &&\r\n                isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON &&\r\n                isPathSeparator(path.charCodeAt(2)));\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        let firstPart;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = firstPart = arg;\r\n                }\r\n                else {\r\n                    joined += `\\\\${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        // Make sure that the joined path doesn't start with two slashes, because\r\n        // normalize() will mistake it for a UNC path then.\r\n        //\r\n        // This step is skipped when it is very clear that the user actually\r\n        // intended to point at a UNC path. This is assumed when the first\r\n        // non-empty string arguments starts with exactly two slashes followed by\r\n        // at least one more non-slash character.\r\n        //\r\n        // Note that for normalize() to treat a path as a UNC path it needs to\r\n        // have at least 2 components, so we don't filter for that here.\r\n        // This means that the user can use join to construct UNC paths from\r\n        // a server name and a share name; for example:\r\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\r\n        let needsReplace = true;\r\n        let slashCount = 0;\r\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\r\n            ++slashCount;\r\n            const firstLen = firstPart.length;\r\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\r\n                ++slashCount;\r\n                if (firstLen > 2) {\r\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\r\n                        ++slashCount;\r\n                    }\r\n                    else {\r\n                        // We matched a UNC path in the first part\r\n                        needsReplace = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (needsReplace) {\r\n            // Find any more consecutive slashes we need to replace\r\n            while (slashCount < joined.length &&\r\n                isPathSeparator(joined.charCodeAt(slashCount))) {\r\n                slashCount++;\r\n            }\r\n            // Replace the slashes if needed\r\n            if (slashCount >= 2) {\r\n                joined = `\\\\${joined.slice(slashCount)}`;\r\n            }\r\n        }\r\n        return win32.normalize(joined);\r\n    },\r\n    // It will solve the relative path from `from` to `to`, for instance:\r\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromOrig = win32.resolve(from);\r\n        const toOrig = win32.resolve(to);\r\n        if (fromOrig === toOrig) {\r\n            return '';\r\n        }\r\n        from = fromOrig.toLowerCase();\r\n        to = toOrig.toLowerCase();\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        let fromStart = 0;\r\n        while (fromStart < from.length &&\r\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\r\n            fromStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let fromEnd = from.length;\r\n        while (fromEnd - 1 > fromStart &&\r\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            fromEnd--;\r\n        }\r\n        const fromLen = fromEnd - fromStart;\r\n        // Trim any leading backslashes\r\n        let toStart = 0;\r\n        while (toStart < to.length &&\r\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            toStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let toEnd = to.length;\r\n        while (toEnd - 1 > toStart &&\r\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            toEnd--;\r\n        }\r\n        const toLen = toEnd - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = fromLen < toLen ? fromLen : toLen;\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        // We found a mismatch before the first common path separator was seen, so\r\n        // return the original `to`.\r\n        if (i !== length) {\r\n            if (lastCommonSep === -1) {\r\n                return toOrig;\r\n            }\r\n        }\r\n        else {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\r\n                    return toOrig.slice(toStart + i + 1);\r\n                }\r\n                if (i === 2) {\r\n                    // We get here if `from` is the device root.\r\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\r\n                    return toOrig.slice(toStart + i);\r\n                }\r\n            }\r\n            if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 2) {\r\n                    // We get here if `to` is the device root.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\r\n                    lastCommonSep = 3;\r\n                }\r\n            }\r\n            if (lastCommonSep === -1) {\r\n                lastCommonSep = 0;\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to` and\r\n        // `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '\\\\..';\r\n            }\r\n        }\r\n        toStart += lastCommonSep;\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\r\n        }\r\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            ++toStart;\r\n        }\r\n        return toOrig.slice(toStart, toEnd);\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Note: this will *probably* throw somewhere.\r\n        if (typeof path !== 'string' || path.length === 0) {\r\n            return path;\r\n        }\r\n        const resolvedPath = win32.resolve(path);\r\n        if (resolvedPath.length <= 2) {\r\n            return path;\r\n        }\r\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\r\n            // Possible UNC root\r\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\r\n                const code = resolvedPath.charCodeAt(2);\r\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\r\n                    // Matched non-long UNC root, convert the path to a long UNC path\r\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\r\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\r\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n            // Matched device root, convert the path to a long UNC path\r\n            return `\\\\\\\\?\\\\${resolvedPath}`;\r\n        }\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = -1;\r\n        let offset = 0;\r\n        const code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work or a dot.\r\n            return isPathSeparator(code) ? path : '.';\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = offset = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            return path;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            // Offset by 1 to include the separator after the UNC root to\r\n                            // treat it as a \"normal root\" on top of a (UNC) root\r\n                            rootEnd = offset = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Possible device root\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\r\n            offset = rootEnd;\r\n        }\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = len - 1; i >= offset; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (rootEnd === -1) {\r\n                return '.';\r\n            }\r\n            end = rootEnd;\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\r\n            path.charCodeAt(1) === CHAR_COLON) {\r\n            start = 2;\r\n        }\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (isPathSeparator(code)) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= start; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            path.charCodeAt(1) === CHAR_COLON &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n            start = startPart = 2;\r\n        }\r\n        for (let i = path.length - 1; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '\\\\'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const len = path.length;\r\n        let rootEnd = 0;\r\n        let code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            if (isPathSeparator(code)) {\r\n                // `path` contains just a path separator, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            ret.base = ret.name = path;\r\n            return ret;\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            rootEnd = j;\r\n                        }\r\n                        else if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            rootEnd = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            if (len <= 2) {\r\n                // `path` contains just a drive root, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            rootEnd = 2;\r\n            if (isPathSeparator(path.charCodeAt(2))) {\r\n                if (len === 3) {\r\n                    // `path` contains just a drive root, exit early to avoid\r\n                    // unnecessary work\r\n                    ret.root = ret.dir = path;\r\n                    return ret;\r\n                }\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        if (rootEnd > 0) {\r\n            ret.root = path.slice(0, rootEnd);\r\n        }\r\n        let startDot = -1;\r\n        let startPart = rootEnd;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= rootEnd; --i) {\r\n            code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(startPart, startDot);\r\n                ret.base = path.slice(startPart, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        // If the directory is the root, use the entire root as the `dir` including\r\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\r\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\r\n        if (startPart > 0 && startPart !== rootEnd) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else {\r\n            ret.dir = ret.root;\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '\\\\',\r\n    delimiter: ';',\r\n    win32: null,\r\n    posix: null\r\n};\r\nconst posixCwd = (() => {\r\n    if (platformIsWin32) {\r\n        // Converts Windows' backslash path separators to POSIX forward slashes\r\n        // and truncates any drive indicator\r\n        const regexp = /\\\\/g;\r\n        return () => {\r\n            const cwd = _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd().replace(regexp, '/');\r\n            return cwd.slice(cwd.indexOf('/'));\r\n        };\r\n    }\r\n    // We're already on POSIX, no need for any transformations\r\n    return () => _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();\r\n})();\r\nconst posix = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedPath = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n            const path = i >= 0 ? pathSegments[i] : posixCwd();\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            resolvedPath = `${path}/${resolvedPath}`;\r\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        // Normalize the path\r\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\r\n        if (resolvedAbsolute) {\r\n            return `/${resolvedPath}`;\r\n        }\r\n        return resolvedPath.length > 0 ? resolvedPath : '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\r\n        // Normalize the path\r\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\r\n        if (path.length === 0) {\r\n            if (isAbsolute) {\r\n                return '/';\r\n            }\r\n            return trailingSeparator ? './' : '.';\r\n        }\r\n        if (trailingSeparator) {\r\n            path += '/';\r\n        }\r\n        return isAbsolute ? `/${path}` : path;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = arg;\r\n                }\r\n                else {\r\n                    joined += `/${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        return posix.normalize(joined);\r\n    },\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim leading forward slashes.\r\n        from = posix.resolve(from);\r\n        to = posix.resolve(to);\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromStart = 1;\r\n        const fromEnd = from.length;\r\n        const fromLen = fromEnd - fromStart;\r\n        const toStart = 1;\r\n        const toLen = to.length - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = (fromLen < toLen ? fromLen : toLen);\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_FORWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        if (i === length) {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n                    return to.slice(toStart + i + 1);\r\n                }\r\n                if (i === 0) {\r\n                    // We get here if `from` is the root\r\n                    // For example: from='/'; to='/foo'\r\n                    return to.slice(toStart + i);\r\n                }\r\n            }\r\n            else if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 0) {\r\n                    // We get here if `to` is the root.\r\n                    // For example: from='/foo/bar'; to='/'\r\n                    lastCommonSep = 0;\r\n                }\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to`\r\n        // and `from`.\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '/..';\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts.\r\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Non-op on posix systems\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = path.length - 1; i >= 1; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return hasRoot ? '/' : '.';\r\n        }\r\n        if (hasRoot && end === 1) {\r\n            return '//';\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (code === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= 0; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        for (let i = path.length - 1; i >= 0; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '/'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let start;\r\n        if (isAbsolute) {\r\n            ret.root = '/';\r\n            start = 1;\r\n        }\r\n        else {\r\n            start = 0;\r\n        }\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(start, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(start, startDot);\r\n                ret.base = path.slice(start, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        if (startPart > 0) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else if (isAbsolute) {\r\n            ret.dir = '/';\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '/',\r\n    delimiter: ':',\r\n    win32: null,\r\n    posix: null\r\n};\r\nposix.win32 = win32.win32 = win32;\r\nposix.posix = win32.posix = posix;\r\nconst normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\r\nconst resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\r\nconst relative = (platformIsWin32 ? win32.relative : posix.relative);\r\nconst dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\r\nconst basename = (platformIsWin32 ? win32.basename : posix.basename);\r\nconst extname = (platformIsWin32 ? win32.extname : posix.extname);\r\nconst sep = (platformIsWin32 ? win32.sep : posix.sep);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcGF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDeEMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQiwrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUssSUFBSSxNQUFNLEVBQUUsWUFBWSxVQUFVLFNBQVM7QUFDMUUsa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsRUFBRSw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQixFQUFFLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSxFQUFFLEtBQUssT0FBTyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUs7QUFDM0U7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBVyxLQUFLLGVBQWUsTUFBTSw0Q0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsSUFBSSxvQkFBb0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxJQUFJLGFBQWE7QUFDL0MsZUFBZSxlQUFlLEVBQUUsYUFBYTtBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsSUFBSSxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVUsSUFBSSxvQkFBb0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQSwrQkFBK0IsT0FBTyxJQUFJLEtBQUssT0FBTyxPQUFPLEVBQUUsS0FBSztBQUNwRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRDQUFXO0FBQzVCLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxHQUFHLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLEVBQUUsa0NBQWtDO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3BhdGguanM/MzJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gTk9URTogVlNDb2RlJ3MgY29weSBvZiBub2RlanMgcGF0aCBsaWJyYXJ5IHRvIGJlIHVzYWJsZSBpbiBjb21tb24gKG5vbi1ub2RlKSBuYW1lc3BhY2VcclxuLy8gQ29waWVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxNi4xNC4yL2xpYi9wYXRoLmpzXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbiAqIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4gKiBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbiAqIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuICogT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4gKiBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuaW1wb3J0ICogYXMgcHJvY2VzcyBmcm9tICcuL3Byb2Nlc3MuanMnO1xyXG5jb25zdCBDSEFSX1VQUEVSQ0FTRV9BID0gNjU7IC8qIEEgKi9cclxuY29uc3QgQ0hBUl9MT1dFUkNBU0VfQSA9IDk3OyAvKiBhICovXHJcbmNvbnN0IENIQVJfVVBQRVJDQVNFX1ogPSA5MDsgLyogWiAqL1xyXG5jb25zdCBDSEFSX0xPV0VSQ0FTRV9aID0gMTIyOyAvKiB6ICovXHJcbmNvbnN0IENIQVJfRE9UID0gNDY7IC8qIC4gKi9cclxuY29uc3QgQ0hBUl9GT1JXQVJEX1NMQVNIID0gNDc7IC8qIC8gKi9cclxuY29uc3QgQ0hBUl9CQUNLV0FSRF9TTEFTSCA9IDkyOyAvKiBcXCAqL1xyXG5jb25zdCBDSEFSX0NPTE9OID0gNTg7IC8qIDogKi9cclxuY29uc3QgQ0hBUl9RVUVTVElPTl9NQVJLID0gNjM7IC8qID8gKi9cclxuY2xhc3MgRXJyb3JJbnZhbGlkQXJnVHlwZSBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcclxuICAgICAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xyXG4gICAgICAgIGxldCBkZXRlcm1pbmVyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIGV4cGVjdGVkLmluZGV4T2YoJ25vdCAnKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcclxuICAgICAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcclxuICAgICAgICBsZXQgbXNnID0gYFRoZSBcIiR7bmFtZX1cIiAke3R5cGV9ICR7ZGV0ZXJtaW5lcn0gb2YgdHlwZSAke2V4cGVjdGVkfWA7XHJcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XHJcbiAgICAgICAgc3VwZXIobXNnKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0lOVkFMSURfQVJHX1RZUEUnO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KHBhdGhPYmplY3QsIG5hbWUpIHtcclxuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvckludmFsaWRBcmdUeXBlKG5hbWUsICdPYmplY3QnLCBwYXRoT2JqZWN0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgbmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbnZhbGlkQXJnVHlwZShuYW1lLCAnc3RyaW5nJywgdmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHBsYXRmb3JtSXNXaW4zMiA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKTtcclxuZnVuY3Rpb24gaXNQYXRoU2VwYXJhdG9yKGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0ggfHwgY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSDtcclxufVxyXG5mdW5jdGlvbiBpc1Bvc2l4UGF0aFNlcGFyYXRvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG59XHJcbmZ1bmN0aW9uIGlzV2luZG93c0RldmljZVJvb3QoY29kZSkge1xyXG4gICAgcmV0dXJuIChjb2RlID49IENIQVJfVVBQRVJDQVNFX0EgJiYgY29kZSA8PSBDSEFSX1VQUEVSQ0FTRV9aKSB8fFxyXG4gICAgICAgIChjb2RlID49IENIQVJfTE9XRVJDQVNFX0EgJiYgY29kZSA8PSBDSEFSX0xPV0VSQ0FTRV9aKTtcclxufVxyXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcclxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHBhdGgsIGFsbG93QWJvdmVSb290LCBzZXBhcmF0b3IsIGlzUGF0aFNlcGFyYXRvcikge1xyXG4gICAgbGV0IHJlcyA9ICcnO1xyXG4gICAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcclxuICAgIGxldCBsYXN0U2xhc2ggPSAtMTtcclxuICAgIGxldCBkb3RzID0gMDtcclxuICAgIGxldCBjb2RlID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTk9PUFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvdHMgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gQ0hBUl9ET1QgfHxcclxuICAgICAgICAgICAgICAgICAgICByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSByZXMubGVuZ3RoID4gMCA/IGAke3NlcGFyYXRvcn0uLmAgOiAnLi4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xyXG4gICAgICAgICAgICBkb3RzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gQ0hBUl9ET1QgJiYgZG90cyAhPT0gLTEpIHtcclxuICAgICAgICAgICAgKytkb3RzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG90cyA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcclxuICAgIHZhbGlkYXRlT2JqZWN0KHBhdGhPYmplY3QsICdwYXRoT2JqZWN0Jyk7XHJcbiAgICBjb25zdCBkaXIgPSBwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LnJvb3Q7XHJcbiAgICBjb25zdCBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8XHJcbiAgICAgICAgYCR7cGF0aE9iamVjdC5uYW1lIHx8ICcnfSR7cGF0aE9iamVjdC5leHQgfHwgJyd9YDtcclxuICAgIGlmICghZGlyKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlyID09PSBwYXRoT2JqZWN0LnJvb3QgPyBgJHtkaXJ9JHtiYXNlfWAgOiBgJHtkaXJ9JHtzZXB9JHtiYXNlfWA7XHJcbn1cclxuZXhwb3J0IGNvbnN0IHdpbjMyID0ge1xyXG4gICAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxyXG4gICAgcmVzb2x2ZSguLi5wYXRoU2VnbWVudHMpIHtcclxuICAgICAgICBsZXQgcmVzb2x2ZWREZXZpY2UgPSAnJztcclxuICAgICAgICBsZXQgcmVzb2x2ZWRUYWlsID0gJyc7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xyXG4gICAgICAgICAgICBsZXQgcGF0aDtcclxuICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhTZWdtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc29sdmVkRGV2aWNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHByb2Nlc3MuY3dkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIGhhcyB0aGUgY29uY2VwdCBvZiBkcml2ZS1zcGVjaWZpYyBjdXJyZW50IHdvcmtpbmdcclxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdG9yaWVzLiBJZiB3ZSd2ZSByZXNvbHZlZCBhIGRyaXZlIGxldHRlciBidXQgbm90IHlldCBhblxyXG4gICAgICAgICAgICAgICAgLy8gYWJzb2x1dGUgcGF0aCwgZ2V0IGN3ZCBmb3IgdGhhdCBkcml2ZSwgb3IgdGhlIHByb2Nlc3MgY3dkIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZHJpdmUgY3dkIGlzIG5vdCBhdmFpbGFibGUuIFdlJ3JlIHN1cmUgdGhlIGRldmljZSBpcyBub3RcclxuICAgICAgICAgICAgICAgIC8vIGEgVU5DIHBhdGggYXQgdGhpcyBwb2ludHMsIGJlY2F1c2UgVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGUuXHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcHJvY2Vzcy5lbnZbYD0ke3Jlc29sdmVkRGV2aWNlfWBdIHx8IHByb2Nlc3MuY3dkKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBhIGN3ZCB3YXMgZm91bmQgYW5kIHRoYXQgaXQgYWN0dWFsbHkgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAvLyB0byBvdXIgZHJpdmUuIElmIG5vdCwgZGVmYXVsdCB0byB0aGUgZHJpdmUncyByb290LlxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRoLnNsaWNlKDAsIDIpLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDIpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBgJHtyZXNvbHZlZERldmljZX1cXFxcYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IHJvb3RFbmQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgZGV2aWNlID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICByb290RW5kID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHdpdGggYSBzZXBhcmF0b3IsIHdlIGtub3cgd2UgYXQgbGVhc3QgaGF2ZSBhblxyXG4gICAgICAgICAgICAgICAgLy8gYWJzb2x1dGUgcGF0aCBvZiBzb21lIGtpbmQgKFVOQyBvciBvdGhlcndpc2UpXHJcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBqID0gMjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhdGguc2xpY2UobGFzdCwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4gfHwgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSA9IGBcXFxcXFxcXCR7Zmlyc3RQYXJ0fVxcXFwke3BhdGguc2xpY2UobGFzdCwgail9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiZcclxuICAgICAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xyXG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcclxuICAgICAgICAgICAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7XHJcbiAgICAgICAgICAgICAgICByb290RW5kID0gMjtcclxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByb290RW5kID0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGV2aWNlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS50b0xvd2VyQ2FzZSgpICE9PSByZXNvbHZlZERldmljZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcGF0aCBwb2ludHMgdG8gYW5vdGhlciBkZXZpY2Ugc28gaXQgaXMgbm90IGFwcGxpY2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWREZXZpY2UgPSBkZXZpY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZFRhaWwgPSBgJHtwYXRoLnNsaWNlKHJvb3RFbmQpfVxcXFwke3Jlc29sdmVkVGFpbH1gO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGlzQWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSAmJiByZXNvbHZlZERldmljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsXHJcbiAgICAgICAgLy8gYnV0IGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpXHJcbiAgICAgICAgLy8gZmFpbHMpXHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSB0YWlsIHBhdGhcclxuICAgICAgICByZXNvbHZlZFRhaWwgPSBub3JtYWxpemVTdHJpbmcocmVzb2x2ZWRUYWlsLCAhcmVzb2x2ZWRBYnNvbHV0ZSwgJ1xcXFwnLCBpc1BhdGhTZXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlZEFic29sdXRlID9cclxuICAgICAgICAgICAgYCR7cmVzb2x2ZWREZXZpY2V9XFxcXCR7cmVzb2x2ZWRUYWlsfWAgOlxyXG4gICAgICAgICAgICBgJHtyZXNvbHZlZERldmljZX0ke3Jlc29sdmVkVGFpbH1gIHx8ICcuJztcclxuICAgIH0sXHJcbiAgICBub3JtYWxpemUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XHJcbiAgICAgICAgbGV0IGRldmljZTtcclxuICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxyXG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBzaW5nbGUgY2hhciwgZXhpdCBlYXJseSB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXHJcbiAgICAgICAgICAgIHJldHVybiBpc1Bvc2l4UGF0aFNlcGFyYXRvcihjb2RlKSA/ICdcXFxcJyA6IHBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcclxuICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW4gYWJzb2x1dGVcclxuICAgICAgICAgICAgLy8gcGF0aCBvZiBzb21lIGtpbmQgKFVOQyBvciBvdGhlcndpc2UpXHJcbiAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgbGV0IGogPSAyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBVTkMgcm9vdCBzaW5jZSB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90aGluZyBsZWZ0IHRvIHByb2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QpfVxcXFxgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSA9IGBcXFxcXFxcXCR7Zmlyc3RQYXJ0fVxcXFwke3BhdGguc2xpY2UobGFzdCwgail9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcclxuICAgICAgICAgICAgZGV2aWNlID0gcGF0aC5zbGljZSgwLCAyKTtcclxuICAgICAgICAgICAgcm9vdEVuZCA9IDI7XHJcbiAgICAgICAgICAgIGlmIChsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcmVhdCBzZXBhcmF0b3IgZm9sbG93aW5nIGRyaXZlIG5hbWUgYXMgYW4gYWJzb2x1dGUgcGF0aFxyXG4gICAgICAgICAgICAgICAgLy8gaW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0YWlsID0gcm9vdEVuZCA8IGxlbiA/XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVN0cmluZyhwYXRoLnNsaWNlKHJvb3RFbmQpLCAhaXNBYnNvbHV0ZSwgJ1xcXFwnLCBpc1BhdGhTZXBhcmF0b3IpIDpcclxuICAgICAgICAgICAgJyc7XHJcbiAgICAgICAgaWYgKHRhaWwubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgIHRhaWwgPSAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWlsLmxlbmd0aCA+IDAgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChsZW4gLSAxKSkpIHtcclxuICAgICAgICAgICAgdGFpbCArPSAnXFxcXCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXZpY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/IGBcXFxcJHt0YWlsfWAgOiB0YWlsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/IGAke2RldmljZX1cXFxcJHt0YWlsfWAgOiBgJHtkZXZpY2V9JHt0YWlsfWA7XHJcbiAgICB9LFxyXG4gICAgaXNBYnNvbHV0ZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICByZXR1cm4gaXNQYXRoU2VwYXJhdG9yKGNvZGUpIHx8XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XHJcbiAgICAgICAgICAgIChsZW4gPiAyICYmXHJcbiAgICAgICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmXHJcbiAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcclxuICAgICAgICAgICAgICAgIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKTtcclxuICAgIH0sXHJcbiAgICBqb2luKC4uLnBhdGhzKSB7XHJcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgam9pbmVkO1xyXG4gICAgICAgIGxldCBmaXJzdFBhcnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcclxuICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcoYXJnLCAncGF0aCcpO1xyXG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGZpcnN0UGFydCA9IGFyZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCArPSBgXFxcXCR7YXJnfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBqb2luZWQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggdHdvIHNsYXNoZXMsIGJlY2F1c2VcclxuICAgICAgICAvLyBub3JtYWxpemUoKSB3aWxsIG1pc3Rha2UgaXQgZm9yIGEgVU5DIHBhdGggdGhlbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoaXMgc3RlcCBpcyBza2lwcGVkIHdoZW4gaXQgaXMgdmVyeSBjbGVhciB0aGF0IHRoZSB1c2VyIGFjdHVhbGx5XHJcbiAgICAgICAgLy8gaW50ZW5kZWQgdG8gcG9pbnQgYXQgYSBVTkMgcGF0aC4gVGhpcyBpcyBhc3N1bWVkIHdoZW4gdGhlIGZpcnN0XHJcbiAgICAgICAgLy8gbm9uLWVtcHR5IHN0cmluZyBhcmd1bWVudHMgc3RhcnRzIHdpdGggZXhhY3RseSB0d28gc2xhc2hlcyBmb2xsb3dlZCBieVxyXG4gICAgICAgIC8vIGF0IGxlYXN0IG9uZSBtb3JlIG5vbi1zbGFzaCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBOb3RlIHRoYXQgZm9yIG5vcm1hbGl6ZSgpIHRvIHRyZWF0IGEgcGF0aCBhcyBhIFVOQyBwYXRoIGl0IG5lZWRzIHRvXHJcbiAgICAgICAgLy8gaGF2ZSBhdCBsZWFzdCAyIGNvbXBvbmVudHMsIHNvIHdlIGRvbid0IGZpbHRlciBmb3IgdGhhdCBoZXJlLlxyXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdXNlciBjYW4gdXNlIGpvaW4gdG8gY29uc3RydWN0IFVOQyBwYXRocyBmcm9tXHJcbiAgICAgICAgLy8gYSBzZXJ2ZXIgbmFtZSBhbmQgYSBzaGFyZSBuYW1lOyBmb3IgZXhhbXBsZTpcclxuICAgICAgICAvLyAgIHBhdGguam9pbignLy9zZXJ2ZXInLCAnc2hhcmUnKSAtPiAnXFxcXFxcXFxzZXJ2ZXJcXFxcc2hhcmVcXFxcJylcclxuICAgICAgICBsZXQgbmVlZHNSZXBsYWNlID0gdHJ1ZTtcclxuICAgICAgICBsZXQgc2xhc2hDb3VudCA9IDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQgPT09ICdzdHJpbmcnICYmIGlzUGF0aFNlcGFyYXRvcihmaXJzdFBhcnQuY2hhckNvZGVBdCgwKSkpIHtcclxuICAgICAgICAgICAgKytzbGFzaENvdW50O1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdExlbiA9IGZpcnN0UGFydC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdExlbiA+IDEgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgKytzbGFzaENvdW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TGVuID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoZmlyc3RQYXJ0LmNoYXJDb2RlQXQoMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrc2xhc2hDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcGF0aCBpbiB0aGUgZmlyc3QgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1JlcGxhY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lZWRzUmVwbGFjZSkge1xyXG4gICAgICAgICAgICAvLyBGaW5kIGFueSBtb3JlIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2UgbmVlZCB0byByZXBsYWNlXHJcbiAgICAgICAgICAgIHdoaWxlIChzbGFzaENvdW50IDwgam9pbmVkLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgaXNQYXRoU2VwYXJhdG9yKGpvaW5lZC5jaGFyQ29kZUF0KHNsYXNoQ291bnQpKSkge1xyXG4gICAgICAgICAgICAgICAgc2xhc2hDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHNsYXNoZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChzbGFzaENvdW50ID49IDIpIHtcclxuICAgICAgICAgICAgICAgIGpvaW5lZCA9IGBcXFxcJHtqb2luZWQuc2xpY2Uoc2xhc2hDb3VudCl9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2luMzIubm9ybWFsaXplKGpvaW5lZCk7XHJcbiAgICB9LFxyXG4gICAgLy8gSXQgd2lsbCBzb2x2ZSB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIGBmcm9tYCB0byBgdG9gLCBmb3IgaW5zdGFuY2U6XHJcbiAgICAvLyAgZnJvbSA9ICdDOlxcXFxvcmFuZGVhXFxcXHRlc3RcXFxcYWFhJ1xyXG4gICAgLy8gIHRvID0gJ0M6XFxcXG9yYW5kZWFcXFxcaW1wbFxcXFxiYmInXHJcbiAgICAvLyBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbiBzaG91bGQgYmU6ICcuLlxcXFwuLlxcXFxpbXBsXFxcXGJiYidcclxuICAgIHJlbGF0aXZlKGZyb20sIHRvKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcoZnJvbSwgJ2Zyb20nKTtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyh0bywgJ3RvJyk7XHJcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJvbU9yaWcgPSB3aW4zMi5yZXNvbHZlKGZyb20pO1xyXG4gICAgICAgIGNvbnN0IHRvT3JpZyA9IHdpbjMyLnJlc29sdmUodG8pO1xyXG4gICAgICAgIGlmIChmcm9tT3JpZyA9PT0gdG9PcmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJvbSA9IGZyb21PcmlnLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdG8gPSB0b09yaWcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXHJcbiAgICAgICAgbGV0IGZyb21TdGFydCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGZyb21TdGFydCA8IGZyb20ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgIGZyb21TdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KVxyXG4gICAgICAgIGxldCBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGZyb21FbmQgLSAxID4gZnJvbVN0YXJ0ICYmXHJcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tRW5kIC0gMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgZnJvbUVuZC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcclxuICAgICAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXHJcbiAgICAgICAgbGV0IHRvU3RhcnQgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0b1N0YXJ0IDwgdG8ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgdG9TdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KVxyXG4gICAgICAgIGxldCB0b0VuZCA9IHRvLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAodG9FbmQgLSAxID4gdG9TdGFydCAmJlxyXG4gICAgICAgICAgICB0by5jaGFyQ29kZUF0KHRvRW5kIC0gMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgdG9FbmQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XHJcbiAgICAgICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcclxuICAgICAgICBsZXQgbGFzdENvbW1vblNlcCA9IC0xO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUNvZGUgIT09IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgZm91bmQgYSBtaXNtYXRjaCBiZWZvcmUgdGhlIGZpcnN0IGNvbW1vbiBwYXRoIHNlcGFyYXRvciB3YXMgc2Vlbiwgc29cclxuICAgICAgICAvLyByZXR1cm4gdGhlIG9yaWdpbmFsIGB0b2AuXHJcbiAgICAgICAgaWYgKGkgIT09IGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b09yaWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcZm9vXFxcXGJhclxcXFxiYXonXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGRldmljZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPSdDOlxcXFwnOyB0bz0nQzpcXFxcZm9vJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b09yaWcuc2xpY2UodG9TdGFydCArIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcZm9vJ1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGRldmljZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPSdDOlxcXFxmb29cXFxcYmFyJzsgdG89J0M6XFxcXCdcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvdXQgPSAnJztcclxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYCBhbmRcclxuICAgICAgICAvLyBgZnJvbWBcclxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gb3V0Lmxlbmd0aCA9PT0gMCA/ICcuLicgOiAnXFxcXC4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XHJcbiAgICAgICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcclxuICAgICAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcclxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke291dH0ke3RvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvT3JpZy5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICsrdG9TdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCk7XHJcbiAgICB9LFxyXG4gICAgdG9OYW1lc3BhY2VkUGF0aChwYXRoKSB7XHJcbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsICpwcm9iYWJseSogdGhyb3cgc29tZXdoZXJlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgfHwgcGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHdpbjMyLnJlc29sdmUocGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENIQVJfUVVFU1RJT05fTUFSSyAmJiBjb2RlICE9PSBDSEFSX0RPVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgbm9uLWxvbmcgVU5DIHJvb3QsIGNvbnZlcnQgdGhlIHBhdGggdG8gYSBsb25nIFVOQyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcVU5DXFxcXCR7cmVzb2x2ZWRQYXRoLnNsaWNlKDIpfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKSkgJiZcclxuICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcclxuICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMikgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgLy8gTWF0Y2hlZCBkZXZpY2Ugcm9vdCwgY29udmVydCB0aGUgcGF0aCB0byBhIGxvbmcgVU5DIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcJHtyZXNvbHZlZFBhdGh9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9LFxyXG4gICAgZGlybmFtZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByb290RW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3IsIGV4aXQgZWFybHkgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yayBvciBhIGRvdC5cclxuICAgICAgICAgICAgcmV0dXJuIGlzUGF0aFNlcGFyYXRvcihjb2RlKSA/IHBhdGggOiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcclxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XHJcbiAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAxO1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgbGV0IGogPSAyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgYnkgMSB0byBpbmNsdWRlIHRoZSBzZXBhcmF0b3IgYWZ0ZXIgdGhlIFVOQyByb290IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIFwibm9ybWFsIHJvb3RcIiBvbiB0b3Agb2YgYSAoVU5DKSByb290XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gb2Zmc2V0ID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcclxuICAgICAgICAgICAgcm9vdEVuZCA9IGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkgPyAzIDogMjtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gcm9vdEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IG9mZnNldDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChyb290RW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmQgPSByb290RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xyXG4gICAgfSxcclxuICAgIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xyXG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhleHQsICdleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBlbmQgPSAtMTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICAvLyBDaGVjayBmb3IgYSBkcml2ZSBsZXR0ZXIgcHJlZml4IHNvIGFzIG5vdCB0byBtaXN0YWtlIHRoZSBmb2xsb3dpbmdcclxuICAgICAgICAvLyBwYXRoIHNlcGFyYXRvciBhcyBhbiBleHRyYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0aCB0aGF0IGNhbiBiZVxyXG4gICAgICAgIC8vIGRpc3JlZ2FyZGVkXHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID49IDIgJiZcclxuICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChwYXRoLmNoYXJDb2RlQXQoMCkpICYmXHJcbiAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xyXG4gICAgICAgICAgICBzdGFydCA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChleHQgPT09IHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRJZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcclxuICAgICAgICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgZXh0bmFtZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xyXG4gICAgICAgIGxldCBzdGFydFBhcnQgPSAwO1xyXG4gICAgICAgIGxldCBlbmQgPSAtMTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXHJcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcclxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBhIGRyaXZlIGxldHRlciBwcmVmaXggc28gYXMgbm90IHRvIG1pc3Rha2UgdGhlIGZvbGxvd2luZ1xyXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXHJcbiAgICAgICAgLy8gZGlzcmVnYXJkZWRcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPj0gMiAmJlxyXG4gICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcclxuICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChwYXRoLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRQYXJ0ID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXHJcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxyXG4gICAgICAgICAgICBlbmQgPT09IC0xIHx8XHJcbiAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XHJcbiAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XHJcbiAgICAgICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcclxuICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxyXG4gICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJ1xcXFwnKSxcclxuICAgIHBhcnNlKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGNvbnN0IHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XHJcbiAgICAgICAgbGV0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHBhdGggc2VwYXJhdG9yLCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXHJcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxyXG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcclxuICAgICAgICAgICAgcm9vdEVuZCA9IDE7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGogKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XHJcbiAgICAgICAgICAgIGlmIChsZW4gPD0gMikge1xyXG4gICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBkcml2ZSByb290LCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXHJcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290RW5kID0gMjtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBkcml2ZSByb290LCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb290RW5kID4gMCkge1xyXG4gICAgICAgICAgICByZXQucm9vdCA9IHBhdGguc2xpY2UoMCwgcm9vdEVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xyXG4gICAgICAgIGxldCBzdGFydFBhcnQgPSByb290RW5kO1xyXG4gICAgICAgIGxldCBlbmQgPSAtMTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXHJcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcclxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xyXG4gICAgICAgIC8vIEdldCBub24tZGlyIGluZm9cclxuICAgICAgICBmb3IgKDsgaSA+PSByb290RW5kOyAtLWkpIHtcclxuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kICE9PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcclxuICAgICAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XHJcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIGRpcmVjdG9yeSBpcyB0aGUgcm9vdCwgdXNlIHRoZSBlbnRpcmUgcm9vdCBhcyB0aGUgYGRpcmAgaW5jbHVkaW5nXHJcbiAgICAgICAgLy8gdGhlIHRyYWlsaW5nIHNsYXNoIGlmIGFueSAoYEM6XFxhYmNgIC0+IGBDOlxcYCkuIE90aGVyd2lzZSwgc3RyaXAgb3V0IHRoZVxyXG4gICAgICAgIC8vIHRyYWlsaW5nIHNsYXNoIChgQzpcXGFiY1xcZGVmYCAtPiBgQzpcXGFiY2ApLlxyXG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwICYmIHN0YXJ0UGFydCAhPT0gcm9vdEVuZCkge1xyXG4gICAgICAgICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSByZXQucm9vdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sXHJcbiAgICBzZXA6ICdcXFxcJyxcclxuICAgIGRlbGltaXRlcjogJzsnLFxyXG4gICAgd2luMzI6IG51bGwsXHJcbiAgICBwb3NpeDogbnVsbFxyXG59O1xyXG5jb25zdCBwb3NpeEN3ZCA9ICgoKSA9PiB7XHJcbiAgICBpZiAocGxhdGZvcm1Jc1dpbjMyKSB7XHJcbiAgICAgICAgLy8gQ29udmVydHMgV2luZG93cycgYmFja3NsYXNoIHBhdGggc2VwYXJhdG9ycyB0byBQT1NJWCBmb3J3YXJkIHNsYXNoZXNcclxuICAgICAgICAvLyBhbmQgdHJ1bmNhdGVzIGFueSBkcml2ZSBpbmRpY2F0b3JcclxuICAgICAgICBjb25zdCByZWdleHAgPSAvXFxcXC9nO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN3ZCA9IHByb2Nlc3MuY3dkKCkucmVwbGFjZShyZWdleHAsICcvJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjd2Quc2xpY2UoY3dkLmluZGV4T2YoJy8nKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFdlJ3JlIGFscmVhZHkgb24gUE9TSVgsIG5vIG5lZWQgZm9yIGFueSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIHJldHVybiAoKSA9PiBwcm9jZXNzLmN3ZCgpO1xyXG59KSgpO1xyXG5leHBvcnQgY29uc3QgcG9zaXggPSB7XHJcbiAgICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXHJcbiAgICByZXNvbHZlKC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgICAgIGxldCByZXNvbHZlZFBhdGggPSAnJztcclxuICAgICAgICBsZXQgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBpID49IDAgPyBwYXRoU2VnbWVudHNbaV0gOiBwb3NpeEN3ZCgpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcclxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlZFBhdGggPSBgJHtwYXRofS8ke3Jlc29sdmVkUGF0aH1gO1xyXG4gICAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcclxuICAgICAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcclxuICAgICAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmcocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSwgJy8nLCBpc1Bvc2l4UGF0aFNlcGFyYXRvcik7XHJcbiAgICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAvJHtyZXNvbHZlZFBhdGh9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aC5sZW5ndGggPiAwID8gcmVzb2x2ZWRQYXRoIDogJy4nO1xyXG4gICAgfSxcclxuICAgIG5vcm1hbGl6ZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcclxuICAgICAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nKHBhdGgsICFpc0Fic29sdXRlLCAnLycsIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nU2VwYXJhdG9yID8gJy4vJyA6ICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHBhdGggKz0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/IGAvJHtwYXRofWAgOiBwYXRoO1xyXG4gICAgfSxcclxuICAgIGlzQWJzb2x1dGUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgIH0sXHJcbiAgICBqb2luKC4uLnBhdGhzKSB7XHJcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgam9pbmVkO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJnID0gcGF0aHNbaV07XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTtcclxuICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgKz0gYC8ke2FyZ31gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zaXgubm9ybWFsaXplKGpvaW5lZCk7XHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhmcm9tLCAnZnJvbScpO1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHRvLCAndG8nKTtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIGxlYWRpbmcgZm9yd2FyZCBzbGFzaGVzLlxyXG4gICAgICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xyXG4gICAgICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XHJcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJvbVN0YXJ0ID0gMTtcclxuICAgICAgICBjb25zdCBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XHJcbiAgICAgICAgY29uc3QgdG9TdGFydCA9IDE7XHJcbiAgICAgICAgY29uc3QgdG9MZW4gPSB0by5sZW5ndGggLSB0b1N0YXJ0O1xyXG4gICAgICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3RcclxuICAgICAgICBjb25zdCBsZW5ndGggPSAoZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuKTtcclxuICAgICAgICBsZXQgbGFzdENvbW1vblNlcCA9IC0xO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUNvZGUgIT09IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbUxlbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvJ1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvdXQgPSAnJztcclxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxyXG4gICAgICAgIC8vIGFuZCBgZnJvbWAuXHJcbiAgICAgICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gb3V0Lmxlbmd0aCA9PT0gMCA/ICcuLicgOiAnLy4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxyXG4gICAgICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0cy5cclxuICAgICAgICByZXR1cm4gYCR7b3V0fSR7dG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApfWA7XHJcbiAgICB9LFxyXG4gICAgdG9OYW1lc3BhY2VkUGF0aChwYXRoKSB7XHJcbiAgICAgICAgLy8gTm9uLW9wIG9uIHBvc2l4IHN5c3RlbXNcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH0sXHJcbiAgICBkaXJuYW1lKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYXNSb290ID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcvLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgYmFzZW5hbWUocGF0aCwgZXh0KSB7XHJcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGV4dCwgJ2V4dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChleHQgPT09IHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXHJcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfSxcclxuICAgIGV4dG5hbWUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcclxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxyXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XHJcbiAgICAgICAgICAgIGVuZCA9PT0gLTEgfHxcclxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcclxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcclxuICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xyXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXHJcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcclxuICAgIH0sXHJcbiAgICBmb3JtYXQ6IF9mb3JtYXQuYmluZChudWxsLCAnLycpLFxyXG4gICAgcGFyc2UocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgcmV0ID0geyByb290OiAnJywgZGlyOiAnJywgYmFzZTogJycsIGV4dDogJycsIG5hbWU6ICcnIH07XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICBsZXQgc3RhcnQ7XHJcbiAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgcmV0LnJvb3QgPSAnLyc7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGxldCBpID0gcGF0aC5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcclxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxyXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XHJcbiAgICAgICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xyXG4gICAgICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlID8gMSA6IHN0YXJ0UGFydDtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcclxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXHJcbiAgICAgICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnQsIHN0YXJ0RG90KTtcclxuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LFxyXG4gICAgc2VwOiAnLycsXHJcbiAgICBkZWxpbWl0ZXI6ICc6JyxcclxuICAgIHdpbjMyOiBudWxsLFxyXG4gICAgcG9zaXg6IG51bGxcclxufTtcclxucG9zaXgud2luMzIgPSB3aW4zMi53aW4zMiA9IHdpbjMyO1xyXG5wb3NpeC5wb3NpeCA9IHdpbjMyLnBvc2l4ID0gcG9zaXg7XHJcbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIubm9ybWFsaXplIDogcG9zaXgubm9ybWFsaXplKTtcclxuZXhwb3J0IGNvbnN0IHJlc29sdmUgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIucmVzb2x2ZSA6IHBvc2l4LnJlc29sdmUpO1xyXG5leHBvcnQgY29uc3QgcmVsYXRpdmUgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIucmVsYXRpdmUgOiBwb3NpeC5yZWxhdGl2ZSk7XHJcbmV4cG9ydCBjb25zdCBkaXJuYW1lID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmRpcm5hbWUgOiBwb3NpeC5kaXJuYW1lKTtcclxuZXhwb3J0IGNvbnN0IGJhc2VuYW1lID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmJhc2VuYW1lIDogcG9zaXguYmFzZW5hbWUpO1xyXG5leHBvcnQgY29uc3QgZXh0bmFtZSA9IChwbGF0Zm9ybUlzV2luMzIgPyB3aW4zMi5leHRuYW1lIDogcG9zaXguZXh0bmFtZSk7XHJcbmV4cG9ydCBjb25zdCBzZXAgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIuc2VwIDogcG9zaXguc2VwKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/path.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/platform.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/platform.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LANGUAGE_DEFAULT: () => (/* binding */ LANGUAGE_DEFAULT),\n/* harmony export */   OS: () => (/* binding */ OS),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isChrome: () => (/* binding */ isChrome),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isFirefox: () => (/* binding */ isFirefox),\n/* harmony export */   isIOS: () => (/* binding */ isIOS),\n/* harmony export */   isLinux: () => (/* binding */ isLinux),\n/* harmony export */   isLittleEndian: () => (/* binding */ isLittleEndian),\n/* harmony export */   isMacintosh: () => (/* binding */ isMacintosh),\n/* harmony export */   isMobile: () => (/* binding */ isMobile),\n/* harmony export */   isNative: () => (/* binding */ isNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isWeb: () => (/* binding */ isWeb),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   isWindows: () => (/* binding */ isWindows),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   setTimeout0: () => (/* binding */ setTimeout0),\n/* harmony export */   setTimeout0IsFaster: () => (/* binding */ setTimeout0IsFaster),\n/* harmony export */   userAgent: () => (/* binding */ userAgent),\n/* harmony export */   webWorkerOrigin: () => (/* binding */ webWorkerOrigin)\n/* harmony export */ });\n/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nls.js */ \"./node_modules/monaco-editor/esm/vs/nls.js\");\nvar _a, _b;\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nconst LANGUAGE_DEFAULT = 'en';\r\nlet _isWindows = false;\r\nlet _isMacintosh = false;\r\nlet _isLinux = false;\r\nlet _isLinuxSnap = false;\r\nlet _isNative = false;\r\nlet _isWeb = false;\r\nlet _isElectron = false;\r\nlet _isIOS = false;\r\nlet _isCI = false;\r\nlet _isMobile = false;\r\nlet _locale = undefined;\r\nlet _language = LANGUAGE_DEFAULT;\r\nlet _platformLocale = LANGUAGE_DEFAULT;\r\nlet _translationsConfigFile = undefined;\r\nlet _userAgent = undefined;\r\nconst $globalThis = globalThis;\r\nlet nodeProcess = undefined;\r\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\r\n    // Native environment (sandboxed)\r\n    nodeProcess = $globalThis.vscode.process;\r\n}\r\nelse if (typeof process !== 'undefined' && typeof ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) === 'string') {\r\n    // Native environment (non-sandboxed)\r\n    nodeProcess = process;\r\n}\r\nconst isElectronProcess = typeof ((_b = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _b === void 0 ? void 0 : _b.electron) === 'string';\r\nconst isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === 'renderer';\r\n// Native environment\r\nif (typeof nodeProcess === 'object') {\r\n    _isWindows = (nodeProcess.platform === 'win32');\r\n    _isMacintosh = (nodeProcess.platform === 'darwin');\r\n    _isLinux = (nodeProcess.platform === 'linux');\r\n    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\r\n    _isElectron = isElectronProcess;\r\n    _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];\r\n    _locale = LANGUAGE_DEFAULT;\r\n    _language = LANGUAGE_DEFAULT;\r\n    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\r\n    if (rawNlsConfig) {\r\n        try {\r\n            const nlsConfig = JSON.parse(rawNlsConfig);\r\n            const resolved = nlsConfig.availableLanguages['*'];\r\n            _locale = nlsConfig.locale;\r\n            _platformLocale = nlsConfig.osLocale;\r\n            // VSCode's default language is 'en'\r\n            _language = resolved ? resolved : LANGUAGE_DEFAULT;\r\n            _translationsConfigFile = nlsConfig._translationsConfigFile;\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    _isNative = true;\r\n}\r\n// Web environment\r\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\r\n    _userAgent = navigator.userAgent;\r\n    _isWindows = _userAgent.indexOf('Windows') >= 0;\r\n    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\r\n    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\r\n    _isLinux = _userAgent.indexOf('Linux') >= 0;\r\n    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf('Mobi')) >= 0;\r\n    _isWeb = true;\r\n    const configuredLocale = _nls_js__WEBPACK_IMPORTED_MODULE_0__.getConfiguredDefaultLocale(\r\n    // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`\r\n    // to ensure that the NLS AMD Loader plugin has been loaded and configured.\r\n    // This is because the loader plugin decides what the default locale is based on\r\n    // how it's able to resolve the strings.\r\n    _nls_js__WEBPACK_IMPORTED_MODULE_0__.localize({ key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] }, '_'));\r\n    _locale = configuredLocale || LANGUAGE_DEFAULT;\r\n    _language = _locale;\r\n    _platformLocale = navigator.language;\r\n}\r\n// Unknown environment\r\nelse {\r\n    console.error('Unable to resolve platform.');\r\n}\r\nlet _platform = 0 /* Platform.Web */;\r\nif (_isMacintosh) {\r\n    _platform = 1 /* Platform.Mac */;\r\n}\r\nelse if (_isWindows) {\r\n    _platform = 3 /* Platform.Windows */;\r\n}\r\nelse if (_isLinux) {\r\n    _platform = 2 /* Platform.Linux */;\r\n}\r\nconst isWindows = _isWindows;\r\nconst isMacintosh = _isMacintosh;\r\nconst isLinux = _isLinux;\r\nconst isNative = _isNative;\r\nconst isWeb = _isWeb;\r\nconst isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\r\nconst webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\r\nconst isIOS = _isIOS;\r\nconst isMobile = _isMobile;\r\nconst userAgent = _userAgent;\r\n/**\r\n * The language used for the user interface. The format of\r\n * the string is all lower case (e.g. zh-tw for Traditional\r\n * Chinese)\r\n */\r\nconst language = _language;\r\nconst setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\r\n/**\r\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\r\n *\r\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\r\n * that browsers set when the nesting level is > 5.\r\n */\r\nconst setTimeout0 = (() => {\r\n    if (setTimeout0IsFaster) {\r\n        const pending = [];\r\n        $globalThis.addEventListener('message', (e) => {\r\n            if (e.data && e.data.vscodeScheduleAsyncWork) {\r\n                for (let i = 0, len = pending.length; i < len; i++) {\r\n                    const candidate = pending[i];\r\n                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {\r\n                        pending.splice(i, 1);\r\n                        candidate.callback();\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        let lastId = 0;\r\n        return (callback) => {\r\n            const myId = ++lastId;\r\n            pending.push({\r\n                id: myId,\r\n                callback: callback\r\n            });\r\n            $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\r\n        };\r\n    }\r\n    return (callback) => setTimeout(callback);\r\n})();\r\nconst OS = (_isMacintosh || _isIOS ? 2 /* OperatingSystem.Macintosh */ : (_isWindows ? 1 /* OperatingSystem.Windows */ : 3 /* OperatingSystem.Linux */));\r\nlet _isLittleEndian = true;\r\nlet _isLittleEndianComputed = false;\r\nfunction isLittleEndian() {\r\n    if (!_isLittleEndianComputed) {\r\n        _isLittleEndianComputed = true;\r\n        const test = new Uint8Array(2);\r\n        test[0] = 1;\r\n        test[1] = 2;\r\n        const view = new Uint16Array(test.buffer);\r\n        _isLittleEndian = (view[0] === (2 << 8) + 1);\r\n    }\r\n    return _isLittleEndian;\r\n}\r\nconst isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\r\nconst isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\r\nconst isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\r\nconst isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\r\nconst isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcGxhdGZvcm0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQVksR0FBRywrQ0FBK0MsT0FBTyxJQUFJO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0NBQXNDLCtCQUErQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcGxhdGZvcm0uanM/MzBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2EsIF9iO1xyXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0ICogYXMgbmxzIGZyb20gJy4uLy4uL25scy5qcyc7XHJcbmV4cG9ydCBjb25zdCBMQU5HVUFHRV9ERUZBVUxUID0gJ2VuJztcclxubGV0IF9pc1dpbmRvd3MgPSBmYWxzZTtcclxubGV0IF9pc01hY2ludG9zaCA9IGZhbHNlO1xyXG5sZXQgX2lzTGludXggPSBmYWxzZTtcclxubGV0IF9pc0xpbnV4U25hcCA9IGZhbHNlO1xyXG5sZXQgX2lzTmF0aXZlID0gZmFsc2U7XHJcbmxldCBfaXNXZWIgPSBmYWxzZTtcclxubGV0IF9pc0VsZWN0cm9uID0gZmFsc2U7XHJcbmxldCBfaXNJT1MgPSBmYWxzZTtcclxubGV0IF9pc0NJID0gZmFsc2U7XHJcbmxldCBfaXNNb2JpbGUgPSBmYWxzZTtcclxubGV0IF9sb2NhbGUgPSB1bmRlZmluZWQ7XHJcbmxldCBfbGFuZ3VhZ2UgPSBMQU5HVUFHRV9ERUZBVUxUO1xyXG5sZXQgX3BsYXRmb3JtTG9jYWxlID0gTEFOR1VBR0VfREVGQVVMVDtcclxubGV0IF90cmFuc2xhdGlvbnNDb25maWdGaWxlID0gdW5kZWZpbmVkO1xyXG5sZXQgX3VzZXJBZ2VudCA9IHVuZGVmaW5lZDtcclxuY29uc3QgJGdsb2JhbFRoaXMgPSBnbG9iYWxUaGlzO1xyXG5sZXQgbm9kZVByb2Nlc3MgPSB1bmRlZmluZWQ7XHJcbmlmICh0eXBlb2YgJGdsb2JhbFRoaXMudnNjb2RlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgJGdsb2JhbFRoaXMudnNjb2RlLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBOYXRpdmUgZW52aXJvbm1lbnQgKHNhbmRib3hlZClcclxuICAgIG5vZGVQcm9jZXNzID0gJGdsb2JhbFRoaXMudnNjb2RlLnByb2Nlc3M7XHJcbn1cclxuZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiAoKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLnZlcnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAvLyBOYXRpdmUgZW52aXJvbm1lbnQgKG5vbi1zYW5kYm94ZWQpXHJcbiAgICBub2RlUHJvY2VzcyA9IHByb2Nlc3M7XHJcbn1cclxuY29uc3QgaXNFbGVjdHJvblByb2Nlc3MgPSB0eXBlb2YgKChfYiA9IG5vZGVQcm9jZXNzID09PSBudWxsIHx8IG5vZGVQcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVsZWN0cm9uKSA9PT0gJ3N0cmluZyc7XHJcbmNvbnN0IGlzRWxlY3Ryb25SZW5kZXJlciA9IGlzRWxlY3Ryb25Qcm9jZXNzICYmIChub2RlUHJvY2VzcyA9PT0gbnVsbCB8fCBub2RlUHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2Nlc3MudHlwZSkgPT09ICdyZW5kZXJlcic7XHJcbi8vIE5hdGl2ZSBlbnZpcm9ubWVudFxyXG5pZiAodHlwZW9mIG5vZGVQcm9jZXNzID09PSAnb2JqZWN0Jykge1xyXG4gICAgX2lzV2luZG93cyA9IChub2RlUHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XHJcbiAgICBfaXNNYWNpbnRvc2ggPSAobm9kZVByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcclxuICAgIF9pc0xpbnV4ID0gKG5vZGVQcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKTtcclxuICAgIF9pc0xpbnV4U25hcCA9IF9pc0xpbnV4ICYmICEhbm9kZVByb2Nlc3MuZW52WydTTkFQJ10gJiYgISFub2RlUHJvY2Vzcy5lbnZbJ1NOQVBfUkVWSVNJT04nXTtcclxuICAgIF9pc0VsZWN0cm9uID0gaXNFbGVjdHJvblByb2Nlc3M7XHJcbiAgICBfaXNDSSA9ICEhbm9kZVByb2Nlc3MuZW52WydDSSddIHx8ICEhbm9kZVByb2Nlc3MuZW52WydCVUlMRF9BUlRJRkFDVFNUQUdJTkdESVJFQ1RPUlknXTtcclxuICAgIF9sb2NhbGUgPSBMQU5HVUFHRV9ERUZBVUxUO1xyXG4gICAgX2xhbmd1YWdlID0gTEFOR1VBR0VfREVGQVVMVDtcclxuICAgIGNvbnN0IHJhd05sc0NvbmZpZyA9IG5vZGVQcm9jZXNzLmVudlsnVlNDT0RFX05MU19DT05GSUcnXTtcclxuICAgIGlmIChyYXdObHNDb25maWcpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBubHNDb25maWcgPSBKU09OLnBhcnNlKHJhd05sc0NvbmZpZyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gbmxzQ29uZmlnLmF2YWlsYWJsZUxhbmd1YWdlc1snKiddO1xyXG4gICAgICAgICAgICBfbG9jYWxlID0gbmxzQ29uZmlnLmxvY2FsZTtcclxuICAgICAgICAgICAgX3BsYXRmb3JtTG9jYWxlID0gbmxzQ29uZmlnLm9zTG9jYWxlO1xyXG4gICAgICAgICAgICAvLyBWU0NvZGUncyBkZWZhdWx0IGxhbmd1YWdlIGlzICdlbidcclxuICAgICAgICAgICAgX2xhbmd1YWdlID0gcmVzb2x2ZWQgPyByZXNvbHZlZCA6IExBTkdVQUdFX0RFRkFVTFQ7XHJcbiAgICAgICAgICAgIF90cmFuc2xhdGlvbnNDb25maWdGaWxlID0gbmxzQ29uZmlnLl90cmFuc2xhdGlvbnNDb25maWdGaWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pc05hdGl2ZSA9IHRydWU7XHJcbn1cclxuLy8gV2ViIGVudmlyb25tZW50XHJcbmVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmICFpc0VsZWN0cm9uUmVuZGVyZXIpIHtcclxuICAgIF91c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgX2lzV2luZG93cyA9IF91c2VyQWdlbnQuaW5kZXhPZignV2luZG93cycpID49IDA7XHJcbiAgICBfaXNNYWNpbnRvc2ggPSBfdXNlckFnZW50LmluZGV4T2YoJ01hY2ludG9zaCcpID49IDA7XHJcbiAgICBfaXNJT1MgPSAoX3VzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwIHx8IF91c2VyQWdlbnQuaW5kZXhPZignaVBhZCcpID49IDAgfHwgX3VzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSA+PSAwKSAmJiAhIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xyXG4gICAgX2lzTGludXggPSBfdXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgPj0gMDtcclxuICAgIF9pc01vYmlsZSA9IChfdXNlckFnZW50ID09PSBudWxsIHx8IF91c2VyQWdlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF91c2VyQWdlbnQuaW5kZXhPZignTW9iaScpKSA+PSAwO1xyXG4gICAgX2lzV2ViID0gdHJ1ZTtcclxuICAgIGNvbnN0IGNvbmZpZ3VyZWRMb2NhbGUgPSBubHMuZ2V0Q29uZmlndXJlZERlZmF1bHRMb2NhbGUoXHJcbiAgICAvLyBUaGlzIGNhbGwgX211c3RfIGJlIGRvbmUgaW4gdGhlIGZpbGUgdGhhdCBjYWxscyBgbmxzLmdldENvbmZpZ3VyZWREZWZhdWx0TG9jYWxlYFxyXG4gICAgLy8gdG8gZW5zdXJlIHRoYXQgdGhlIE5MUyBBTUQgTG9hZGVyIHBsdWdpbiBoYXMgYmVlbiBsb2FkZWQgYW5kIGNvbmZpZ3VyZWQuXHJcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlIGxvYWRlciBwbHVnaW4gZGVjaWRlcyB3aGF0IHRoZSBkZWZhdWx0IGxvY2FsZSBpcyBiYXNlZCBvblxyXG4gICAgLy8gaG93IGl0J3MgYWJsZSB0byByZXNvbHZlIHRoZSBzdHJpbmdzLlxyXG4gICAgbmxzLmxvY2FsaXplKHsga2V5OiAnZW5zdXJlTG9hZGVyUGx1Z2luSXNMb2FkZWQnLCBjb21tZW50OiBbJ3tMb2NrZWR9J10gfSwgJ18nKSk7XHJcbiAgICBfbG9jYWxlID0gY29uZmlndXJlZExvY2FsZSB8fCBMQU5HVUFHRV9ERUZBVUxUO1xyXG4gICAgX2xhbmd1YWdlID0gX2xvY2FsZTtcclxuICAgIF9wbGF0Zm9ybUxvY2FsZSA9IG5hdmlnYXRvci5sYW5ndWFnZTtcclxufVxyXG4vLyBVbmtub3duIGVudmlyb25tZW50XHJcbmVsc2Uge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJlc29sdmUgcGxhdGZvcm0uJyk7XHJcbn1cclxubGV0IF9wbGF0Zm9ybSA9IDAgLyogUGxhdGZvcm0uV2ViICovO1xyXG5pZiAoX2lzTWFjaW50b3NoKSB7XHJcbiAgICBfcGxhdGZvcm0gPSAxIC8qIFBsYXRmb3JtLk1hYyAqLztcclxufVxyXG5lbHNlIGlmIChfaXNXaW5kb3dzKSB7XHJcbiAgICBfcGxhdGZvcm0gPSAzIC8qIFBsYXRmb3JtLldpbmRvd3MgKi87XHJcbn1cclxuZWxzZSBpZiAoX2lzTGludXgpIHtcclxuICAgIF9wbGF0Zm9ybSA9IDIgLyogUGxhdGZvcm0uTGludXggKi87XHJcbn1cclxuZXhwb3J0IGNvbnN0IGlzV2luZG93cyA9IF9pc1dpbmRvd3M7XHJcbmV4cG9ydCBjb25zdCBpc01hY2ludG9zaCA9IF9pc01hY2ludG9zaDtcclxuZXhwb3J0IGNvbnN0IGlzTGludXggPSBfaXNMaW51eDtcclxuZXhwb3J0IGNvbnN0IGlzTmF0aXZlID0gX2lzTmF0aXZlO1xyXG5leHBvcnQgY29uc3QgaXNXZWIgPSBfaXNXZWI7XHJcbmV4cG9ydCBjb25zdCBpc1dlYldvcmtlciA9IChfaXNXZWIgJiYgdHlwZW9mICRnbG9iYWxUaGlzLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicpO1xyXG5leHBvcnQgY29uc3Qgd2ViV29ya2VyT3JpZ2luID0gaXNXZWJXb3JrZXIgPyAkZ2xvYmFsVGhpcy5vcmlnaW4gOiB1bmRlZmluZWQ7XHJcbmV4cG9ydCBjb25zdCBpc0lPUyA9IF9pc0lPUztcclxuZXhwb3J0IGNvbnN0IGlzTW9iaWxlID0gX2lzTW9iaWxlO1xyXG5leHBvcnQgY29uc3QgdXNlckFnZW50ID0gX3VzZXJBZ2VudDtcclxuLyoqXHJcbiAqIFRoZSBsYW5ndWFnZSB1c2VkIGZvciB0aGUgdXNlciBpbnRlcmZhY2UuIFRoZSBmb3JtYXQgb2ZcclxuICogdGhlIHN0cmluZyBpcyBhbGwgbG93ZXIgY2FzZSAoZS5nLiB6aC10dyBmb3IgVHJhZGl0aW9uYWxcclxuICogQ2hpbmVzZSlcclxuICovXHJcbmV4cG9ydCBjb25zdCBsYW5ndWFnZSA9IF9sYW5ndWFnZTtcclxuZXhwb3J0IGNvbnN0IHNldFRpbWVvdXQwSXNGYXN0ZXIgPSAodHlwZW9mICRnbG9iYWxUaGlzLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nICYmICEkZ2xvYmFsVGhpcy5pbXBvcnRTY3JpcHRzKTtcclxuLyoqXHJcbiAqIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sIzp+OnRleHQ9dGhhbiUyMDQlMkMlMjB0aGVuLSxzZXQlMjB0aW1lb3V0JTIwdG8lMjA0LC0uXHJcbiAqXHJcbiAqIFdvcmtzIHNpbWlsYXJseSB0byBgc2V0VGltZW91dCgwKWAgYnV0IGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhlIDRtcyBhcnRpZmljaWFsIGRlbGF5XHJcbiAqIHRoYXQgYnJvd3NlcnMgc2V0IHdoZW4gdGhlIG5lc3RpbmcgbGV2ZWwgaXMgPiA1LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldFRpbWVvdXQwID0gKCgpID0+IHtcclxuICAgIGlmIChzZXRUaW1lb3V0MElzRmFzdGVyKSB7XHJcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IFtdO1xyXG4gICAgICAgICRnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS52c2NvZGVTY2hlZHVsZUFzeW5jV29yaykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBlbmRpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBwZW5kaW5nW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuaWQgPT09IGUuZGF0YS52c2NvZGVTY2hlZHVsZUFzeW5jV29yaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgbGFzdElkID0gMDtcclxuICAgICAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG15SWQgPSArK2xhc3RJZDtcclxuICAgICAgICAgICAgcGVuZGluZy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGlkOiBteUlkLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh7IHZzY29kZVNjaGVkdWxlQXN5bmNXb3JrOiBteUlkIH0sICcqJyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHNldFRpbWVvdXQoY2FsbGJhY2spO1xyXG59KSgpO1xyXG5leHBvcnQgY29uc3QgT1MgPSAoX2lzTWFjaW50b3NoIHx8IF9pc0lPUyA/IDIgLyogT3BlcmF0aW5nU3lzdGVtLk1hY2ludG9zaCAqLyA6IChfaXNXaW5kb3dzID8gMSAvKiBPcGVyYXRpbmdTeXN0ZW0uV2luZG93cyAqLyA6IDMgLyogT3BlcmF0aW5nU3lzdGVtLkxpbnV4ICovKSk7XHJcbmxldCBfaXNMaXR0bGVFbmRpYW4gPSB0cnVlO1xyXG5sZXQgX2lzTGl0dGxlRW5kaWFuQ29tcHV0ZWQgPSBmYWxzZTtcclxuZXhwb3J0IGZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xyXG4gICAgaWYgKCFfaXNMaXR0bGVFbmRpYW5Db21wdXRlZCkge1xyXG4gICAgICAgIF9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB0ZXN0ID0gbmV3IFVpbnQ4QXJyYXkoMik7XHJcbiAgICAgICAgdGVzdFswXSA9IDE7XHJcbiAgICAgICAgdGVzdFsxXSA9IDI7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0ZXN0LmJ1ZmZlcik7XHJcbiAgICAgICAgX2lzTGl0dGxlRW5kaWFuID0gKHZpZXdbMF0gPT09ICgyIDw8IDgpICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2lzTGl0dGxlRW5kaWFuO1xyXG59XHJcbmV4cG9ydCBjb25zdCBpc0Nocm9tZSA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPj0gMCk7XHJcbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSAhISh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+PSAwKTtcclxuZXhwb3J0IGNvbnN0IGlzU2FmYXJpID0gISEoIWlzQ2hyb21lICYmICh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpID49IDApKTtcclxuZXhwb3J0IGNvbnN0IGlzRWRnZSA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignRWRnLycpID49IDApO1xyXG5leHBvcnQgY29uc3QgaXNBbmRyb2lkID0gISEodXNlckFnZW50ICYmIHVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPj0gMCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/platform.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/process.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/process.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cwd: () => (/* binding */ cwd),\n/* harmony export */   env: () => (/* binding */ env),\n/* harmony export */   platform: () => (/* binding */ platform)\n/* harmony export */ });\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ \"./node_modules/monaco-editor/esm/vs/base/common/platform.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nlet safeProcess;\r\n// Native sandbox environment\r\nconst vscodeGlobal = globalThis.vscode;\r\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {\r\n    const sandboxProcess = vscodeGlobal.process;\r\n    safeProcess = {\r\n        get platform() { return sandboxProcess.platform; },\r\n        get arch() { return sandboxProcess.arch; },\r\n        get env() { return sandboxProcess.env; },\r\n        cwd() { return sandboxProcess.cwd(); }\r\n    };\r\n}\r\n// Native node.js environment\r\nelse if (typeof process !== 'undefined') {\r\n    safeProcess = {\r\n        get platform() { return process.platform; },\r\n        get arch() { return process.arch; },\r\n        get env() { return process.env; },\r\n        cwd() { return process.env['VSCODE_CWD'] || process.cwd(); }\r\n    };\r\n}\r\n// Web environment\r\nelse {\r\n    safeProcess = {\r\n        // Supported\r\n        get platform() { return _platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows ? 'win32' : _platform_js__WEBPACK_IMPORTED_MODULE_0__.isMacintosh ? 'darwin' : 'linux'; },\r\n        get arch() { return undefined; /* arch is undefined in web */ },\r\n        // Unsupported\r\n        get env() { return {}; },\r\n        cwd() { return '/'; }\r\n    };\r\n}\r\n/**\r\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\r\n * environments.\r\n *\r\n * Note: in web, this property is hardcoded to be `/`.\r\n *\r\n * @skipMangle\r\n */\r\nconst cwd = safeProcess.cwd;\r\n/**\r\n * Provides safe access to the `env` property in node.js, sandboxed or web\r\n * environments.\r\n *\r\n * Note: in web, this property is hardcoded to be `{}`.\r\n */\r\nconst env = safeProcess.env;\r\n/**\r\n * Provides safe access to the `platform` property in node.js, sandboxed or web\r\n * environments.\r\n */\r\nconst platform = safeProcess.platform;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcHJvY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRCxxQkFBcUIsNkJBQTZCO0FBQ2xELG9CQUFvQiw0QkFBNEI7QUFDaEQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25ELHFCQUFxQixzQkFBc0I7QUFDM0Msb0JBQW9CLHFCQUFxQjtBQUN6QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sbURBQVMsYUFBYSxxREFBVyx3QkFBd0I7QUFDekYscUJBQXFCLGtCQUFrQixnQ0FBZ0M7QUFDdkU7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3Byb2Nlc3MuanM/YzMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgaXNNYWNpbnRvc2gsIGlzV2luZG93cyB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xyXG5sZXQgc2FmZVByb2Nlc3M7XHJcbi8vIE5hdGl2ZSBzYW5kYm94IGVudmlyb25tZW50XHJcbmNvbnN0IHZzY29kZUdsb2JhbCA9IGdsb2JhbFRoaXMudnNjb2RlO1xyXG5pZiAodHlwZW9mIHZzY29kZUdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZzY29kZUdsb2JhbC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgY29uc3Qgc2FuZGJveFByb2Nlc3MgPSB2c2NvZGVHbG9iYWwucHJvY2VzcztcclxuICAgIHNhZmVQcm9jZXNzID0ge1xyXG4gICAgICAgIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLnBsYXRmb3JtOyB9LFxyXG4gICAgICAgIGdldCBhcmNoKCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MuYXJjaDsgfSxcclxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MuZW52OyB9LFxyXG4gICAgICAgIGN3ZCgpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLmN3ZCgpOyB9XHJcbiAgICB9O1xyXG59XHJcbi8vIE5hdGl2ZSBub2RlLmpzIGVudmlyb25tZW50XHJcbmVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgc2FmZVByb2Nlc3MgPSB7XHJcbiAgICAgICAgZ2V0IHBsYXRmb3JtKCkgeyByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybTsgfSxcclxuICAgICAgICBnZXQgYXJjaCgpIHsgcmV0dXJuIHByb2Nlc3MuYXJjaDsgfSxcclxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4gcHJvY2Vzcy5lbnY7IH0sXHJcbiAgICAgICAgY3dkKCkgeyByZXR1cm4gcHJvY2Vzcy5lbnZbJ1ZTQ09ERV9DV0QnXSB8fCBwcm9jZXNzLmN3ZCgpOyB9XHJcbiAgICB9O1xyXG59XHJcbi8vIFdlYiBlbnZpcm9ubWVudFxyXG5lbHNlIHtcclxuICAgIHNhZmVQcm9jZXNzID0ge1xyXG4gICAgICAgIC8vIFN1cHBvcnRlZFxyXG4gICAgICAgIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIGlzV2luZG93cyA/ICd3aW4zMicgOiBpc01hY2ludG9zaCA/ICdkYXJ3aW4nIDogJ2xpbnV4JzsgfSxcclxuICAgICAgICBnZXQgYXJjaCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgLyogYXJjaCBpcyB1bmRlZmluZWQgaW4gd2ViICovIH0sXHJcbiAgICAgICAgLy8gVW5zdXBwb3J0ZWRcclxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4ge307IH0sXHJcbiAgICAgICAgY3dkKCkgeyByZXR1cm4gJy8nOyB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzYWZlIGFjY2VzcyB0byB0aGUgYGN3ZGAgcHJvcGVydHkgaW4gbm9kZS5qcywgc2FuZGJveGVkIG9yIHdlYlxyXG4gKiBlbnZpcm9ubWVudHMuXHJcbiAqXHJcbiAqIE5vdGU6IGluIHdlYiwgdGhpcyBwcm9wZXJ0eSBpcyBoYXJkY29kZWQgdG8gYmUgYC9gLlxyXG4gKlxyXG4gKiBAc2tpcE1hbmdsZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGN3ZCA9IHNhZmVQcm9jZXNzLmN3ZDtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgZW52YCBwcm9wZXJ0eSBpbiBub2RlLmpzLCBzYW5kYm94ZWQgb3Igd2ViXHJcbiAqIGVudmlyb25tZW50cy5cclxuICpcclxuICogTm90ZTogaW4gd2ViLCB0aGlzIHByb3BlcnR5IGlzIGhhcmRjb2RlZCB0byBiZSBge31gLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudiA9IHNhZmVQcm9jZXNzLmVudjtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgcGxhdGZvcm1gIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcclxuICogZW52aXJvbm1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBsYXRmb3JtID0gc2FmZVByb2Nlc3MucGxhdGZvcm07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/process.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StopWatch: () => (/* binding */ StopWatch)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst hasPerformanceNow = (globalThis.performance && typeof globalThis.performance.now === 'function');\r\nclass StopWatch {\r\n    static create(highResolution) {\r\n        return new StopWatch(highResolution);\r\n    }\r\n    constructor(highResolution) {\r\n        this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);\r\n        this._startTime = this._now();\r\n        this._stopTime = -1;\r\n    }\r\n    stop() {\r\n        this._stopTime = this._now();\r\n    }\r\n    reset() {\r\n        this._startTime = this._now();\r\n        this._stopTime = -1;\r\n    }\r\n    elapsed() {\r\n        if (this._stopTime !== -1) {\r\n            return this._stopTime - this._startTime;\r\n        }\r\n        return this._now() - this._startTime;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9zdG9wd2F0Y2guanM/ZTU4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuY29uc3QgaGFzUGVyZm9ybWFuY2VOb3cgPSAoZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpO1xyXG5leHBvcnQgY2xhc3MgU3RvcFdhdGNoIHtcclxuICAgIHN0YXRpYyBjcmVhdGUoaGlnaFJlc29sdXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFN0b3BXYXRjaChoaWdoUmVzb2x1dGlvbik7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihoaWdoUmVzb2x1dGlvbikge1xyXG4gICAgICAgIHRoaXMuX25vdyA9IGhhc1BlcmZvcm1hbmNlTm93ICYmIGhpZ2hSZXNvbHV0aW9uID09PSBmYWxzZSA/IERhdGUubm93IDogZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZS5ub3cuYmluZChnbG9iYWxUaGlzLnBlcmZvcm1hbmNlKTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLl9ub3coKTtcclxuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IC0xO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRoaXMuX25vdygpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5fbm93KCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcFRpbWUgPSAtMTtcclxuICAgIH1cclxuICAgIGVsYXBzZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BUaW1lICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWUgLSB0aGlzLl9zdGFydFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub3coKSAtIHRoaXMuX3N0YXJ0VGltZTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/strings.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/strings.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguousCharacters: () => (/* binding */ AmbiguousCharacters),\n/* harmony export */   CodePointIterator: () => (/* binding */ CodePointIterator),\n/* harmony export */   GraphemeIterator: () => (/* binding */ GraphemeIterator),\n/* harmony export */   InvisibleCharacters: () => (/* binding */ InvisibleCharacters),\n/* harmony export */   UNUSUAL_LINE_TERMINATORS: () => (/* binding */ UNUSUAL_LINE_TERMINATORS),\n/* harmony export */   UTF8_BOM_CHARACTER: () => (/* binding */ UTF8_BOM_CHARACTER),\n/* harmony export */   commonPrefixLength: () => (/* binding */ commonPrefixLength),\n/* harmony export */   commonSuffixLength: () => (/* binding */ commonSuffixLength),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   compareIgnoreCase: () => (/* binding */ compareIgnoreCase),\n/* harmony export */   compareSubstring: () => (/* binding */ compareSubstring),\n/* harmony export */   compareSubstringIgnoreCase: () => (/* binding */ compareSubstringIgnoreCase),\n/* harmony export */   computeCodePoint: () => (/* binding */ computeCodePoint),\n/* harmony export */   containsRTL: () => (/* binding */ containsRTL),\n/* harmony export */   containsUnusualLineTerminators: () => (/* binding */ containsUnusualLineTerminators),\n/* harmony export */   containsUppercaseCharacter: () => (/* binding */ containsUppercaseCharacter),\n/* harmony export */   convertSimple2RegExpPattern: () => (/* binding */ convertSimple2RegExpPattern),\n/* harmony export */   createRegExp: () => (/* binding */ createRegExp),\n/* harmony export */   equalsIgnoreCase: () => (/* binding */ equalsIgnoreCase),\n/* harmony export */   escape: () => (/* binding */ escape),\n/* harmony export */   escapeRegExpCharacters: () => (/* binding */ escapeRegExpCharacters),\n/* harmony export */   firstNonWhitespaceIndex: () => (/* binding */ firstNonWhitespaceIndex),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   getCharContainingOffset: () => (/* binding */ getCharContainingOffset),\n/* harmony export */   getLeadingWhitespace: () => (/* binding */ getLeadingWhitespace),\n/* harmony export */   getLeftDeleteOffset: () => (/* binding */ getLeftDeleteOffset),\n/* harmony export */   getNextCodePoint: () => (/* binding */ getNextCodePoint),\n/* harmony export */   htmlAttributeEncodeValue: () => (/* binding */ htmlAttributeEncodeValue),\n/* harmony export */   isAsciiDigit: () => (/* binding */ isAsciiDigit),\n/* harmony export */   isBasicASCII: () => (/* binding */ isBasicASCII),\n/* harmony export */   isEmojiImprecise: () => (/* binding */ isEmojiImprecise),\n/* harmony export */   isFalsyOrWhitespace: () => (/* binding */ isFalsyOrWhitespace),\n/* harmony export */   isFullWidthCharacter: () => (/* binding */ isFullWidthCharacter),\n/* harmony export */   isHighSurrogate: () => (/* binding */ isHighSurrogate),\n/* harmony export */   isLowSurrogate: () => (/* binding */ isLowSurrogate),\n/* harmony export */   isLowerAsciiLetter: () => (/* binding */ isLowerAsciiLetter),\n/* harmony export */   isUpperAsciiLetter: () => (/* binding */ isUpperAsciiLetter),\n/* harmony export */   lastNonWhitespaceIndex: () => (/* binding */ lastNonWhitespaceIndex),\n/* harmony export */   ltrim: () => (/* binding */ ltrim),\n/* harmony export */   nextCharLength: () => (/* binding */ nextCharLength),\n/* harmony export */   noBreakWhitespace: () => (/* binding */ noBreakWhitespace),\n/* harmony export */   prevCharLength: () => (/* binding */ prevCharLength),\n/* harmony export */   regExpLeadsToEndlessLoop: () => (/* binding */ regExpLeadsToEndlessLoop),\n/* harmony export */   rtrim: () => (/* binding */ rtrim),\n/* harmony export */   singleLetterHash: () => (/* binding */ singleLetterHash),\n/* harmony export */   splitLines: () => (/* binding */ splitLines),\n/* harmony export */   splitLinesIncludeSeparators: () => (/* binding */ splitLinesIncludeSeparators),\n/* harmony export */   startsWithIgnoreCase: () => (/* binding */ startsWithIgnoreCase),\n/* harmony export */   startsWithUTF8BOM: () => (/* binding */ startsWithUTF8BOM),\n/* harmony export */   stripWildcards: () => (/* binding */ stripWildcards),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache.js */ \"./node_modules/monaco-editor/esm/vs/base/common/cache.js\");\n/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lazy.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar _a;\r\n\r\n\r\nfunction isFalsyOrWhitespace(str) {\r\n    if (!str || typeof str !== 'string') {\r\n        return true;\r\n    }\r\n    return str.trim().length === 0;\r\n}\r\nconst _formatRegexp = /{(\\d+)}/g;\r\n/**\r\n * Helper to produce a string with a variable number of arguments. Insert variable segments\r\n * into the string using the {n} notation where N is the index of the argument following the string.\r\n * @param value string to which formatting is applied\r\n * @param args replacements for {n}-entries\r\n */\r\nfunction format(value, ...args) {\r\n    if (args.length === 0) {\r\n        return value;\r\n    }\r\n    return value.replace(_formatRegexp, function (match, group) {\r\n        const idx = parseInt(group, 10);\r\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\r\n            match :\r\n            args[idx];\r\n    });\r\n}\r\n/**\r\n * Encodes the given value so that it can be used as literal value in html attributes.\r\n *\r\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\r\n * This prevents XSS injection.\r\n */\r\nfunction htmlAttributeEncodeValue(value) {\r\n    return value.replace(/[<>\"'&]/g, ch => {\r\n        switch (ch) {\r\n            case '<': return '&lt;';\r\n            case '>': return '&gt;';\r\n            case '\"': return '&quot;';\r\n            case '\\'': return '&apos;';\r\n            case '&': return '&amp;';\r\n        }\r\n        return ch;\r\n    });\r\n}\r\n/**\r\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\r\n * being used e.g. in HTMLElement.innerHTML.\r\n */\r\nfunction escape(html) {\r\n    return html.replace(/[<>&]/g, function (match) {\r\n        switch (match) {\r\n            case '<': return '&lt;';\r\n            case '>': return '&gt;';\r\n            case '&': return '&amp;';\r\n            default: return match;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Escapes regular expression characters in a given string\r\n */\r\nfunction escapeRegExpCharacters(value) {\r\n    return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\r\n}\r\n/**\r\n * Removes all occurrences of needle from the beginning and end of haystack.\r\n * @param haystack string to trim\r\n * @param needle the thing to trim (default is a blank)\r\n */\r\nfunction trim(haystack, needle = ' ') {\r\n    const trimmed = ltrim(haystack, needle);\r\n    return rtrim(trimmed, needle);\r\n}\r\n/**\r\n * Removes all occurrences of needle from the beginning of haystack.\r\n * @param haystack string to trim\r\n * @param needle the thing to trim\r\n */\r\nfunction ltrim(haystack, needle) {\r\n    if (!haystack || !needle) {\r\n        return haystack;\r\n    }\r\n    const needleLen = needle.length;\r\n    if (needleLen === 0 || haystack.length === 0) {\r\n        return haystack;\r\n    }\r\n    let offset = 0;\r\n    while (haystack.indexOf(needle, offset) === offset) {\r\n        offset = offset + needleLen;\r\n    }\r\n    return haystack.substring(offset);\r\n}\r\n/**\r\n * Removes all occurrences of needle from the end of haystack.\r\n * @param haystack string to trim\r\n * @param needle the thing to trim\r\n */\r\nfunction rtrim(haystack, needle) {\r\n    if (!haystack || !needle) {\r\n        return haystack;\r\n    }\r\n    const needleLen = needle.length, haystackLen = haystack.length;\r\n    if (needleLen === 0 || haystackLen === 0) {\r\n        return haystack;\r\n    }\r\n    let offset = haystackLen, idx = -1;\r\n    while (true) {\r\n        idx = haystack.lastIndexOf(needle, offset - 1);\r\n        if (idx === -1 || idx + needleLen !== offset) {\r\n            break;\r\n        }\r\n        if (idx === 0) {\r\n            return '';\r\n        }\r\n        offset = idx;\r\n    }\r\n    return haystack.substring(0, offset);\r\n}\r\nfunction convertSimple2RegExpPattern(pattern) {\r\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\r\n}\r\nfunction stripWildcards(pattern) {\r\n    return pattern.replace(/\\*/g, '');\r\n}\r\nfunction createRegExp(searchString, isRegex, options = {}) {\r\n    if (!searchString) {\r\n        throw new Error('Cannot create regex from empty string');\r\n    }\r\n    if (!isRegex) {\r\n        searchString = escapeRegExpCharacters(searchString);\r\n    }\r\n    if (options.wholeWord) {\r\n        if (!/\\B/.test(searchString.charAt(0))) {\r\n            searchString = '\\\\b' + searchString;\r\n        }\r\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\r\n            searchString = searchString + '\\\\b';\r\n        }\r\n    }\r\n    let modifiers = '';\r\n    if (options.global) {\r\n        modifiers += 'g';\r\n    }\r\n    if (!options.matchCase) {\r\n        modifiers += 'i';\r\n    }\r\n    if (options.multiline) {\r\n        modifiers += 'm';\r\n    }\r\n    if (options.unicode) {\r\n        modifiers += 'u';\r\n    }\r\n    return new RegExp(searchString, modifiers);\r\n}\r\nfunction regExpLeadsToEndlessLoop(regexp) {\r\n    // Exit early if it's one of these special cases which are meant to match\r\n    // against an empty string\r\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\r\n        return false;\r\n    }\r\n    // We check against an empty string. If the regular expression doesn't advance\r\n    // (e.g. ends in an endless loop) it will match an empty string.\r\n    const match = regexp.exec('');\r\n    return !!(match && regexp.lastIndex === 0);\r\n}\r\nfunction splitLines(str) {\r\n    return str.split(/\\r\\n|\\r|\\n/);\r\n}\r\nfunction splitLinesIncludeSeparators(str) {\r\n    var _b;\r\n    const linesWithSeparators = [];\r\n    const splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\r\n    for (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\r\n        linesWithSeparators.push(splitLinesAndSeparators[2 * i] + ((_b = splitLinesAndSeparators[2 * i + 1]) !== null && _b !== void 0 ? _b : ''));\r\n    }\r\n    return linesWithSeparators;\r\n}\r\n/**\r\n * Returns first index of the string that is not whitespace.\r\n * If string is empty or contains only whitespaces, returns -1\r\n */\r\nfunction firstNonWhitespaceIndex(str) {\r\n    for (let i = 0, len = str.length; i < len; i++) {\r\n        const chCode = str.charCodeAt(i);\r\n        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Returns the leading whitespace of the string.\r\n * If the string contains only whitespaces, returns entire string\r\n */\r\nfunction getLeadingWhitespace(str, start = 0, end = str.length) {\r\n    for (let i = start; i < end; i++) {\r\n        const chCode = str.charCodeAt(i);\r\n        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {\r\n            return str.substring(start, i);\r\n        }\r\n    }\r\n    return str.substring(start, end);\r\n}\r\n/**\r\n * Returns last index of the string that is not whitespace.\r\n * If string is empty or contains only whitespaces, returns -1\r\n */\r\nfunction lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\r\n    for (let i = startIndex; i >= 0; i--) {\r\n        const chCode = str.charCodeAt(i);\r\n        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction compare(a, b) {\r\n    if (a < b) {\r\n        return -1;\r\n    }\r\n    else if (a > b) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nfunction compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\r\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\r\n        const codeA = a.charCodeAt(aStart);\r\n        const codeB = b.charCodeAt(bStart);\r\n        if (codeA < codeB) {\r\n            return -1;\r\n        }\r\n        else if (codeA > codeB) {\r\n            return 1;\r\n        }\r\n    }\r\n    const aLen = aEnd - aStart;\r\n    const bLen = bEnd - bStart;\r\n    if (aLen < bLen) {\r\n        return -1;\r\n    }\r\n    else if (aLen > bLen) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction compareIgnoreCase(a, b) {\r\n    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\r\n}\r\nfunction compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\r\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\r\n        let codeA = a.charCodeAt(aStart);\r\n        let codeB = b.charCodeAt(bStart);\r\n        if (codeA === codeB) {\r\n            // equal\r\n            continue;\r\n        }\r\n        if (codeA >= 128 || codeB >= 128) {\r\n            // not ASCII letters -> fallback to lower-casing strings\r\n            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\r\n        }\r\n        // mapper lower-case ascii letter onto upper-case varinats\r\n        // [97-122] (lower ascii) --> [65-90] (upper ascii)\r\n        if (isLowerAsciiLetter(codeA)) {\r\n            codeA -= 32;\r\n        }\r\n        if (isLowerAsciiLetter(codeB)) {\r\n            codeB -= 32;\r\n        }\r\n        // compare both code points\r\n        const diff = codeA - codeB;\r\n        if (diff === 0) {\r\n            continue;\r\n        }\r\n        return diff;\r\n    }\r\n    const aLen = aEnd - aStart;\r\n    const bLen = bEnd - bStart;\r\n    if (aLen < bLen) {\r\n        return -1;\r\n    }\r\n    else if (aLen > bLen) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction isAsciiDigit(code) {\r\n    return code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */;\r\n}\r\nfunction isLowerAsciiLetter(code) {\r\n    return code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */;\r\n}\r\nfunction isUpperAsciiLetter(code) {\r\n    return code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */;\r\n}\r\nfunction equalsIgnoreCase(a, b) {\r\n    return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\r\n}\r\nfunction startsWithIgnoreCase(str, candidate) {\r\n    const candidateLength = candidate.length;\r\n    if (candidate.length > str.length) {\r\n        return false;\r\n    }\r\n    return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\r\n}\r\n/**\r\n * @returns the length of the common prefix of the two strings.\r\n */\r\nfunction commonPrefixLength(a, b) {\r\n    const len = Math.min(a.length, b.length);\r\n    let i;\r\n    for (i = 0; i < len; i++) {\r\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return len;\r\n}\r\n/**\r\n * @returns the length of the common suffix of the two strings.\r\n */\r\nfunction commonSuffixLength(a, b) {\r\n    const len = Math.min(a.length, b.length);\r\n    let i;\r\n    const aLastIndex = a.length - 1;\r\n    const bLastIndex = b.length - 1;\r\n    for (i = 0; i < len; i++) {\r\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return len;\r\n}\r\n/**\r\n * See http://en.wikipedia.org/wiki/Surrogate_pair\r\n */\r\nfunction isHighSurrogate(charCode) {\r\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\r\n}\r\n/**\r\n * See http://en.wikipedia.org/wiki/Surrogate_pair\r\n */\r\nfunction isLowSurrogate(charCode) {\r\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\r\n}\r\n/**\r\n * See http://en.wikipedia.org/wiki/Surrogate_pair\r\n */\r\nfunction computeCodePoint(highSurrogate, lowSurrogate) {\r\n    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\r\n}\r\n/**\r\n * get the code point that begins at offset `offset`\r\n */\r\nfunction getNextCodePoint(str, len, offset) {\r\n    const charCode = str.charCodeAt(offset);\r\n    if (isHighSurrogate(charCode) && offset + 1 < len) {\r\n        const nextCharCode = str.charCodeAt(offset + 1);\r\n        if (isLowSurrogate(nextCharCode)) {\r\n            return computeCodePoint(charCode, nextCharCode);\r\n        }\r\n    }\r\n    return charCode;\r\n}\r\n/**\r\n * get the code point that ends right before offset `offset`\r\n */\r\nfunction getPrevCodePoint(str, offset) {\r\n    const charCode = str.charCodeAt(offset - 1);\r\n    if (isLowSurrogate(charCode) && offset > 1) {\r\n        const prevCharCode = str.charCodeAt(offset - 2);\r\n        if (isHighSurrogate(prevCharCode)) {\r\n            return computeCodePoint(prevCharCode, charCode);\r\n        }\r\n    }\r\n    return charCode;\r\n}\r\nclass CodePointIterator {\r\n    get offset() {\r\n        return this._offset;\r\n    }\r\n    constructor(str, offset = 0) {\r\n        this._str = str;\r\n        this._len = str.length;\r\n        this._offset = offset;\r\n    }\r\n    setOffset(offset) {\r\n        this._offset = offset;\r\n    }\r\n    prevCodePoint() {\r\n        const codePoint = getPrevCodePoint(this._str, this._offset);\r\n        this._offset -= (codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\r\n        return codePoint;\r\n    }\r\n    nextCodePoint() {\r\n        const codePoint = getNextCodePoint(this._str, this._len, this._offset);\r\n        this._offset += (codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\r\n        return codePoint;\r\n    }\r\n    eol() {\r\n        return (this._offset >= this._len);\r\n    }\r\n}\r\nclass GraphemeIterator {\r\n    get offset() {\r\n        return this._iterator.offset;\r\n    }\r\n    constructor(str, offset = 0) {\r\n        this._iterator = new CodePointIterator(str, offset);\r\n    }\r\n    nextGraphemeLength() {\r\n        const graphemeBreakTree = GraphemeBreakTree.getInstance();\r\n        const iterator = this._iterator;\r\n        const initialOffset = iterator.offset;\r\n        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\r\n        while (!iterator.eol()) {\r\n            const offset = iterator.offset;\r\n            const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\r\n            if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\r\n                // move iterator back\r\n                iterator.setOffset(offset);\r\n                break;\r\n            }\r\n            graphemeBreakType = nextGraphemeBreakType;\r\n        }\r\n        return (iterator.offset - initialOffset);\r\n    }\r\n    prevGraphemeLength() {\r\n        const graphemeBreakTree = GraphemeBreakTree.getInstance();\r\n        const iterator = this._iterator;\r\n        const initialOffset = iterator.offset;\r\n        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\r\n        while (iterator.offset > 0) {\r\n            const offset = iterator.offset;\r\n            const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\r\n            if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\r\n                // move iterator back\r\n                iterator.setOffset(offset);\r\n                break;\r\n            }\r\n            graphemeBreakType = prevGraphemeBreakType;\r\n        }\r\n        return (initialOffset - iterator.offset);\r\n    }\r\n    eol() {\r\n        return this._iterator.eol();\r\n    }\r\n}\r\nfunction nextCharLength(str, initialOffset) {\r\n    const iterator = new GraphemeIterator(str, initialOffset);\r\n    return iterator.nextGraphemeLength();\r\n}\r\nfunction prevCharLength(str, initialOffset) {\r\n    const iterator = new GraphemeIterator(str, initialOffset);\r\n    return iterator.prevGraphemeLength();\r\n}\r\nfunction getCharContainingOffset(str, offset) {\r\n    if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\r\n        offset--;\r\n    }\r\n    const endOffset = offset + nextCharLength(str, offset);\r\n    const startOffset = endOffset - prevCharLength(str, endOffset);\r\n    return [startOffset, endOffset];\r\n}\r\nlet CONTAINS_RTL = undefined;\r\nfunction makeContainsRtl() {\r\n    // Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\r\n    return /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\r\n}\r\n/**\r\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\r\n */\r\nfunction containsRTL(str) {\r\n    if (!CONTAINS_RTL) {\r\n        CONTAINS_RTL = makeContainsRtl();\r\n    }\r\n    return CONTAINS_RTL.test(str);\r\n}\r\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\r\n/**\r\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\r\n */\r\nfunction isBasicASCII(str) {\r\n    return IS_BASIC_ASCII.test(str);\r\n}\r\nconst UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\r\n/**\r\n * Returns true if `str` contains unusual line terminators, like LS or PS\r\n */\r\nfunction containsUnusualLineTerminators(str) {\r\n    return UNUSUAL_LINE_TERMINATORS.test(str);\r\n}\r\nfunction isFullWidthCharacter(charCode) {\r\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\r\n    // http://jrgraphix.net/research/unicode_blocks.php\r\n    //          2E80 - 2EFF   CJK Radicals Supplement\r\n    //          2F00 - 2FDF   Kangxi Radicals\r\n    //          2FF0 - 2FFF   Ideographic Description Characters\r\n    //          3000 - 303F   CJK Symbols and Punctuation\r\n    //          3040 - 309F   Hiragana\r\n    //          30A0 - 30FF   Katakana\r\n    //          3100 - 312F   Bopomofo\r\n    //          3130 - 318F   Hangul Compatibility Jamo\r\n    //          3190 - 319F   Kanbun\r\n    //          31A0 - 31BF   Bopomofo Extended\r\n    //          31F0 - 31FF   Katakana Phonetic Extensions\r\n    //          3200 - 32FF   Enclosed CJK Letters and Months\r\n    //          3300 - 33FF   CJK Compatibility\r\n    //          3400 - 4DBF   CJK Unified Ideographs Extension A\r\n    //          4DC0 - 4DFF   Yijing Hexagram Symbols\r\n    //          4E00 - 9FFF   CJK Unified Ideographs\r\n    //          A000 - A48F   Yi Syllables\r\n    //          A490 - A4CF   Yi Radicals\r\n    //          AC00 - D7AF   Hangul Syllables\r\n    // [IGNORE] D800 - DB7F   High Surrogates\r\n    // [IGNORE] DB80 - DBFF   High Private Use Surrogates\r\n    // [IGNORE] DC00 - DFFF   Low Surrogates\r\n    // [IGNORE] E000 - F8FF   Private Use Area\r\n    //          F900 - FAFF   CJK Compatibility Ideographs\r\n    // [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\r\n    // [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\r\n    // [IGNORE] FE00 - FE0F   Variation Selectors\r\n    // [IGNORE] FE20 - FE2F   Combining Half Marks\r\n    // [IGNORE] FE30 - FE4F   CJK Compatibility Forms\r\n    // [IGNORE] FE50 - FE6F   Small Form Variants\r\n    // [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\r\n    //          FF00 - FFEF   Halfwidth and Fullwidth Forms\r\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\r\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\r\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\r\n    // [IGNORE] FFF0 - FFFF   Specials\r\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\r\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\r\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\r\n}\r\n/**\r\n * A fast function (therefore imprecise) to check if code points are emojis.\r\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\r\n */\r\nfunction isEmojiImprecise(x) {\r\n    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\r\n        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\r\n        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\r\n        || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\r\n        || (x >= 129648 && x <= 129782));\r\n}\r\n// -- UTF-8 BOM\r\nconst UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* CharCode.UTF8_BOM */);\r\nfunction startsWithUTF8BOM(str) {\r\n    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* CharCode.UTF8_BOM */);\r\n}\r\nfunction containsUppercaseCharacter(target, ignoreEscapedChars = false) {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (ignoreEscapedChars) {\r\n        target = target.replace(/\\\\./g, '');\r\n    }\r\n    return target.toLowerCase() !== target;\r\n}\r\n/**\r\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\r\n */\r\nfunction singleLetterHash(n) {\r\n    const LETTERS_CNT = (90 /* CharCode.Z */ - 65 /* CharCode.A */ + 1);\r\n    n = n % (2 * LETTERS_CNT);\r\n    if (n < LETTERS_CNT) {\r\n        return String.fromCharCode(97 /* CharCode.a */ + n);\r\n    }\r\n    return String.fromCharCode(65 /* CharCode.A */ + n - LETTERS_CNT);\r\n}\r\nfunction breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {\r\n    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\r\n    // !!! Let's make the common case a bit faster\r\n    if (breakTypeA === 0 /* GraphemeBreakType.Other */) {\r\n        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\r\n        return (breakTypeB !== 5 /* GraphemeBreakType.Extend */ && breakTypeB !== 7 /* GraphemeBreakType.SpacingMark */);\r\n    }\r\n    // Do not break between a CR and LF. Otherwise, break before and after controls.\r\n    // GB3                                        CR × LF\r\n    // GB4                       (Control | CR | LF) ÷\r\n    // GB5                                           ÷ (Control | CR | LF)\r\n    if (breakTypeA === 2 /* GraphemeBreakType.CR */) {\r\n        if (breakTypeB === 3 /* GraphemeBreakType.LF */) {\r\n            return false; // GB3\r\n        }\r\n    }\r\n    if (breakTypeA === 4 /* GraphemeBreakType.Control */ || breakTypeA === 2 /* GraphemeBreakType.CR */ || breakTypeA === 3 /* GraphemeBreakType.LF */) {\r\n        return true; // GB4\r\n    }\r\n    if (breakTypeB === 4 /* GraphemeBreakType.Control */ || breakTypeB === 2 /* GraphemeBreakType.CR */ || breakTypeB === 3 /* GraphemeBreakType.LF */) {\r\n        return true; // GB5\r\n    }\r\n    // Do not break Hangul syllable sequences.\r\n    // GB6                                         L × (L | V | LV | LVT)\r\n    // GB7                                  (LV | V) × (V | T)\r\n    // GB8                                 (LVT | T) × T\r\n    if (breakTypeA === 8 /* GraphemeBreakType.L */) {\r\n        if (breakTypeB === 8 /* GraphemeBreakType.L */ || breakTypeB === 9 /* GraphemeBreakType.V */ || breakTypeB === 11 /* GraphemeBreakType.LV */ || breakTypeB === 12 /* GraphemeBreakType.LVT */) {\r\n            return false; // GB6\r\n        }\r\n    }\r\n    if (breakTypeA === 11 /* GraphemeBreakType.LV */ || breakTypeA === 9 /* GraphemeBreakType.V */) {\r\n        if (breakTypeB === 9 /* GraphemeBreakType.V */ || breakTypeB === 10 /* GraphemeBreakType.T */) {\r\n            return false; // GB7\r\n        }\r\n    }\r\n    if (breakTypeA === 12 /* GraphemeBreakType.LVT */ || breakTypeA === 10 /* GraphemeBreakType.T */) {\r\n        if (breakTypeB === 10 /* GraphemeBreakType.T */) {\r\n            return false; // GB8\r\n        }\r\n    }\r\n    // Do not break before extending characters or ZWJ.\r\n    // GB9                                           × (Extend | ZWJ)\r\n    if (breakTypeB === 5 /* GraphemeBreakType.Extend */ || breakTypeB === 13 /* GraphemeBreakType.ZWJ */) {\r\n        return false; // GB9\r\n    }\r\n    // The GB9a and GB9b rules only apply to extended grapheme clusters:\r\n    // Do not break before SpacingMarks, or after Prepend characters.\r\n    // GB9a                                          × SpacingMark\r\n    // GB9b                                  Prepend ×\r\n    if (breakTypeB === 7 /* GraphemeBreakType.SpacingMark */) {\r\n        return false; // GB9a\r\n    }\r\n    if (breakTypeA === 1 /* GraphemeBreakType.Prepend */) {\r\n        return false; // GB9b\r\n    }\r\n    // Do not break within emoji modifier sequences or emoji zwj sequences.\r\n    // GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\r\n    if (breakTypeA === 13 /* GraphemeBreakType.ZWJ */ && breakTypeB === 14 /* GraphemeBreakType.Extended_Pictographic */) {\r\n        // Note: we are not implementing the rule entirely here to avoid introducing states\r\n        return false; // GB11\r\n    }\r\n    // GB12                          sot (RI RI)* RI × RI\r\n    // GB13                        [^RI] (RI RI)* RI × RI\r\n    if (breakTypeA === 6 /* GraphemeBreakType.Regional_Indicator */ && breakTypeB === 6 /* GraphemeBreakType.Regional_Indicator */) {\r\n        // Note: we are not implementing the rule entirely here to avoid introducing states\r\n        return false; // GB12 & GB13\r\n    }\r\n    // GB999                                     Any ÷ Any\r\n    return true;\r\n}\r\nclass GraphemeBreakTree {\r\n    static getInstance() {\r\n        if (!GraphemeBreakTree._INSTANCE) {\r\n            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\r\n        }\r\n        return GraphemeBreakTree._INSTANCE;\r\n    }\r\n    constructor() {\r\n        this._data = getGraphemeBreakRawData();\r\n    }\r\n    getGraphemeBreakType(codePoint) {\r\n        // !!! Let's make 7bit ASCII a bit faster: 0..31\r\n        if (codePoint < 32) {\r\n            if (codePoint === 10 /* CharCode.LineFeed */) {\r\n                return 3 /* GraphemeBreakType.LF */;\r\n            }\r\n            if (codePoint === 13 /* CharCode.CarriageReturn */) {\r\n                return 2 /* GraphemeBreakType.CR */;\r\n            }\r\n            return 4 /* GraphemeBreakType.Control */;\r\n        }\r\n        // !!! Let's make 7bit ASCII a bit faster: 32..126\r\n        if (codePoint < 127) {\r\n            return 0 /* GraphemeBreakType.Other */;\r\n        }\r\n        const data = this._data;\r\n        const nodeCount = data.length / 3;\r\n        let nodeIndex = 1;\r\n        while (nodeIndex <= nodeCount) {\r\n            if (codePoint < data[3 * nodeIndex]) {\r\n                // go left\r\n                nodeIndex = 2 * nodeIndex;\r\n            }\r\n            else if (codePoint > data[3 * nodeIndex + 1]) {\r\n                // go right\r\n                nodeIndex = 2 * nodeIndex + 1;\r\n            }\r\n            else {\r\n                // hit\r\n                return data[3 * nodeIndex + 2];\r\n            }\r\n        }\r\n        return 0 /* GraphemeBreakType.Other */;\r\n    }\r\n}\r\nGraphemeBreakTree._INSTANCE = null;\r\nfunction getGraphemeBreakRawData() {\r\n    // generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\r\n    return JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\r\n}\r\n//#endregion\r\n/**\r\n * Computes the offset after performing a left delete on the given string,\r\n * while considering unicode grapheme/emoji rules.\r\n*/\r\nfunction getLeftDeleteOffset(offset, str) {\r\n    if (offset === 0) {\r\n        return 0;\r\n    }\r\n    // Try to delete emoji part.\r\n    const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\r\n    if (emojiOffset !== undefined) {\r\n        return emojiOffset;\r\n    }\r\n    // Otherwise, just skip a single code point.\r\n    const iterator = new CodePointIterator(str, offset);\r\n    iterator.prevCodePoint();\r\n    return iterator.offset;\r\n}\r\nfunction getOffsetBeforeLastEmojiComponent(initialOffset, str) {\r\n    // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\r\n    // structure of emojis.\r\n    const iterator = new CodePointIterator(str, initialOffset);\r\n    let codePoint = iterator.prevCodePoint();\r\n    // Skip modifiers\r\n    while ((isEmojiModifier(codePoint) || codePoint === 65039 /* CodePoint.emojiVariantSelector */ || codePoint === 8419 /* CodePoint.enclosingKeyCap */)) {\r\n        if (iterator.offset === 0) {\r\n            // Cannot skip modifier, no preceding emoji base.\r\n            return undefined;\r\n        }\r\n        codePoint = iterator.prevCodePoint();\r\n    }\r\n    // Expect base emoji\r\n    if (!isEmojiImprecise(codePoint)) {\r\n        // Unexpected code point, not a valid emoji.\r\n        return undefined;\r\n    }\r\n    let resultOffset = iterator.offset;\r\n    if (resultOffset > 0) {\r\n        // Skip optional ZWJ code points that combine multiple emojis.\r\n        // In theory, we should check if that ZWJ actually combines multiple emojis\r\n        // to prevent deleting ZWJs in situations we didn't account for.\r\n        const optionalZwjCodePoint = iterator.prevCodePoint();\r\n        if (optionalZwjCodePoint === 8205 /* CodePoint.zwj */) {\r\n            resultOffset = iterator.offset;\r\n        }\r\n    }\r\n    return resultOffset;\r\n}\r\nfunction isEmojiModifier(codePoint) {\r\n    return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\r\n}\r\nconst noBreakWhitespace = '\\xa0';\r\nclass AmbiguousCharacters {\r\n    static getInstance(locales) {\r\n        return _a.cache.get(Array.from(locales));\r\n    }\r\n    static getLocales() {\r\n        return _a._locales.value;\r\n    }\r\n    constructor(confusableDictionary) {\r\n        this.confusableDictionary = confusableDictionary;\r\n    }\r\n    isAmbiguous(codePoint) {\r\n        return this.confusableDictionary.has(codePoint);\r\n    }\r\n    /**\r\n     * Returns the non basic ASCII code point that the given code point can be confused,\r\n     * or undefined if such code point does note exist.\r\n     */\r\n    getPrimaryConfusable(codePoint) {\r\n        return this.confusableDictionary.get(codePoint);\r\n    }\r\n    getConfusableCodePoints() {\r\n        return new Set(this.confusableDictionary.keys());\r\n    }\r\n}\r\n_a = AmbiguousCharacters;\r\nAmbiguousCharacters.ambiguousCharacterData = new _lazy_js__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => {\r\n    // Generated using https://github.com/hediet/vscode-unicode-data\r\n    // Stored as key1, value1, key2, value2, ...\r\n    return JSON.parse('{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\\\"_default\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"cs\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"fr\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ja\\\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\\\"ko\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ru\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"zh-hans\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\\\"zh-hant\\\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');\r\n});\r\nAmbiguousCharacters.cache = new _cache_js__WEBPACK_IMPORTED_MODULE_0__.LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {\r\n    function arrayToMap(arr) {\r\n        const result = new Map();\r\n        for (let i = 0; i < arr.length; i += 2) {\r\n            result.set(arr[i], arr[i + 1]);\r\n        }\r\n        return result;\r\n    }\r\n    function mergeMaps(map1, map2) {\r\n        const result = new Map(map1);\r\n        for (const [key, value] of map2) {\r\n            result.set(key, value);\r\n        }\r\n        return result;\r\n    }\r\n    function intersectMaps(map1, map2) {\r\n        if (!map1) {\r\n            return map2;\r\n        }\r\n        const result = new Map();\r\n        for (const [key, value] of map1) {\r\n            if (map2.has(key)) {\r\n                result.set(key, value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    const data = _a.ambiguousCharacterData.value;\r\n    let filteredLocales = locales.filter((l) => !l.startsWith('_') && l in data);\r\n    if (filteredLocales.length === 0) {\r\n        filteredLocales = ['_default'];\r\n    }\r\n    let languageSpecificMap = undefined;\r\n    for (const locale of filteredLocales) {\r\n        const map = arrayToMap(data[locale]);\r\n        languageSpecificMap = intersectMaps(languageSpecificMap, map);\r\n    }\r\n    const commonMap = arrayToMap(data['_common']);\r\n    const map = mergeMaps(commonMap, languageSpecificMap);\r\n    return new _a(map);\r\n});\r\nAmbiguousCharacters._locales = new _lazy_js__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => Object.keys(_a.ambiguousCharacterData.value).filter((k) => !k.startsWith('_')));\r\nclass InvisibleCharacters {\r\n    static getRawData() {\r\n        // Generated using https://github.com/hediet/vscode-unicode-data\r\n        return JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');\r\n    }\r\n    static getData() {\r\n        if (!this._data) {\r\n            this._data = new Set(InvisibleCharacters.getRawData());\r\n        }\r\n        return this._data;\r\n    }\r\n    static isInvisibleCharacter(codePoint) {\r\n        return InvisibleCharacters.getData().has(codePoint);\r\n    }\r\n    static get codePoints() {\r\n        return InvisibleCharacters.getData();\r\n    }\r\n}\r\nInvisibleCharacters._data = undefined;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDZDtBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ08seURBQXlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQW1EO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ08sbURBQW1EO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QixpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQ0FBSTtBQUNyRDtBQUNBO0FBQ0Esd0JBQXdCLHF4bUJBQXF4bUI7QUFDN3ltQixDQUFDO0FBQ0QsZ0NBQWdDLHdEQUFpQixHQUFHLDZCQUE2QjtBQUNqRjtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLDBDQUFJO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3N0cmluZ3MuanM/Mzc0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIF9hO1xyXG5pbXBvcnQgeyBMUlVDYWNoZWRGdW5jdGlvbiB9IGZyb20gJy4vY2FjaGUuanMnO1xyXG5pbXBvcnQgeyBMYXp5IH0gZnJvbSAnLi9sYXp5LmpzJztcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPcldoaXRlc3BhY2Uoc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ci50cmltKCkubGVuZ3RoID09PSAwO1xyXG59XHJcbmNvbnN0IF9mb3JtYXRSZWdleHAgPSAveyhcXGQrKX0vZztcclxuLyoqXHJcbiAqIEhlbHBlciB0byBwcm9kdWNlIGEgc3RyaW5nIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLiBJbnNlcnQgdmFyaWFibGUgc2VnbWVudHNcclxuICogaW50byB0aGUgc3RyaW5nIHVzaW5nIHRoZSB7bn0gbm90YXRpb24gd2hlcmUgTiBpcyB0aGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IGZvbGxvd2luZyB0aGUgc3RyaW5nLlxyXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHRvIHdoaWNoIGZvcm1hdHRpbmcgaXMgYXBwbGllZFxyXG4gKiBAcGFyYW0gYXJncyByZXBsYWNlbWVudHMgZm9yIHtufS1lbnRyaWVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShfZm9ybWF0UmVnZXhwLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcclxuICAgICAgICByZXR1cm4gaXNOYU4oaWR4KSB8fCBpZHggPCAwIHx8IGlkeCA+PSBhcmdzLmxlbmd0aCA/XHJcbiAgICAgICAgICAgIG1hdGNoIDpcclxuICAgICAgICAgICAgYXJnc1tpZHhdO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHZhbHVlIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgbGl0ZXJhbCB2YWx1ZSBpbiBodG1sIGF0dHJpYnV0ZXMuXHJcbiAqXHJcbiAqIEluIG90aGVyIHdvcmRzLCBjb21wdXRlcyBgJHZhbGAsIHN1Y2ggdGhhdCBgYXR0cmAgaW4gYDxkaXYgYXR0cj1cIiR2YWxcIiAvPmAgaGFzIHRoZSBydW50aW1lIHZhbHVlIGB2YWx1ZWAuXHJcbiAqIFRoaXMgcHJldmVudHMgWFNTIGluamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBodG1sQXR0cmlidXRlRW5jb2RlVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bPD5cIicmXS9nLCBjaCA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChjaCkge1xyXG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcclxuICAgICAgICAgICAgY2FzZSAnPic6IHJldHVybiAnJmd0Oyc7XHJcbiAgICAgICAgICAgIGNhc2UgJ1wiJzogcmV0dXJuICcmcXVvdDsnO1xyXG4gICAgICAgICAgICBjYXNlICdcXCcnOiByZXR1cm4gJyZhcG9zOyc7XHJcbiAgICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIEhUTUwgY2hhcmFjdGVycyBpbnNpZGUgdGhlIHN0cmluZyB0byB1c2UgZW50aXRpZXMgaW5zdGVhZC4gTWFrZXMgdGhlIHN0cmluZyBzYWZlIGZyb21cclxuICogYmVpbmcgdXNlZCBlLmcuIGluIEhUTUxFbGVtZW50LmlubmVySFRNTC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUoaHRtbCkge1xyXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvWzw+Jl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgc3dpdGNoIChtYXRjaCkge1xyXG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcclxuICAgICAgICAgICAgY2FzZSAnPic6IHJldHVybiAnJmd0Oyc7XHJcbiAgICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBFc2NhcGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGFyYWN0ZXJzIGluIGEgZ2l2ZW4gc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXFxcXFx7XFx9XFwqXFwrXFw/XFx8XFxeXFwkXFwuXFxbXFxdXFwoXFwpXS9nLCAnXFxcXCQmJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBoYXlzdGFjay5cclxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXHJcbiAqIEBwYXJhbSBuZWVkbGUgdGhlIHRoaW5nIHRvIHRyaW0gKGRlZmF1bHQgaXMgYSBibGFuaylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKGhheXN0YWNrLCBuZWVkbGUgPSAnICcpIHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsdHJpbShoYXlzdGFjaywgbmVlZGxlKTtcclxuICAgIHJldHVybiBydHJpbSh0cmltbWVkLCBuZWVkbGUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGhheXN0YWNrLlxyXG4gKiBAcGFyYW0gaGF5c3RhY2sgc3RyaW5nIHRvIHRyaW1cclxuICogQHBhcmFtIG5lZWRsZSB0aGUgdGhpbmcgdG8gdHJpbVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGx0cmltKGhheXN0YWNrLCBuZWVkbGUpIHtcclxuICAgIGlmICghaGF5c3RhY2sgfHwgIW5lZWRsZSkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcclxuICAgIH1cclxuICAgIGNvbnN0IG5lZWRsZUxlbiA9IG5lZWRsZS5sZW5ndGg7XHJcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcclxuICAgIH1cclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgd2hpbGUgKGhheXN0YWNrLmluZGV4T2YobmVlZGxlLCBvZmZzZXQpID09PSBvZmZzZXQpIHtcclxuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBuZWVkbGVMZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGF5c3RhY2suc3Vic3RyaW5nKG9mZnNldCk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBlbmQgb2YgaGF5c3RhY2suXHJcbiAqIEBwYXJhbSBoYXlzdGFjayBzdHJpbmcgdG8gdHJpbVxyXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcnRyaW0oaGF5c3RhY2ssIG5lZWRsZSkge1xyXG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmVlZGxlTGVuID0gbmVlZGxlLmxlbmd0aCwgaGF5c3RhY2tMZW4gPSBoYXlzdGFjay5sZW5ndGg7XHJcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrTGVuID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xyXG4gICAgfVxyXG4gICAgbGV0IG9mZnNldCA9IGhheXN0YWNrTGVuLCBpZHggPSAtMTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWR4ID0gaGF5c3RhY2subGFzdEluZGV4T2YobmVlZGxlLCBvZmZzZXQgLSAxKTtcclxuICAgICAgICBpZiAoaWR4ID09PSAtMSB8fCBpZHggKyBuZWVkbGVMZW4gIT09IG9mZnNldCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCA9IGlkeDtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXlzdGFjay5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFNpbXBsZTJSZWdFeHBQYXR0ZXJuKHBhdHRlcm4pIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1tcXC1cXFxcXFx7XFx9XFwrXFw/XFx8XFxeXFwkXFwuXFwsXFxbXFxdXFwoXFwpXFwjXFxzXS9nLCAnXFxcXCQmJykucmVwbGFjZSgvW1xcKl0vZywgJy4qJyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwV2lsZGNhcmRzKHBhdHRlcm4pIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1xcKi9nLCAnJyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZ0V4cChzZWFyY2hTdHJpbmcsIGlzUmVnZXgsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKCFzZWFyY2hTdHJpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcmVnZXggZnJvbSBlbXB0eSBzdHJpbmcnKTtcclxuICAgIH1cclxuICAgIGlmICghaXNSZWdleCkge1xyXG4gICAgICAgIHNlYXJjaFN0cmluZyA9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc2VhcmNoU3RyaW5nKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLndob2xlV29yZCkge1xyXG4gICAgICAgIGlmICghL1xcQi8udGVzdChzZWFyY2hTdHJpbmcuY2hhckF0KDApKSkge1xyXG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSAnXFxcXGInICsgc2VhcmNoU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdChzZWFyY2hTdHJpbmcubGVuZ3RoIC0gMSkpKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaFN0cmluZyA9IHNlYXJjaFN0cmluZyArICdcXFxcYic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG1vZGlmaWVycyA9ICcnO1xyXG4gICAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XHJcbiAgICAgICAgbW9kaWZpZXJzICs9ICdnJztcclxuICAgIH1cclxuICAgIGlmICghb3B0aW9ucy5tYXRjaENhc2UpIHtcclxuICAgICAgICBtb2RpZmllcnMgKz0gJ2knO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgbW9kaWZpZXJzICs9ICdtJztcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnVuaWNvZGUpIHtcclxuICAgICAgICBtb2RpZmllcnMgKz0gJ3UnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoU3RyaW5nLCBtb2RpZmllcnMpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZWdFeHBMZWFkc1RvRW5kbGVzc0xvb3AocmVnZXhwKSB7XHJcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGl0J3Mgb25lIG9mIHRoZXNlIHNwZWNpYWwgY2FzZXMgd2hpY2ggYXJlIG1lYW50IHRvIG1hdGNoXHJcbiAgICAvLyBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgaWYgKHJlZ2V4cC5zb3VyY2UgPT09ICdeJyB8fCByZWdleHAuc291cmNlID09PSAnXiQnIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICckJyB8fCByZWdleHAuc291cmNlID09PSAnXlxcXFxzKiQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCBhbiBlbXB0eSBzdHJpbmcuIElmIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZG9lc24ndCBhZHZhbmNlXHJcbiAgICAvLyAoZS5nLiBlbmRzIGluIGFuIGVuZGxlc3MgbG9vcCkgaXQgd2lsbCBtYXRjaCBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4cC5leGVjKCcnKTtcclxuICAgIHJldHVybiAhIShtYXRjaCAmJiByZWdleHAubGFzdEluZGV4ID09PSAwKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRMaW5lcyhzdHIpIHtcclxuICAgIHJldHVybiBzdHIuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0TGluZXNJbmNsdWRlU2VwYXJhdG9ycyhzdHIpIHtcclxuICAgIHZhciBfYjtcclxuICAgIGNvbnN0IGxpbmVzV2l0aFNlcGFyYXRvcnMgPSBbXTtcclxuICAgIGNvbnN0IHNwbGl0TGluZXNBbmRTZXBhcmF0b3JzID0gc3RyLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGguY2VpbChzcGxpdExpbmVzQW5kU2VwYXJhdG9ycy5sZW5ndGggLyAyKTsgaSsrKSB7XHJcbiAgICAgICAgbGluZXNXaXRoU2VwYXJhdG9ycy5wdXNoKHNwbGl0TGluZXNBbmRTZXBhcmF0b3JzWzIgKiBpXSArICgoX2IgPSBzcGxpdExpbmVzQW5kU2VwYXJhdG9yc1syICogaSArIDFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpbmVzV2l0aFNlcGFyYXRvcnM7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgZmlyc3QgaW5kZXggb2YgdGhlIHN0cmluZyB0aGF0IGlzIG5vdCB3aGl0ZXNwYWNlLlxyXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KHN0cikge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjaENvZGUgIT09IDMyIC8qIENoYXJDb2RlLlNwYWNlICovICYmIGNoQ29kZSAhPT0gOSAvKiBDaGFyQ29kZS5UYWIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIHN0cmluZy5cclxuICogSWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLCByZXR1cm5zIGVudGlyZSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWFkaW5nV2hpdGVzcGFjZShzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyLmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBsYXN0IGluZGV4IG9mIHRoZSBzdHJpbmcgdGhhdCBpcyBub3Qgd2hpdGVzcGFjZS5cclxuICogSWYgc3RyaW5nIGlzIGVtcHR5IG9yIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZXMsIHJldHVybnMgLTFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXN0Tm9uV2hpdGVzcGFjZUluZGV4KHN0ciwgc3RhcnRJbmRleCA9IHN0ci5sZW5ndGggLSAxKSB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XHJcbiAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhID4gYikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmcoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcclxuICAgIGZvciAoOyBhU3RhcnQgPCBhRW5kICYmIGJTdGFydCA8IGJFbmQ7IGFTdGFydCsrLCBiU3RhcnQrKykge1xyXG4gICAgICAgIGNvbnN0IGNvZGVBID0gYS5jaGFyQ29kZUF0KGFTdGFydCk7XHJcbiAgICAgICAgY29uc3QgY29kZUIgPSBiLmNoYXJDb2RlQXQoYlN0YXJ0KTtcclxuICAgICAgICBpZiAoY29kZUEgPCBjb2RlQikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVBID4gY29kZUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgYUxlbiA9IGFFbmQgLSBhU3RhcnQ7XHJcbiAgICBjb25zdCBiTGVuID0gYkVuZCAtIGJTdGFydDtcclxuICAgIGlmIChhTGVuIDwgYkxlbikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFMZW4gPiBiTGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUlnbm9yZUNhc2UoYSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIsIDAsIGEubGVuZ3RoLCAwLCBiLmxlbmd0aCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIsIGFTdGFydCA9IDAsIGFFbmQgPSBhLmxlbmd0aCwgYlN0YXJ0ID0gMCwgYkVuZCA9IGIubGVuZ3RoKSB7XHJcbiAgICBmb3IgKDsgYVN0YXJ0IDwgYUVuZCAmJiBiU3RhcnQgPCBiRW5kOyBhU3RhcnQrKywgYlN0YXJ0KyspIHtcclxuICAgICAgICBsZXQgY29kZUEgPSBhLmNoYXJDb2RlQXQoYVN0YXJ0KTtcclxuICAgICAgICBsZXQgY29kZUIgPSBiLmNoYXJDb2RlQXQoYlN0YXJ0KTtcclxuICAgICAgICBpZiAoY29kZUEgPT09IGNvZGVCKSB7XHJcbiAgICAgICAgICAgIC8vIGVxdWFsXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZUEgPj0gMTI4IHx8IGNvZGVCID49IDEyOCkge1xyXG4gICAgICAgICAgICAvLyBub3QgQVNDSUkgbGV0dGVycyAtPiBmYWxsYmFjayB0byBsb3dlci1jYXNpbmcgc3RyaW5nc1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVN1YnN0cmluZyhhLnRvTG93ZXJDYXNlKCksIGIudG9Mb3dlckNhc2UoKSwgYVN0YXJ0LCBhRW5kLCBiU3RhcnQsIGJFbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYXBwZXIgbG93ZXItY2FzZSBhc2NpaSBsZXR0ZXIgb250byB1cHBlci1jYXNlIHZhcmluYXRzXHJcbiAgICAgICAgLy8gWzk3LTEyMl0gKGxvd2VyIGFzY2lpKSAtLT4gWzY1LTkwXSAodXBwZXIgYXNjaWkpXHJcbiAgICAgICAgaWYgKGlzTG93ZXJBc2NpaUxldHRlcihjb2RlQSkpIHtcclxuICAgICAgICAgICAgY29kZUEgLT0gMzI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZUIpKSB7XHJcbiAgICAgICAgICAgIGNvZGVCIC09IDMyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21wYXJlIGJvdGggY29kZSBwb2ludHNcclxuICAgICAgICBjb25zdCBkaWZmID0gY29kZUEgLSBjb2RlQjtcclxuICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcclxuICAgIGNvbnN0IGJMZW4gPSBiRW5kIC0gYlN0YXJ0O1xyXG4gICAgaWYgKGFMZW4gPCBiTGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYUxlbiA+IGJMZW4pIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0FzY2lpRGlnaXQoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPj0gNDggLyogQ2hhckNvZGUuRGlnaXQwICovICYmIGNvZGUgPD0gNTcgLyogQ2hhckNvZGUuRGlnaXQ5ICovO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPj0gOTcgLyogQ2hhckNvZGUuYSAqLyAmJiBjb2RlIDw9IDEyMiAvKiBDaGFyQ29kZS56ICovO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPj0gNjUgLyogQ2hhckNvZGUuQSAqLyAmJiBjb2RlIDw9IDkwIC8qIENoYXJDb2RlLlogKi87XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsc0lnbm9yZUNhc2UoYSwgYikge1xyXG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBjb21wYXJlU3Vic3RyaW5nSWdub3JlQ2FzZShhLCBiKSA9PT0gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aElnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZUxlbmd0aCA9IGNhbmRpZGF0ZS5sZW5ndGg7XHJcbiAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUsIDAsIGNhbmRpZGF0ZUxlbmd0aCkgPT09IDA7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBwcmVmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeExlbmd0aChhLCBiKSB7XHJcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgbGV0IGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGkpICE9PSBiLmNoYXJDb2RlQXQoaSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0aGUgdHdvIHN0cmluZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4TGVuZ3RoKGEsIGIpIHtcclxuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBsZXQgaTtcclxuICAgIGNvbnN0IGFMYXN0SW5kZXggPSBhLmxlbmd0aCAtIDE7XHJcbiAgICBjb25zdCBiTGFzdEluZGV4ID0gYi5sZW5ndGggLSAxO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGEuY2hhckNvZGVBdChhTGFzdEluZGV4IC0gaSkgIT09IGIuY2hhckNvZGVBdChiTGFzdEluZGV4IC0gaSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufVxyXG4vKipcclxuICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Vycm9nYXRlX3BhaXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpIHtcclxuICAgIHJldHVybiAoMHhEODAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDB4REJGRik7XHJcbn1cclxuLyoqXHJcbiAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cnJvZ2F0ZV9wYWlyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpIHtcclxuICAgIHJldHVybiAoMHhEQzAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDB4REZGRik7XHJcbn1cclxuLyoqXHJcbiAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cnJvZ2F0ZV9wYWlyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNvZGVQb2ludChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpIHtcclxuICAgIHJldHVybiAoKGhpZ2hTdXJyb2dhdGUgLSAweEQ4MDApIDw8IDEwKSArIChsb3dTdXJyb2dhdGUgLSAweERDMDApICsgMHgxMDAwMDtcclxufVxyXG4vKipcclxuICogZ2V0IHRoZSBjb2RlIHBvaW50IHRoYXQgYmVnaW5zIGF0IG9mZnNldCBgb2Zmc2V0YFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRDb2RlUG9pbnQoc3RyLCBsZW4sIG9mZnNldCkge1xyXG4gICAgY29uc3QgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xyXG4gICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkgJiYgb2Zmc2V0ICsgMSA8IGxlbikge1xyXG4gICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xyXG4gICAgICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShuZXh0Q2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQ29kZVBvaW50KGNoYXJDb2RlLCBuZXh0Q2hhckNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGFyQ29kZTtcclxufVxyXG4vKipcclxuICogZ2V0IHRoZSBjb2RlIHBvaW50IHRoYXQgZW5kcyByaWdodCBiZWZvcmUgb2Zmc2V0IGBvZmZzZXRgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcmV2Q29kZVBvaW50KHN0ciwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDEpO1xyXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSAmJiBvZmZzZXQgPiAxKSB7XHJcbiAgICAgICAgY29uc3QgcHJldkNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMik7XHJcbiAgICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShwcmV2Q2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQ29kZVBvaW50KHByZXZDaGFyQ29kZSwgY2hhckNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGFyQ29kZTtcclxufVxyXG5leHBvcnQgY2xhc3MgQ29kZVBvaW50SXRlcmF0b3Ige1xyXG4gICAgZ2V0IG9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Ioc3RyLCBvZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgdGhpcy5fc3RyID0gc3RyO1xyXG4gICAgICAgIHRoaXMuX2xlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgc2V0T2Zmc2V0KG9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcclxuICAgIH1cclxuICAgIHByZXZDb2RlUG9pbnQoKSB7XHJcbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gZ2V0UHJldkNvZGVQb2ludCh0aGlzLl9zdHIsIHRoaXMuX29mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0IC09IChjb2RlUG9pbnQgPj0gNjU1MzYgLyogQ29uc3RhbnRzLlVOSUNPREVfU1VQUExFTUVOVEFSWV9QTEFORV9CRUdJTiAqLyA/IDIgOiAxKTtcclxuICAgICAgICByZXR1cm4gY29kZVBvaW50O1xyXG4gICAgfVxyXG4gICAgbmV4dENvZGVQb2ludCgpIHtcclxuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBnZXROZXh0Q29kZVBvaW50KHRoaXMuX3N0ciwgdGhpcy5fbGVuLCB0aGlzLl9vZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX29mZnNldCArPSAoY29kZVBvaW50ID49IDY1NTM2IC8qIENvbnN0YW50cy5VTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcclxuICAgIH1cclxuICAgIGVvbCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX29mZnNldCA+PSB0aGlzLl9sZW4pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBHcmFwaGVtZUl0ZXJhdG9yIHtcclxuICAgIGdldCBvZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZXJhdG9yLm9mZnNldDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHN0ciwgb2Zmc2V0ID0gMCkge1xyXG4gICAgICAgIHRoaXMuX2l0ZXJhdG9yID0gbmV3IENvZGVQb2ludEl0ZXJhdG9yKHN0ciwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIG5leHRHcmFwaGVtZUxlbmd0aCgpIHtcclxuICAgICAgICBjb25zdCBncmFwaGVtZUJyZWFrVHJlZSA9IEdyYXBoZW1lQnJlYWtUcmVlLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcclxuICAgICAgICBjb25zdCBpbml0aWFsT2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xyXG4gICAgICAgIGxldCBncmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLm5leHRDb2RlUG9pbnQoKSk7XHJcbiAgICAgICAgd2hpbGUgKCFpdGVyYXRvci5lb2woKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRHcmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLm5leHRDb2RlUG9pbnQoKSk7XHJcbiAgICAgICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShncmFwaGVtZUJyZWFrVHlwZSwgbmV4dEdyYXBoZW1lQnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBpdGVyYXRvciBiYWNrXHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zZXRPZmZzZXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyYXBoZW1lQnJlYWtUeXBlID0gbmV4dEdyYXBoZW1lQnJlYWtUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGl0ZXJhdG9yLm9mZnNldCAtIGluaXRpYWxPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgcHJldkdyYXBoZW1lTGVuZ3RoKCkge1xyXG4gICAgICAgIGNvbnN0IGdyYXBoZW1lQnJlYWtUcmVlID0gR3JhcGhlbWVCcmVha1RyZWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2l0ZXJhdG9yO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XHJcbiAgICAgICAgbGV0IGdyYXBoZW1lQnJlYWtUeXBlID0gZ3JhcGhlbWVCcmVha1RyZWUuZ2V0R3JhcGhlbWVCcmVha1R5cGUoaXRlcmF0b3IucHJldkNvZGVQb2ludCgpKTtcclxuICAgICAgICB3aGlsZSAoaXRlcmF0b3Iub2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZHcmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKSk7XHJcbiAgICAgICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShwcmV2R3JhcGhlbWVCcmVha1R5cGUsIGdyYXBoZW1lQnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBpdGVyYXRvciBiYWNrXHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zZXRPZmZzZXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyYXBoZW1lQnJlYWtUeXBlID0gcHJldkdyYXBoZW1lQnJlYWtUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGluaXRpYWxPZmZzZXQgLSBpdGVyYXRvci5vZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgZW9sKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRvci5lb2woKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbmV4dENoYXJMZW5ndGgoc3RyLCBpbml0aWFsT2Zmc2V0KSB7XHJcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBHcmFwaGVtZUl0ZXJhdG9yKHN0ciwgaW5pdGlhbE9mZnNldCk7XHJcbiAgICByZXR1cm4gaXRlcmF0b3IubmV4dEdyYXBoZW1lTGVuZ3RoKCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZDaGFyTGVuZ3RoKHN0ciwgaW5pdGlhbE9mZnNldCkge1xyXG4gICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgR3JhcGhlbWVJdGVyYXRvcihzdHIsIGluaXRpYWxPZmZzZXQpO1xyXG4gICAgcmV0dXJuIGl0ZXJhdG9yLnByZXZHcmFwaGVtZUxlbmd0aCgpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFyQ29udGFpbmluZ09mZnNldChzdHIsIG9mZnNldCkge1xyXG4gICAgaWYgKG9mZnNldCA+IDAgJiYgaXNMb3dTdXJyb2dhdGUoc3RyLmNoYXJDb2RlQXQob2Zmc2V0KSkpIHtcclxuICAgICAgICBvZmZzZXQtLTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZE9mZnNldCA9IG9mZnNldCArIG5leHRDaGFyTGVuZ3RoKHN0ciwgb2Zmc2V0KTtcclxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZW5kT2Zmc2V0IC0gcHJldkNoYXJMZW5ndGgoc3RyLCBlbmRPZmZzZXQpO1xyXG4gICAgcmV0dXJuIFtzdGFydE9mZnNldCwgZW5kT2Zmc2V0XTtcclxufVxyXG5sZXQgQ09OVEFJTlNfUlRMID0gdW5kZWZpbmVkO1xyXG5mdW5jdGlvbiBtYWtlQ29udGFpbnNSdGwoKSB7XHJcbiAgICAvLyBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYWluL3J0bC10ZXN0LmpzXHJcbiAgICByZXR1cm4gLyg/OltcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVEMC1cXHUwNUY0XFx1MDYwOFxcdTA2MEJcXHUwNjBEXFx1MDYxQi1cXHUwNjRBXFx1MDY2RC1cXHUwNjZGXFx1MDY3MS1cXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjEtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA3RkUtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4MzAtXFx1MDg1OFxcdTA4NUUtXFx1MDg4RVxcdTA4QTAtXFx1MDhDOVxcdTIwMEZcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGRDNEXFx1RkQ1MC1cXHVGREM3XFx1RkRGMC1cXHVGREZDXFx1RkU3MC1cXHVGRUZDXXxcXHVEODAyW1xcdURDMDAtXFx1REQxQlxcdUREMjAtXFx1REUwMFxcdURFMTAtXFx1REUzNVxcdURFNDAtXFx1REVFNFxcdURFRUItXFx1REYzNVxcdURGNDAtXFx1REZGRl18XFx1RDgwM1tcXHVEQzAwLVxcdUREMjNcXHVERTgwLVxcdURFQTlcXHVERUFELVxcdURGNDVcXHVERjUxLVxcdURGODFcXHVERjg2LVxcdURGRjZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0NGXFx1REQwMC1cXHVERDQzXFx1REQ0Qi1cXHVERkZGXXxcXHVEODNCW1xcdURDMDAtXFx1REVCQl0pLztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIGFueSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGlzIGNsYXNzaWZpZWQgYXMgXCJSXCIgb3IgXCJBTFwiLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUlRMKHN0cikge1xyXG4gICAgaWYgKCFDT05UQUlOU19SVEwpIHtcclxuICAgICAgICBDT05UQUlOU19SVEwgPSBtYWtlQ29udGFpbnNSdGwoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBDT05UQUlOU19SVEwudGVzdChzdHIpO1xyXG59XHJcbmNvbnN0IElTX0JBU0lDX0FTQ0lJID0gL15bXFx0XFxuXFxyXFx4MjAtXFx4N0VdKiQvO1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIG9ubHkgYmFzaWMgQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgMzIgLSAxMjYgKGluY2x1ZGluZyAzMiBhbmQgMTI2KSBvciBcXG4sIFxcciwgXFx0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNCYXNpY0FTQ0lJKHN0cikge1xyXG4gICAgcmV0dXJuIElTX0JBU0lDX0FTQ0lJLnRlc3Qoc3RyKTtcclxufVxyXG5leHBvcnQgY29uc3QgVU5VU1VBTF9MSU5FX1RFUk1JTkFUT1JTID0gL1tcXHUyMDI4XFx1MjAyOV0vOyAvLyBMSU5FIFNFUEFSQVRPUiAoTFMpIG9yIFBBUkFHUkFQSCBTRVBBUkFUT1IgKFBTKVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIHVudXN1YWwgbGluZSB0ZXJtaW5hdG9ycywgbGlrZSBMUyBvciBQU1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycyhzdHIpIHtcclxuICAgIHJldHVybiBVTlVTVUFMX0xJTkVfVEVSTUlOQVRPUlMudGVzdChzdHIpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGxXaWR0aENoYXJhY3RlcihjaGFyQ29kZSkge1xyXG4gICAgLy8gRG8gYSBjaGVhcCB0cmljayB0byBiZXR0ZXIgc3VwcG9ydCB3cmFwcGluZyBvZiB3aWRlIGNoYXJhY3RlcnMsIHRyZWF0IHRoZW0gYXMgMiBjb2x1bW5zXHJcbiAgICAvLyBodHRwOi8vanJncmFwaGl4Lm5ldC9yZXNlYXJjaC91bmljb2RlX2Jsb2Nrcy5waHBcclxuICAgIC8vICAgICAgICAgIDJFODAgLSAyRUZGICAgQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcclxuICAgIC8vICAgICAgICAgIDJGMDAgLSAyRkRGICAgS2FuZ3hpIFJhZGljYWxzXHJcbiAgICAvLyAgICAgICAgICAyRkYwIC0gMkZGRiAgIElkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcclxuICAgIC8vICAgICAgICAgIDMwMDAgLSAzMDNGICAgQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXHJcbiAgICAvLyAgICAgICAgICAzMDQwIC0gMzA5RiAgIEhpcmFnYW5hXHJcbiAgICAvLyAgICAgICAgICAzMEEwIC0gMzBGRiAgIEthdGFrYW5hXHJcbiAgICAvLyAgICAgICAgICAzMTAwIC0gMzEyRiAgIEJvcG9tb2ZvXHJcbiAgICAvLyAgICAgICAgICAzMTMwIC0gMzE4RiAgIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cclxuICAgIC8vICAgICAgICAgIDMxOTAgLSAzMTlGICAgS2FuYnVuXHJcbiAgICAvLyAgICAgICAgICAzMUEwIC0gMzFCRiAgIEJvcG9tb2ZvIEV4dGVuZGVkXHJcbiAgICAvLyAgICAgICAgICAzMUYwIC0gMzFGRiAgIEthdGFrYW5hIFBob25ldGljIEV4dGVuc2lvbnNcclxuICAgIC8vICAgICAgICAgIDMyMDAgLSAzMkZGICAgRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1xyXG4gICAgLy8gICAgICAgICAgMzMwMCAtIDMzRkYgICBDSksgQ29tcGF0aWJpbGl0eVxyXG4gICAgLy8gICAgICAgICAgMzQwMCAtIDREQkYgICBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBBXHJcbiAgICAvLyAgICAgICAgICA0REMwIC0gNERGRiAgIFlpamluZyBIZXhhZ3JhbSBTeW1ib2xzXHJcbiAgICAvLyAgICAgICAgICA0RTAwIC0gOUZGRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcclxuICAgIC8vICAgICAgICAgIEEwMDAgLSBBNDhGICAgWWkgU3lsbGFibGVzXHJcbiAgICAvLyAgICAgICAgICBBNDkwIC0gQTRDRiAgIFlpIFJhZGljYWxzXHJcbiAgICAvLyAgICAgICAgICBBQzAwIC0gRDdBRiAgIEhhbmd1bCBTeWxsYWJsZXNcclxuICAgIC8vIFtJR05PUkVdIEQ4MDAgLSBEQjdGICAgSGlnaCBTdXJyb2dhdGVzXHJcbiAgICAvLyBbSUdOT1JFXSBEQjgwIC0gREJGRiAgIEhpZ2ggUHJpdmF0ZSBVc2UgU3Vycm9nYXRlc1xyXG4gICAgLy8gW0lHTk9SRV0gREMwMCAtIERGRkYgICBMb3cgU3Vycm9nYXRlc1xyXG4gICAgLy8gW0lHTk9SRV0gRTAwMCAtIEY4RkYgICBQcml2YXRlIFVzZSBBcmVhXHJcbiAgICAvLyAgICAgICAgICBGOTAwIC0gRkFGRiAgIENKSyBDb21wYXRpYmlsaXR5IElkZW9ncmFwaHNcclxuICAgIC8vIFtJR05PUkVdIEZCMDAgLSBGQjRGICAgQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcclxuICAgIC8vIFtJR05PUkVdIEZCNTAgLSBGREZGICAgQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXHJcbiAgICAvLyBbSUdOT1JFXSBGRTAwIC0gRkUwRiAgIFZhcmlhdGlvbiBTZWxlY3RvcnNcclxuICAgIC8vIFtJR05PUkVdIEZFMjAgLSBGRTJGICAgQ29tYmluaW5nIEhhbGYgTWFya3NcclxuICAgIC8vIFtJR05PUkVdIEZFMzAgLSBGRTRGICAgQ0pLIENvbXBhdGliaWxpdHkgRm9ybXNcclxuICAgIC8vIFtJR05PUkVdIEZFNTAgLSBGRTZGICAgU21hbGwgRm9ybSBWYXJpYW50c1xyXG4gICAgLy8gW0lHTk9SRV0gRkU3MCAtIEZFRkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcclxuICAgIC8vICAgICAgICAgIEZGMDAgLSBGRkVGICAgSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcclxuICAgIC8vICAgICAgICAgICAgICAgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbGZ3aWR0aF9hbmRfZnVsbHdpZHRoX2Zvcm1zXVxyXG4gICAgLy8gICAgICAgICAgICAgICBvZiB3aGljaCBGRjAxIC0gRkY1RSBmdWxsd2lkdGggQVNDSUkgb2YgMjEgdG8gN0VcclxuICAgIC8vIFtJR05PUkVdICAgIGFuZCBGRjY1IC0gRkZEQyBoYWxmd2lkdGggb2YgS2F0YWthbmEgYW5kIEhhbmd1bFxyXG4gICAgLy8gW0lHTk9SRV0gRkZGMCAtIEZGRkYgICBTcGVjaWFsc1xyXG4gICAgcmV0dXJuICgoY2hhckNvZGUgPj0gMHgyRTgwICYmIGNoYXJDb2RlIDw9IDB4RDdBRilcclxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGOTAwICYmIGNoYXJDb2RlIDw9IDB4RkFGRilcclxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGRjAxICYmIGNoYXJDb2RlIDw9IDB4RkY1RSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGZhc3QgZnVuY3Rpb24gKHRoZXJlZm9yZSBpbXByZWNpc2UpIHRvIGNoZWNrIGlmIGNvZGUgcG9pbnRzIGFyZSBlbW9qaXMuXHJcbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGRpbWEvdW5pY29kZS11dGlscy9ibG9iL21haW4vZW1vamktdGVzdC5qc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1vamlJbXByZWNpc2UoeCkge1xyXG4gICAgcmV0dXJuICgoeCA+PSAweDFGMUU2ICYmIHggPD0gMHgxRjFGRikgfHwgKHggPT09IDg5ODYpIHx8ICh4ID09PSA4OTg3KSB8fCAoeCA9PT0gOTIwMClcclxuICAgICAgICB8fCAoeCA9PT0gOTIwMykgfHwgKHggPj0gOTcyOCAmJiB4IDw9IDEwMTc1KSB8fCAoeCA9PT0gMTEwODgpIHx8ICh4ID09PSAxMTA5MylcclxuICAgICAgICB8fCAoeCA+PSAxMjc3NDQgJiYgeCA8PSAxMjg1OTEpIHx8ICh4ID49IDEyODY0MCAmJiB4IDw9IDEyODc2NClcclxuICAgICAgICB8fCAoeCA+PSAxMjg5OTIgJiYgeCA8PSAxMjkwMDgpIHx8ICh4ID49IDEyOTI4MCAmJiB4IDw9IDEyOTUzNSlcclxuICAgICAgICB8fCAoeCA+PSAxMjk2NDggJiYgeCA8PSAxMjk3ODIpKTtcclxufVxyXG4vLyAtLSBVVEYtOCBCT01cclxuZXhwb3J0IGNvbnN0IFVURjhfQk9NX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjUyNzkgLyogQ2hhckNvZGUuVVRGOF9CT00gKi8pO1xyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aFVURjhCT00oc3RyKSB7XHJcbiAgICByZXR1cm4gISEoc3RyICYmIHN0ci5sZW5ndGggPiAwICYmIHN0ci5jaGFyQ29kZUF0KDApID09PSA2NTI3OSAvKiBDaGFyQ29kZS5VVEY4X0JPTSAqLyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKHRhcmdldCwgaWdub3JlRXNjYXBlZENoYXJzID0gZmFsc2UpIHtcclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlnbm9yZUVzY2FwZWRDaGFycykge1xyXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5yZXBsYWNlKC9cXFxcLi9nLCAnJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0LnRvTG93ZXJDYXNlKCkgIT09IHRhcmdldDtcclxufVxyXG4vKipcclxuICogUHJvZHVjZXMgJ2EnLSd6JywgZm9sbG93ZWQgYnkgJ0EnLSdaJy4uLiBmb2xsb3dlZCBieSAnYSctJ3onLCBldGMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlTGV0dGVySGFzaChuKSB7XHJcbiAgICBjb25zdCBMRVRURVJTX0NOVCA9ICg5MCAvKiBDaGFyQ29kZS5aICovIC0gNjUgLyogQ2hhckNvZGUuQSAqLyArIDEpO1xyXG4gICAgbiA9IG4gJSAoMiAqIExFVFRFUlNfQ05UKTtcclxuICAgIGlmIChuIDwgTEVUVEVSU19DTlQpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyAvKiBDaGFyQ29kZS5hICovICsgbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSAvKiBDaGFyQ29kZS5BICovICsgbiAtIExFVFRFUlNfQ05UKTtcclxufVxyXG5mdW5jdGlvbiBicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShicmVha1R5cGVBLCBicmVha1R5cGVCKSB7XHJcbiAgICAvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jR3JhcGhlbWVfQ2x1c3Rlcl9Cb3VuZGFyeV9SdWxlc1xyXG4gICAgLy8gISEhIExldCdzIG1ha2UgdGhlIGNvbW1vbiBjYXNlIGEgYml0IGZhc3RlclxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDAgLyogR3JhcGhlbWVCcmVha1R5cGUuT3RoZXIgKi8pIHtcclxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LTEzLjAuMGQxMC5odG1sI3RhYmxlXHJcbiAgICAgICAgcmV0dXJuIChicmVha1R5cGVCICE9PSA1IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkV4dGVuZCAqLyAmJiBicmVha1R5cGVCICE9PSA3IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlNwYWNpbmdNYXJrICovKTtcclxuICAgIH1cclxuICAgIC8vIERvIG5vdCBicmVhayBiZXR3ZWVuIGEgQ1IgYW5kIExGLiBPdGhlcndpc2UsIGJyZWFrIGJlZm9yZSBhbmQgYWZ0ZXIgY29udHJvbHMuXHJcbiAgICAvLyBHQjMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1Igw5cgTEZcclxuICAgIC8vIEdCNCAgICAgICAgICAgICAgICAgICAgICAgKENvbnRyb2wgfCBDUiB8IExGKSDDt1xyXG4gICAgLy8gR0I1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIMO3IChDb250cm9sIHwgQ1IgfCBMRilcclxuICAgIGlmIChicmVha1R5cGVBID09PSAyIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNSICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDMgLyogR3JhcGhlbWVCcmVha1R5cGUuTEYgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjNcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5Db250cm9sICovIHx8IGJyZWFrVHlwZUEgPT09IDIgLyogR3JhcGhlbWVCcmVha1R5cGUuQ1IgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMyAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MRiAqLykge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBHQjRcclxuICAgIH1cclxuICAgIGlmIChicmVha1R5cGVCID09PSA0IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNvbnRyb2wgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5DUiAqLyB8fCBicmVha1R5cGVCID09PSAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEdCNVxyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGJyZWFrIEhhbmd1bCBzeWxsYWJsZSBzZXF1ZW5jZXMuXHJcbiAgICAvLyBHQjYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgw5cgKEwgfCBWIHwgTFYgfCBMVlQpXHJcbiAgICAvLyBHQjcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWIHwgVikgw5cgKFYgfCBUKVxyXG4gICAgLy8gR0I4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWVCB8IFQpIMOXIFRcclxuICAgIGlmIChicmVha1R5cGVBID09PSA4IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkwgKi8pIHtcclxuICAgICAgICBpZiAoYnJlYWtUeXBlQiA9PT0gOCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MICovIHx8IGJyZWFrVHlwZUIgPT09IDkgLyogR3JhcGhlbWVCcmVha1R5cGUuViAqLyB8fCBicmVha1R5cGVCID09PSAxMSAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MViAqLyB8fCBicmVha1R5cGVCID09PSAxMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MVlQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjZcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMTEgLyogR3JhcGhlbWVCcmVha1R5cGUuTFYgKi8gfHwgYnJlYWtUeXBlQSA9PT0gOSAvKiBHcmFwaGVtZUJyZWFrVHlwZS5WICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDkgLyogR3JhcGhlbWVCcmVha1R5cGUuViAqLyB8fCBicmVha1R5cGVCID09PSAxMCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I3XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEyIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxWVCAqLyB8fCBicmVha1R5cGVBID09PSAxMCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5UICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDEwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLlQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjhcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEbyBub3QgYnJlYWsgYmVmb3JlIGV4dGVuZGluZyBjaGFyYWN0ZXJzIG9yIFpXSi5cclxuICAgIC8vIEdCOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDlyAoRXh0ZW5kIHwgWldKKVxyXG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDUgLyogR3JhcGhlbWVCcmVha1R5cGUuRXh0ZW5kICovIHx8IGJyZWFrVHlwZUIgPT09IDEzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLlpXSiAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgR0I5YSBhbmQgR0I5YiBydWxlcyBvbmx5IGFwcGx5IHRvIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzOlxyXG4gICAgLy8gRG8gbm90IGJyZWFrIGJlZm9yZSBTcGFjaW5nTWFya3MsIG9yIGFmdGVyIFByZXBlbmQgY2hhcmFjdGVycy5cclxuICAgIC8vIEdCOWEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDlyBTcGFjaW5nTWFya1xyXG4gICAgLy8gR0I5YiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmVwZW5kIMOXXHJcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNyAvKiBHcmFwaGVtZUJyZWFrVHlwZS5TcGFjaW5nTWFyayAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5YVxyXG4gICAgfVxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEgLyogR3JhcGhlbWVCcmVha1R5cGUuUHJlcGVuZCAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5YlxyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBtb2RpZmllciBzZXF1ZW5jZXMgb3IgZW1vamkgendqIHNlcXVlbmNlcy5cclxuICAgIC8vIEdCMTEgICAgXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY30gRXh0ZW5kKiBaV0ogw5cgXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY31cclxuICAgIGlmIChicmVha1R5cGVBID09PSAxMyAvKiBHcmFwaGVtZUJyZWFrVHlwZS5aV0ogKi8gJiYgYnJlYWtUeXBlQiA9PT0gMTQgLyogR3JhcGhlbWVCcmVha1R5cGUuRXh0ZW5kZWRfUGljdG9ncmFwaGljICovKSB7XHJcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUgZW50aXJlbHkgaGVyZSB0byBhdm9pZCBpbnRyb2R1Y2luZyBzdGF0ZXNcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCMTFcclxuICAgIH1cclxuICAgIC8vIEdCMTIgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdCAoUkkgUkkpKiBSSSDDlyBSSVxyXG4gICAgLy8gR0IxMyAgICAgICAgICAgICAgICAgICAgICAgIFteUkldIChSSSBSSSkqIFJJIMOXIFJJXHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5SZWdpb25hbF9JbmRpY2F0b3IgKi8gJiYgYnJlYWtUeXBlQiA9PT0gNiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5SZWdpb25hbF9JbmRpY2F0b3IgKi8pIHtcclxuICAgICAgICAvLyBOb3RlOiB3ZSBhcmUgbm90IGltcGxlbWVudGluZyB0aGUgcnVsZSBlbnRpcmVseSBoZXJlIHRvIGF2b2lkIGludHJvZHVjaW5nIHN0YXRlc1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0IxMiAmIEdCMTNcclxuICAgIH1cclxuICAgIC8vIEdCOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSDDtyBBbnlcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmNsYXNzIEdyYXBoZW1lQnJlYWtUcmVlIHtcclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICBpZiAoIUdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSkge1xyXG4gICAgICAgICAgICBHcmFwaGVtZUJyZWFrVHJlZS5fSU5TVEFOQ0UgPSBuZXcgR3JhcGhlbWVCcmVha1RyZWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBnZXRHcmFwaGVtZUJyZWFrUmF3RGF0YSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0R3JhcGhlbWVCcmVha1R5cGUoY29kZVBvaW50KSB7XHJcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDAuLjMxXHJcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDMyKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MRiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogR3JhcGhlbWVCcmVha1R5cGUuQ1IgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDQgLyogR3JhcGhlbWVCcmVha1R5cGUuQ29udHJvbCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDMyLi4xMjZcclxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMTI3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLk90aGVyICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBjb25zdCBub2RlQ291bnQgPSBkYXRhLmxlbmd0aCAvIDM7XHJcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKG5vZGVJbmRleCA8PSBub2RlQ291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IGRhdGFbMyAqIG5vZGVJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIGxlZnRcclxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IDIgKiBub2RlSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID4gZGF0YVszICogbm9kZUluZGV4ICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSAyICogbm9kZUluZGV4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGhpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMyAqIG5vZGVJbmRleCArIDJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLk90aGVyICovO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldEdyYXBoZW1lQnJlYWtSYXdEYXRhKCkge1xyXG4gICAgLy8gZ2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFpbi9ncmFwaGVtZS1icmVhay5qc1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoJ1swLDAsMCw1MTIyOSw1MTI1NSwxMiw0NDA2MSw0NDA4NywxMiwxMjc0NjIsMTI3NDg3LDYsNzA4Myw3MDg1LDUsNDc2NDUsNDc2NzEsMTIsNTQ4MTMsNTQ4MzksMTIsMTI4Njc4LDEyODY3OCwxNCwzMjcwLDMyNzAsNSw5OTE5LDk5MjMsMTQsNDU4NTMsNDU4NzksMTIsNDk0MzcsNDk0NjMsMTIsNTMwMjEsNTMwNDcsMTIsNzEyMTYsNzEyMTgsNywxMjgzOTgsMTI4Mzk5LDE0LDEyOTM2MCwxMjkzNzQsMTQsMjUxOSwyNTE5LDUsNDQ0OCw0NTE5LDksOTc0Miw5NzQyLDE0LDEyMzM2LDEyMzM2LDE0LDQ0OTU3LDQ0OTgzLDEyLDQ2NzQ5LDQ2Nzc1LDEyLDQ4NTQxLDQ4NTY3LDEyLDUwMzMzLDUwMzU5LDEyLDUyMTI1LDUyMTUxLDEyLDUzOTE3LDUzOTQzLDEyLDY5ODg4LDY5ODkwLDUsNzMwMTgsNzMwMTgsNSwxMjc5OTAsMTI3OTkwLDE0LDEyODU1OCwxMjg1NTksMTQsMTI4NzU5LDEyODc2MCwxNCwxMjk2NTMsMTI5NjU1LDE0LDIwMjcsMjAzNSw1LDI4OTEsMjg5Miw3LDM3NjEsMzc2MSw1LDY2ODMsNjY4Myw1LDgyOTMsODI5Myw0LDk4MjUsOTgyNiwxNCw5OTk5LDk5OTksMTQsNDM0NTIsNDM0NTMsNSw0NDUwOSw0NDUzNSwxMiw0NTQwNSw0NTQzMSwxMiw0NjMwMSw0NjMyNywxMiw0NzE5Nyw0NzIyMywxMiw0ODA5Myw0ODExOSwxMiw0ODk4OSw0OTAxNSwxMiw0OTg4NSw0OTkxMSwxMiw1MDc4MSw1MDgwNywxMiw1MTY3Nyw1MTcwMywxMiw1MjU3Myw1MjU5OSwxMiw1MzQ2OSw1MzQ5NSwxMiw1NDM2NSw1NDM5MSwxMiw2NTI3OSw2NTI3OSw0LDcwNDcxLDcwNDcyLDcsNzIxNDUsNzIxNDcsNywxMTkxNzMsMTE5MTc5LDUsMTI3Nzk5LDEyNzgxOCwxNCwxMjgyNDAsMTI4MjQ0LDE0LDEyODUxMiwxMjg1MTIsMTQsMTI4NjUyLDEyODY1MiwxNCwxMjg3MjEsMTI4NzIyLDE0LDEyOTI5MiwxMjkyOTIsMTQsMTI5NDQ1LDEyOTQ1MCwxNCwxMjk3MzQsMTI5NzQzLDE0LDE0NzYsMTQ3Nyw1LDIzNjYsMjM2OCw3LDI3NTAsMjc1Miw3LDMwNzYsMzA3Niw1LDM0MTUsMzQxNSw1LDQxNDEsNDE0NCw1LDYxMDksNjEwOSw1LDY5NjQsNjk2NCw1LDczOTQsNzQwMCw1LDkxOTcsOTE5OCwxNCw5NzcwLDk3NzAsMTQsOTg3Nyw5ODc3LDE0LDk5NjgsOTk2OSwxNCwxMDA4NCwxMDA4NCwxNCw0MzA1Miw0MzA1Miw1LDQzNzEzLDQzNzEzLDUsNDQyODUsNDQzMTEsMTIsNDQ3MzMsNDQ3NTksMTIsNDUxODEsNDUyMDcsMTIsNDU2MjksNDU2NTUsMTIsNDYwNzcsNDYxMDMsMTIsNDY1MjUsNDY1NTEsMTIsNDY5NzMsNDY5OTksMTIsNDc0MjEsNDc0NDcsMTIsNDc4NjksNDc4OTUsMTIsNDgzMTcsNDgzNDMsMTIsNDg3NjUsNDg3OTEsMTIsNDkyMTMsNDkyMzksMTIsNDk2NjEsNDk2ODcsMTIsNTAxMDksNTAxMzUsMTIsNTA1NTcsNTA1ODMsMTIsNTEwMDUsNTEwMzEsMTIsNTE0NTMsNTE0NzksMTIsNTE5MDEsNTE5MjcsMTIsNTIzNDksNTIzNzUsMTIsNTI3OTcsNTI4MjMsMTIsNTMyNDUsNTMyNzEsMTIsNTM2OTMsNTM3MTksMTIsNTQxNDEsNTQxNjcsMTIsNTQ1ODksNTQ2MTUsMTIsNTUwMzcsNTUwNjMsMTIsNjk1MDYsNjk1MDksNSw3MDE5MSw3MDE5Myw1LDcwODQxLDcwODQxLDcsNzE0NjMsNzE0NjcsNSw3MjMzMCw3MjM0Miw1LDk0MDMxLDk0MDMxLDUsMTIzNjI4LDEyMzYzMSw1LDEyNzc2MywxMjc3NjUsMTQsMTI3OTQxLDEyNzk0MSwxNCwxMjgwNDMsMTI4MDYyLDE0LDEyODMwMiwxMjgzMTcsMTQsMTI4NDY1LDEyODQ2NywxNCwxMjg1MzksMTI4NTM5LDE0LDEyODY0MCwxMjg2NDAsMTQsMTI4NjYyLDEyODY2MiwxNCwxMjg3MDMsMTI4NzAzLDE0LDEyODc0NSwxMjg3NDUsMTQsMTI5MDA0LDEyOTAwNywxNCwxMjkzMjksMTI5MzMwLDE0LDEyOTQwMiwxMjk0MDIsMTQsMTI5NDgzLDEyOTQ4MywxNCwxMjk2ODYsMTI5NzA0LDE0LDEzMDA0OCwxMzEwNjksMTQsMTczLDE3Myw0LDE3NTcsMTc1NywxLDIyMDAsMjIwNyw1LDI0MzQsMjQzNSw3LDI2MzEsMjYzMiw1LDI4MTcsMjgxNyw1LDMwMDgsMzAwOCw1LDMyMDEsMzIwMSw1LDMzODcsMzM4OCw1LDM1NDIsMzU0Miw1LDM5MDIsMzkwMyw3LDQxOTAsNDE5Miw1LDYwMDIsNjAwMyw1LDY0MzksNjQ0MCw1LDY3NjUsNjc3MCw3LDcwMTksNzAyNyw1LDcxNTQsNzE1NSw3LDgyMDUsODIwNSwxMyw4NTA1LDg1MDUsMTQsOTY1NCw5NjU0LDE0LDk3NTcsOTc1NywxNCw5NzkyLDk3OTIsMTQsOTg1Miw5ODUzLDE0LDk4OTAsOTg5NCwxNCw5OTM3LDk5MzcsMTQsOTk4MSw5OTgxLDE0LDEwMDM1LDEwMDM2LDE0LDExMDM1LDExMDM2LDE0LDQyNjU0LDQyNjU1LDUsNDMzNDYsNDMzNDcsNyw0MzU4Nyw0MzU4Nyw1LDQ0MDA2LDQ0MDA3LDcsNDQxNzMsNDQxOTksMTIsNDQzOTcsNDQ0MjMsMTIsNDQ2MjEsNDQ2NDcsMTIsNDQ4NDUsNDQ4NzEsMTIsNDUwNjksNDUwOTUsMTIsNDUyOTMsNDUzMTksMTIsNDU1MTcsNDU1NDMsMTIsNDU3NDEsNDU3NjcsMTIsNDU5NjUsNDU5OTEsMTIsNDYxODksNDYyMTUsMTIsNDY0MTMsNDY0MzksMTIsNDY2MzcsNDY2NjMsMTIsNDY4NjEsNDY4ODcsMTIsNDcwODUsNDcxMTEsMTIsNDczMDksNDczMzUsMTIsNDc1MzMsNDc1NTksMTIsNDc3NTcsNDc3ODMsMTIsNDc5ODEsNDgwMDcsMTIsNDgyMDUsNDgyMzEsMTIsNDg0MjksNDg0NTUsMTIsNDg2NTMsNDg2NzksMTIsNDg4NzcsNDg5MDMsMTIsNDkxMDEsNDkxMjcsMTIsNDkzMjUsNDkzNTEsMTIsNDk1NDksNDk1NzUsMTIsNDk3NzMsNDk3OTksMTIsNDk5OTcsNTAwMjMsMTIsNTAyMjEsNTAyNDcsMTIsNTA0NDUsNTA0NzEsMTIsNTA2NjksNTA2OTUsMTIsNTA4OTMsNTA5MTksMTIsNTExMTcsNTExNDMsMTIsNTEzNDEsNTEzNjcsMTIsNTE1NjUsNTE1OTEsMTIsNTE3ODksNTE4MTUsMTIsNTIwMTMsNTIwMzksMTIsNTIyMzcsNTIyNjMsMTIsNTI0NjEsNTI0ODcsMTIsNTI2ODUsNTI3MTEsMTIsNTI5MDksNTI5MzUsMTIsNTMxMzMsNTMxNTksMTIsNTMzNTcsNTMzODMsMTIsNTM1ODEsNTM2MDcsMTIsNTM4MDUsNTM4MzEsMTIsNTQwMjksNTQwNTUsMTIsNTQyNTMsNTQyNzksMTIsNTQ0NzcsNTQ1MDMsMTIsNTQ3MDEsNTQ3MjcsMTIsNTQ5MjUsNTQ5NTEsMTIsNTUxNDksNTUxNzUsMTIsNjgxMDEsNjgxMDIsNSw2OTc2Miw2OTc2Miw3LDcwMDY3LDcwMDY5LDcsNzAzNzEsNzAzNzgsNSw3MDcyMCw3MDcyMSw3LDcxMDg3LDcxMDg3LDUsNzEzNDEsNzEzNDEsNSw3MTk5NSw3MTk5Niw1LDcyMjQ5LDcyMjQ5LDcsNzI4NTAsNzI4NzEsNSw3MzEwOSw3MzEwOSw1LDExODU3NiwxMTg1OTgsNSwxMjE1MDUsMTIxNTE5LDUsMTI3MjQ1LDEyNzI0NywxNCwxMjc1NjgsMTI3NTY5LDE0LDEyNzc3NywxMjc3NzcsMTQsMTI3ODcyLDEyNzg5MSwxNCwxMjc5NTYsMTI3OTY3LDE0LDEyODAxNSwxMjgwMTYsMTQsMTI4MTEwLDEyODE3MiwxNCwxMjgyNTksMTI4MjU5LDE0LDEyODM2NywxMjgzNjgsMTQsMTI4NDI0LDEyODQyNCwxNCwxMjg0ODgsMTI4NDg4LDE0LDEyODUzMCwxMjg1MzIsMTQsMTI4NTUwLDEyODU1MSwxNCwxMjg1NjYsMTI4NTY2LDE0LDEyODY0NywxMjg2NDcsMTQsMTI4NjU2LDEyODY1NiwxNCwxMjg2NjcsMTI4NjczLDE0LDEyODY5MSwxMjg2OTMsMTQsMTI4NzE1LDEyODcxNSwxNCwxMjg3MjgsMTI4NzMyLDE0LDEyODc1MiwxMjg3NTIsMTQsMTI4NzY1LDEyODc2NywxNCwxMjkwOTYsMTI5MTAzLDE0LDEyOTMxMSwxMjkzMTEsMTQsMTI5MzQ0LDEyOTM0OSwxNCwxMjkzOTQsMTI5Mzk0LDE0LDEyOTQxMywxMjk0MjUsMTQsMTI5NDY2LDEyOTQ3MSwxNCwxMjk1MTEsMTI5NTM1LDE0LDEyOTY2NCwxMjk2NjYsMTQsMTI5NzE5LDEyOTcyMiwxNCwxMjk3NjAsMTI5NzY3LDE0LDkxNzUzNiw5MTc2MzEsNSwxMywxMywyLDExNjAsMTE2MSw1LDE1NjQsMTU2NCw0LDE4MDcsMTgwNywxLDIwODUsMjA4Nyw1LDIzMDcsMjMwNyw3LDIzODIsMjM4Myw3LDI0OTcsMjUwMCw1LDI1NjMsMjU2Myw3LDI2NzcsMjY3Nyw1LDI3NjMsMjc2NCw3LDI4NzksMjg3OSw1LDI5MTQsMjkxNSw1LDMwMjEsMzAyMSw1LDMxNDIsMzE0NCw1LDMyNjMsMzI2Myw1LDMyODUsMzI4Niw1LDMzOTgsMzQwMCw3LDM1MzAsMzUzMCw1LDM2MzMsMzYzMyw1LDM4NjQsMzg2NSw1LDM5NzQsMzk3NSw1LDQxNTUsNDE1Niw3LDQyMjksNDIzMCw1LDU5MDksNTkwOSw3LDYwNzgsNjA4NSw3LDYyNzcsNjI3OCw1LDY0NTEsNjQ1Niw3LDY3NDQsNjc1MCw1LDY4NDYsNjg0Niw1LDY5NzIsNjk3Miw1LDcwNzQsNzA3Nyw1LDcxNDYsNzE0OCw3LDcyMjIsNzIyMyw1LDc0MTYsNzQxNyw1LDgyMzQsODIzOCw0LDg0MTcsODQxNyw1LDkwMDAsOTAwMCwxNCw5MjAzLDkyMDMsMTQsOTczMCw5NzMxLDE0LDk3NDgsOTc0OSwxNCw5NzYyLDk3NjMsMTQsOTc3Niw5NzgzLDE0LDk4MDAsOTgxMSwxNCw5ODMxLDk4MzEsMTQsOTg3Miw5ODczLDE0LDk4ODIsOTg4MiwxNCw5OTAwLDk5MDMsMTQsOTkyOSw5OTMzLDE0LDk5NDEsOTk2MCwxNCw5OTc0LDk5NzQsMTQsOTk4OSw5OTg5LDE0LDEwMDA2LDEwMDA2LDE0LDEwMDYyLDEwMDYyLDE0LDEwMTYwLDEwMTYwLDE0LDExNjQ3LDExNjQ3LDUsMTI5NTMsMTI5NTMsMTQsNDMwMTksNDMwMTksNSw0MzIzMiw0MzI0OSw1LDQzNDQzLDQzNDQzLDUsNDM1NjcsNDM1NjgsNyw0MzY5Niw0MzY5Niw1LDQzNzY1LDQzNzY1LDcsNDQwMTMsNDQwMTMsNSw0NDExNyw0NDE0MywxMiw0NDIyOSw0NDI1NSwxMiw0NDM0MSw0NDM2NywxMiw0NDQ1Myw0NDQ3OSwxMiw0NDU2NSw0NDU5MSwxMiw0NDY3Nyw0NDcwMywxMiw0NDc4OSw0NDgxNSwxMiw0NDkwMSw0NDkyNywxMiw0NTAxMyw0NTAzOSwxMiw0NTEyNSw0NTE1MSwxMiw0NTIzNyw0NTI2MywxMiw0NTM0OSw0NTM3NSwxMiw0NTQ2MSw0NTQ4NywxMiw0NTU3Myw0NTU5OSwxMiw0NTY4NSw0NTcxMSwxMiw0NTc5Nyw0NTgyMywxMiw0NTkwOSw0NTkzNSwxMiw0NjAyMSw0NjA0NywxMiw0NjEzMyw0NjE1OSwxMiw0NjI0NSw0NjI3MSwxMiw0NjM1Nyw0NjM4MywxMiw0NjQ2OSw0NjQ5NSwxMiw0NjU4MSw0NjYwNywxMiw0NjY5Myw0NjcxOSwxMiw0NjgwNSw0NjgzMSwxMiw0NjkxNyw0Njk0MywxMiw0NzAyOSw0NzA1NSwxMiw0NzE0MSw0NzE2NywxMiw0NzI1Myw0NzI3OSwxMiw0NzM2NSw0NzM5MSwxMiw0NzQ3Nyw0NzUwMywxMiw0NzU4OSw0NzYxNSwxMiw0NzcwMSw0NzcyNywxMiw0NzgxMyw0NzgzOSwxMiw0NzkyNSw0Nzk1MSwxMiw0ODAzNyw0ODA2MywxMiw0ODE0OSw0ODE3NSwxMiw0ODI2MSw0ODI4NywxMiw0ODM3Myw0ODM5OSwxMiw0ODQ4NSw0ODUxMSwxMiw0ODU5Nyw0ODYyMywxMiw0ODcwOSw0ODczNSwxMiw0ODgyMSw0ODg0NywxMiw0ODkzMyw0ODk1OSwxMiw0OTA0NSw0OTA3MSwxMiw0OTE1Nyw0OTE4MywxMiw0OTI2OSw0OTI5NSwxMiw0OTM4MSw0OTQwNywxMiw0OTQ5Myw0OTUxOSwxMiw0OTYwNSw0OTYzMSwxMiw0OTcxNyw0OTc0MywxMiw0OTgyOSw0OTg1NSwxMiw0OTk0MSw0OTk2NywxMiw1MDA1Myw1MDA3OSwxMiw1MDE2NSw1MDE5MSwxMiw1MDI3Nyw1MDMwMywxMiw1MDM4OSw1MDQxNSwxMiw1MDUwMSw1MDUyNywxMiw1MDYxMyw1MDYzOSwxMiw1MDcyNSw1MDc1MSwxMiw1MDgzNyw1MDg2MywxMiw1MDk0OSw1MDk3NSwxMiw1MTA2MSw1MTA4NywxMiw1MTE3Myw1MTE5OSwxMiw1MTI4NSw1MTMxMSwxMiw1MTM5Nyw1MTQyMywxMiw1MTUwOSw1MTUzNSwxMiw1MTYyMSw1MTY0NywxMiw1MTczMyw1MTc1OSwxMiw1MTg0NSw1MTg3MSwxMiw1MTk1Nyw1MTk4MywxMiw1MjA2OSw1MjA5NSwxMiw1MjE4MSw1MjIwNywxMiw1MjI5Myw1MjMxOSwxMiw1MjQwNSw1MjQzMSwxMiw1MjUxNyw1MjU0MywxMiw1MjYyOSw1MjY1NSwxMiw1Mjc0MSw1Mjc2NywxMiw1Mjg1Myw1Mjg3OSwxMiw1Mjk2NSw1Mjk5MSwxMiw1MzA3Nyw1MzEwMywxMiw1MzE4OSw1MzIxNSwxMiw1MzMwMSw1MzMyNywxMiw1MzQxMyw1MzQzOSwxMiw1MzUyNSw1MzU1MSwxMiw1MzYzNyw1MzY2MywxMiw1Mzc0OSw1Mzc3NSwxMiw1Mzg2MSw1Mzg4NywxMiw1Mzk3Myw1Mzk5OSwxMiw1NDA4NSw1NDExMSwxMiw1NDE5Nyw1NDIyMywxMiw1NDMwOSw1NDMzNSwxMiw1NDQyMSw1NDQ0NywxMiw1NDUzMyw1NDU1OSwxMiw1NDY0NSw1NDY3MSwxMiw1NDc1Nyw1NDc4MywxMiw1NDg2OSw1NDg5NSwxMiw1NDk4MSw1NTAwNywxMiw1NTA5Myw1NTExOSwxMiw1NTI0Myw1NTI5MSwxMCw2NjA0NSw2NjA0NSw1LDY4MzI1LDY4MzI2LDUsNjk2ODgsNjk3MDIsNSw2OTgxNyw2OTgxOCw1LDY5OTU3LDY5OTU4LDcsNzAwODksNzAwOTIsNSw3MDE5OCw3MDE5OSw1LDcwNDYyLDcwNDYyLDUsNzA1MDIsNzA1MDgsNSw3MDc1MCw3MDc1MCw1LDcwODQ2LDcwODQ2LDcsNzExMDAsNzExMDEsNSw3MTIzMCw3MTIzMCw3LDcxMzUxLDcxMzUxLDUsNzE3MzcsNzE3MzgsNSw3MjAwMCw3MjAwMCw3LDcyMTYwLDcyMTYwLDUsNzIyNzMsNzIyNzgsNSw3Mjc1Miw3Mjc1OCw1LDcyODgyLDcyODgzLDUsNzMwMzEsNzMwMzEsNSw3MzQ2MSw3MzQ2Miw3LDk0MTkyLDk0MTkzLDcsMTE5MTQ5LDExOTE0OSw3LDEyMTQwMywxMjE0NTIsNSwxMjI5MTUsMTIyOTE2LDUsMTI2OTgwLDEyNjk4MCwxNCwxMjczNTgsMTI3MzU5LDE0LDEyNzUzNSwxMjc1MzUsMTQsMTI3NzU5LDEyNzc1OSwxNCwxMjc3NzEsMTI3NzcxLDE0LDEyNzc5MiwxMjc3OTMsMTQsMTI3ODI1LDEyNzg2NywxNCwxMjc4OTcsMTI3ODk5LDE0LDEyNzk0NSwxMjc5NDUsMTQsMTI3OTg1LDEyNzk4NiwxNCwxMjgwMDAsMTI4MDA3LDE0LDEyODAyMSwxMjgwMjEsMTQsMTI4MDY2LDEyODEwMCwxNCwxMjgxODQsMTI4MjM1LDE0LDEyODI0OSwxMjgyNTIsMTQsMTI4MjY2LDEyODI3NiwxNCwxMjgzMzUsMTI4MzM1LDE0LDEyODM3OSwxMjgzOTAsMTQsMTI4NDA3LDEyODQxOSwxNCwxMjg0NDQsMTI4NDQ0LDE0LDEyODQ4MSwxMjg0ODEsMTQsMTI4NDk5LDEyODQ5OSwxNCwxMjg1MjYsMTI4NTI2LDE0LDEyODUzNiwxMjg1MzYsMTQsMTI4NTQzLDEyODU0MywxNCwxMjg1NTYsMTI4NTU2LDE0LDEyODU2NCwxMjg1NjQsMTQsMTI4NTc3LDEyODU4MCwxNCwxMjg2NDMsMTI4NjQ1LDE0LDEyODY0OSwxMjg2NDksMTQsMTI4NjU0LDEyODY1NCwxNCwxMjg2NjAsMTI4NjYwLDE0LDEyODY2NCwxMjg2NjQsMTQsMTI4Njc1LDEyODY3NSwxNCwxMjg2ODYsMTI4Njg5LDE0LDEyODY5NSwxMjg2OTYsMTQsMTI4NzA1LDEyODcwOSwxNCwxMjg3MTcsMTI4NzE5LDE0LDEyODcyNSwxMjg3MjUsMTQsMTI4NzM2LDEyODc0MSwxNCwxMjg3NDcsMTI4NzQ4LDE0LDEyODc1NSwxMjg3NTUsMTQsMTI4NzYyLDEyODc2MiwxNCwxMjg5ODEsMTI4OTkxLDE0LDEyOTAwOSwxMjkwMjMsMTQsMTI5MTYwLDEyOTE2NywxNCwxMjkyOTYsMTI5MzA0LDE0LDEyOTMyMCwxMjkzMjcsMTQsMTI5MzQwLDEyOTM0MiwxNCwxMjkzNTYsMTI5MzU2LDE0LDEyOTM4OCwxMjkzOTIsMTQsMTI5Mzk5LDEyOTQwMCwxNCwxMjk0MDQsMTI5NDA3LDE0LDEyOTQzMiwxMjk0NDIsMTQsMTI5NDU0LDEyOTQ1NSwxNCwxMjk0NzMsMTI5NDc0LDE0LDEyOTQ4NSwxMjk0ODcsMTQsMTI5NjQ4LDEyOTY1MSwxNCwxMjk2NTksMTI5NjYwLDE0LDEyOTY3MSwxMjk2NzksMTQsMTI5NzA5LDEyOTcxMSwxNCwxMjk3MjgsMTI5NzMwLDE0LDEyOTc1MSwxMjk3NTMsMTQsMTI5Nzc2LDEyOTc4MiwxNCw5MTc1MDUsOTE3NTA1LDQsOTE3NzYwLDkxNzk5OSw1LDEwLDEwLDMsMTI3LDE1OSw0LDc2OCw4NzksNSwxNDcxLDE0NzEsNSwxNTM2LDE1NDEsMSwxNjQ4LDE2NDgsNSwxNzY3LDE3NjgsNSwxODQwLDE4NjYsNSwyMDcwLDIwNzMsNSwyMTM3LDIxMzksNSwyMjc0LDIyNzQsMSwyMzYzLDIzNjMsNywyMzc3LDIzODAsNywyNDAyLDI0MDMsNSwyNDk0LDI0OTQsNSwyNTA3LDI1MDgsNywyNTU4LDI1NTgsNSwyNjIyLDI2MjQsNywyNjQxLDI2NDEsNSwyNjkxLDI2OTEsNywyNzU5LDI3NjAsNSwyNzg2LDI3ODcsNSwyODc2LDI4NzYsNSwyODgxLDI4ODQsNSwyOTAxLDI5MDIsNSwzMDA2LDMwMDYsNSwzMDE0LDMwMTYsNywzMDcyLDMwNzIsNSwzMTM0LDMxMzYsNSwzMTU3LDMxNTgsNSwzMjYwLDMyNjAsNSwzMjY2LDMyNjYsNSwzMjc0LDMyNzUsNywzMzI4LDMzMjksNSwzMzkxLDMzOTIsNywzNDA1LDM0MDUsNSwzNDU3LDM0NTcsNSwzNTM2LDM1MzcsNywzNTUxLDM1NTEsNSwzNjM2LDM2NDIsNSwzNzY0LDM3NzIsNSwzODk1LDM4OTUsNSwzOTY3LDM5NjcsNywzOTkzLDQwMjgsNSw0MTQ2LDQxNTEsNSw0MTgyLDQxODMsNyw0MjI2LDQyMjYsNSw0MjUzLDQyNTMsNSw0OTU3LDQ5NTksNSw1OTQwLDU5NDAsNyw2MDcwLDYwNzAsNyw2MDg3LDYwODgsNyw2MTU4LDYxNTgsNCw2NDMyLDY0MzQsNSw2NDQ4LDY0NDksNyw2Njc5LDY2ODAsNSw2NzQyLDY3NDIsNSw2NzU0LDY3NTQsNSw2NzgzLDY3ODMsNSw2OTEyLDY5MTUsNSw2OTY2LDY5NzAsNSw2OTc4LDY5NzgsNSw3MDQyLDcwNDIsNyw3MDgwLDcwODEsNSw3MTQzLDcxNDMsNyw3MTUwLDcxNTAsNyw3MjEyLDcyMTksNSw3MzgwLDczOTIsNSw3NDEyLDc0MTIsNSw4MjAzLDgyMDMsNCw4MjMyLDgyMzIsNCw4MjY1LDgyNjUsMTQsODQwMCw4NDEyLDUsODQyMSw4NDMyLDUsODYxNyw4NjE4LDE0LDkxNjcsOTE2NywxNCw5MjAwLDkyMDAsMTQsOTQxMCw5NDEwLDE0LDk3MjMsOTcyNiwxNCw5NzMzLDk3MzMsMTQsOTc0NSw5NzQ1LDE0LDk3NTIsOTc1MiwxNCw5NzYwLDk3NjAsMTQsOTc2Niw5NzY2LDE0LDk3NzQsOTc3NCwxNCw5Nzg2LDk3ODYsMTQsOTc5NCw5Nzk0LDE0LDk4MjMsOTgyMywxNCw5ODI4LDk4MjgsMTQsOTgzMyw5ODUwLDE0LDk4NTUsOTg1NSwxNCw5ODc1LDk4NzUsMTQsOTg4MCw5ODgwLDE0LDk4ODUsOTg4NywxNCw5ODk2LDk4OTcsMTQsOTkwNiw5OTE2LDE0LDk5MjYsOTkyNywxNCw5OTM1LDk5MzUsMTQsOTkzOSw5OTM5LDE0LDk5NjIsOTk2MiwxNCw5OTcyLDk5NzIsMTQsOTk3OCw5OTc4LDE0LDk5ODYsOTk4NiwxNCw5OTk3LDk5OTcsMTQsMTAwMDIsMTAwMDIsMTQsMTAwMTcsMTAwMTcsMTQsMTAwNTUsMTAwNTUsMTQsMTAwNzEsMTAwNzEsMTQsMTAxMzMsMTAxMzUsMTQsMTA1NDgsMTA1NDksMTQsMTEwOTMsMTEwOTMsMTQsMTIzMzAsMTIzMzMsNSwxMjQ0MSwxMjQ0Miw1LDQyNjA4LDQyNjEwLDUsNDMwMTAsNDMwMTAsNSw0MzA0NSw0MzA0Niw1LDQzMTg4LDQzMjAzLDcsNDMzMDIsNDMzMDksNSw0MzM5Miw0MzM5NCw1LDQzNDQ2LDQzNDQ5LDUsNDM0OTMsNDM0OTMsNSw0MzU3MSw0MzU3Miw3LDQzNTk3LDQzNTk3LDcsNDM3MDMsNDM3MDQsNSw0Mzc1Niw0Mzc1Nyw1LDQ0MDAzLDQ0MDA0LDcsNDQwMDksNDQwMTAsNyw0NDAzMyw0NDA1OSwxMiw0NDA4OSw0NDExNSwxMiw0NDE0NSw0NDE3MSwxMiw0NDIwMSw0NDIyNywxMiw0NDI1Nyw0NDI4MywxMiw0NDMxMyw0NDMzOSwxMiw0NDM2OSw0NDM5NSwxMiw0NDQyNSw0NDQ1MSwxMiw0NDQ4MSw0NDUwNywxMiw0NDUzNyw0NDU2MywxMiw0NDU5Myw0NDYxOSwxMiw0NDY0OSw0NDY3NSwxMiw0NDcwNSw0NDczMSwxMiw0NDc2MSw0NDc4NywxMiw0NDgxNyw0NDg0MywxMiw0NDg3Myw0NDg5OSwxMiw0NDkyOSw0NDk1NSwxMiw0NDk4NSw0NTAxMSwxMiw0NTA0MSw0NTA2NywxMiw0NTA5Nyw0NTEyMywxMiw0NTE1Myw0NTE3OSwxMiw0NTIwOSw0NTIzNSwxMiw0NTI2NSw0NTI5MSwxMiw0NTMyMSw0NTM0NywxMiw0NTM3Nyw0NTQwMywxMiw0NTQzMyw0NTQ1OSwxMiw0NTQ4OSw0NTUxNSwxMiw0NTU0NSw0NTU3MSwxMiw0NTYwMSw0NTYyNywxMiw0NTY1Nyw0NTY4MywxMiw0NTcxMyw0NTczOSwxMiw0NTc2OSw0NTc5NSwxMiw0NTgyNSw0NTg1MSwxMiw0NTg4MSw0NTkwNywxMiw0NTkzNyw0NTk2MywxMiw0NTk5Myw0NjAxOSwxMiw0NjA0OSw0NjA3NSwxMiw0NjEwNSw0NjEzMSwxMiw0NjE2MSw0NjE4NywxMiw0NjIxNyw0NjI0MywxMiw0NjI3Myw0NjI5OSwxMiw0NjMyOSw0NjM1NSwxMiw0NjM4NSw0NjQxMSwxMiw0NjQ0MSw0NjQ2NywxMiw0NjQ5Nyw0NjUyMywxMiw0NjU1Myw0NjU3OSwxMiw0NjYwOSw0NjYzNSwxMiw0NjY2NSw0NjY5MSwxMiw0NjcyMSw0Njc0NywxMiw0Njc3Nyw0NjgwMywxMiw0NjgzMyw0Njg1OSwxMiw0Njg4OSw0NjkxNSwxMiw0Njk0NSw0Njk3MSwxMiw0NzAwMSw0NzAyNywxMiw0NzA1Nyw0NzA4MywxMiw0NzExMyw0NzEzOSwxMiw0NzE2OSw0NzE5NSwxMiw0NzIyNSw0NzI1MSwxMiw0NzI4MSw0NzMwNywxMiw0NzMzNyw0NzM2MywxMiw0NzM5Myw0NzQxOSwxMiw0NzQ0OSw0NzQ3NSwxMiw0NzUwNSw0NzUzMSwxMiw0NzU2MSw0NzU4NywxMiw0NzYxNyw0NzY0MywxMiw0NzY3Myw0NzY5OSwxMiw0NzcyOSw0Nzc1NSwxMiw0Nzc4NSw0NzgxMSwxMiw0Nzg0MSw0Nzg2NywxMiw0Nzg5Nyw0NzkyMywxMiw0Nzk1Myw0Nzk3OSwxMiw0ODAwOSw0ODAzNSwxMiw0ODA2NSw0ODA5MSwxMiw0ODEyMSw0ODE0NywxMiw0ODE3Nyw0ODIwMywxMiw0ODIzMyw0ODI1OSwxMiw0ODI4OSw0ODMxNSwxMiw0ODM0NSw0ODM3MSwxMiw0ODQwMSw0ODQyNywxMiw0ODQ1Nyw0ODQ4MywxMiw0ODUxMyw0ODUzOSwxMiw0ODU2OSw0ODU5NSwxMiw0ODYyNSw0ODY1MSwxMiw0ODY4MSw0ODcwNywxMiw0ODczNyw0ODc2MywxMiw0ODc5Myw0ODgxOSwxMiw0ODg0OSw0ODg3NSwxMiw0ODkwNSw0ODkzMSwxMiw0ODk2MSw0ODk4NywxMiw0OTAxNyw0OTA0MywxMiw0OTA3Myw0OTA5OSwxMiw0OTEyOSw0OTE1NSwxMiw0OTE4NSw0OTIxMSwxMiw0OTI0MSw0OTI2NywxMiw0OTI5Nyw0OTMyMywxMiw0OTM1Myw0OTM3OSwxMiw0OTQwOSw0OTQzNSwxMiw0OTQ2NSw0OTQ5MSwxMiw0OTUyMSw0OTU0NywxMiw0OTU3Nyw0OTYwMywxMiw0OTYzMyw0OTY1OSwxMiw0OTY4OSw0OTcxNSwxMiw0OTc0NSw0OTc3MSwxMiw0OTgwMSw0OTgyNywxMiw0OTg1Nyw0OTg4MywxMiw0OTkxMyw0OTkzOSwxMiw0OTk2OSw0OTk5NSwxMiw1MDAyNSw1MDA1MSwxMiw1MDA4MSw1MDEwNywxMiw1MDEzNyw1MDE2MywxMiw1MDE5Myw1MDIxOSwxMiw1MDI0OSw1MDI3NSwxMiw1MDMwNSw1MDMzMSwxMiw1MDM2MSw1MDM4NywxMiw1MDQxNyw1MDQ0MywxMiw1MDQ3Myw1MDQ5OSwxMiw1MDUyOSw1MDU1NSwxMiw1MDU4NSw1MDYxMSwxMiw1MDY0MSw1MDY2NywxMiw1MDY5Nyw1MDcyMywxMiw1MDc1Myw1MDc3OSwxMiw1MDgwOSw1MDgzNSwxMiw1MDg2NSw1MDg5MSwxMiw1MDkyMSw1MDk0NywxMiw1MDk3Nyw1MTAwMywxMiw1MTAzMyw1MTA1OSwxMiw1MTA4OSw1MTExNSwxMiw1MTE0NSw1MTE3MSwxMiw1MTIwMSw1MTIyNywxMiw1MTI1Nyw1MTI4MywxMiw1MTMxMyw1MTMzOSwxMiw1MTM2OSw1MTM5NSwxMiw1MTQyNSw1MTQ1MSwxMiw1MTQ4MSw1MTUwNywxMiw1MTUzNyw1MTU2MywxMiw1MTU5Myw1MTYxOSwxMiw1MTY0OSw1MTY3NSwxMiw1MTcwNSw1MTczMSwxMiw1MTc2MSw1MTc4NywxMiw1MTgxNyw1MTg0MywxMiw1MTg3Myw1MTg5OSwxMiw1MTkyOSw1MTk1NSwxMiw1MTk4NSw1MjAxMSwxMiw1MjA0MSw1MjA2NywxMiw1MjA5Nyw1MjEyMywxMiw1MjE1Myw1MjE3OSwxMiw1MjIwOSw1MjIzNSwxMiw1MjI2NSw1MjI5MSwxMiw1MjMyMSw1MjM0NywxMiw1MjM3Nyw1MjQwMywxMiw1MjQzMyw1MjQ1OSwxMiw1MjQ4OSw1MjUxNSwxMiw1MjU0NSw1MjU3MSwxMiw1MjYwMSw1MjYyNywxMiw1MjY1Nyw1MjY4MywxMiw1MjcxMyw1MjczOSwxMiw1Mjc2OSw1Mjc5NSwxMiw1MjgyNSw1Mjg1MSwxMiw1Mjg4MSw1MjkwNywxMiw1MjkzNyw1Mjk2MywxMiw1Mjk5Myw1MzAxOSwxMiw1MzA0OSw1MzA3NSwxMiw1MzEwNSw1MzEzMSwxMiw1MzE2MSw1MzE4NywxMiw1MzIxNyw1MzI0MywxMiw1MzI3Myw1MzI5OSwxMiw1MzMyOSw1MzM1NSwxMiw1MzM4NSw1MzQxMSwxMiw1MzQ0MSw1MzQ2NywxMiw1MzQ5Nyw1MzUyMywxMiw1MzU1Myw1MzU3OSwxMiw1MzYwOSw1MzYzNSwxMiw1MzY2NSw1MzY5MSwxMiw1MzcyMSw1Mzc0NywxMiw1Mzc3Nyw1MzgwMywxMiw1MzgzMyw1Mzg1OSwxMiw1Mzg4OSw1MzkxNSwxMiw1Mzk0NSw1Mzk3MSwxMiw1NDAwMSw1NDAyNywxMiw1NDA1Nyw1NDA4MywxMiw1NDExMyw1NDEzOSwxMiw1NDE2OSw1NDE5NSwxMiw1NDIyNSw1NDI1MSwxMiw1NDI4MSw1NDMwNywxMiw1NDMzNyw1NDM2MywxMiw1NDM5Myw1NDQxOSwxMiw1NDQ0OSw1NDQ3NSwxMiw1NDUwNSw1NDUzMSwxMiw1NDU2MSw1NDU4NywxMiw1NDYxNyw1NDY0MywxMiw1NDY3Myw1NDY5OSwxMiw1NDcyOSw1NDc1NSwxMiw1NDc4NSw1NDgxMSwxMiw1NDg0MSw1NDg2NywxMiw1NDg5Nyw1NDkyMywxMiw1NDk1Myw1NDk3OSwxMiw1NTAwOSw1NTAzNSwxMiw1NTA2NSw1NTA5MSwxMiw1NTEyMSw1NTE0NywxMiw1NTE3Nyw1NTIwMywxMiw2NTAyNCw2NTAzOSw1LDY1NTIwLDY1NTI4LDQsNjY0MjIsNjY0MjYsNSw2ODE1Miw2ODE1NCw1LDY5MjkxLDY5MjkyLDUsNjk2MzMsNjk2MzMsNSw2OTc0Nyw2OTc0OCw1LDY5ODExLDY5ODE0LDUsNjk4MjYsNjk4MjYsNSw2OTkzMiw2OTkzMiw3LDcwMDE2LDcwMDE3LDUsNzAwNzksNzAwODAsNyw3MDA5NSw3MDA5NSw1LDcwMTk2LDcwMTk2LDUsNzAzNjcsNzAzNjcsNSw3MDQwMiw3MDQwMyw3LDcwNDY0LDcwNDY0LDUsNzA0ODcsNzA0ODcsNSw3MDcwOSw3MDcxMSw3LDcwNzI1LDcwNzI1LDcsNzA4MzMsNzA4MzQsNyw3MDg0Myw3MDg0NCw3LDcwODQ5LDcwODQ5LDcsNzEwOTAsNzEwOTMsNSw3MTEwMyw3MTEwNCw1LDcxMjI3LDcxMjI4LDcsNzEzMzksNzEzMzksNSw3MTM0NCw3MTM0OSw1LDcxNDU4LDcxNDYxLDUsNzE3MjcsNzE3MzUsNSw3MTk4NSw3MTk4OSw3LDcxOTk4LDcxOTk4LDUsNzIwMDIsNzIwMDIsNyw3MjE1NCw3MjE1NSw1LDcyMTkzLDcyMjAyLDUsNzIyNTEsNzIyNTQsNSw3MjI4MSw3MjI4Myw1LDcyMzQ0LDcyMzQ1LDUsNzI3NjYsNzI3NjYsNyw3Mjg3NCw3Mjg4MCw1LDcyODg1LDcyODg2LDUsNzMwMjMsNzMwMjksNSw3MzEwNCw3MzEwNSw1LDczMTExLDczMTExLDUsOTI5MTIsOTI5MTYsNSw5NDA5NSw5NDA5OCw1LDExMzgyNCwxMTM4MjcsNCwxMTkxNDIsMTE5MTQyLDcsMTE5MTU1LDExOTE2Miw0LDExOTM2MiwxMTkzNjQsNSwxMjE0NzYsMTIxNDc2LDUsMTIyODg4LDEyMjkwNCw1LDEyMzE4NCwxMjMxOTAsNSwxMjUyNTIsMTI1MjU4LDUsMTI3MTgzLDEyNzE4MywxNCwxMjczNDAsMTI3MzQzLDE0LDEyNzM3NywxMjczODYsMTQsMTI3NDkxLDEyNzUwMywxNCwxMjc1NDgsMTI3NTUxLDE0LDEyNzc0NCwxMjc3NTYsMTQsMTI3NzYxLDEyNzc2MSwxNCwxMjc3NjksMTI3NzY5LDE0LDEyNzc3MywxMjc3NzQsMTQsMTI3NzgwLDEyNzc4OCwxNCwxMjc3OTYsMTI3Nzk3LDE0LDEyNzgyMCwxMjc4MjMsMTQsMTI3ODY5LDEyNzg2OSwxNCwxMjc4OTQsMTI3ODk1LDE0LDEyNzkwMiwxMjc5MDMsMTQsMTI3OTQzLDEyNzk0MywxNCwxMjc5NDcsMTI3OTUwLDE0LDEyNzk3MiwxMjc5NzIsMTQsMTI3OTg4LDEyNzk4OCwxNCwxMjc5OTIsMTI3OTk0LDE0LDEyODAwOSwxMjgwMTEsMTQsMTI4MDE5LDEyODAxOSwxNCwxMjgwMjMsMTI4MDQxLDE0LDEyODA2NCwxMjgwNjQsMTQsMTI4MTAyLDEyODEwNywxNCwxMjgxNzQsMTI4MTgxLDE0LDEyODIzOCwxMjgyMzgsMTQsMTI4MjQ2LDEyODI0NywxNCwxMjgyNTQsMTI4MjU0LDE0LDEyODI2NCwxMjgyNjQsMTQsMTI4Mjc4LDEyODI5OSwxNCwxMjgzMjksMTI4MzMwLDE0LDEyODM0OCwxMjgzNTksMTQsMTI4MzcxLDEyODM3NywxNCwxMjgzOTIsMTI4MzkzLDE0LDEyODQwMSwxMjg0MDQsMTQsMTI4NDIxLDEyODQyMSwxNCwxMjg0MzMsMTI4NDM0LDE0LDEyODQ1MCwxMjg0NTIsMTQsMTI4NDc2LDEyODQ3OCwxNCwxMjg0ODMsMTI4NDgzLDE0LDEyODQ5NSwxMjg0OTUsMTQsMTI4NTA2LDEyODUwNiwxNCwxMjg1MTksMTI4NTIwLDE0LDEyODUyOCwxMjg1MjgsMTQsMTI4NTM0LDEyODUzNCwxNCwxMjg1MzgsMTI4NTM4LDE0LDEyODU0MCwxMjg1NDIsMTQsMTI4NTQ0LDEyODU0OSwxNCwxMjg1NTIsMTI4NTU1LDE0LDEyODU1NywxMjg1NTcsMTQsMTI4NTYwLDEyODU2MywxNCwxMjg1NjUsMTI4NTY1LDE0LDEyODU2NywxMjg1NzYsMTQsMTI4NTgxLDEyODU5MSwxNCwxMjg2NDEsMTI4NjQyLDE0LDEyODY0NiwxMjg2NDYsMTQsMTI4NjQ4LDEyODY0OCwxNCwxMjg2NTAsMTI4NjUxLDE0LDEyODY1MywxMjg2NTMsMTQsMTI4NjU1LDEyODY1NSwxNCwxMjg2NTcsMTI4NjU5LDE0LDEyODY2MSwxMjg2NjEsMTQsMTI4NjYzLDEyODY2MywxNCwxMjg2NjUsMTI4NjY2LDE0LDEyODY3NCwxMjg2NzQsMTQsMTI4Njc2LDEyODY3NywxNCwxMjg2NzksMTI4Njg1LDE0LDEyODY5MCwxMjg2OTAsMTQsMTI4Njk0LDEyODY5NCwxNCwxMjg2OTcsMTI4NzAyLDE0LDEyODcwNCwxMjg3MDQsMTQsMTI4NzEwLDEyODcxNCwxNCwxMjg3MTYsMTI4NzE2LDE0LDEyODcyMCwxMjg3MjAsMTQsMTI4NzIzLDEyODcyNCwxNCwxMjg3MjYsMTI4NzI3LDE0LDEyODczMywxMjg3MzUsMTQsMTI4NzQyLDEyODc0NCwxNCwxMjg3NDYsMTI4NzQ2LDE0LDEyODc0OSwxMjg3NTEsMTQsMTI4NzUzLDEyODc1NCwxNCwxMjg3NTYsMTI4NzU4LDE0LDEyODc2MSwxMjg3NjEsMTQsMTI4NzYzLDEyODc2NCwxNCwxMjg4ODQsMTI4ODk1LDE0LDEyODk5MiwxMjkwMDMsMTQsMTI5MDA4LDEyOTAwOCwxNCwxMjkwMzYsMTI5MDM5LDE0LDEyOTExNCwxMjkxMTksMTQsMTI5MTk4LDEyOTI3OSwxNCwxMjkyOTMsMTI5Mjk1LDE0LDEyOTMwNSwxMjkzMTAsMTQsMTI5MzEyLDEyOTMxOSwxNCwxMjkzMjgsMTI5MzI4LDE0LDEyOTMzMSwxMjkzMzgsMTQsMTI5MzQzLDEyOTM0MywxNCwxMjkzNTEsMTI5MzU1LDE0LDEyOTM1NywxMjkzNTksMTQsMTI5Mzc1LDEyOTM4NywxNCwxMjkzOTMsMTI5MzkzLDE0LDEyOTM5NSwxMjkzOTgsMTQsMTI5NDAxLDEyOTQwMSwxNCwxMjk0MDMsMTI5NDAzLDE0LDEyOTQwOCwxMjk0MTIsMTQsMTI5NDI2LDEyOTQzMSwxNCwxMjk0NDMsMTI5NDQ0LDE0LDEyOTQ1MSwxMjk0NTMsMTQsMTI5NDU2LDEyOTQ2NSwxNCwxMjk0NzIsMTI5NDcyLDE0LDEyOTQ3NSwxMjk0ODIsMTQsMTI5NDg0LDEyOTQ4NCwxNCwxMjk0ODgsMTI5NTEwLDE0LDEyOTUzNiwxMjk2NDcsMTQsMTI5NjUyLDEyOTY1MiwxNCwxMjk2NTYsMTI5NjU4LDE0LDEyOTY2MSwxMjk2NjMsMTQsMTI5NjY3LDEyOTY3MCwxNCwxMjk2ODAsMTI5Njg1LDE0LDEyOTcwNSwxMjk3MDgsMTQsMTI5NzEyLDEyOTcxOCwxNCwxMjk3MjMsMTI5NzI3LDE0LDEyOTczMSwxMjk3MzMsMTQsMTI5NzQ0LDEyOTc1MCwxNCwxMjk3NTQsMTI5NzU5LDE0LDEyOTc2OCwxMjk3NzUsMTQsMTI5NzgzLDEyOTc5MSwxNCw5MTc1MDQsOTE3NTA0LDQsOTE3NTA2LDkxNzUzNSw0LDkxNzYzMiw5MTc3NTksNCw5MTgwMDAsOTIxNTk5LDQsMCw5LDQsMTEsMTIsNCwxNCwzMSw0LDE2OSwxNjksMTQsMTc0LDE3NCwxNCwxMTU1LDExNTksNSwxNDI1LDE0NjksNSwxNDczLDE0NzQsNSwxNDc5LDE0NzksNSwxNTUyLDE1NjIsNSwxNjExLDE2MzEsNSwxNzUwLDE3NTYsNSwxNzU5LDE3NjQsNSwxNzcwLDE3NzMsNSwxODA5LDE4MDksNSwxOTU4LDE5NjgsNSwyMDQ1LDIwNDUsNSwyMDc1LDIwODMsNSwyMDg5LDIwOTMsNSwyMTkyLDIxOTMsMSwyMjUwLDIyNzMsNSwyMjc1LDIzMDYsNSwyMzYyLDIzNjIsNSwyMzY0LDIzNjQsNSwyMzY5LDIzNzYsNSwyMzgxLDIzODEsNSwyMzg1LDIzOTEsNSwyNDMzLDI0MzMsNSwyNDkyLDI0OTIsNSwyNDk1LDI0OTYsNywyNTAzLDI1MDQsNywyNTA5LDI1MDksNSwyNTMwLDI1MzEsNSwyNTYxLDI1NjIsNSwyNjIwLDI2MjAsNSwyNjI1LDI2MjYsNSwyNjM1LDI2MzcsNSwyNjcyLDI2NzMsNSwyNjg5LDI2OTAsNSwyNzQ4LDI3NDgsNSwyNzUzLDI3NTcsNSwyNzYxLDI3NjEsNywyNzY1LDI3NjUsNSwyODEwLDI4MTUsNSwyODE4LDI4MTksNywyODc4LDI4NzgsNSwyODgwLDI4ODAsNywyODg3LDI4ODgsNywyODkzLDI4OTMsNSwyOTAzLDI5MDMsNSwyOTQ2LDI5NDYsNSwzMDA3LDMwMDcsNywzMDA5LDMwMTAsNywzMDE4LDMwMjAsNywzMDMxLDMwMzEsNSwzMDczLDMwNzUsNywzMTMyLDMxMzIsNSwzMTM3LDMxNDAsNywzMTQ2LDMxNDksNSwzMTcwLDMxNzEsNSwzMjAyLDMyMDMsNywzMjYyLDMyNjIsNywzMjY0LDMyNjUsNywzMjY3LDMyNjgsNywzMjcxLDMyNzIsNywzMjc2LDMyNzcsNSwzMjk4LDMyOTksNSwzMzMwLDMzMzEsNywzMzkwLDMzOTAsNSwzMzkzLDMzOTYsNSwzNDAyLDM0MDQsNywzNDA2LDM0MDYsMSwzNDI2LDM0MjcsNSwzNDU4LDM0NTksNywzNTM1LDM1MzUsNSwzNTM4LDM1NDAsNSwzNTQ0LDM1NTAsNywzNTcwLDM1NzEsNywzNjM1LDM2MzUsNywzNjU1LDM2NjIsNSwzNzYzLDM3NjMsNywzNzg0LDM3ODksNSwzODkzLDM4OTMsNSwzODk3LDM4OTcsNSwzOTUzLDM5NjYsNSwzOTY4LDM5NzIsNSwzOTgxLDM5OTEsNSw0MDM4LDQwMzgsNSw0MTQ1LDQxNDUsNyw0MTUzLDQxNTQsNSw0MTU3LDQxNTgsNSw0MTg0LDQxODUsNSw0MjA5LDQyMTIsNSw0MjI4LDQyMjgsNyw0MjM3LDQyMzcsNSw0MzUyLDQ0NDcsOCw0NTIwLDQ2MDcsMTAsNTkwNiw1OTA4LDUsNTkzOCw1OTM5LDUsNTk3MCw1OTcxLDUsNjA2OCw2MDY5LDUsNjA3MSw2MDc3LDUsNjA4Niw2MDg2LDUsNjA4OSw2MDk5LDUsNjE1NSw2MTU3LDUsNjE1OSw2MTU5LDUsNjMxMyw2MzEzLDUsNjQzNSw2NDM4LDcsNjQ0MSw2NDQzLDcsNjQ1MCw2NDUwLDUsNjQ1Nyw2NDU5LDUsNjY4MSw2NjgyLDcsNjc0MSw2NzQxLDcsNjc0Myw2NzQzLDcsNjc1Miw2NzUyLDUsNjc1Nyw2NzY0LDUsNjc3MSw2NzgwLDUsNjgzMiw2ODQ1LDUsNjg0Nyw2ODYyLDUsNjkxNiw2OTE2LDcsNjk2NSw2OTY1LDUsNjk3MSw2OTcxLDcsNjk3Myw2OTc3LDcsNjk3OSw2OTgwLDcsNzA0MCw3MDQxLDUsNzA3Myw3MDczLDcsNzA3OCw3MDc5LDcsNzA4Miw3MDgyLDcsNzE0Miw3MTQyLDUsNzE0NCw3MTQ1LDUsNzE0OSw3MTQ5LDUsNzE1MSw3MTUzLDUsNzIwNCw3MjExLDcsNzIyMCw3MjIxLDcsNzM3Niw3Mzc4LDUsNzM5Myw3MzkzLDcsNzQwNSw3NDA1LDUsNzQxNSw3NDE1LDcsNzYxNiw3Njc5LDUsODIwNCw4MjA0LDUsODIwNiw4MjA3LDQsODIzMyw4MjMzLDQsODI1Miw4MjUyLDE0LDgyODgsODI5Miw0LDgyOTQsODMwMyw0LDg0MTMsODQxNiw1LDg0MTgsODQyMCw1LDg0ODIsODQ4MiwxNCw4NTk2LDg2MDEsMTQsODk4Niw4OTg3LDE0LDkwOTYsOTA5NiwxNCw5MTkzLDkxOTYsMTQsOTE5OSw5MTk5LDE0LDkyMDEsOTIwMiwxNCw5MjA4LDkyMTAsMTQsOTY0Miw5NjQzLDE0LDk2NjQsOTY2NCwxNCw5NzI4LDk3MjksMTQsOTczMiw5NzMyLDE0LDk3MzUsOTc0MSwxNCw5NzQzLDk3NDQsMTQsOTc0Niw5NzQ2LDE0LDk3NTAsOTc1MSwxNCw5NzUzLDk3NTYsMTQsOTc1OCw5NzU5LDE0LDk3NjEsOTc2MSwxNCw5NzY0LDk3NjUsMTQsOTc2Nyw5NzY5LDE0LDk3NzEsOTc3MywxNCw5Nzc1LDk3NzUsMTQsOTc4NCw5Nzg1LDE0LDk3ODcsOTc5MSwxNCw5NzkzLDk3OTMsMTQsOTc5NSw5Nzk5LDE0LDk4MTIsOTgyMiwxNCw5ODI0LDk4MjQsMTQsOTgyNyw5ODI3LDE0LDk4MjksOTgzMCwxNCw5ODMyLDk4MzIsMTQsOTg1MSw5ODUxLDE0LDk4NTQsOTg1NCwxNCw5ODU2LDk4NjEsMTQsOTg3NCw5ODc0LDE0LDk4NzYsOTg3NiwxNCw5ODc4LDk4NzksMTQsOTg4MSw5ODgxLDE0LDk4ODMsOTg4NCwxNCw5ODg4LDk4ODksMTQsOTg5NSw5ODk1LDE0LDk4OTgsOTg5OSwxNCw5OTA0LDk5MDUsMTQsOTkxNyw5OTE4LDE0LDk5MjQsOTkyNSwxNCw5OTI4LDk5MjgsMTQsOTkzNCw5OTM0LDE0LDk5MzYsOTkzNiwxNCw5OTM4LDk5MzgsMTQsOTk0MCw5OTQwLDE0LDk5NjEsOTk2MSwxNCw5OTYzLDk5NjcsMTQsOTk3MCw5OTcxLDE0LDk5NzMsOTk3MywxNCw5OTc1LDk5NzcsMTQsOTk3OSw5OTgwLDE0LDk5ODIsOTk4NSwxNCw5OTg3LDk5ODgsMTQsOTk5Miw5OTk2LDE0LDk5OTgsOTk5OCwxNCwxMDAwMCwxMDAwMSwxNCwxMDAwNCwxMDAwNCwxNCwxMDAxMywxMDAxMywxNCwxMDAyNCwxMDAyNCwxNCwxMDA1MiwxMDA1MiwxNCwxMDA2MCwxMDA2MCwxNCwxMDA2NywxMDA2OSwxNCwxMDA4MywxMDA4MywxNCwxMDA4NSwxMDA4NywxNCwxMDE0NSwxMDE0NSwxNCwxMDE3NSwxMDE3NSwxNCwxMTAxMywxMTAxNSwxNCwxMTA4OCwxMTA4OCwxNCwxMTUwMywxMTUwNSw1LDExNzQ0LDExNzc1LDUsMTIzMzQsMTIzMzUsNSwxMjM0OSwxMjM0OSwxNCwxMjk1MSwxMjk1MSwxNCw0MjYwNyw0MjYwNyw1LDQyNjEyLDQyNjIxLDUsNDI3MzYsNDI3MzcsNSw0MzAxNCw0MzAxNCw1LDQzMDQzLDQzMDQ0LDcsNDMwNDcsNDMwNDcsNyw0MzEzNiw0MzEzNyw3LDQzMjA0LDQzMjA1LDUsNDMyNjMsNDMyNjMsNSw0MzMzNSw0MzM0NSw1LDQzMzYwLDQzMzg4LDgsNDMzOTUsNDMzOTUsNyw0MzQ0NCw0MzQ0NSw3LDQzNDUwLDQzNDUxLDcsNDM0NTQsNDM0NTYsNyw0MzU2MSw0MzU2Niw1LDQzNTY5LDQzNTcwLDUsNDM1NzMsNDM1NzQsNSw0MzU5Niw0MzU5Niw1LDQzNjQ0LDQzNjQ0LDUsNDM2OTgsNDM3MDAsNSw0MzcxMCw0MzcxMSw1LDQzNzU1LDQzNzU1LDcsNDM3NTgsNDM3NTksNyw0Mzc2Niw0Mzc2Niw1LDQ0MDA1LDQ0MDA1LDUsNDQwMDgsNDQwMDgsNSw0NDAxMiw0NDAxMiw3LDQ0MDMyLDQ0MDMyLDExLDQ0MDYwLDQ0MDYwLDExLDQ0MDg4LDQ0MDg4LDExLDQ0MTE2LDQ0MTE2LDExLDQ0MTQ0LDQ0MTQ0LDExLDQ0MTcyLDQ0MTcyLDExLDQ0MjAwLDQ0MjAwLDExLDQ0MjI4LDQ0MjI4LDExLDQ0MjU2LDQ0MjU2LDExLDQ0Mjg0LDQ0Mjg0LDExLDQ0MzEyLDQ0MzEyLDExLDQ0MzQwLDQ0MzQwLDExLDQ0MzY4LDQ0MzY4LDExLDQ0Mzk2LDQ0Mzk2LDExLDQ0NDI0LDQ0NDI0LDExLDQ0NDUyLDQ0NDUyLDExLDQ0NDgwLDQ0NDgwLDExLDQ0NTA4LDQ0NTA4LDExLDQ0NTM2LDQ0NTM2LDExLDQ0NTY0LDQ0NTY0LDExLDQ0NTkyLDQ0NTkyLDExLDQ0NjIwLDQ0NjIwLDExLDQ0NjQ4LDQ0NjQ4LDExLDQ0Njc2LDQ0Njc2LDExLDQ0NzA0LDQ0NzA0LDExLDQ0NzMyLDQ0NzMyLDExLDQ0NzYwLDQ0NzYwLDExLDQ0Nzg4LDQ0Nzg4LDExLDQ0ODE2LDQ0ODE2LDExLDQ0ODQ0LDQ0ODQ0LDExLDQ0ODcyLDQ0ODcyLDExLDQ0OTAwLDQ0OTAwLDExLDQ0OTI4LDQ0OTI4LDExLDQ0OTU2LDQ0OTU2LDExLDQ0OTg0LDQ0OTg0LDExLDQ1MDEyLDQ1MDEyLDExLDQ1MDQwLDQ1MDQwLDExLDQ1MDY4LDQ1MDY4LDExLDQ1MDk2LDQ1MDk2LDExLDQ1MTI0LDQ1MTI0LDExLDQ1MTUyLDQ1MTUyLDExLDQ1MTgwLDQ1MTgwLDExLDQ1MjA4LDQ1MjA4LDExLDQ1MjM2LDQ1MjM2LDExLDQ1MjY0LDQ1MjY0LDExLDQ1MjkyLDQ1MjkyLDExLDQ1MzIwLDQ1MzIwLDExLDQ1MzQ4LDQ1MzQ4LDExLDQ1Mzc2LDQ1Mzc2LDExLDQ1NDA0LDQ1NDA0LDExLDQ1NDMyLDQ1NDMyLDExLDQ1NDYwLDQ1NDYwLDExLDQ1NDg4LDQ1NDg4LDExLDQ1NTE2LDQ1NTE2LDExLDQ1NTQ0LDQ1NTQ0LDExLDQ1NTcyLDQ1NTcyLDExLDQ1NjAwLDQ1NjAwLDExLDQ1NjI4LDQ1NjI4LDExLDQ1NjU2LDQ1NjU2LDExLDQ1Njg0LDQ1Njg0LDExLDQ1NzEyLDQ1NzEyLDExLDQ1NzQwLDQ1NzQwLDExLDQ1NzY4LDQ1NzY4LDExLDQ1Nzk2LDQ1Nzk2LDExLDQ1ODI0LDQ1ODI0LDExLDQ1ODUyLDQ1ODUyLDExLDQ1ODgwLDQ1ODgwLDExLDQ1OTA4LDQ1OTA4LDExLDQ1OTM2LDQ1OTM2LDExLDQ1OTY0LDQ1OTY0LDExLDQ1OTkyLDQ1OTkyLDExLDQ2MDIwLDQ2MDIwLDExLDQ2MDQ4LDQ2MDQ4LDExLDQ2MDc2LDQ2MDc2LDExLDQ2MTA0LDQ2MTA0LDExLDQ2MTMyLDQ2MTMyLDExLDQ2MTYwLDQ2MTYwLDExLDQ2MTg4LDQ2MTg4LDExLDQ2MjE2LDQ2MjE2LDExLDQ2MjQ0LDQ2MjQ0LDExLDQ2MjcyLDQ2MjcyLDExLDQ2MzAwLDQ2MzAwLDExLDQ2MzI4LDQ2MzI4LDExLDQ2MzU2LDQ2MzU2LDExLDQ2Mzg0LDQ2Mzg0LDExLDQ2NDEyLDQ2NDEyLDExLDQ2NDQwLDQ2NDQwLDExLDQ2NDY4LDQ2NDY4LDExLDQ2NDk2LDQ2NDk2LDExLDQ2NTI0LDQ2NTI0LDExLDQ2NTUyLDQ2NTUyLDExLDQ2NTgwLDQ2NTgwLDExLDQ2NjA4LDQ2NjA4LDExLDQ2NjM2LDQ2NjM2LDExLDQ2NjY0LDQ2NjY0LDExLDQ2NjkyLDQ2NjkyLDExLDQ2NzIwLDQ2NzIwLDExLDQ2NzQ4LDQ2NzQ4LDExLDQ2Nzc2LDQ2Nzc2LDExLDQ2ODA0LDQ2ODA0LDExLDQ2ODMyLDQ2ODMyLDExLDQ2ODYwLDQ2ODYwLDExLDQ2ODg4LDQ2ODg4LDExLDQ2OTE2LDQ2OTE2LDExLDQ2OTQ0LDQ2OTQ0LDExLDQ2OTcyLDQ2OTcyLDExLDQ3MDAwLDQ3MDAwLDExLDQ3MDI4LDQ3MDI4LDExLDQ3MDU2LDQ3MDU2LDExLDQ3MDg0LDQ3MDg0LDExLDQ3MTEyLDQ3MTEyLDExLDQ3MTQwLDQ3MTQwLDExLDQ3MTY4LDQ3MTY4LDExLDQ3MTk2LDQ3MTk2LDExLDQ3MjI0LDQ3MjI0LDExLDQ3MjUyLDQ3MjUyLDExLDQ3MjgwLDQ3MjgwLDExLDQ3MzA4LDQ3MzA4LDExLDQ3MzM2LDQ3MzM2LDExLDQ3MzY0LDQ3MzY0LDExLDQ3MzkyLDQ3MzkyLDExLDQ3NDIwLDQ3NDIwLDExLDQ3NDQ4LDQ3NDQ4LDExLDQ3NDc2LDQ3NDc2LDExLDQ3NTA0LDQ3NTA0LDExLDQ3NTMyLDQ3NTMyLDExLDQ3NTYwLDQ3NTYwLDExLDQ3NTg4LDQ3NTg4LDExLDQ3NjE2LDQ3NjE2LDExLDQ3NjQ0LDQ3NjQ0LDExLDQ3NjcyLDQ3NjcyLDExLDQ3NzAwLDQ3NzAwLDExLDQ3NzI4LDQ3NzI4LDExLDQ3NzU2LDQ3NzU2LDExLDQ3Nzg0LDQ3Nzg0LDExLDQ3ODEyLDQ3ODEyLDExLDQ3ODQwLDQ3ODQwLDExLDQ3ODY4LDQ3ODY4LDExLDQ3ODk2LDQ3ODk2LDExLDQ3OTI0LDQ3OTI0LDExLDQ3OTUyLDQ3OTUyLDExLDQ3OTgwLDQ3OTgwLDExLDQ4MDA4LDQ4MDA4LDExLDQ4MDM2LDQ4MDM2LDExLDQ4MDY0LDQ4MDY0LDExLDQ4MDkyLDQ4MDkyLDExLDQ4MTIwLDQ4MTIwLDExLDQ4MTQ4LDQ4MTQ4LDExLDQ4MTc2LDQ4MTc2LDExLDQ4MjA0LDQ4MjA0LDExLDQ4MjMyLDQ4MjMyLDExLDQ4MjYwLDQ4MjYwLDExLDQ4Mjg4LDQ4Mjg4LDExLDQ4MzE2LDQ4MzE2LDExLDQ4MzQ0LDQ4MzQ0LDExLDQ4MzcyLDQ4MzcyLDExLDQ4NDAwLDQ4NDAwLDExLDQ4NDI4LDQ4NDI4LDExLDQ4NDU2LDQ4NDU2LDExLDQ4NDg0LDQ4NDg0LDExLDQ4NTEyLDQ4NTEyLDExLDQ4NTQwLDQ4NTQwLDExLDQ4NTY4LDQ4NTY4LDExLDQ4NTk2LDQ4NTk2LDExLDQ4NjI0LDQ4NjI0LDExLDQ4NjUyLDQ4NjUyLDExLDQ4NjgwLDQ4NjgwLDExLDQ4NzA4LDQ4NzA4LDExLDQ4NzM2LDQ4NzM2LDExLDQ4NzY0LDQ4NzY0LDExLDQ4NzkyLDQ4NzkyLDExLDQ4ODIwLDQ4ODIwLDExLDQ4ODQ4LDQ4ODQ4LDExLDQ4ODc2LDQ4ODc2LDExLDQ4OTA0LDQ4OTA0LDExLDQ4OTMyLDQ4OTMyLDExLDQ4OTYwLDQ4OTYwLDExLDQ4OTg4LDQ4OTg4LDExLDQ5MDE2LDQ5MDE2LDExLDQ5MDQ0LDQ5MDQ0LDExLDQ5MDcyLDQ5MDcyLDExLDQ5MTAwLDQ5MTAwLDExLDQ5MTI4LDQ5MTI4LDExLDQ5MTU2LDQ5MTU2LDExLDQ5MTg0LDQ5MTg0LDExLDQ5MjEyLDQ5MjEyLDExLDQ5MjQwLDQ5MjQwLDExLDQ5MjY4LDQ5MjY4LDExLDQ5Mjk2LDQ5Mjk2LDExLDQ5MzI0LDQ5MzI0LDExLDQ5MzUyLDQ5MzUyLDExLDQ5MzgwLDQ5MzgwLDExLDQ5NDA4LDQ5NDA4LDExLDQ5NDM2LDQ5NDM2LDExLDQ5NDY0LDQ5NDY0LDExLDQ5NDkyLDQ5NDkyLDExLDQ5NTIwLDQ5NTIwLDExLDQ5NTQ4LDQ5NTQ4LDExLDQ5NTc2LDQ5NTc2LDExLDQ5NjA0LDQ5NjA0LDExLDQ5NjMyLDQ5NjMyLDExLDQ5NjYwLDQ5NjYwLDExLDQ5Njg4LDQ5Njg4LDExLDQ5NzE2LDQ5NzE2LDExLDQ5NzQ0LDQ5NzQ0LDExLDQ5NzcyLDQ5NzcyLDExLDQ5ODAwLDQ5ODAwLDExLDQ5ODI4LDQ5ODI4LDExLDQ5ODU2LDQ5ODU2LDExLDQ5ODg0LDQ5ODg0LDExLDQ5OTEyLDQ5OTEyLDExLDQ5OTQwLDQ5OTQwLDExLDQ5OTY4LDQ5OTY4LDExLDQ5OTk2LDQ5OTk2LDExLDUwMDI0LDUwMDI0LDExLDUwMDUyLDUwMDUyLDExLDUwMDgwLDUwMDgwLDExLDUwMTA4LDUwMTA4LDExLDUwMTM2LDUwMTM2LDExLDUwMTY0LDUwMTY0LDExLDUwMTkyLDUwMTkyLDExLDUwMjIwLDUwMjIwLDExLDUwMjQ4LDUwMjQ4LDExLDUwMjc2LDUwMjc2LDExLDUwMzA0LDUwMzA0LDExLDUwMzMyLDUwMzMyLDExLDUwMzYwLDUwMzYwLDExLDUwMzg4LDUwMzg4LDExLDUwNDE2LDUwNDE2LDExLDUwNDQ0LDUwNDQ0LDExLDUwNDcyLDUwNDcyLDExLDUwNTAwLDUwNTAwLDExLDUwNTI4LDUwNTI4LDExLDUwNTU2LDUwNTU2LDExLDUwNTg0LDUwNTg0LDExLDUwNjEyLDUwNjEyLDExLDUwNjQwLDUwNjQwLDExLDUwNjY4LDUwNjY4LDExLDUwNjk2LDUwNjk2LDExLDUwNzI0LDUwNzI0LDExLDUwNzUyLDUwNzUyLDExLDUwNzgwLDUwNzgwLDExLDUwODA4LDUwODA4LDExLDUwODM2LDUwODM2LDExLDUwODY0LDUwODY0LDExLDUwODkyLDUwODkyLDExLDUwOTIwLDUwOTIwLDExLDUwOTQ4LDUwOTQ4LDExLDUwOTc2LDUwOTc2LDExLDUxMDA0LDUxMDA0LDExLDUxMDMyLDUxMDMyLDExLDUxMDYwLDUxMDYwLDExLDUxMDg4LDUxMDg4LDExLDUxMTE2LDUxMTE2LDExLDUxMTQ0LDUxMTQ0LDExLDUxMTcyLDUxMTcyLDExLDUxMjAwLDUxMjAwLDExLDUxMjI4LDUxMjI4LDExLDUxMjU2LDUxMjU2LDExLDUxMjg0LDUxMjg0LDExLDUxMzEyLDUxMzEyLDExLDUxMzQwLDUxMzQwLDExLDUxMzY4LDUxMzY4LDExLDUxMzk2LDUxMzk2LDExLDUxNDI0LDUxNDI0LDExLDUxNDUyLDUxNDUyLDExLDUxNDgwLDUxNDgwLDExLDUxNTA4LDUxNTA4LDExLDUxNTM2LDUxNTM2LDExLDUxNTY0LDUxNTY0LDExLDUxNTkyLDUxNTkyLDExLDUxNjIwLDUxNjIwLDExLDUxNjQ4LDUxNjQ4LDExLDUxNjc2LDUxNjc2LDExLDUxNzA0LDUxNzA0LDExLDUxNzMyLDUxNzMyLDExLDUxNzYwLDUxNzYwLDExLDUxNzg4LDUxNzg4LDExLDUxODE2LDUxODE2LDExLDUxODQ0LDUxODQ0LDExLDUxODcyLDUxODcyLDExLDUxOTAwLDUxOTAwLDExLDUxOTI4LDUxOTI4LDExLDUxOTU2LDUxOTU2LDExLDUxOTg0LDUxOTg0LDExLDUyMDEyLDUyMDEyLDExLDUyMDQwLDUyMDQwLDExLDUyMDY4LDUyMDY4LDExLDUyMDk2LDUyMDk2LDExLDUyMTI0LDUyMTI0LDExLDUyMTUyLDUyMTUyLDExLDUyMTgwLDUyMTgwLDExLDUyMjA4LDUyMjA4LDExLDUyMjM2LDUyMjM2LDExLDUyMjY0LDUyMjY0LDExLDUyMjkyLDUyMjkyLDExLDUyMzIwLDUyMzIwLDExLDUyMzQ4LDUyMzQ4LDExLDUyMzc2LDUyMzc2LDExLDUyNDA0LDUyNDA0LDExLDUyNDMyLDUyNDMyLDExLDUyNDYwLDUyNDYwLDExLDUyNDg4LDUyNDg4LDExLDUyNTE2LDUyNTE2LDExLDUyNTQ0LDUyNTQ0LDExLDUyNTcyLDUyNTcyLDExLDUyNjAwLDUyNjAwLDExLDUyNjI4LDUyNjI4LDExLDUyNjU2LDUyNjU2LDExLDUyNjg0LDUyNjg0LDExLDUyNzEyLDUyNzEyLDExLDUyNzQwLDUyNzQwLDExLDUyNzY4LDUyNzY4LDExLDUyNzk2LDUyNzk2LDExLDUyODI0LDUyODI0LDExLDUyODUyLDUyODUyLDExLDUyODgwLDUyODgwLDExLDUyOTA4LDUyOTA4LDExLDUyOTM2LDUyOTM2LDExLDUyOTY0LDUyOTY0LDExLDUyOTkyLDUyOTkyLDExLDUzMDIwLDUzMDIwLDExLDUzMDQ4LDUzMDQ4LDExLDUzMDc2LDUzMDc2LDExLDUzMTA0LDUzMTA0LDExLDUzMTMyLDUzMTMyLDExLDUzMTYwLDUzMTYwLDExLDUzMTg4LDUzMTg4LDExLDUzMjE2LDUzMjE2LDExLDUzMjQ0LDUzMjQ0LDExLDUzMjcyLDUzMjcyLDExLDUzMzAwLDUzMzAwLDExLDUzMzI4LDUzMzI4LDExLDUzMzU2LDUzMzU2LDExLDUzMzg0LDUzMzg0LDExLDUzNDEyLDUzNDEyLDExLDUzNDQwLDUzNDQwLDExLDUzNDY4LDUzNDY4LDExLDUzNDk2LDUzNDk2LDExLDUzNTI0LDUzNTI0LDExLDUzNTUyLDUzNTUyLDExLDUzNTgwLDUzNTgwLDExLDUzNjA4LDUzNjA4LDExLDUzNjM2LDUzNjM2LDExLDUzNjY0LDUzNjY0LDExLDUzNjkyLDUzNjkyLDExLDUzNzIwLDUzNzIwLDExLDUzNzQ4LDUzNzQ4LDExLDUzNzc2LDUzNzc2LDExLDUzODA0LDUzODA0LDExLDUzODMyLDUzODMyLDExLDUzODYwLDUzODYwLDExLDUzODg4LDUzODg4LDExLDUzOTE2LDUzOTE2LDExLDUzOTQ0LDUzOTQ0LDExLDUzOTcyLDUzOTcyLDExLDU0MDAwLDU0MDAwLDExLDU0MDI4LDU0MDI4LDExLDU0MDU2LDU0MDU2LDExLDU0MDg0LDU0MDg0LDExLDU0MTEyLDU0MTEyLDExLDU0MTQwLDU0MTQwLDExLDU0MTY4LDU0MTY4LDExLDU0MTk2LDU0MTk2LDExLDU0MjI0LDU0MjI0LDExLDU0MjUyLDU0MjUyLDExLDU0MjgwLDU0MjgwLDExLDU0MzA4LDU0MzA4LDExLDU0MzM2LDU0MzM2LDExLDU0MzY0LDU0MzY0LDExLDU0MzkyLDU0MzkyLDExLDU0NDIwLDU0NDIwLDExLDU0NDQ4LDU0NDQ4LDExLDU0NDc2LDU0NDc2LDExLDU0NTA0LDU0NTA0LDExLDU0NTMyLDU0NTMyLDExLDU0NTYwLDU0NTYwLDExLDU0NTg4LDU0NTg4LDExLDU0NjE2LDU0NjE2LDExLDU0NjQ0LDU0NjQ0LDExLDU0NjcyLDU0NjcyLDExLDU0NzAwLDU0NzAwLDExLDU0NzI4LDU0NzI4LDExLDU0NzU2LDU0NzU2LDExLDU0Nzg0LDU0Nzg0LDExLDU0ODEyLDU0ODEyLDExLDU0ODQwLDU0ODQwLDExLDU0ODY4LDU0ODY4LDExLDU0ODk2LDU0ODk2LDExLDU0OTI0LDU0OTI0LDExLDU0OTUyLDU0OTUyLDExLDU0OTgwLDU0OTgwLDExLDU1MDA4LDU1MDA4LDExLDU1MDM2LDU1MDM2LDExLDU1MDY0LDU1MDY0LDExLDU1MDkyLDU1MDkyLDExLDU1MTIwLDU1MTIwLDExLDU1MTQ4LDU1MTQ4LDExLDU1MTc2LDU1MTc2LDExLDU1MjE2LDU1MjM4LDksNjQyODYsNjQyODYsNSw2NTA1Niw2NTA3MSw1LDY1NDM4LDY1NDM5LDUsNjU1MjksNjU1MzEsNCw2NjI3Miw2NjI3Miw1LDY4MDk3LDY4MDk5LDUsNjgxMDgsNjgxMTEsNSw2ODE1OSw2ODE1OSw1LDY4OTAwLDY4OTAzLDUsNjk0NDYsNjk0NTYsNSw2OTYzMiw2OTYzMiw3LDY5NjM0LDY5NjM0LDcsNjk3NDQsNjk3NDQsNSw2OTc1OSw2OTc2MSw1LDY5ODA4LDY5ODEwLDcsNjk4MTUsNjk4MTYsNyw2OTgyMSw2OTgyMSwxLDY5ODM3LDY5ODM3LDEsNjk5MjcsNjk5MzEsNSw2OTkzMyw2OTk0MCw1LDcwMDAzLDcwMDAzLDUsNzAwMTgsNzAwMTgsNyw3MDA3MCw3MDA3OCw1LDcwMDgyLDcwMDgzLDEsNzAwOTQsNzAwOTQsNyw3MDE4OCw3MDE5MCw3LDcwMTk0LDcwMTk1LDcsNzAxOTcsNzAxOTcsNyw3MDIwNiw3MDIwNiw1LDcwMzY4LDcwMzcwLDcsNzA0MDAsNzA0MDEsNSw3MDQ1OSw3MDQ2MCw1LDcwNDYzLDcwNDYzLDcsNzA0NjUsNzA0NjgsNyw3MDQ3NSw3MDQ3Nyw3LDcwNDk4LDcwNDk5LDcsNzA1MTIsNzA1MTYsNSw3MDcxMiw3MDcxOSw1LDcwNzIyLDcwNzI0LDUsNzA3MjYsNzA3MjYsNSw3MDgzMiw3MDgzMiw1LDcwODM1LDcwODQwLDUsNzA4NDIsNzA4NDIsNSw3MDg0NSw3MDg0NSw1LDcwODQ3LDcwODQ4LDUsNzA4NTAsNzA4NTEsNSw3MTA4OCw3MTA4OSw3LDcxMDk2LDcxMDk5LDcsNzExMDIsNzExMDIsNyw3MTEzMiw3MTEzMyw1LDcxMjE5LDcxMjI2LDUsNzEyMjksNzEyMjksNSw3MTIzMSw3MTIzMiw1LDcxMzQwLDcxMzQwLDcsNzEzNDIsNzEzNDMsNyw3MTM1MCw3MTM1MCw3LDcxNDUzLDcxNDU1LDUsNzE0NjIsNzE0NjIsNyw3MTcyNCw3MTcyNiw3LDcxNzM2LDcxNzM2LDcsNzE5ODQsNzE5ODQsNSw3MTk5MSw3MTk5Miw3LDcxOTk3LDcxOTk3LDcsNzE5OTksNzE5OTksMSw3MjAwMSw3MjAwMSwxLDcyMDAzLDcyMDAzLDUsNzIxNDgsNzIxNTEsNSw3MjE1Niw3MjE1OSw3LDcyMTY0LDcyMTY0LDcsNzIyNDMsNzIyNDgsNSw3MjI1MCw3MjI1MCwxLDcyMjYzLDcyMjYzLDUsNzIyNzksNzIyODAsNyw3MjMyNCw3MjMyOSwxLDcyMzQzLDcyMzQzLDcsNzI3NTEsNzI3NTEsNyw3Mjc2MCw3Mjc2NSw1LDcyNzY3LDcyNzY3LDUsNzI4NzMsNzI4NzMsNyw3Mjg4MSw3Mjg4MSw3LDcyODg0LDcyODg0LDcsNzMwMDksNzMwMTQsNSw3MzAyMCw3MzAyMSw1LDczMDMwLDczMDMwLDEsNzMwOTgsNzMxMDIsNyw3MzEwNyw3MzEwOCw3LDczMTEwLDczMTEwLDcsNzM0NTksNzM0NjAsNSw3ODg5Niw3ODkwNCw0LDkyOTc2LDkyOTgyLDUsOTQwMzMsOTQwODcsNyw5NDE4MCw5NDE4MCw1LDExMzgyMSwxMTM4MjIsNSwxMTg1MjgsMTE4NTczLDUsMTE5MTQxLDExOTE0MSw1LDExOTE0MywxMTkxNDUsNSwxMTkxNTAsMTE5MTU0LDUsMTE5MTYzLDExOTE3MCw1LDExOTIxMCwxMTkyMTMsNSwxMjEzNDQsMTIxMzk4LDUsMTIxNDYxLDEyMTQ2MSw1LDEyMTQ5OSwxMjE1MDMsNSwxMjI4ODAsMTIyODg2LDUsMTIyOTA3LDEyMjkxMyw1LDEyMjkxOCwxMjI5MjIsNSwxMjM1NjYsMTIzNTY2LDUsMTI1MTM2LDEyNTE0Miw1LDEyNjk3NiwxMjY5NzksMTQsMTI2OTgxLDEyNzE4MiwxNCwxMjcxODQsMTI3MjMxLDE0LDEyNzI3OSwxMjcyNzksMTQsMTI3MzQ0LDEyNzM0NSwxNCwxMjczNzQsMTI3Mzc0LDE0LDEyNzQwNSwxMjc0NjEsMTQsMTI3NDg5LDEyNzQ5MCwxNCwxMjc1MTQsMTI3NTE0LDE0LDEyNzUzOCwxMjc1NDYsMTQsMTI3NTYxLDEyNzU2NywxNCwxMjc1NzAsMTI3NzQzLDE0LDEyNzc1NywxMjc3NTgsMTQsMTI3NzYwLDEyNzc2MCwxNCwxMjc3NjIsMTI3NzYyLDE0LDEyNzc2NiwxMjc3NjgsMTQsMTI3NzcwLDEyNzc3MCwxNCwxMjc3NzIsMTI3NzcyLDE0LDEyNzc3NSwxMjc3NzYsMTQsMTI3Nzc4LDEyNzc3OSwxNCwxMjc3ODksMTI3NzkxLDE0LDEyNzc5NCwxMjc3OTUsMTQsMTI3Nzk4LDEyNzc5OCwxNCwxMjc4MTksMTI3ODE5LDE0LDEyNzgyNCwxMjc4MjQsMTQsMTI3ODY4LDEyNzg2OCwxNCwxMjc4NzAsMTI3ODcxLDE0LDEyNzg5MiwxMjc4OTMsMTQsMTI3ODk2LDEyNzg5NiwxNCwxMjc5MDAsMTI3OTAxLDE0LDEyNzkwNCwxMjc5NDAsMTQsMTI3OTQyLDEyNzk0MiwxNCwxMjc5NDQsMTI3OTQ0LDE0LDEyNzk0NiwxMjc5NDYsMTQsMTI3OTUxLDEyNzk1NSwxNCwxMjc5NjgsMTI3OTcxLDE0LDEyNzk3MywxMjc5ODQsMTQsMTI3OTg3LDEyNzk4NywxNCwxMjc5ODksMTI3OTg5LDE0LDEyNzk5MSwxMjc5OTEsMTQsMTI3OTk1LDEyNzk5OSw1LDEyODAwOCwxMjgwMDgsMTQsMTI4MDEyLDEyODAxNCwxNCwxMjgwMTcsMTI4MDE4LDE0LDEyODAyMCwxMjgwMjAsMTQsMTI4MDIyLDEyODAyMiwxNCwxMjgwNDIsMTI4MDQyLDE0LDEyODA2MywxMjgwNjMsMTQsMTI4MDY1LDEyODA2NSwxNCwxMjgxMDEsMTI4MTAxLDE0LDEyODEwOCwxMjgxMDksMTQsMTI4MTczLDEyODE3MywxNCwxMjgxODIsMTI4MTgzLDE0LDEyODIzNiwxMjgyMzcsMTQsMTI4MjM5LDEyODIzOSwxNCwxMjgyNDUsMTI4MjQ1LDE0LDEyODI0OCwxMjgyNDgsMTQsMTI4MjUzLDEyODI1MywxNCwxMjgyNTUsMTI4MjU4LDE0LDEyODI2MCwxMjgyNjMsMTQsMTI4MjY1LDEyODI2NSwxNCwxMjgyNzcsMTI4Mjc3LDE0LDEyODMwMCwxMjgzMDEsMTQsMTI4MzI2LDEyODMyOCwxNCwxMjgzMzEsMTI4MzM0LDE0LDEyODMzNiwxMjgzNDcsMTQsMTI4MzYwLDEyODM2NiwxNCwxMjgzNjksMTI4MzcwLDE0LDEyODM3OCwxMjgzNzgsMTQsMTI4MzkxLDEyODM5MSwxNCwxMjgzOTQsMTI4Mzk3LDE0LDEyODQwMCwxMjg0MDAsMTQsMTI4NDA1LDEyODQwNiwxNCwxMjg0MjAsMTI4NDIwLDE0LDEyODQyMiwxMjg0MjMsMTQsMTI4NDI1LDEyODQzMiwxNCwxMjg0MzUsMTI4NDQzLDE0LDEyODQ0NSwxMjg0NDksMTQsMTI4NDUzLDEyODQ2NCwxNCwxMjg0NjgsMTI4NDc1LDE0LDEyODQ3OSwxMjg0ODAsMTQsMTI4NDgyLDEyODQ4MiwxNCwxMjg0ODQsMTI4NDg3LDE0LDEyODQ4OSwxMjg0OTQsMTQsMTI4NDk2LDEyODQ5OCwxNCwxMjg1MDAsMTI4NTA1LDE0LDEyODUwNywxMjg1MTEsMTQsMTI4NTEzLDEyODUxOCwxNCwxMjg1MjEsMTI4NTI1LDE0LDEyODUyNywxMjg1MjcsMTQsMTI4NTI5LDEyODUyOSwxNCwxMjg1MzMsMTI4NTMzLDE0LDEyODUzNSwxMjg1MzUsMTQsMTI4NTM3LDEyODUzNywxNF0nKTtcclxufVxyXG4vLyNlbmRyZWdpb25cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBvZmZzZXQgYWZ0ZXIgcGVyZm9ybWluZyBhIGxlZnQgZGVsZXRlIG9uIHRoZSBnaXZlbiBzdHJpbmcsXHJcbiAqIHdoaWxlIGNvbnNpZGVyaW5nIHVuaWNvZGUgZ3JhcGhlbWUvZW1vamkgcnVsZXMuXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWZ0RGVsZXRlT2Zmc2V0KG9mZnNldCwgc3RyKSB7XHJcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gZGVsZXRlIGVtb2ppIHBhcnQuXHJcbiAgICBjb25zdCBlbW9qaU9mZnNldCA9IGdldE9mZnNldEJlZm9yZUxhc3RFbW9qaUNvbXBvbmVudChvZmZzZXQsIHN0cik7XHJcbiAgICBpZiAoZW1vamlPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBlbW9qaU9mZnNldDtcclxuICAgIH1cclxuICAgIC8vIE90aGVyd2lzZSwganVzdCBza2lwIGEgc2luZ2xlIGNvZGUgcG9pbnQuXHJcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBDb2RlUG9pbnRJdGVyYXRvcihzdHIsIG9mZnNldCk7XHJcbiAgICBpdGVyYXRvci5wcmV2Q29kZVBvaW50KCk7XHJcbiAgICByZXR1cm4gaXRlcmF0b3Iub2Zmc2V0O1xyXG59XHJcbmZ1bmN0aW9uIGdldE9mZnNldEJlZm9yZUxhc3RFbW9qaUNvbXBvbmVudChpbml0aWFsT2Zmc2V0LCBzdHIpIHtcclxuICAgIC8vIFNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyNTEvdHI1MS0xNC5odG1sI0VCTkZfYW5kX1JlZ2V4IGZvciB0aGVcclxuICAgIC8vIHN0cnVjdHVyZSBvZiBlbW9qaXMuXHJcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBDb2RlUG9pbnRJdGVyYXRvcihzdHIsIGluaXRpYWxPZmZzZXQpO1xyXG4gICAgbGV0IGNvZGVQb2ludCA9IGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKTtcclxuICAgIC8vIFNraXAgbW9kaWZpZXJzXHJcbiAgICB3aGlsZSAoKGlzRW1vamlNb2RpZmllcihjb2RlUG9pbnQpIHx8IGNvZGVQb2ludCA9PT0gNjUwMzkgLyogQ29kZVBvaW50LmVtb2ppVmFyaWFudFNlbGVjdG9yICovIHx8IGNvZGVQb2ludCA9PT0gODQxOSAvKiBDb2RlUG9pbnQuZW5jbG9zaW5nS2V5Q2FwICovKSkge1xyXG4gICAgICAgIGlmIChpdGVyYXRvci5vZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gQ2Fubm90IHNraXAgbW9kaWZpZXIsIG5vIHByZWNlZGluZyBlbW9qaSBiYXNlLlxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2RlUG9pbnQgPSBpdGVyYXRvci5wcmV2Q29kZVBvaW50KCk7XHJcbiAgICB9XHJcbiAgICAvLyBFeHBlY3QgYmFzZSBlbW9qaVxyXG4gICAgaWYgKCFpc0Vtb2ppSW1wcmVjaXNlKGNvZGVQb2ludCkpIHtcclxuICAgICAgICAvLyBVbmV4cGVjdGVkIGNvZGUgcG9pbnQsIG5vdCBhIHZhbGlkIGVtb2ppLlxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xyXG4gICAgaWYgKHJlc3VsdE9mZnNldCA+IDApIHtcclxuICAgICAgICAvLyBTa2lwIG9wdGlvbmFsIFpXSiBjb2RlIHBvaW50cyB0aGF0IGNvbWJpbmUgbXVsdGlwbGUgZW1vamlzLlxyXG4gICAgICAgIC8vIEluIHRoZW9yeSwgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoYXQgWldKIGFjdHVhbGx5IGNvbWJpbmVzIG11bHRpcGxlIGVtb2ppc1xyXG4gICAgICAgIC8vIHRvIHByZXZlbnQgZGVsZXRpbmcgWldKcyBpbiBzaXR1YXRpb25zIHdlIGRpZG4ndCBhY2NvdW50IGZvci5cclxuICAgICAgICBjb25zdCBvcHRpb25hbFp3akNvZGVQb2ludCA9IGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKTtcclxuICAgICAgICBpZiAob3B0aW9uYWxad2pDb2RlUG9pbnQgPT09IDgyMDUgLyogQ29kZVBvaW50Lnp3aiAqLykge1xyXG4gICAgICAgICAgICByZXN1bHRPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxufVxyXG5mdW5jdGlvbiBpc0Vtb2ppTW9kaWZpZXIoY29kZVBvaW50KSB7XHJcbiAgICByZXR1cm4gMHgxRjNGQiA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUYzRkY7XHJcbn1cclxuZXhwb3J0IGNvbnN0IG5vQnJlYWtXaGl0ZXNwYWNlID0gJ1xceGEwJztcclxuZXhwb3J0IGNsYXNzIEFtYmlndW91c0NoYXJhY3RlcnMge1xyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKGxvY2FsZXMpIHtcclxuICAgICAgICByZXR1cm4gX2EuY2FjaGUuZ2V0KEFycmF5LmZyb20obG9jYWxlcykpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldExvY2FsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hLl9sb2NhbGVzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoY29uZnVzYWJsZURpY3Rpb25hcnkpIHtcclxuICAgICAgICB0aGlzLmNvbmZ1c2FibGVEaWN0aW9uYXJ5ID0gY29uZnVzYWJsZURpY3Rpb25hcnk7XHJcbiAgICB9XHJcbiAgICBpc0FtYmlndW91cyhjb2RlUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeS5oYXMoY29kZVBvaW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbm9uIGJhc2ljIEFTQ0lJIGNvZGUgcG9pbnQgdGhhdCB0aGUgZ2l2ZW4gY29kZSBwb2ludCBjYW4gYmUgY29uZnVzZWQsXHJcbiAgICAgKiBvciB1bmRlZmluZWQgaWYgc3VjaCBjb2RlIHBvaW50IGRvZXMgbm90ZSBleGlzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJpbWFyeUNvbmZ1c2FibGUoY29kZVBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZnVzYWJsZURpY3Rpb25hcnkuZ2V0KGNvZGVQb2ludCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb25mdXNhYmxlQ29kZVBvaW50cygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLmNvbmZ1c2FibGVEaWN0aW9uYXJ5LmtleXMoKSk7XHJcbiAgICB9XHJcbn1cclxuX2EgPSBBbWJpZ3VvdXNDaGFyYWN0ZXJzO1xyXG5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmFtYmlndW91c0NoYXJhY3RlckRhdGEgPSBuZXcgTGF6eSgoKSA9PiB7XHJcbiAgICAvLyBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2hlZGlldC92c2NvZGUtdW5pY29kZS1kYXRhXHJcbiAgICAvLyBTdG9yZWQgYXMga2V5MSwgdmFsdWUxLCBrZXkyLCB2YWx1ZTIsIC4uLlxyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoJ3tcXFwiX2NvbW1vblxcXCI6WzgyMzIsMzIsODIzMywzMiw1NzYwLDMyLDgxOTIsMzIsODE5MywzMiw4MTk0LDMyLDgxOTUsMzIsODE5NiwzMiw4MTk3LDMyLDgxOTgsMzIsODIwMCwzMiw4MjAxLDMyLDgyMDIsMzIsODI4NywzMiw4MTk5LDMyLDgyMzksMzIsMjA0Miw5NSw2NTEwMSw5NSw2NTEwMiw5NSw2NTEwMyw5NSw4MjA4LDQ1LDgyMDksNDUsODIxMCw0NSw2NTExMiw0NSwxNzQ4LDQ1LDgyNTksNDUsNzI3LDQ1LDg3MjIsNDUsMTAxMzQsNDUsMTE0NTAsNDUsMTU0OSw0NCwxNjQzLDQ0LDgyMTgsNDQsMTg0LDQ0LDQyMjMzLDQ0LDg5NCw1OSwyMzA3LDU4LDI2OTEsNTgsMTQxNyw1OCwxNzk1LDU4LDE3OTYsNTgsNTg2OCw1OCw2NTA3Miw1OCw2MTQ3LDU4LDYxNTMsNTgsODI4Miw1OCwxNDc1LDU4LDc2MCw1OCw0Mjg4OSw1OCw4NzU4LDU4LDcyMCw1OCw0MjIzNyw1OCw0NTEsMzMsMTE2MDEsMzMsNjYwLDYzLDU3Nyw2MywyNDI5LDYzLDUwMzgsNjMsNDI3MzEsNjMsMTE5MTQ5LDQ2LDgyMjgsNDYsMTc5Myw0NiwxNzk0LDQ2LDQyNTEwLDQ2LDY4MTc2LDQ2LDE2MzIsNDYsMTc3Niw0Niw0MjIzMiw0NiwxMzczLDk2LDY1Mjg3LDk2LDgyMTksOTYsODI0Miw5NiwxMzcwLDk2LDE1MjMsOTYsODE3NSw5Niw2NTM0NCw5Niw5MDAsOTYsODE4OSw5Niw4MTI1LDk2LDgxMjcsOTYsODE5MCw5Niw2OTcsOTYsODg0LDk2LDcxMiw5Niw3MTQsOTYsNzE1LDk2LDc1Niw5Niw2OTksOTYsNzAxLDk2LDcwMCw5Niw3MDIsOTYsNDI4OTIsOTYsMTQ5Nyw5NiwyMDM2LDk2LDIwMzcsOTYsNTE5NCw5Niw1ODM2LDk2LDk0MDMzLDk2LDk0MDM0LDk2LDY1MzM5LDkxLDEwMDg4LDQwLDEwMDk4LDQwLDEyMzA4LDQwLDY0ODMwLDQwLDY1MzQxLDkzLDEwMDg5LDQxLDEwMDk5LDQxLDEyMzA5LDQxLDY0ODMxLDQxLDEwMTAwLDEyMywxMTkwNjAsMTIzLDEwMTAxLDEyNSw2NTM0Miw5NCw4MjcwLDQyLDE2NDUsNDIsODcyNyw0Miw2NjMzNSw0Miw1OTQxLDQ3LDgyNTcsNDcsODcyNSw0Nyw4MjYwLDQ3LDk1ODUsNDcsMTAxODcsNDcsMTA3NDQsNDcsMTE5MzU0LDQ3LDEyNzU1LDQ3LDEyMzM5LDQ3LDExNDYyLDQ3LDIwMDMxLDQ3LDEyMDM1LDQ3LDY1MzQwLDkyLDY1MTI4LDkyLDg3MjYsOTIsMTAxODksOTIsMTA3NDEsOTIsMTA3NDUsOTIsMTE5MzExLDkyLDExOTM1NSw5MiwxMjc1Niw5MiwyMDAyMiw5MiwxMjAzNCw5Miw0Mjg3MiwzOCw3MDgsOTQsNzEwLDk0LDU4NjksNDMsMTAxMzMsNDMsNjYyMDMsNDMsODI0OSw2MCwxMDA5NCw2MCw3MDYsNjAsMTE5MzUwLDYwLDUxNzYsNjAsNTgxMCw2MCw1MTIwLDYxLDExODQwLDYxLDEyNDQ4LDYxLDQyMjM5LDYxLDgyNTAsNjIsMTAwOTUsNjIsNzA3LDYyLDExOTM1MSw2Miw1MTcxLDYyLDk0MDE1LDYyLDgyNzUsMTI2LDczMiwxMjYsODEyOCwxMjYsODc2NCwxMjYsNjUzNzIsMTI0LDY1MjkzLDQ1LDEyMDc4NCw1MCwxMjA3OTQsNTAsMTIwODA0LDUwLDEyMDgxNCw1MCwxMjA4MjQsNTAsMTMwMDM0LDUwLDQyODQyLDUwLDQyMyw1MCwxMDAwLDUwLDQyNTY0LDUwLDUzMTEsNTAsNDI3MzUsNTAsMTE5MzAyLDUxLDEyMDc4NSw1MSwxMjA3OTUsNTEsMTIwODA1LDUxLDEyMDgxNSw1MSwxMjA4MjUsNTEsMTMwMDM1LDUxLDQyOTIzLDUxLDU0MCw1MSw0MzksNTEsNDI4NTgsNTEsMTE0NjgsNTEsMTI0OCw1MSw5NDAxMSw1MSw3MTg4Miw1MSwxMjA3ODYsNTIsMTIwNzk2LDUyLDEyMDgwNiw1MiwxMjA4MTYsNTIsMTIwODI2LDUyLDEzMDAzNiw1Miw1MDcwLDUyLDcxODU1LDUyLDEyMDc4Nyw1MywxMjA3OTcsNTMsMTIwODA3LDUzLDEyMDgxNyw1MywxMjA4MjcsNTMsMTMwMDM3LDUzLDQ0NCw1Myw3MTg2Nyw1MywxMjA3ODgsNTQsMTIwNzk4LDU0LDEyMDgwOCw1NCwxMjA4MTgsNTQsMTIwODI4LDU0LDEzMDAzOCw1NCwxMTQ3NCw1NCw1MTAyLDU0LDcxODkzLDU0LDExOTMxNCw1NSwxMjA3ODksNTUsMTIwNzk5LDU1LDEyMDgwOSw1NSwxMjA4MTksNTUsMTIwODI5LDU1LDEzMDAzOSw1NSw2Njc3MCw1NSw3MTg3OCw1NSwyODE5LDU2LDI1MzgsNTYsMjY2Niw1NiwxMjUxMzEsNTYsMTIwNzkwLDU2LDEyMDgwMCw1NiwxMjA4MTAsNTYsMTIwODIwLDU2LDEyMDgzMCw1NiwxMzAwNDAsNTYsNTQ3LDU2LDU0Niw1Niw2NjMzMCw1NiwyNjYzLDU3LDI5MjAsNTcsMjU0MSw1NywzNDM3LDU3LDEyMDc5MSw1NywxMjA4MDEsNTcsMTIwODExLDU3LDEyMDgyMSw1NywxMjA4MzEsNTcsMTMwMDQxLDU3LDQyODYyLDU3LDExNDY2LDU3LDcxODg0LDU3LDcxODUyLDU3LDcxODk0LDU3LDkwODIsOTcsNjUzNDUsOTcsMTE5ODM0LDk3LDExOTg4Niw5NywxMTk5MzgsOTcsMTE5OTkwLDk3LDEyMDA0Miw5NywxMjAwOTQsOTcsMTIwMTQ2LDk3LDEyMDE5OCw5NywxMjAyNTAsOTcsMTIwMzAyLDk3LDEyMDM1NCw5NywxMjA0MDYsOTcsMTIwNDU4LDk3LDU5Myw5Nyw5NDUsOTcsMTIwNTE0LDk3LDEyMDU3Miw5NywxMjA2MzAsOTcsMTIwNjg4LDk3LDEyMDc0Niw5Nyw2NTMxMyw2NSwxMTk4MDgsNjUsMTE5ODYwLDY1LDExOTkxMiw2NSwxMTk5NjQsNjUsMTIwMDE2LDY1LDEyMDA2OCw2NSwxMjAxMjAsNjUsMTIwMTcyLDY1LDEyMDIyNCw2NSwxMjAyNzYsNjUsMTIwMzI4LDY1LDEyMDM4MCw2NSwxMjA0MzIsNjUsOTEzLDY1LDEyMDQ4OCw2NSwxMjA1NDYsNjUsMTIwNjA0LDY1LDEyMDY2Miw2NSwxMjA3MjAsNjUsNTAzNCw2NSw1NTczLDY1LDQyMjIyLDY1LDk0MDE2LDY1LDY2MjA4LDY1LDExOTgzNSw5OCwxMTk4ODcsOTgsMTE5OTM5LDk4LDExOTk5MSw5OCwxMjAwNDMsOTgsMTIwMDk1LDk4LDEyMDE0Nyw5OCwxMjAxOTksOTgsMTIwMjUxLDk4LDEyMDMwMyw5OCwxMjAzNTUsOTgsMTIwNDA3LDk4LDEyMDQ1OSw5OCwzODgsOTgsNTA3MSw5OCw1MjM0LDk4LDU1NTEsOTgsNjUzMTQsNjYsODQ5Miw2NiwxMTk4MDksNjYsMTE5ODYxLDY2LDExOTkxMyw2NiwxMjAwMTcsNjYsMTIwMDY5LDY2LDEyMDEyMSw2NiwxMjAxNzMsNjYsMTIwMjI1LDY2LDEyMDI3Nyw2NiwxMjAzMjksNjYsMTIwMzgxLDY2LDEyMDQzMyw2Niw0MjkzMiw2Niw5MTQsNjYsMTIwNDg5LDY2LDEyMDU0Nyw2NiwxMjA2MDUsNjYsMTIwNjYzLDY2LDEyMDcyMSw2Niw1MTA4LDY2LDU2MjMsNjYsNDIxOTIsNjYsNjYxNzgsNjYsNjYyMDksNjYsNjYzMDUsNjYsNjUzNDcsOTksODU3Myw5OSwxMTk4MzYsOTksMTE5ODg4LDk5LDExOTk0MCw5OSwxMTk5OTIsOTksMTIwMDQ0LDk5LDEyMDA5Niw5OSwxMjAxNDgsOTksMTIwMjAwLDk5LDEyMDI1Miw5OSwxMjAzMDQsOTksMTIwMzU2LDk5LDEyMDQwOCw5OSwxMjA0NjAsOTksNzQyOCw5OSwxMDEwLDk5LDExNDI5LDk5LDQzOTUxLDk5LDY2NjIxLDk5LDEyODg0NCw2Nyw3MTkyMiw2Nyw3MTkxMyw2Nyw2NTMxNSw2Nyw4NTU3LDY3LDg0NTAsNjcsODQ5Myw2NywxMTk4MTAsNjcsMTE5ODYyLDY3LDExOTkxNCw2NywxMTk5NjYsNjcsMTIwMDE4LDY3LDEyMDE3NCw2NywxMjAyMjYsNjcsMTIwMjc4LDY3LDEyMDMzMCw2NywxMjAzODIsNjcsMTIwNDM0LDY3LDEwMTcsNjcsMTE0MjgsNjcsNTA4Nyw2Nyw0MjIwMiw2Nyw2NjIxMCw2Nyw2NjMwNiw2Nyw2NjU4MSw2Nyw2Njg0NCw2Nyw4NTc0LDEwMCw4NTE4LDEwMCwxMTk4MzcsMTAwLDExOTg4OSwxMDAsMTE5OTQxLDEwMCwxMTk5OTMsMTAwLDEyMDA0NSwxMDAsMTIwMDk3LDEwMCwxMjAxNDksMTAwLDEyMDIwMSwxMDAsMTIwMjUzLDEwMCwxMjAzMDUsMTAwLDEyMDM1NywxMDAsMTIwNDA5LDEwMCwxMjA0NjEsMTAwLDEyODEsMTAwLDUwOTUsMTAwLDUyMzEsMTAwLDQyMTk0LDEwMCw4NTU4LDY4LDg1MTcsNjgsMTE5ODExLDY4LDExOTg2Myw2OCwxMTk5MTUsNjgsMTE5OTY3LDY4LDEyMDAxOSw2OCwxMjAwNzEsNjgsMTIwMTIzLDY4LDEyMDE3NSw2OCwxMjAyMjcsNjgsMTIwMjc5LDY4LDEyMDMzMSw2OCwxMjAzODMsNjgsMTIwNDM1LDY4LDUwMjQsNjgsNTU5OCw2OCw1NjEwLDY4LDQyMTk1LDY4LDg0OTQsMTAxLDY1MzQ5LDEwMSw4NDk1LDEwMSw4NTE5LDEwMSwxMTk4MzgsMTAxLDExOTg5MCwxMDEsMTE5OTQyLDEwMSwxMjAwNDYsMTAxLDEyMDA5OCwxMDEsMTIwMTUwLDEwMSwxMjAyMDIsMTAxLDEyMDI1NCwxMDEsMTIwMzA2LDEwMSwxMjAzNTgsMTAxLDEyMDQxMCwxMDEsMTIwNDYyLDEwMSw0MzgyNiwxMDEsMTIxMywxMDEsODk1OSw2OSw2NTMxNyw2OSw4NDk2LDY5LDExOTgxMiw2OSwxMTk4NjQsNjksMTE5OTE2LDY5LDEyMDAyMCw2OSwxMjAwNzIsNjksMTIwMTI0LDY5LDEyMDE3Niw2OSwxMjAyMjgsNjksMTIwMjgwLDY5LDEyMDMzMiw2OSwxMjAzODQsNjksMTIwNDM2LDY5LDkxNyw2OSwxMjA0OTIsNjksMTIwNTUwLDY5LDEyMDYwOCw2OSwxMjA2NjYsNjksMTIwNzI0LDY5LDExNTc3LDY5LDUwMzYsNjksNDIyMjQsNjksNzE4NDYsNjksNzE4NTQsNjksNjYxODIsNjksMTE5ODM5LDEwMiwxMTk4OTEsMTAyLDExOTk0MywxMDIsMTE5OTk1LDEwMiwxMjAwNDcsMTAyLDEyMDA5OSwxMDIsMTIwMTUxLDEwMiwxMjAyMDMsMTAyLDEyMDI1NSwxMDIsMTIwMzA3LDEwMiwxMjAzNTksMTAyLDEyMDQxMSwxMDIsMTIwNDYzLDEwMiw0MzgyOSwxMDIsNDI5MDUsMTAyLDM4MywxMDIsNzgzNywxMDIsMTQxMiwxMDIsMTE5MzE1LDcwLDg0OTcsNzAsMTE5ODEzLDcwLDExOTg2NSw3MCwxMTk5MTcsNzAsMTIwMDIxLDcwLDEyMDA3Myw3MCwxMjAxMjUsNzAsMTIwMTc3LDcwLDEyMDIyOSw3MCwxMjAyODEsNzAsMTIwMzMzLDcwLDEyMDM4NSw3MCwxMjA0MzcsNzAsNDI5MDQsNzAsOTg4LDcwLDEyMDc3OCw3MCw1NTU2LDcwLDQyMjA1LDcwLDcxODc0LDcwLDcxODQyLDcwLDY2MTgzLDcwLDY2MjEzLDcwLDY2ODUzLDcwLDY1MzUxLDEwMyw4NDU4LDEwMywxMTk4NDAsMTAzLDExOTg5MiwxMDMsMTE5OTQ0LDEwMywxMjAwNDgsMTAzLDEyMDEwMCwxMDMsMTIwMTUyLDEwMywxMjAyMDQsMTAzLDEyMDI1NiwxMDMsMTIwMzA4LDEwMywxMjAzNjAsMTAzLDEyMDQxMiwxMDMsMTIwNDY0LDEwMyw2MDksMTAzLDc1NTUsMTAzLDM5NywxMDMsMTQwOSwxMDMsMTE5ODE0LDcxLDExOTg2Niw3MSwxMTk5MTgsNzEsMTE5OTcwLDcxLDEyMDAyMiw3MSwxMjAwNzQsNzEsMTIwMTI2LDcxLDEyMDE3OCw3MSwxMjAyMzAsNzEsMTIwMjgyLDcxLDEyMDMzNCw3MSwxMjAzODYsNzEsMTIwNDM4LDcxLDEyOTIsNzEsNTA1Niw3MSw1MTA3LDcxLDQyMTk4LDcxLDY1MzUyLDEwNCw4NDYyLDEwNCwxMTk4NDEsMTA0LDExOTk0NSwxMDQsMTE5OTk3LDEwNCwxMjAwNDksMTA0LDEyMDEwMSwxMDQsMTIwMTUzLDEwNCwxMjAyMDUsMTA0LDEyMDI1NywxMDQsMTIwMzA5LDEwNCwxMjAzNjEsMTA0LDEyMDQxMywxMDQsMTIwNDY1LDEwNCwxMjExLDEwNCwxMzkyLDEwNCw1MDU4LDEwNCw2NTMyMCw3Miw4NDU5LDcyLDg0NjAsNzIsODQ2MSw3MiwxMTk4MTUsNzIsMTE5ODY3LDcyLDExOTkxOSw3MiwxMjAwMjMsNzIsMTIwMTc5LDcyLDEyMDIzMSw3MiwxMjAyODMsNzIsMTIwMzM1LDcyLDEyMDM4Nyw3MiwxMjA0MzksNzIsOTE5LDcyLDEyMDQ5NCw3MiwxMjA1NTIsNzIsMTIwNjEwLDcyLDEyMDY2OCw3MiwxMjA3MjYsNzIsMTE0MDYsNzIsNTA1MSw3Miw1NTAwLDcyLDQyMjE1LDcyLDY2MjU1LDcyLDczMSwxMDUsOTA3NSwxMDUsNjUzNTMsMTA1LDg1NjAsMTA1LDg1MDUsMTA1LDg1MjAsMTA1LDExOTg0MiwxMDUsMTE5ODk0LDEwNSwxMTk5NDYsMTA1LDExOTk5OCwxMDUsMTIwMDUwLDEwNSwxMjAxMDIsMTA1LDEyMDE1NCwxMDUsMTIwMjA2LDEwNSwxMjAyNTgsMTA1LDEyMDMxMCwxMDUsMTIwMzYyLDEwNSwxMjA0MTQsMTA1LDEyMDQ2NiwxMDUsMTIwNDg0LDEwNSw2MTgsMTA1LDYxNywxMDUsOTUzLDEwNSw4MTI2LDEwNSw4OTAsMTA1LDEyMDUyMiwxMDUsMTIwNTgwLDEwNSwxMjA2MzgsMTA1LDEyMDY5NiwxMDUsMTIwNzU0LDEwNSwxMTEwLDEwNSw0MjU2NywxMDUsMTIzMSwxMDUsNDM4OTMsMTA1LDUwMjksMTA1LDcxODc1LDEwNSw2NTM1NCwxMDYsODUyMSwxMDYsMTE5ODQzLDEwNiwxMTk4OTUsMTA2LDExOTk0NywxMDYsMTE5OTk5LDEwNiwxMjAwNTEsMTA2LDEyMDEwMywxMDYsMTIwMTU1LDEwNiwxMjAyMDcsMTA2LDEyMDI1OSwxMDYsMTIwMzExLDEwNiwxMjAzNjMsMTA2LDEyMDQxNSwxMDYsMTIwNDY3LDEwNiwxMDExLDEwNiwxMTEyLDEwNiw2NTMyMiw3NCwxMTk4MTcsNzQsMTE5ODY5LDc0LDExOTkyMSw3NCwxMTk5NzMsNzQsMTIwMDI1LDc0LDEyMDA3Nyw3NCwxMjAxMjksNzQsMTIwMTgxLDc0LDEyMDIzMyw3NCwxMjAyODUsNzQsMTIwMzM3LDc0LDEyMDM4OSw3NCwxMjA0NDEsNzQsNDI5MzAsNzQsODk1LDc0LDEwMzIsNzQsNTAzNSw3NCw1MjYxLDc0LDQyMjAxLDc0LDExOTg0NCwxMDcsMTE5ODk2LDEwNywxMTk5NDgsMTA3LDEyMDAwMCwxMDcsMTIwMDUyLDEwNywxMjAxMDQsMTA3LDEyMDE1NiwxMDcsMTIwMjA4LDEwNywxMjAyNjAsMTA3LDEyMDMxMiwxMDcsMTIwMzY0LDEwNywxMjA0MTYsMTA3LDEyMDQ2OCwxMDcsODQ5MCw3NSw2NTMyMyw3NSwxMTk4MTgsNzUsMTE5ODcwLDc1LDExOTkyMiw3NSwxMTk5NzQsNzUsMTIwMDI2LDc1LDEyMDA3OCw3NSwxMjAxMzAsNzUsMTIwMTgyLDc1LDEyMDIzNCw3NSwxMjAyODYsNzUsMTIwMzM4LDc1LDEyMDM5MCw3NSwxMjA0NDIsNzUsOTIyLDc1LDEyMDQ5Nyw3NSwxMjA1NTUsNzUsMTIwNjEzLDc1LDEyMDY3MSw3NSwxMjA3MjksNzUsMTE0MTIsNzUsNTA5NCw3NSw1ODQ1LDc1LDQyMTk5LDc1LDY2ODQwLDc1LDE0NzIsMTA4LDg3MzksNzMsOTIxMyw3Myw2NTUxMiw3MywxNjMzLDEwOCwxNzc3LDczLDY2MzM2LDEwOCwxMjUxMjcsMTA4LDEyMDc4Myw3MywxMjA3OTMsNzMsMTIwODAzLDczLDEyMDgxMyw3MywxMjA4MjMsNzMsMTMwMDMzLDczLDY1MzIxLDczLDg1NDQsNzMsODQ2NCw3Myw4NDY1LDczLDExOTgxNiw3MywxMTk4NjgsNzMsMTE5OTIwLDczLDEyMDAyNCw3MywxMjAxMjgsNzMsMTIwMTgwLDczLDEyMDIzMiw3MywxMjAyODQsNzMsMTIwMzM2LDczLDEyMDM4OCw3MywxMjA0NDAsNzMsNjUzNTYsMTA4LDg1NzIsNzMsODQ2NywxMDgsMTE5ODQ1LDEwOCwxMTk4OTcsMTA4LDExOTk0OSwxMDgsMTIwMDAxLDEwOCwxMjAwNTMsMTA4LDEyMDEwNSw3MywxMjAxNTcsNzMsMTIwMjA5LDczLDEyMDI2MSw3MywxMjAzMTMsNzMsMTIwMzY1LDczLDEyMDQxNyw3MywxMjA0NjksNzMsNDQ4LDczLDEyMDQ5Niw3MywxMjA1NTQsNzMsMTIwNjEyLDczLDEyMDY3MCw3MywxMjA3MjgsNzMsMTE0MTAsNzMsMTAzMCw3MywxMjE2LDczLDE0OTMsMTA4LDE1MDMsMTA4LDE1NzUsMTA4LDEyNjQ2NCwxMDgsMTI2NTkyLDEwOCw2NTE2NiwxMDgsNjUxNjUsMTA4LDE5OTQsMTA4LDExNTk5LDczLDU4MjUsNzMsNDIyMjYsNzMsOTM5OTIsNzMsNjYxODYsMTI0LDY2MzEzLDEyNCwxMTkzMzgsNzYsODU1Niw3Niw4NDY2LDc2LDExOTgxOSw3NiwxMTk4NzEsNzYsMTE5OTIzLDc2LDEyMDAyNyw3NiwxMjAwNzksNzYsMTIwMTMxLDc2LDEyMDE4Myw3NiwxMjAyMzUsNzYsMTIwMjg3LDc2LDEyMDMzOSw3NiwxMjAzOTEsNzYsMTIwNDQzLDc2LDExNDcyLDc2LDUwODYsNzYsNTI5MCw3Niw0MjIwOSw3Niw5Mzk3NCw3Niw3MTg0Myw3Niw3MTg1OCw3Niw2NjU4Nyw3Niw2Njg1NCw3Niw2NTMyNSw3Nyw4NTU5LDc3LDg0OTksNzcsMTE5ODIwLDc3LDExOTg3Miw3NywxMTk5MjQsNzcsMTIwMDI4LDc3LDEyMDA4MCw3NywxMjAxMzIsNzcsMTIwMTg0LDc3LDEyMDIzNiw3NywxMjAyODgsNzcsMTIwMzQwLDc3LDEyMDM5Miw3NywxMjA0NDQsNzcsOTI0LDc3LDEyMDQ5OSw3NywxMjA1NTcsNzcsMTIwNjE1LDc3LDEyMDY3Myw3NywxMjA3MzEsNzcsMTAxOCw3NywxMTQxNiw3Nyw1MDQ3LDc3LDU2MTYsNzcsNTg0Niw3Nyw0MjIwNyw3Nyw2NjIyNCw3Nyw2NjMyMSw3NywxMTk4NDcsMTEwLDExOTg5OSwxMTAsMTE5OTUxLDExMCwxMjAwMDMsMTEwLDEyMDA1NSwxMTAsMTIwMTA3LDExMCwxMjAxNTksMTEwLDEyMDIxMSwxMTAsMTIwMjYzLDExMCwxMjAzMTUsMTEwLDEyMDM2NywxMTAsMTIwNDE5LDExMCwxMjA0NzEsMTEwLDE0MDAsMTEwLDE0MDQsMTEwLDY1MzI2LDc4LDg0NjksNzgsMTE5ODIxLDc4LDExOTg3Myw3OCwxMTk5MjUsNzgsMTE5OTc3LDc4LDEyMDAyOSw3OCwxMjAwODEsNzgsMTIwMTg1LDc4LDEyMDIzNyw3OCwxMjAyODksNzgsMTIwMzQxLDc4LDEyMDM5Myw3OCwxMjA0NDUsNzgsOTI1LDc4LDEyMDUwMCw3OCwxMjA1NTgsNzgsMTIwNjE2LDc4LDEyMDY3NCw3OCwxMjA3MzIsNzgsMTE0MTgsNzgsNDIyMDgsNzgsNjY4MzUsNzgsMzA3NCwxMTEsMzIwMiwxMTEsMzMzMCwxMTEsMzQ1OCwxMTEsMjQwNiwxMTEsMjY2MiwxMTEsMjc5MCwxMTEsMzA0NiwxMTEsMzE3NCwxMTEsMzMwMiwxMTEsMzQzMCwxMTEsMzY2NCwxMTEsMzc5MiwxMTEsNDE2MCwxMTEsMTYzNywxMTEsMTc4MSwxMTEsNjUzNTksMTExLDg1MDAsMTExLDExOTg0OCwxMTEsMTE5OTAwLDExMSwxMTk5NTIsMTExLDEyMDA1NiwxMTEsMTIwMTA4LDExMSwxMjAxNjAsMTExLDEyMDIxMiwxMTEsMTIwMjY0LDExMSwxMjAzMTYsMTExLDEyMDM2OCwxMTEsMTIwNDIwLDExMSwxMjA0NzIsMTExLDc0MzksMTExLDc0NDEsMTExLDQzODM3LDExMSw5NTksMTExLDEyMDUyOCwxMTEsMTIwNTg2LDExMSwxMjA2NDQsMTExLDEyMDcwMiwxMTEsMTIwNzYwLDExMSw5NjMsMTExLDEyMDUzMiwxMTEsMTIwNTkwLDExMSwxMjA2NDgsMTExLDEyMDcwNiwxMTEsMTIwNzY0LDExMSwxMTQyMywxMTEsNDM1MSwxMTEsMTQxMywxMTEsMTUwNSwxMTEsMTYwNywxMTEsMTI2NTAwLDExMSwxMjY1NjQsMTExLDEyNjU5NiwxMTEsNjUyNTksMTExLDY1MjYwLDExMSw2NTI1OCwxMTEsNjUyNTcsMTExLDE3MjYsMTExLDY0NDI4LDExMSw2NDQyOSwxMTEsNjQ0MjcsMTExLDY0NDI2LDExMSwxNzI5LDExMSw2NDQyNCwxMTEsNjQ0MjUsMTExLDY0NDIzLDExMSw2NDQyMiwxMTEsMTc0OSwxMTEsMzM2MCwxMTEsNDEyNSwxMTEsNjY3OTQsMTExLDcxODgwLDExMSw3MTg5NSwxMTEsNjY2MDQsMTExLDE5ODQsNzksMjUzNCw3OSwyOTE4LDc5LDEyMjk1LDc5LDcwODY0LDc5LDcxOTA0LDc5LDEyMDc4Miw3OSwxMjA3OTIsNzksMTIwODAyLDc5LDEyMDgxMiw3OSwxMjA4MjIsNzksMTMwMDMyLDc5LDY1MzI3LDc5LDExOTgyMiw3OSwxMTk4NzQsNzksMTE5OTI2LDc5LDExOTk3OCw3OSwxMjAwMzAsNzksMTIwMDgyLDc5LDEyMDEzNCw3OSwxMjAxODYsNzksMTIwMjM4LDc5LDEyMDI5MCw3OSwxMjAzNDIsNzksMTIwMzk0LDc5LDEyMDQ0Niw3OSw5MjcsNzksMTIwNTAyLDc5LDEyMDU2MCw3OSwxMjA2MTgsNzksMTIwNjc2LDc5LDEyMDczNCw3OSwxMTQyMiw3OSwxMzY1LDc5LDExNjA0LDc5LDQ4MTYsNzksMjg0OCw3OSw2Njc1NCw3OSw0MjIyNyw3OSw3MTg2MSw3OSw2NjE5NCw3OSw2NjIxOSw3OSw2NjU2NCw3OSw2NjgzOCw3OSw5MDc2LDExMiw2NTM2MCwxMTIsMTE5ODQ5LDExMiwxMTk5MDEsMTEyLDExOTk1MywxMTIsMTIwMDA1LDExMiwxMjAwNTcsMTEyLDEyMDEwOSwxMTIsMTIwMTYxLDExMiwxMjAyMTMsMTEyLDEyMDI2NSwxMTIsMTIwMzE3LDExMiwxMjAzNjksMTEyLDEyMDQyMSwxMTIsMTIwNDczLDExMiw5NjEsMTEyLDEyMDUzMCwxMTIsMTIwNTQ0LDExMiwxMjA1ODgsMTEyLDEyMDYwMiwxMTIsMTIwNjQ2LDExMiwxMjA2NjAsMTEyLDEyMDcwNCwxMTIsMTIwNzE4LDExMiwxMjA3NjIsMTEyLDEyMDc3NiwxMTIsMTE0MjcsMTEyLDY1MzI4LDgwLDg0NzMsODAsMTE5ODIzLDgwLDExOTg3NSw4MCwxMTk5MjcsODAsMTE5OTc5LDgwLDEyMDAzMSw4MCwxMjAwODMsODAsMTIwMTg3LDgwLDEyMDIzOSw4MCwxMjAyOTEsODAsMTIwMzQzLDgwLDEyMDM5NSw4MCwxMjA0NDcsODAsOTI5LDgwLDEyMDUwNCw4MCwxMjA1NjIsODAsMTIwNjIwLDgwLDEyMDY3OCw4MCwxMjA3MzYsODAsMTE0MjYsODAsNTA5MCw4MCw1MjI5LDgwLDQyMTkzLDgwLDY2MTk3LDgwLDExOTg1MCwxMTMsMTE5OTAyLDExMywxMTk5NTQsMTEzLDEyMDAwNiwxMTMsMTIwMDU4LDExMywxMjAxMTAsMTEzLDEyMDE2MiwxMTMsMTIwMjE0LDExMywxMjAyNjYsMTEzLDEyMDMxOCwxMTMsMTIwMzcwLDExMywxMjA0MjIsMTEzLDEyMDQ3NCwxMTMsMTMwNywxMTMsMTM3OSwxMTMsMTM4MiwxMTMsODQ3NCw4MSwxMTk4MjQsODEsMTE5ODc2LDgxLDExOTkyOCw4MSwxMTk5ODAsODEsMTIwMDMyLDgxLDEyMDA4NCw4MSwxMjAxODgsODEsMTIwMjQwLDgxLDEyMDI5Miw4MSwxMjAzNDQsODEsMTIwMzk2LDgxLDEyMDQ0OCw4MSwxMTYwNSw4MSwxMTk4NTEsMTE0LDExOTkwMywxMTQsMTE5OTU1LDExNCwxMjAwMDcsMTE0LDEyMDA1OSwxMTQsMTIwMTExLDExNCwxMjAxNjMsMTE0LDEyMDIxNSwxMTQsMTIwMjY3LDExNCwxMjAzMTksMTE0LDEyMDM3MSwxMTQsMTIwNDIzLDExNCwxMjA0NzUsMTE0LDQzODQ3LDExNCw0Mzg0OCwxMTQsNzQ2MiwxMTQsMTEzOTcsMTE0LDQzOTA1LDExNCwxMTkzMTgsODIsODQ3NSw4Miw4NDc2LDgyLDg0NzcsODIsMTE5ODI1LDgyLDExOTg3Nyw4MiwxMTk5MjksODIsMTIwMDMzLDgyLDEyMDE4OSw4MiwxMjAyNDEsODIsMTIwMjkzLDgyLDEyMDM0NSw4MiwxMjAzOTcsODIsMTIwNDQ5LDgyLDQyMiw4Miw1MDI1LDgyLDUwNzQsODIsNjY3NDAsODIsNTUxMSw4Miw0MjIxMSw4Miw5NDAwNSw4Miw2NTM2MywxMTUsMTE5ODUyLDExNSwxMTk5MDQsMTE1LDExOTk1NiwxMTUsMTIwMDA4LDExNSwxMjAwNjAsMTE1LDEyMDExMiwxMTUsMTIwMTY0LDExNSwxMjAyMTYsMTE1LDEyMDI2OCwxMTUsMTIwMzIwLDExNSwxMjAzNzIsMTE1LDEyMDQyNCwxMTUsMTIwNDc2LDExNSw0MjgwMSwxMTUsNDQ1LDExNSwxMTA5LDExNSw0Mzk0NiwxMTUsNzE4NzMsMTE1LDY2NjMyLDExNSw2NTMzMSw4MywxMTk4MjYsODMsMTE5ODc4LDgzLDExOTkzMCw4MywxMTk5ODIsODMsMTIwMDM0LDgzLDEyMDA4Niw4MywxMjAxMzgsODMsMTIwMTkwLDgzLDEyMDI0Miw4MywxMjAyOTQsODMsMTIwMzQ2LDgzLDEyMDM5OCw4MywxMjA0NTAsODMsMTAyOSw4MywxMzU5LDgzLDUwNzcsODMsNTA4Miw4Myw0MjIxMCw4Myw5NDAxMCw4Myw2NjE5OCw4Myw2NjU5Miw4MywxMTk4NTMsMTE2LDExOTkwNSwxMTYsMTE5OTU3LDExNiwxMjAwMDksMTE2LDEyMDA2MSwxMTYsMTIwMTEzLDExNiwxMjAxNjUsMTE2LDEyMDIxNywxMTYsMTIwMjY5LDExNiwxMjAzMjEsMTE2LDEyMDM3MywxMTYsMTIwNDI1LDExNiwxMjA0NzcsMTE2LDg4NjgsODQsMTAyMDEsODQsMTI4ODcyLDg0LDY1MzMyLDg0LDExOTgyNyw4NCwxMTk4NzksODQsMTE5OTMxLDg0LDExOTk4Myw4NCwxMjAwMzUsODQsMTIwMDg3LDg0LDEyMDEzOSw4NCwxMjAxOTEsODQsMTIwMjQzLDg0LDEyMDI5NSw4NCwxMjAzNDcsODQsMTIwMzk5LDg0LDEyMDQ1MSw4NCw5MzIsODQsMTIwNTA3LDg0LDEyMDU2NSw4NCwxMjA2MjMsODQsMTIwNjgxLDg0LDEyMDczOSw4NCwxMTQzMCw4NCw1MDI2LDg0LDQyMTk2LDg0LDkzOTYyLDg0LDcxODY4LDg0LDY2MTk5LDg0LDY2MjI1LDg0LDY2MzI1LDg0LDExOTg1NCwxMTcsMTE5OTA2LDExNywxMTk5NTgsMTE3LDEyMDAxMCwxMTcsMTIwMDYyLDExNywxMjAxMTQsMTE3LDEyMDE2NiwxMTcsMTIwMjE4LDExNywxMjAyNzAsMTE3LDEyMDMyMiwxMTcsMTIwMzc0LDExNywxMjA0MjYsMTE3LDEyMDQ3OCwxMTcsNDI5MTEsMTE3LDc0NTIsMTE3LDQzODU0LDExNyw0Mzg1OCwxMTcsNjUxLDExNyw5NjUsMTE3LDEyMDUzNCwxMTcsMTIwNTkyLDExNywxMjA2NTAsMTE3LDEyMDcwOCwxMTcsMTIwNzY2LDExNywxNDA1LDExNyw2NjgwNiwxMTcsNzE4OTYsMTE3LDg3NDYsODUsODg5OSw4NSwxMTk4MjgsODUsMTE5ODgwLDg1LDExOTkzMiw4NSwxMTk5ODQsODUsMTIwMDM2LDg1LDEyMDA4OCw4NSwxMjAxNDAsODUsMTIwMTkyLDg1LDEyMDI0NCw4NSwxMjAyOTYsODUsMTIwMzQ4LDg1LDEyMDQwMCw4NSwxMjA0NTIsODUsMTM1Nyw4NSw0NjA4LDg1LDY2NzY2LDg1LDUxOTYsODUsNDIyMjgsODUsOTQwMTgsODUsNzE4NjQsODUsODc0NCwxMTgsODg5NywxMTgsNjUzNjYsMTE4LDg1NjQsMTE4LDExOTg1NSwxMTgsMTE5OTA3LDExOCwxMTk5NTksMTE4LDEyMDAxMSwxMTgsMTIwMDYzLDExOCwxMjAxMTUsMTE4LDEyMDE2NywxMTgsMTIwMjE5LDExOCwxMjAyNzEsMTE4LDEyMDMyMywxMTgsMTIwMzc1LDExOCwxMjA0MjcsMTE4LDEyMDQ3OSwxMTgsNzQ1NiwxMTgsOTU3LDExOCwxMjA1MjYsMTE4LDEyMDU4NCwxMTgsMTIwNjQyLDExOCwxMjA3MDAsMTE4LDEyMDc1OCwxMTgsMTE0MSwxMTgsMTQ5NiwxMTgsNzE0MzAsMTE4LDQzOTQ1LDExOCw3MTg3MiwxMTgsMTE5MzA5LDg2LDE2MzksODYsMTc4Myw4Niw4NTQ4LDg2LDExOTgyOSw4NiwxMTk4ODEsODYsMTE5OTMzLDg2LDExOTk4NSw4NiwxMjAwMzcsODYsMTIwMDg5LDg2LDEyMDE0MSw4NiwxMjAxOTMsODYsMTIwMjQ1LDg2LDEyMDI5Nyw4NiwxMjAzNDksODYsMTIwNDAxLDg2LDEyMDQ1Myw4NiwxMTQwLDg2LDExNTc2LDg2LDUwODEsODYsNTE2Nyw4Niw0MjcxOSw4Niw0MjIxNCw4Niw5Mzk2MCw4Niw3MTg0MCw4Niw2Njg0NSw4Niw2MjMsMTE5LDExOTg1NiwxMTksMTE5OTA4LDExOSwxMTk5NjAsMTE5LDEyMDAxMiwxMTksMTIwMDY0LDExOSwxMjAxMTYsMTE5LDEyMDE2OCwxMTksMTIwMjIwLDExOSwxMjAyNzIsMTE5LDEyMDMyNCwxMTksMTIwMzc2LDExOSwxMjA0MjgsMTE5LDEyMDQ4MCwxMTksNzQ1NywxMTksMTEyMSwxMTksMTMwOSwxMTksMTM3NywxMTksNzE0MzQsMTE5LDcxNDM4LDExOSw3MTQzOSwxMTksNDM5MDcsMTE5LDcxOTE5LDg3LDcxOTEwLDg3LDExOTgzMCw4NywxMTk4ODIsODcsMTE5OTM0LDg3LDExOTk4Niw4NywxMjAwMzgsODcsMTIwMDkwLDg3LDEyMDE0Miw4NywxMjAxOTQsODcsMTIwMjQ2LDg3LDEyMDI5OCw4NywxMjAzNTAsODcsMTIwNDAyLDg3LDEyMDQ1NCw4NywxMzA4LDg3LDUwNDMsODcsNTA3Niw4Nyw0MjIxOCw4Nyw1NzQyLDEyMCwxMDUzOSwxMjAsMTA1NDAsMTIwLDEwNzk5LDEyMCw2NTM2OCwxMjAsODU2OSwxMjAsMTE5ODU3LDEyMCwxMTk5MDksMTIwLDExOTk2MSwxMjAsMTIwMDEzLDEyMCwxMjAwNjUsMTIwLDEyMDExNywxMjAsMTIwMTY5LDEyMCwxMjAyMjEsMTIwLDEyMDI3MywxMjAsMTIwMzI1LDEyMCwxMjAzNzcsMTIwLDEyMDQyOSwxMjAsMTIwNDgxLDEyMCw1NDQxLDEyMCw1NTAxLDEyMCw1NzQxLDg4LDk1ODcsODgsNjYzMzgsODgsNzE5MTYsODgsNjUzMzYsODgsODU1Myw4OCwxMTk4MzEsODgsMTE5ODgzLDg4LDExOTkzNSw4OCwxMTk5ODcsODgsMTIwMDM5LDg4LDEyMDA5MSw4OCwxMjAxNDMsODgsMTIwMTk1LDg4LDEyMDI0Nyw4OCwxMjAyOTksODgsMTIwMzUxLDg4LDEyMDQwMyw4OCwxMjA0NTUsODgsNDI5MzEsODgsOTM1LDg4LDEyMDUxMCw4OCwxMjA1NjgsODgsMTIwNjI2LDg4LDEyMDY4NCw4OCwxMjA3NDIsODgsMTE0MzYsODgsMTE2MTMsODgsNTgxNSw4OCw0MjIxOSw4OCw2NjE5Miw4OCw2NjIyOCw4OCw2NjMyNyw4OCw2Njg1NSw4OCw2MTEsMTIxLDc1NjQsMTIxLDY1MzY5LDEyMSwxMTk4NTgsMTIxLDExOTkxMCwxMjEsMTE5OTYyLDEyMSwxMjAwMTQsMTIxLDEyMDA2NiwxMjEsMTIwMTE4LDEyMSwxMjAxNzAsMTIxLDEyMDIyMiwxMjEsMTIwMjc0LDEyMSwxMjAzMjYsMTIxLDEyMDM3OCwxMjEsMTIwNDMwLDEyMSwxMjA0ODIsMTIxLDY1NSwxMjEsNzkzNSwxMjEsNDM4NjYsMTIxLDk0NywxMjEsODUwOSwxMjEsMTIwNTE2LDEyMSwxMjA1NzQsMTIxLDEyMDYzMiwxMjEsMTIwNjkwLDEyMSwxMjA3NDgsMTIxLDExOTksMTIxLDQzMjcsMTIxLDcxOTAwLDEyMSw2NTMzNyw4OSwxMTk4MzIsODksMTE5ODg0LDg5LDExOTkzNiw4OSwxMTk5ODgsODksMTIwMDQwLDg5LDEyMDA5Miw4OSwxMjAxNDQsODksMTIwMTk2LDg5LDEyMDI0OCw4OSwxMjAzMDAsODksMTIwMzUyLDg5LDEyMDQwNCw4OSwxMjA0NTYsODksOTMzLDg5LDk3OCw4OSwxMjA1MDgsODksMTIwNTY2LDg5LDEyMDYyNCw4OSwxMjA2ODIsODksMTIwNzQwLDg5LDExNDMyLDg5LDExOTgsODksNTAzMyw4OSw1MDUzLDg5LDQyMjIwLDg5LDk0MDE5LDg5LDcxODQ0LDg5LDY2MjI2LDg5LDExOTg1OSwxMjIsMTE5OTExLDEyMiwxMTk5NjMsMTIyLDEyMDAxNSwxMjIsMTIwMDY3LDEyMiwxMjAxMTksMTIyLDEyMDE3MSwxMjIsMTIwMjIzLDEyMiwxMjAyNzUsMTIyLDEyMDMyNywxMjIsMTIwMzc5LDEyMiwxMjA0MzEsMTIyLDEyMDQ4MywxMjIsNzQ1OCwxMjIsNDM5MjMsMTIyLDcxODc2LDEyMiw2NjI5Myw5MCw3MTkwOSw5MCw2NTMzOCw5MCw4NDg0LDkwLDg0ODgsOTAsMTE5ODMzLDkwLDExOTg4NSw5MCwxMTk5MzcsOTAsMTE5OTg5LDkwLDEyMDA0MSw5MCwxMjAxOTcsOTAsMTIwMjQ5LDkwLDEyMDMwMSw5MCwxMjAzNTMsOTAsMTIwNDA1LDkwLDEyMDQ1Nyw5MCw5MTgsOTAsMTIwNDkzLDkwLDEyMDU1MSw5MCwxMjA2MDksOTAsMTIwNjY3LDkwLDEyMDcyNSw5MCw1MDU5LDkwLDQyMjA0LDkwLDcxODQ5LDkwLDY1MjgyLDM0LDY1Mjg0LDM2LDY1Mjg1LDM3LDY1Mjg2LDM4LDY1MjkwLDQyLDY1MjkxLDQzLDY1Mjk0LDQ2LDY1Mjk1LDQ3LDY1Mjk2LDQ4LDY1Mjk3LDQ5LDY1Mjk4LDUwLDY1Mjk5LDUxLDY1MzAwLDUyLDY1MzAxLDUzLDY1MzAyLDU0LDY1MzAzLDU1LDY1MzA0LDU2LDY1MzA1LDU3LDY1MzA4LDYwLDY1MzA5LDYxLDY1MzEwLDYyLDY1MzEyLDY0LDY1MzE2LDY4LDY1MzE4LDcwLDY1MzE5LDcxLDY1MzI0LDc2LDY1MzI5LDgxLDY1MzMwLDgyLDY1MzMzLDg1LDY1MzM0LDg2LDY1MzM1LDg3LDY1MzQzLDk1LDY1MzQ2LDk4LDY1MzQ4LDEwMCw2NTM1MCwxMDIsNjUzNTUsMTA3LDY1MzU3LDEwOSw2NTM1OCwxMTAsNjUzNjEsMTEzLDY1MzYyLDExNCw2NTM2NCwxMTYsNjUzNjUsMTE3LDY1MzY3LDExOSw2NTM3MCwxMjIsNjUzNzEsMTIzLDY1MzczLDEyNSwxMTk4NDYsMTA5XSxcXFwiX2RlZmF1bHRcXFwiOlsxNjAsMzIsODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiY3NcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImRlXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJlc1xcXCI6WzgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJmclxcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyNDUsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJpdFxcXCI6WzE2MCwzMiw4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiamFcXFwiOls4MjExLDQ1LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI5Miw0NCw2NTMwNyw1OV0sXFxcImtvXFxcIjpbODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJwbFxcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJwdC1CUlxcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJxcHMtcGxvY1xcXCI6WzE2MCwzMiw4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJydVxcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMzA1LDEwNSw5MjEsNzMsMTAwOSwxMTIsMjE1LDEyMCw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInRyXFxcIjpbMTYwLDMyLDgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInpoLWhhbnNcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODgsNDAsNjUyODksNDFdLFxcXCJ6aC1oYW50XFxcIjpbODIxMSw0NSw2NTM3NCwxMjYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1MzA3LDU5XX0nKTtcclxufSk7XHJcbkFtYmlndW91c0NoYXJhY3RlcnMuY2FjaGUgPSBuZXcgTFJVQ2FjaGVkRnVuY3Rpb24oeyBnZXRDYWNoZUtleTogSlNPTi5zdHJpbmdpZnkgfSwgKGxvY2FsZXMpID0+IHtcclxuICAgIGZ1bmN0aW9uIGFycmF5VG9NYXAoYXJyKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoYXJyW2ldLCBhcnJbaSArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlTWFwcyhtYXAxLCBtYXAyKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcChtYXAxKTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RNYXBzKG1hcDEsIG1hcDIpIHtcclxuICAgICAgICBpZiAoIW1hcDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXAyLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gX2EuYW1iaWd1b3VzQ2hhcmFjdGVyRGF0YS52YWx1ZTtcclxuICAgIGxldCBmaWx0ZXJlZExvY2FsZXMgPSBsb2NhbGVzLmZpbHRlcigobCkgPT4gIWwuc3RhcnRzV2l0aCgnXycpICYmIGwgaW4gZGF0YSk7XHJcbiAgICBpZiAoZmlsdGVyZWRMb2NhbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGZpbHRlcmVkTG9jYWxlcyA9IFsnX2RlZmF1bHQnXTtcclxuICAgIH1cclxuICAgIGxldCBsYW5ndWFnZVNwZWNpZmljTWFwID0gdW5kZWZpbmVkO1xyXG4gICAgZm9yIChjb25zdCBsb2NhbGUgb2YgZmlsdGVyZWRMb2NhbGVzKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gYXJyYXlUb01hcChkYXRhW2xvY2FsZV0pO1xyXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNYXAgPSBpbnRlcnNlY3RNYXBzKGxhbmd1YWdlU3BlY2lmaWNNYXAsIG1hcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21tb25NYXAgPSBhcnJheVRvTWFwKGRhdGFbJ19jb21tb24nXSk7XHJcbiAgICBjb25zdCBtYXAgPSBtZXJnZU1hcHMoY29tbW9uTWFwLCBsYW5ndWFnZVNwZWNpZmljTWFwKTtcclxuICAgIHJldHVybiBuZXcgX2EobWFwKTtcclxufSk7XHJcbkFtYmlndW91c0NoYXJhY3RlcnMuX2xvY2FsZXMgPSBuZXcgTGF6eSgoKSA9PiBPYmplY3Qua2V5cyhfYS5hbWJpZ3VvdXNDaGFyYWN0ZXJEYXRhLnZhbHVlKS5maWx0ZXIoKGspID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpO1xyXG5leHBvcnQgY2xhc3MgSW52aXNpYmxlQ2hhcmFjdGVycyB7XHJcbiAgICBzdGF0aWMgZ2V0UmF3RGF0YSgpIHtcclxuICAgICAgICAvLyBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2hlZGlldC92c2NvZGUtdW5pY29kZS1kYXRhXHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoJ1s5LDEwLDExLDEyLDEzLDMyLDEyNywxNjAsMTczLDg0NywxNTY0LDQ0NDcsNDQ0OCw2MDY4LDYwNjksNjE1NSw2MTU2LDYxNTcsNjE1OCw3MzU1LDczNTYsODE5Miw4MTkzLDgxOTQsODE5NSw4MTk2LDgxOTcsODE5OCw4MTk5LDgyMDAsODIwMSw4MjAyLDgyMDMsODIwNCw4MjA1LDgyMDYsODIwNyw4MjM0LDgyMzUsODIzNiw4MjM3LDgyMzgsODIzOSw4Mjg3LDgyODgsODI4OSw4MjkwLDgyOTEsODI5Miw4MjkzLDgyOTQsODI5NSw4Mjk2LDgyOTcsODI5OCw4Mjk5LDgzMDAsODMwMSw4MzAyLDgzMDMsMTAyNDAsMTIyODgsMTI2NDQsNjUwMjQsNjUwMjUsNjUwMjYsNjUwMjcsNjUwMjgsNjUwMjksNjUwMzAsNjUwMzEsNjUwMzIsNjUwMzMsNjUwMzQsNjUwMzUsNjUwMzYsNjUwMzcsNjUwMzgsNjUwMzksNjUyNzksNjU0NDAsNjU1MjAsNjU1MjEsNjU1MjIsNjU1MjMsNjU1MjQsNjU1MjUsNjU1MjYsNjU1MjcsNjU1MjgsNjU1MzIsNzg4NDQsMTE5MTU1LDExOTE1NiwxMTkxNTcsMTE5MTU4LDExOTE1OSwxMTkxNjAsMTE5MTYxLDExOTE2Miw5MTc1MDQsOTE3NTA1LDkxNzUwNiw5MTc1MDcsOTE3NTA4LDkxNzUwOSw5MTc1MTAsOTE3NTExLDkxNzUxMiw5MTc1MTMsOTE3NTE0LDkxNzUxNSw5MTc1MTYsOTE3NTE3LDkxNzUxOCw5MTc1MTksOTE3NTIwLDkxNzUyMSw5MTc1MjIsOTE3NTIzLDkxNzUyNCw5MTc1MjUsOTE3NTI2LDkxNzUyNyw5MTc1MjgsOTE3NTI5LDkxNzUzMCw5MTc1MzEsOTE3NTMyLDkxNzUzMyw5MTc1MzQsOTE3NTM1LDkxNzUzNiw5MTc1MzcsOTE3NTM4LDkxNzUzOSw5MTc1NDAsOTE3NTQxLDkxNzU0Miw5MTc1NDMsOTE3NTQ0LDkxNzU0NSw5MTc1NDYsOTE3NTQ3LDkxNzU0OCw5MTc1NDksOTE3NTUwLDkxNzU1MSw5MTc1NTIsOTE3NTUzLDkxNzU1NCw5MTc1NTUsOTE3NTU2LDkxNzU1Nyw5MTc1NTgsOTE3NTU5LDkxNzU2MCw5MTc1NjEsOTE3NTYyLDkxNzU2Myw5MTc1NjQsOTE3NTY1LDkxNzU2Niw5MTc1NjcsOTE3NTY4LDkxNzU2OSw5MTc1NzAsOTE3NTcxLDkxNzU3Miw5MTc1NzMsOTE3NTc0LDkxNzU3NSw5MTc1NzYsOTE3NTc3LDkxNzU3OCw5MTc1NzksOTE3NTgwLDkxNzU4MSw5MTc1ODIsOTE3NTgzLDkxNzU4NCw5MTc1ODUsOTE3NTg2LDkxNzU4Nyw5MTc1ODgsOTE3NTg5LDkxNzU5MCw5MTc1OTEsOTE3NTkyLDkxNzU5Myw5MTc1OTQsOTE3NTk1LDkxNzU5Niw5MTc1OTcsOTE3NTk4LDkxNzU5OSw5MTc2MDAsOTE3NjAxLDkxNzYwMiw5MTc2MDMsOTE3NjA0LDkxNzYwNSw5MTc2MDYsOTE3NjA3LDkxNzYwOCw5MTc2MDksOTE3NjEwLDkxNzYxMSw5MTc2MTIsOTE3NjEzLDkxNzYxNCw5MTc2MTUsOTE3NjE2LDkxNzYxNyw5MTc2MTgsOTE3NjE5LDkxNzYyMCw5MTc2MjEsOTE3NjIyLDkxNzYyMyw5MTc2MjQsOTE3NjI1LDkxNzYyNiw5MTc2MjcsOTE3NjI4LDkxNzYyOSw5MTc2MzAsOTE3NjMxLDkxNzc2MCw5MTc3NjEsOTE3NzYyLDkxNzc2Myw5MTc3NjQsOTE3NzY1LDkxNzc2Niw5MTc3NjcsOTE3NzY4LDkxNzc2OSw5MTc3NzAsOTE3NzcxLDkxNzc3Miw5MTc3NzMsOTE3Nzc0LDkxNzc3NSw5MTc3NzYsOTE3Nzc3LDkxNzc3OCw5MTc3NzksOTE3NzgwLDkxNzc4MSw5MTc3ODIsOTE3NzgzLDkxNzc4NCw5MTc3ODUsOTE3Nzg2LDkxNzc4Nyw5MTc3ODgsOTE3Nzg5LDkxNzc5MCw5MTc3OTEsOTE3NzkyLDkxNzc5Myw5MTc3OTQsOTE3Nzk1LDkxNzc5Niw5MTc3OTcsOTE3Nzk4LDkxNzc5OSw5MTc4MDAsOTE3ODAxLDkxNzgwMiw5MTc4MDMsOTE3ODA0LDkxNzgwNSw5MTc4MDYsOTE3ODA3LDkxNzgwOCw5MTc4MDksOTE3ODEwLDkxNzgxMSw5MTc4MTIsOTE3ODEzLDkxNzgxNCw5MTc4MTUsOTE3ODE2LDkxNzgxNyw5MTc4MTgsOTE3ODE5LDkxNzgyMCw5MTc4MjEsOTE3ODIyLDkxNzgyMyw5MTc4MjQsOTE3ODI1LDkxNzgyNiw5MTc4MjcsOTE3ODI4LDkxNzgyOSw5MTc4MzAsOTE3ODMxLDkxNzgzMiw5MTc4MzMsOTE3ODM0LDkxNzgzNSw5MTc4MzYsOTE3ODM3LDkxNzgzOCw5MTc4MzksOTE3ODQwLDkxNzg0MSw5MTc4NDIsOTE3ODQzLDkxNzg0NCw5MTc4NDUsOTE3ODQ2LDkxNzg0Nyw5MTc4NDgsOTE3ODQ5LDkxNzg1MCw5MTc4NTEsOTE3ODUyLDkxNzg1Myw5MTc4NTQsOTE3ODU1LDkxNzg1Niw5MTc4NTcsOTE3ODU4LDkxNzg1OSw5MTc4NjAsOTE3ODYxLDkxNzg2Miw5MTc4NjMsOTE3ODY0LDkxNzg2NSw5MTc4NjYsOTE3ODY3LDkxNzg2OCw5MTc4NjksOTE3ODcwLDkxNzg3MSw5MTc4NzIsOTE3ODczLDkxNzg3NCw5MTc4NzUsOTE3ODc2LDkxNzg3Nyw5MTc4NzgsOTE3ODc5LDkxNzg4MCw5MTc4ODEsOTE3ODgyLDkxNzg4Myw5MTc4ODQsOTE3ODg1LDkxNzg4Niw5MTc4ODcsOTE3ODg4LDkxNzg4OSw5MTc4OTAsOTE3ODkxLDkxNzg5Miw5MTc4OTMsOTE3ODk0LDkxNzg5NSw5MTc4OTYsOTE3ODk3LDkxNzg5OCw5MTc4OTksOTE3OTAwLDkxNzkwMSw5MTc5MDIsOTE3OTAzLDkxNzkwNCw5MTc5MDUsOTE3OTA2LDkxNzkwNyw5MTc5MDgsOTE3OTA5LDkxNzkxMCw5MTc5MTEsOTE3OTEyLDkxNzkxMyw5MTc5MTQsOTE3OTE1LDkxNzkxNiw5MTc5MTcsOTE3OTE4LDkxNzkxOSw5MTc5MjAsOTE3OTIxLDkxNzkyMiw5MTc5MjMsOTE3OTI0LDkxNzkyNSw5MTc5MjYsOTE3OTI3LDkxNzkyOCw5MTc5MjksOTE3OTMwLDkxNzkzMSw5MTc5MzIsOTE3OTMzLDkxNzkzNCw5MTc5MzUsOTE3OTM2LDkxNzkzNyw5MTc5MzgsOTE3OTM5LDkxNzk0MCw5MTc5NDEsOTE3OTQyLDkxNzk0Myw5MTc5NDQsOTE3OTQ1LDkxNzk0Niw5MTc5NDcsOTE3OTQ4LDkxNzk0OSw5MTc5NTAsOTE3OTUxLDkxNzk1Miw5MTc5NTMsOTE3OTU0LDkxNzk1NSw5MTc5NTYsOTE3OTU3LDkxNzk1OCw5MTc5NTksOTE3OTYwLDkxNzk2MSw5MTc5NjIsOTE3OTYzLDkxNzk2NCw5MTc5NjUsOTE3OTY2LDkxNzk2Nyw5MTc5NjgsOTE3OTY5LDkxNzk3MCw5MTc5NzEsOTE3OTcyLDkxNzk3Myw5MTc5NzQsOTE3OTc1LDkxNzk3Niw5MTc5NzcsOTE3OTc4LDkxNzk3OSw5MTc5ODAsOTE3OTgxLDkxNzk4Miw5MTc5ODMsOTE3OTg0LDkxNzk4NSw5MTc5ODYsOTE3OTg3LDkxNzk4OCw5MTc5ODksOTE3OTkwLDkxNzk5MSw5MTc5OTIsOTE3OTkzLDkxNzk5NCw5MTc5OTUsOTE3OTk2LDkxNzk5Nyw5MTc5OTgsOTE3OTk5XScpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldERhdGEoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgU2V0KEludmlzaWJsZUNoYXJhY3RlcnMuZ2V0UmF3RGF0YSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNJbnZpc2libGVDaGFyYWN0ZXIoY29kZVBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIEludmlzaWJsZUNoYXJhY3RlcnMuZ2V0RGF0YSgpLmhhcyhjb2RlUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBjb2RlUG9pbnRzKCkge1xyXG4gICAgICAgIHJldHVybiBJbnZpc2libGVDaGFyYWN0ZXJzLmdldERhdGEoKTtcclxuICAgIH1cclxufVxyXG5JbnZpc2libGVDaGFyYWN0ZXJzLl9kYXRhID0gdW5kZWZpbmVkO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/strings.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertIsDefined: () => (/* binding */ assertIsDefined),\n/* harmony export */   assertType: () => (/* binding */ assertType),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isIterable: () => (/* binding */ isIterable),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTypedArray: () => (/* binding */ isTypedArray),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   isUndefinedOrNull: () => (/* binding */ isUndefinedOrNull),\n/* harmony export */   validateConstraint: () => (/* binding */ validateConstraint),\n/* harmony export */   validateConstraints: () => (/* binding */ validateConstraints)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * @returns whether the provided parameter is a JavaScript String or not.\r\n */\r\nfunction isString(str) {\r\n    return (typeof str === 'string');\r\n}\r\n/**\r\n * @returns whether the provided parameter is of type `object` but **not**\r\n *\t`null`, an `array`, a `regexp`, nor a `date`.\r\n */\r\nfunction isObject(obj) {\r\n    // The method can't do a type cast since there are type (like strings) which\r\n    // are subclasses of any put not positvely matched by the function. Hence type\r\n    // narrowing results in wrong results.\r\n    return typeof obj === 'object'\r\n        && obj !== null\r\n        && !Array.isArray(obj)\r\n        && !(obj instanceof RegExp)\r\n        && !(obj instanceof Date);\r\n}\r\n/**\r\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\r\n */\r\nfunction isTypedArray(obj) {\r\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\r\n    return typeof obj === 'object'\r\n        && obj instanceof TypedArray;\r\n}\r\n/**\r\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\r\n * @returns whether the provided parameter is a JavaScript Number or not.\r\n */\r\nfunction isNumber(obj) {\r\n    return (typeof obj === 'number' && !isNaN(obj));\r\n}\r\n/**\r\n * @returns whether the provided parameter is an Iterable, casting to the given generic\r\n */\r\nfunction isIterable(obj) {\r\n    return !!obj && typeof obj[Symbol.iterator] === 'function';\r\n}\r\n/**\r\n * @returns whether the provided parameter is a JavaScript Boolean or not.\r\n */\r\nfunction isBoolean(obj) {\r\n    return (obj === true || obj === false);\r\n}\r\n/**\r\n * @returns whether the provided parameter is undefined.\r\n */\r\nfunction isUndefined(obj) {\r\n    return (typeof obj === 'undefined');\r\n}\r\n/**\r\n * @returns whether the provided parameter is defined.\r\n */\r\nfunction isDefined(arg) {\r\n    return !isUndefinedOrNull(arg);\r\n}\r\n/**\r\n * @returns whether the provided parameter is undefined or null.\r\n */\r\nfunction isUndefinedOrNull(obj) {\r\n    return (isUndefined(obj) || obj === null);\r\n}\r\nfunction assertType(condition, type) {\r\n    if (!condition) {\r\n        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\r\n    }\r\n}\r\n/**\r\n * Asserts that the argument passed in is neither undefined nor null.\r\n */\r\nfunction assertIsDefined(arg) {\r\n    if (isUndefinedOrNull(arg)) {\r\n        throw new Error('Assertion Failed: argument is undefined or null');\r\n    }\r\n    return arg;\r\n}\r\n/**\r\n * @returns whether the provided parameter is a JavaScript Function or not.\r\n */\r\nfunction isFunction(obj) {\r\n    return (typeof obj === 'function');\r\n}\r\nfunction validateConstraints(args, constraints) {\r\n    const len = Math.min(args.length, constraints.length);\r\n    for (let i = 0; i < len; i++) {\r\n        validateConstraint(args[i], constraints[i]);\r\n    }\r\n}\r\nfunction validateConstraint(arg, constraint) {\r\n    if (isString(constraint)) {\r\n        if (typeof arg !== constraint) {\r\n            throw new Error(`argument does not match constraint: typeof ${constraint}`);\r\n        }\r\n    }\r\n    else if (isFunction(constraint)) {\r\n        try {\r\n            if (arg instanceof constraint) {\r\n                return;\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // ignore\r\n        }\r\n        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\r\n            return;\r\n        }\r\n        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\r\n            return;\r\n        }\r\n        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkRBQTZELEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3R5cGVzLmpzP2VmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IFN0cmluZyBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgYG9iamVjdGAgYnV0ICoqbm90KipcclxuICpcdGBudWxsYCwgYW4gYGFycmF5YCwgYSBgcmVnZXhwYCwgbm9yIGEgYGRhdGVgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gICAgLy8gVGhlIG1ldGhvZCBjYW4ndCBkbyBhIHR5cGUgY2FzdCBzaW5jZSB0aGVyZSBhcmUgdHlwZSAobGlrZSBzdHJpbmdzKSB3aGljaFxyXG4gICAgLy8gYXJlIHN1YmNsYXNzZXMgb2YgYW55IHB1dCBub3QgcG9zaXR2ZWx5IG1hdGNoZWQgYnkgdGhlIGZ1bmN0aW9uLiBIZW5jZSB0eXBlXHJcbiAgICAvLyBuYXJyb3dpbmcgcmVzdWx0cyBpbiB3cm9uZyByZXN1bHRzLlxyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXHJcbiAgICAgICAgJiYgb2JqICE9PSBudWxsXHJcbiAgICAgICAgJiYgIUFycmF5LmlzQXJyYXkob2JqKVxyXG4gICAgICAgICYmICEob2JqIGluc3RhbmNlb2YgUmVnRXhwKVxyXG4gICAgICAgICYmICEob2JqIGluc3RhbmNlb2YgRGF0ZSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBvZiB0eXBlIGBCdWZmZXJgIG9yIFVpbnQ4QXJyYXkgZGVydml2ZWQgdHlwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZWRBcnJheShvYmopIHtcclxuICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcclxuICAgICAgICAmJiBvYmogaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xyXG59XHJcbi8qKlxyXG4gKiBJbiAqKmNvbnRyYXN0KiogdG8ganVzdCBjaGVja2luZyBgdHlwZW9mYCB0aGlzIHdpbGwgcmV0dXJuIGBmYWxzZWAgZm9yIGBOYU5gLlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IE51bWJlciBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdudW1iZXInICYmICFpc05hTihvYmopKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGFuIEl0ZXJhYmxlLCBjYXN0aW5nIHRvIHRoZSBnaXZlbiBnZW5lcmljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcclxuICAgIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgQm9vbGVhbiBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xyXG4gICAgcmV0dXJuIChvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGRlZmluZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKGFyZykge1xyXG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZE9yTnVsbChhcmcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwob2JqKSB7XHJcbiAgICByZXR1cm4gKGlzVW5kZWZpbmVkKG9iaikgfHwgb2JqID09PSBudWxsKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZShjb25kaXRpb24sIHR5cGUpIHtcclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgPyBgVW5leHBlY3RlZCB0eXBlLCBleHBlY3RlZCAnJHt0eXBlfSdgIDogJ1VuZXhwZWN0ZWQgdHlwZScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGFyZ3VtZW50IHBhc3NlZCBpbiBpcyBuZWl0aGVyIHVuZGVmaW5lZCBub3IgbnVsbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0RlZmluZWQoYXJnKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWRPck51bGwoYXJnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIEZhaWxlZDogYXJndW1lbnQgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmc7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgRnVuY3Rpb24gb3Igbm90LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnRzKGFyZ3MsIGNvbnN0cmFpbnRzKSB7XHJcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhcmdzLmxlbmd0aCwgY29uc3RyYWludHMubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YWxpZGF0ZUNvbnN0cmFpbnQoYXJnc1tpXSwgY29uc3RyYWludHNbaV0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnQoYXJnLCBjb25zdHJhaW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29uc3RyYWludCkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIGNvbnN0cmFpbnQ6IHR5cGVvZiAke2NvbnN0cmFpbnR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjb25zdHJhaW50KSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkT3JOdWxsKGFyZykgJiYgYXJnLmNvbnN0cnVjdG9yID09PSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVuZ3RoID09PSAxICYmIGNvbnN0cmFpbnQuY2FsbCh1bmRlZmluZWQsIGFyZykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIG9uZSBvZiB0aGVzZSBjb25zdHJhaW50czogYXJnIGluc3RhbmNlb2YgY29uc3RyYWludCwgYXJnLmNvbnN0cnVjdG9yID09PSBjb25zdHJhaW50LCBub3IgY29uc3RyYWludChhcmcpID09PSB0cnVlYCk7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/types.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uint.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toUint32: () => (/* binding */ toUint32),\n/* harmony export */   toUint8: () => (/* binding */ toUint8)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction toUint8(v) {\r\n    if (v < 0) {\r\n        return 0;\r\n    }\r\n    if (v > 255 /* Constants.MAX_UINT_8 */) {\r\n        return 255 /* Constants.MAX_UINT_8 */;\r\n    }\r\n    return v | 0;\r\n}\r\nfunction toUint32(v) {\r\n    if (v < 0) {\r\n        return 0;\r\n    }\r\n    if (v > 4294967295 /* Constants.MAX_UINT_32 */) {\r\n        return 4294967295 /* Constants.MAX_UINT_32 */;\r\n    }\r\n    return v | 0;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdWludC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VpbnQuanM/MDk5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDgodikge1xyXG4gICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAodiA+IDI1NSAvKiBDb25zdGFudHMuTUFYX1VJTlRfOCAqLykge1xyXG4gICAgICAgIHJldHVybiAyNTUgLyogQ29uc3RhbnRzLk1BWF9VSU5UXzggKi87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdiB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDMyKHYpIHtcclxuICAgIGlmICh2IDwgMCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHYgPiA0Mjk0OTY3Mjk1IC8qIENvbnN0YW50cy5NQVhfVUlOVF8zMiAqLykge1xyXG4gICAgICAgIHJldHVybiA0Mjk0OTY3Mjk1IC8qIENvbnN0YW50cy5NQVhfVUlOVF8zMiAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB2IHwgMDtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/uint.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uri.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uri.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   URI: () => (/* binding */ URI),\n/* harmony export */   uriToFsPath: () => (/* binding */ uriToFsPath)\n/* harmony export */ });\n/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ \"./node_modules/monaco-editor/esm/vs/base/common/path.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ \"./node_modules/monaco-editor/esm/vs/base/common/platform.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\r\nconst _singleSlashStart = /^\\//;\r\nconst _doubleSlashStart = /^\\/\\//;\r\nfunction _validateUri(ret, _strict) {\r\n    // scheme, must be set\r\n    if (!ret.scheme && _strict) {\r\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\r\n    }\r\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\r\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\r\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\r\n        throw new Error('[UriError]: Scheme contains illegal characters.');\r\n    }\r\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\r\n    // If a URI contains an authority component, then the path component\r\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\r\n    // does not contain an authority component, then the path cannot begin\r\n    // with two slash characters (\"//\").\r\n    if (ret.path) {\r\n        if (ret.authority) {\r\n            if (!_singleSlashStart.test(ret.path)) {\r\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\r\n            }\r\n        }\r\n        else {\r\n            if (_doubleSlashStart.test(ret.path)) {\r\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\r\n            }\r\n        }\r\n    }\r\n}\r\n// for a while we allowed uris *without* schemes and this is the migration\r\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\r\n// back to the file-scheme. that should cause the least carnage and still be a\r\n// clear warning\r\nfunction _schemeFix(scheme, _strict) {\r\n    if (!scheme && !_strict) {\r\n        return 'file';\r\n    }\r\n    return scheme;\r\n}\r\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\r\nfunction _referenceResolution(scheme, path) {\r\n    // the slash-character is our 'default base' as we don't\r\n    // support constructing URIs relative to other URIs. This\r\n    // also means that we alter and potentially break paths.\r\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\r\n    switch (scheme) {\r\n        case 'https':\r\n        case 'http':\r\n        case 'file':\r\n            if (!path) {\r\n                path = _slash;\r\n            }\r\n            else if (path[0] !== _slash) {\r\n                path = _slash + path;\r\n            }\r\n            break;\r\n    }\r\n    return path;\r\n}\r\nconst _empty = '';\r\nconst _slash = '/';\r\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n/**\r\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\r\n * This class is a simple parser which creates the basic component parts\r\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\r\n * and encoding.\r\n *\r\n * ```txt\r\n *       foo://example.com:8042/over/there?name=ferret#nose\r\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\r\n *        |           |            |            |        |\r\n *     scheme     authority       path        query   fragment\r\n *        |   _____________________|__\r\n *       / \\ /                        \\\r\n *       urn:example:animal:ferret:nose\r\n * ```\r\n */\r\nclass URI {\r\n    static isUri(thing) {\r\n        if (thing instanceof URI) {\r\n            return true;\r\n        }\r\n        if (!thing) {\r\n            return false;\r\n        }\r\n        return typeof thing.authority === 'string'\r\n            && typeof thing.fragment === 'string'\r\n            && typeof thing.path === 'string'\r\n            && typeof thing.query === 'string'\r\n            && typeof thing.scheme === 'string'\r\n            && typeof thing.fsPath === 'string'\r\n            && typeof thing.with === 'function'\r\n            && typeof thing.toString === 'function';\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\r\n        if (typeof schemeOrData === 'object') {\r\n            this.scheme = schemeOrData.scheme || _empty;\r\n            this.authority = schemeOrData.authority || _empty;\r\n            this.path = schemeOrData.path || _empty;\r\n            this.query = schemeOrData.query || _empty;\r\n            this.fragment = schemeOrData.fragment || _empty;\r\n            // no validation because it's this URI\r\n            // that creates uri components.\r\n            // _validateUri(this);\r\n        }\r\n        else {\r\n            this.scheme = _schemeFix(schemeOrData, _strict);\r\n            this.authority = authority || _empty;\r\n            this.path = _referenceResolution(this.scheme, path || _empty);\r\n            this.query = query || _empty;\r\n            this.fragment = fragment || _empty;\r\n            _validateUri(this, _strict);\r\n        }\r\n    }\r\n    // ---- filesystem path -----------------------\r\n    /**\r\n     * Returns a string representing the corresponding file system path of this URI.\r\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\r\n     * platform specific path separator.\r\n     *\r\n     * * Will *not* validate the path for invalid characters and semantics.\r\n     * * Will *not* look at the scheme of this URI.\r\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\r\n     *\r\n     *\r\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\r\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\r\n     *\r\n     * ```ts\r\n        const u = URI.parse('file://server/c$/folder/file.txt')\r\n        u.authority === 'server'\r\n        u.path === '/shares/c$/file.txt'\r\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\r\n    ```\r\n     *\r\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\r\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\r\n     * with URIs that represent files on disk (`file` scheme).\r\n     */\r\n    get fsPath() {\r\n        // if (this.scheme !== 'file') {\r\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\r\n        // }\r\n        return uriToFsPath(this, false);\r\n    }\r\n    // ---- modify to new -------------------------\r\n    with(change) {\r\n        if (!change) {\r\n            return this;\r\n        }\r\n        let { scheme, authority, path, query, fragment } = change;\r\n        if (scheme === undefined) {\r\n            scheme = this.scheme;\r\n        }\r\n        else if (scheme === null) {\r\n            scheme = _empty;\r\n        }\r\n        if (authority === undefined) {\r\n            authority = this.authority;\r\n        }\r\n        else if (authority === null) {\r\n            authority = _empty;\r\n        }\r\n        if (path === undefined) {\r\n            path = this.path;\r\n        }\r\n        else if (path === null) {\r\n            path = _empty;\r\n        }\r\n        if (query === undefined) {\r\n            query = this.query;\r\n        }\r\n        else if (query === null) {\r\n            query = _empty;\r\n        }\r\n        if (fragment === undefined) {\r\n            fragment = this.fragment;\r\n        }\r\n        else if (fragment === null) {\r\n            fragment = _empty;\r\n        }\r\n        if (scheme === this.scheme\r\n            && authority === this.authority\r\n            && path === this.path\r\n            && query === this.query\r\n            && fragment === this.fragment) {\r\n            return this;\r\n        }\r\n        return new Uri(scheme, authority, path, query, fragment);\r\n    }\r\n    // ---- parse & validate ------------------------\r\n    /**\r\n     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\r\n     * `file:///usr/home`, or `scheme:with/path`.\r\n     *\r\n     * @param value A string which represents an URI (see `URI#toString`).\r\n     */\r\n    static parse(value, _strict = false) {\r\n        const match = _regexp.exec(value);\r\n        if (!match) {\r\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\r\n        }\r\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\r\n    }\r\n    /**\r\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\r\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\r\n     *\r\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\r\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\r\n     * `URI.parse('file://' + path)` because the path might contain characters that are\r\n     * interpreted (# and ?). See the following sample:\r\n     * ```ts\r\n    const good = URI.file('/coding/c#/project1');\r\n    good.scheme === 'file';\r\n    good.path === '/coding/c#/project1';\r\n    good.fragment === '';\r\n    const bad = URI.parse('file://' + '/coding/c#/project1');\r\n    bad.scheme === 'file';\r\n    bad.path === '/coding/c'; // path is now broken\r\n    bad.fragment === '/project1';\r\n    ```\r\n     *\r\n     * @param path A file system path (see `URI#fsPath`)\r\n     */\r\n    static file(path) {\r\n        let authority = _empty;\r\n        // normalize to fwd-slashes on windows,\r\n        // on other systems bwd-slashes are valid\r\n        // filename character, eg /f\\oo/ba\\r.txt\r\n        if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows) {\r\n            path = path.replace(/\\\\/g, _slash);\r\n        }\r\n        // check for authority as used in UNC shares\r\n        // or use the path as given\r\n        if (path[0] === _slash && path[1] === _slash) {\r\n            const idx = path.indexOf(_slash, 2);\r\n            if (idx === -1) {\r\n                authority = path.substring(2);\r\n                path = _slash;\r\n            }\r\n            else {\r\n                authority = path.substring(2, idx);\r\n                path = path.substring(idx) || _slash;\r\n            }\r\n        }\r\n        return new Uri('file', authority, path, _empty, _empty);\r\n    }\r\n    /**\r\n     * Creates new URI from uri components.\r\n     *\r\n     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\r\n     * validation and should be used for untrusted uri components retrieved from storage,\r\n     * user input, command arguments etc\r\n     */\r\n    static from(components, strict) {\r\n        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);\r\n        return result;\r\n    }\r\n    /**\r\n     * Join a URI path with path fragments and normalizes the resulting path.\r\n     *\r\n     * @param uri The input URI.\r\n     * @param pathFragment The path fragment to add to the URI path.\r\n     * @returns The resulting URI.\r\n     */\r\n    static joinPath(uri, ...pathFragment) {\r\n        if (!uri.path) {\r\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\r\n        }\r\n        let newPath;\r\n        if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows && uri.scheme === 'file') {\r\n            newPath = URI.file(_path_js__WEBPACK_IMPORTED_MODULE_0__.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\r\n        }\r\n        else {\r\n            newPath = _path_js__WEBPACK_IMPORTED_MODULE_0__.posix.join(uri.path, ...pathFragment);\r\n        }\r\n        return uri.with({ path: newPath });\r\n    }\r\n    // ---- printing/externalize ---------------------------\r\n    /**\r\n     * Creates a string representation for this URI. It's guaranteed that calling\r\n     * `URI.parse` with the result of this function creates an URI which is equal\r\n     * to this URI.\r\n     *\r\n     * * The result shall *not* be used for display purposes but for externalization or transport.\r\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\r\n     * ignore the scheme-specific encoding rules.\r\n     *\r\n     * @param skipEncoding Do not encode the result, default is `false`\r\n     */\r\n    toString(skipEncoding = false) {\r\n        return _asFormatted(this, skipEncoding);\r\n    }\r\n    toJSON() {\r\n        return this;\r\n    }\r\n    static revive(data) {\r\n        var _a, _b;\r\n        if (!data) {\r\n            return data;\r\n        }\r\n        else if (data instanceof URI) {\r\n            return data;\r\n        }\r\n        else {\r\n            const result = new Uri(data);\r\n            result._formatted = (_a = data.external) !== null && _a !== void 0 ? _a : null;\r\n            result._fsPath = data._sep === _pathSepMarker ? (_b = data.fsPath) !== null && _b !== void 0 ? _b : null : null;\r\n            return result;\r\n        }\r\n    }\r\n}\r\nconst _pathSepMarker = _platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows ? 1 : undefined;\r\n// This class exists so that URI is compatible with vscode.Uri (API).\r\nclass Uri extends URI {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._formatted = null;\r\n        this._fsPath = null;\r\n    }\r\n    get fsPath() {\r\n        if (!this._fsPath) {\r\n            this._fsPath = uriToFsPath(this, false);\r\n        }\r\n        return this._fsPath;\r\n    }\r\n    toString(skipEncoding = false) {\r\n        if (!skipEncoding) {\r\n            if (!this._formatted) {\r\n                this._formatted = _asFormatted(this, false);\r\n            }\r\n            return this._formatted;\r\n        }\r\n        else {\r\n            // we don't cache that\r\n            return _asFormatted(this, true);\r\n        }\r\n    }\r\n    toJSON() {\r\n        const res = {\r\n            $mid: 1 /* MarshalledId.Uri */\r\n        };\r\n        // cached state\r\n        if (this._fsPath) {\r\n            res.fsPath = this._fsPath;\r\n            res._sep = _pathSepMarker;\r\n        }\r\n        if (this._formatted) {\r\n            res.external = this._formatted;\r\n        }\r\n        //--- uri components\r\n        if (this.path) {\r\n            res.path = this.path;\r\n        }\r\n        // TODO\r\n        // this isn't correct and can violate the UriComponents contract but\r\n        // this is part of the vscode.Uri API and we shouldn't change how that\r\n        // works anymore\r\n        if (this.scheme) {\r\n            res.scheme = this.scheme;\r\n        }\r\n        if (this.authority) {\r\n            res.authority = this.authority;\r\n        }\r\n        if (this.query) {\r\n            res.query = this.query;\r\n        }\r\n        if (this.fragment) {\r\n            res.fragment = this.fragment;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\r\nconst encodeTable = {\r\n    [58 /* CharCode.Colon */]: '%3A', // gen-delims\r\n    [47 /* CharCode.Slash */]: '%2F',\r\n    [63 /* CharCode.QuestionMark */]: '%3F',\r\n    [35 /* CharCode.Hash */]: '%23',\r\n    [91 /* CharCode.OpenSquareBracket */]: '%5B',\r\n    [93 /* CharCode.CloseSquareBracket */]: '%5D',\r\n    [64 /* CharCode.AtSign */]: '%40',\r\n    [33 /* CharCode.ExclamationMark */]: '%21', // sub-delims\r\n    [36 /* CharCode.DollarSign */]: '%24',\r\n    [38 /* CharCode.Ampersand */]: '%26',\r\n    [39 /* CharCode.SingleQuote */]: '%27',\r\n    [40 /* CharCode.OpenParen */]: '%28',\r\n    [41 /* CharCode.CloseParen */]: '%29',\r\n    [42 /* CharCode.Asterisk */]: '%2A',\r\n    [43 /* CharCode.Plus */]: '%2B',\r\n    [44 /* CharCode.Comma */]: '%2C',\r\n    [59 /* CharCode.Semicolon */]: '%3B',\r\n    [61 /* CharCode.Equals */]: '%3D',\r\n    [32 /* CharCode.Space */]: '%20',\r\n};\r\nfunction encodeURIComponentFast(uriComponent, isPath, isAuthority) {\r\n    let res = undefined;\r\n    let nativeEncodePos = -1;\r\n    for (let pos = 0; pos < uriComponent.length; pos++) {\r\n        const code = uriComponent.charCodeAt(pos);\r\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\r\n        if ((code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */)\r\n            || (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */)\r\n            || (code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */)\r\n            || code === 45 /* CharCode.Dash */\r\n            || code === 46 /* CharCode.Period */\r\n            || code === 95 /* CharCode.Underline */\r\n            || code === 126 /* CharCode.Tilde */\r\n            || (isPath && code === 47 /* CharCode.Slash */)\r\n            || (isAuthority && code === 91 /* CharCode.OpenSquareBracket */)\r\n            || (isAuthority && code === 93 /* CharCode.CloseSquareBracket */)\r\n            || (isAuthority && code === 58 /* CharCode.Colon */)) {\r\n            // check if we are delaying native encode\r\n            if (nativeEncodePos !== -1) {\r\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\r\n                nativeEncodePos = -1;\r\n            }\r\n            // check if we write into a new string (by default we try to return the param)\r\n            if (res !== undefined) {\r\n                res += uriComponent.charAt(pos);\r\n            }\r\n        }\r\n        else {\r\n            // encoding needed, we need to allocate a new string\r\n            if (res === undefined) {\r\n                res = uriComponent.substr(0, pos);\r\n            }\r\n            // check with default table first\r\n            const escaped = encodeTable[code];\r\n            if (escaped !== undefined) {\r\n                // check if we are delaying native encode\r\n                if (nativeEncodePos !== -1) {\r\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\r\n                    nativeEncodePos = -1;\r\n                }\r\n                // append escaped variant to result\r\n                res += escaped;\r\n            }\r\n            else if (nativeEncodePos === -1) {\r\n                // use native encode only when needed\r\n                nativeEncodePos = pos;\r\n            }\r\n        }\r\n    }\r\n    if (nativeEncodePos !== -1) {\r\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\r\n    }\r\n    return res !== undefined ? res : uriComponent;\r\n}\r\nfunction encodeURIComponentMinimal(path) {\r\n    let res = undefined;\r\n    for (let pos = 0; pos < path.length; pos++) {\r\n        const code = path.charCodeAt(pos);\r\n        if (code === 35 /* CharCode.Hash */ || code === 63 /* CharCode.QuestionMark */) {\r\n            if (res === undefined) {\r\n                res = path.substr(0, pos);\r\n            }\r\n            res += encodeTable[code];\r\n        }\r\n        else {\r\n            if (res !== undefined) {\r\n                res += path[pos];\r\n            }\r\n        }\r\n    }\r\n    return res !== undefined ? res : path;\r\n}\r\n/**\r\n * Compute `fsPath` for the given uri\r\n */\r\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\r\n    let value;\r\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\r\n        // unc path: file://shares/c$/far/boo\r\n        value = `//${uri.authority}${uri.path}`;\r\n    }\r\n    else if (uri.path.charCodeAt(0) === 47 /* CharCode.Slash */\r\n        && (uri.path.charCodeAt(1) >= 65 /* CharCode.A */ && uri.path.charCodeAt(1) <= 90 /* CharCode.Z */ || uri.path.charCodeAt(1) >= 97 /* CharCode.a */ && uri.path.charCodeAt(1) <= 122 /* CharCode.z */)\r\n        && uri.path.charCodeAt(2) === 58 /* CharCode.Colon */) {\r\n        if (!keepDriveLetterCasing) {\r\n            // windows drive letter: file:///c:/far/boo\r\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\r\n        }\r\n        else {\r\n            value = uri.path.substr(1);\r\n        }\r\n    }\r\n    else {\r\n        // other path\r\n        value = uri.path;\r\n    }\r\n    if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows) {\r\n        value = value.replace(/\\//g, '\\\\');\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Create the external version of a uri\r\n */\r\nfunction _asFormatted(uri, skipEncoding) {\r\n    const encoder = !skipEncoding\r\n        ? encodeURIComponentFast\r\n        : encodeURIComponentMinimal;\r\n    let res = '';\r\n    let { scheme, authority, path, query, fragment } = uri;\r\n    if (scheme) {\r\n        res += scheme;\r\n        res += ':';\r\n    }\r\n    if (authority || scheme === 'file') {\r\n        res += _slash;\r\n        res += _slash;\r\n    }\r\n    if (authority) {\r\n        let idx = authority.indexOf('@');\r\n        if (idx !== -1) {\r\n            // <user>@<auth>\r\n            const userinfo = authority.substr(0, idx);\r\n            authority = authority.substr(idx + 1);\r\n            idx = userinfo.lastIndexOf(':');\r\n            if (idx === -1) {\r\n                res += encoder(userinfo, false, false);\r\n            }\r\n            else {\r\n                // <user>:<pass>@<auth>\r\n                res += encoder(userinfo.substr(0, idx), false, false);\r\n                res += ':';\r\n                res += encoder(userinfo.substr(idx + 1), false, true);\r\n            }\r\n            res += '@';\r\n        }\r\n        authority = authority.toLowerCase();\r\n        idx = authority.lastIndexOf(':');\r\n        if (idx === -1) {\r\n            res += encoder(authority, false, true);\r\n        }\r\n        else {\r\n            // <auth>:<port>\r\n            res += encoder(authority.substr(0, idx), false, true);\r\n            res += authority.substr(idx);\r\n        }\r\n    }\r\n    if (path) {\r\n        // lower-case windows drive letters in /C:/fff or C:/fff\r\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* CharCode.Slash */ && path.charCodeAt(2) === 58 /* CharCode.Colon */) {\r\n            const code = path.charCodeAt(1);\r\n            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\r\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\r\n            }\r\n        }\r\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* CharCode.Colon */) {\r\n            const code = path.charCodeAt(0);\r\n            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\r\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\r\n            }\r\n        }\r\n        // encode the rest of the path\r\n        res += encoder(path, true, false);\r\n    }\r\n    if (query) {\r\n        res += '?';\r\n        res += encoder(query, false, false);\r\n    }\r\n    if (fragment) {\r\n        res += '#';\r\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\r\n    }\r\n    return res;\r\n}\r\n// --- decode\r\nfunction decodeURIComponentGraceful(str) {\r\n    try {\r\n        return decodeURIComponent(str);\r\n    }\r\n    catch (_a) {\r\n        if (str.length > 3) {\r\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\r\n        }\r\n        else {\r\n            return str;\r\n        }\r\n    }\r\n}\r\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\r\nfunction percentDecode(str) {\r\n    if (!str.match(_rEncodedAsHex)) {\r\n        return str;\r\n    }\r\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdXJpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNtQztBQUNPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwwQkFBMEIsY0FBYyxZQUFZLFNBQVMsYUFBYSxVQUFVLGdCQUFnQixhQUFhLEVBQUU7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQVM7QUFDckIsK0JBQStCLDJDQUFXO0FBQzFDO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQVc7QUFDakM7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYyxFQUFFLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0IsR0FBRyxlQUFlLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0IsR0FBRyxlQUFlLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VyaS5qcz82ZDhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgKiBhcyBwYXRocyBmcm9tICcuL3BhdGguanMnO1xyXG5pbXBvcnQgeyBpc1dpbmRvd3MgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcclxuY29uc3QgX3NjaGVtZVBhdHRlcm4gPSAvXlxcd1tcXHdcXGQrLi1dKiQvO1xyXG5jb25zdCBfc2luZ2xlU2xhc2hTdGFydCA9IC9eXFwvLztcclxuY29uc3QgX2RvdWJsZVNsYXNoU3RhcnQgPSAvXlxcL1xcLy87XHJcbmZ1bmN0aW9uIF92YWxpZGF0ZVVyaShyZXQsIF9zdHJpY3QpIHtcclxuICAgIC8vIHNjaGVtZSwgbXVzdCBiZSBzZXRcclxuICAgIGlmICghcmV0LnNjaGVtZSAmJiBfc3RyaWN0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBTY2hlbWUgaXMgbWlzc2luZzoge3NjaGVtZTogXCJcIiwgYXV0aG9yaXR5OiBcIiR7cmV0LmF1dGhvcml0eX1cIiwgcGF0aDogXCIke3JldC5wYXRofVwiLCBxdWVyeTogXCIke3JldC5xdWVyeX1cIiwgZnJhZ21lbnQ6IFwiJHtyZXQuZnJhZ21lbnR9XCJ9YCk7XHJcbiAgICB9XHJcbiAgICAvLyBzY2hlbWUsIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXHJcbiAgICAvLyBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcclxuICAgIGlmIChyZXQuc2NoZW1lICYmICFfc2NoZW1lUGF0dGVybi50ZXN0KHJldC5zY2hlbWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLicpO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0aCwgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuM1xyXG4gICAgLy8gSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnRcclxuICAgIC8vIG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSBzbGFzaCAoXCIvXCIpIGNoYXJhY3Rlci4gIElmIGEgVVJJXHJcbiAgICAvLyBkb2VzIG5vdCBjb250YWluIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY2Fubm90IGJlZ2luXHJcbiAgICAvLyB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpLlxyXG4gICAgaWYgKHJldC5wYXRoKSB7XHJcbiAgICAgICAgaWYgKHJldC5hdXRob3JpdHkpIHtcclxuICAgICAgICAgICAgaWYgKCFfc2luZ2xlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKF9kb3VibGVTbGFzaFN0YXJ0LnRlc3QocmV0LnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGZvciBhIHdoaWxlIHdlIGFsbG93ZWQgdXJpcyAqd2l0aG91dCogc2NoZW1lcyBhbmQgdGhpcyBpcyB0aGUgbWlncmF0aW9uXHJcbi8vIGZvciB0aGVtLCBlLmcuIGFuIHVyaSB3aXRob3V0IHNjaGVtZSBhbmQgd2l0aG91dCBzdHJpY3QtbW9kZSB3YXJucyBhbmQgZmFsbHNcclxuLy8gYmFjayB0byB0aGUgZmlsZS1zY2hlbWUuIHRoYXQgc2hvdWxkIGNhdXNlIHRoZSBsZWFzdCBjYXJuYWdlIGFuZCBzdGlsbCBiZSBhXHJcbi8vIGNsZWFyIHdhcm5pbmdcclxuZnVuY3Rpb24gX3NjaGVtZUZpeChzY2hlbWUsIF9zdHJpY3QpIHtcclxuICAgIGlmICghc2NoZW1lICYmICFfc3RyaWN0KSB7XHJcbiAgICAgICAgcmV0dXJuICdmaWxlJztcclxuICAgIH1cclxuICAgIHJldHVybiBzY2hlbWU7XHJcbn1cclxuLy8gaW1wbGVtZW50cyBhIGJpdCBvZiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTVcclxuZnVuY3Rpb24gX3JlZmVyZW5jZVJlc29sdXRpb24oc2NoZW1lLCBwYXRoKSB7XHJcbiAgICAvLyB0aGUgc2xhc2gtY2hhcmFjdGVyIGlzIG91ciAnZGVmYXVsdCBiYXNlJyBhcyB3ZSBkb24ndFxyXG4gICAgLy8gc3VwcG9ydCBjb25zdHJ1Y3RpbmcgVVJJcyByZWxhdGl2ZSB0byBvdGhlciBVUklzLiBUaGlzXHJcbiAgICAvLyBhbHNvIG1lYW5zIHRoYXQgd2UgYWx0ZXIgYW5kIHBvdGVudGlhbGx5IGJyZWFrIHBhdGhzLlxyXG4gICAgLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4xLjRcclxuICAgIHN3aXRjaCAoc2NoZW1lKSB7XHJcbiAgICAgICAgY2FzZSAnaHR0cHMnOlxyXG4gICAgICAgIGNhc2UgJ2h0dHAnOlxyXG4gICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aFswXSAhPT0gX3NsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gX3NsYXNoICsgcGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoO1xyXG59XHJcbmNvbnN0IF9lbXB0eSA9ICcnO1xyXG5jb25zdCBfc2xhc2ggPSAnLyc7XHJcbmNvbnN0IF9yZWdleHAgPSAvXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztcclxuLyoqXHJcbiAqIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxyXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2ltcGxlIHBhcnNlciB3aGljaCBjcmVhdGVzIHRoZSBiYXNpYyBjb21wb25lbnQgcGFydHNcclxuICogKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zKSB3aXRoIG1pbmltYWwgdmFsaWRhdGlvblxyXG4gKiBhbmQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIGBgYHR4dFxyXG4gKiAgICAgICBmb286Ly9leGFtcGxlLmNvbTo4MDQyL292ZXIvdGhlcmU/bmFtZT1mZXJyZXQjbm9zZVxyXG4gKiAgICAgICBcXF8vICAgXFxfX19fX19fX19fX19fXy9cXF9fX19fX19fXy8gXFxfX19fX19fX18vIFxcX18vXHJcbiAqICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgfCAgICAgICAgICAgIHwgICAgICAgIHxcclxuICogICAgIHNjaGVtZSAgICAgYXV0aG9yaXR5ICAgICAgIHBhdGggICAgICAgIHF1ZXJ5ICAgZnJhZ21lbnRcclxuICogICAgICAgIHwgICBfX19fX19fX19fX19fX19fX19fX198X19cclxuICogICAgICAgLyBcXCAvICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICogICAgICAgdXJuOmV4YW1wbGU6YW5pbWFsOmZlcnJldDpub3NlXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFVSSSB7XHJcbiAgICBzdGF0aWMgaXNVcmkodGhpbmcpIHtcclxuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBVUkkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmF1dGhvcml0eSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLmZyYWdtZW50ID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcucGF0aCA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLnF1ZXJ5ID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuc2NoZW1lID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuZnNQYXRoID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcud2l0aCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcudG9TdHJpbmcgPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWVPckRhdGEsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50LCBfc3RyaWN0ID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtZU9yRGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBzY2hlbWVPckRhdGEuc2NoZW1lIHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBzY2hlbWVPckRhdGEuYXV0aG9yaXR5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gc2NoZW1lT3JEYXRhLnBhdGggfHwgX2VtcHR5O1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gc2NoZW1lT3JEYXRhLnF1ZXJ5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHNjaGVtZU9yRGF0YS5mcmFnbWVudCB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIC8vIG5vIHZhbGlkYXRpb24gYmVjYXVzZSBpdCdzIHRoaXMgVVJJXHJcbiAgICAgICAgICAgIC8vIHRoYXQgY3JlYXRlcyB1cmkgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgLy8gX3ZhbGlkYXRlVXJpKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBfc2NoZW1lRml4KHNjaGVtZU9yRGF0YSwgX3N0cmljdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gYXV0aG9yaXR5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gX3JlZmVyZW5jZVJlc29sdXRpb24odGhpcy5zY2hlbWUsIHBhdGggfHwgX2VtcHR5KTtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgX3ZhbGlkYXRlVXJpKHRoaXMsIF9zdHJpY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIC0tLS0gZmlsZXN5c3RlbSBwYXRoIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgc3lzdGVtIHBhdGggb2YgdGhpcyBVUkkuXHJcbiAgICAgKiBXaWxsIGhhbmRsZSBVTkMgcGF0aHMsIG5vcm1hbGl6ZXMgd2luZG93cyBkcml2ZSBsZXR0ZXJzIHRvIGxvd2VyLWNhc2UsIGFuZCB1c2VzIHRoZVxyXG4gICAgICogcGxhdGZvcm0gc3BlY2lmaWMgcGF0aCBzZXBhcmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKiBXaWxsICpub3QqIHZhbGlkYXRlIHRoZSBwYXRoIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIHNlbWFudGljcy5cclxuICAgICAqICogV2lsbCAqbm90KiBsb29rIGF0IHRoZSBzY2hlbWUgb2YgdGhpcyBVUkkuXHJcbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGFjY2Vzc2luZyBhIGZpbGUgb24gZGlzay5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogVGhlICpkaWZmZXJlbmNlKiB0byBgVVJJI3BhdGhgIGlzIHRoZSB1c2Ugb2YgdGhlIHBsYXRmb3JtIHNwZWNpZmljIHNlcGFyYXRvciBhbmQgdGhlIGhhbmRsaW5nXHJcbiAgICAgKiBvZiBVTkMgcGF0aHMuIFNlZSB0aGUgYmVsb3cgc2FtcGxlIG9mIGEgZmlsZS11cmkgd2l0aCBhbiBhdXRob3JpdHkgKFVOQyBwYXRoKS5cclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICAgIGNvbnN0IHUgPSBVUkkucGFyc2UoJ2ZpbGU6Ly9zZXJ2ZXIvYyQvZm9sZGVyL2ZpbGUudHh0JylcclxuICAgICAgICB1LmF1dGhvcml0eSA9PT0gJ3NlcnZlcidcclxuICAgICAgICB1LnBhdGggPT09ICcvc2hhcmVzL2MkL2ZpbGUudHh0J1xyXG4gICAgICAgIHUuZnNQYXRoID09PSAnXFxcXHNlcnZlclxcYyRcXGZvbGRlclxcZmlsZS50eHQnXHJcbiAgICBgYGBcclxuICAgICAqXHJcbiAgICAgKiBVc2luZyBgVVJJI3BhdGhgIHRvIHJlYWQgYSBmaWxlICh1c2luZyBmcy1hcGlzKSB3b3VsZCBub3QgYmUgZW5vdWdoIGJlY2F1c2UgcGFydHMgb2YgdGhlIHBhdGgsXHJcbiAgICAgKiBuYW1lbHkgdGhlIHNlcnZlciBuYW1lLCB3b3VsZCBiZSBtaXNzaW5nLiBUaGVyZWZvcmUgYFVSSSNmc1BhdGhgIGV4aXN0cyAtIGl0J3Mgc3VnYXIgdG8gZWFzZSB3b3JraW5nXHJcbiAgICAgKiB3aXRoIFVSSXMgdGhhdCByZXByZXNlbnQgZmlsZXMgb24gZGlzayAoYGZpbGVgIHNjaGVtZSkuXHJcbiAgICAgKi9cclxuICAgIGdldCBmc1BhdGgoKSB7XHJcbiAgICAgICAgLy8gaWYgKHRoaXMuc2NoZW1lICE9PSAnZmlsZScpIHtcclxuICAgICAgICAvLyBcdGNvbnNvbGUud2FybihgW1VyaUVycm9yXSBjYWxsaW5nIGZzUGF0aCB3aXRoIHNjaGVtZSAke3RoaXMuc2NoZW1lfWApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gdXJpVG9Gc1BhdGgodGhpcywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBtb2RpZnkgdG8gbmV3IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHdpdGgoY2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQgfSA9IGNoYW5nZTtcclxuICAgICAgICBpZiAoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gdGhpcy5zY2hlbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzY2hlbWUgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXV0aG9yaXR5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IF9lbXB0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocXVlcnkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcXVlcnkgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2hlbWUgPT09IHRoaXMuc2NoZW1lXHJcbiAgICAgICAgICAgICYmIGF1dGhvcml0eSA9PT0gdGhpcy5hdXRob3JpdHlcclxuICAgICAgICAgICAgJiYgcGF0aCA9PT0gdGhpcy5wYXRoXHJcbiAgICAgICAgICAgICYmIHF1ZXJ5ID09PSB0aGlzLnF1ZXJ5XHJcbiAgICAgICAgICAgICYmIGZyYWdtZW50ID09PSB0aGlzLmZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVyaShzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50KTtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gcGFyc2UgJiB2YWxpZGF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBVUkkgZnJvbSBhIHN0cmluZywgZS5nLiBgaHR0cDovL3d3dy5leGFtcGxlLmNvbS9zb21lL3BhdGhgLFxyXG4gICAgICogYGZpbGU6Ly8vdXNyL2hvbWVgLCBvciBgc2NoZW1lOndpdGgvcGF0aGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHdoaWNoIHJlcHJlc2VudHMgYW4gVVJJIChzZWUgYFVSSSN0b1N0cmluZ2ApLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIF9zdHJpY3QgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3JlZ2V4cC5leGVjKHZhbHVlKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJpKF9lbXB0eSwgX2VtcHR5LCBfZW1wdHksIF9lbXB0eSwgX2VtcHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVcmkobWF0Y2hbMl0gfHwgX2VtcHR5LCBwZXJjZW50RGVjb2RlKG1hdGNoWzRdIHx8IF9lbXB0eSksIHBlcmNlbnREZWNvZGUobWF0Y2hbNV0gfHwgX2VtcHR5KSwgcGVyY2VudERlY29kZShtYXRjaFs3XSB8fCBfZW1wdHkpLCBwZXJjZW50RGVjb2RlKG1hdGNoWzldIHx8IF9lbXB0eSksIF9zdHJpY3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFVSSSBmcm9tIGEgZmlsZSBzeXN0ZW0gcGF0aCwgZS5nLiBgYzpcXG15XFxmaWxlc2AsXHJcbiAgICAgKiBgL3Vzci9ob21lYCwgb3IgYFxcXFxzZXJ2ZXJcXHNoYXJlXFxzb21lXFxwYXRoYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgKmRpZmZlcmVuY2UqIGJldHdlZW4gYFVSSSNwYXJzZWAgYW5kIGBVUkkjZmlsZWAgaXMgdGhhdCB0aGUgbGF0dGVyIHRyZWF0cyB0aGUgYXJndW1lbnRcclxuICAgICAqIGFzIHBhdGgsIG5vdCBhcyBzdHJpbmdpZmllZC11cmkuIEUuZy4gYFVSSS5maWxlKHBhdGgpYCBpcyAqKm5vdCB0aGUgc2FtZSBhcyoqXHJcbiAgICAgKiBgVVJJLnBhcnNlKCdmaWxlOi8vJyArIHBhdGgpYCBiZWNhdXNlIHRoZSBwYXRoIG1pZ2h0IGNvbnRhaW4gY2hhcmFjdGVycyB0aGF0IGFyZVxyXG4gICAgICogaW50ZXJwcmV0ZWQgKCMgYW5kID8pLiBTZWUgdGhlIGZvbGxvd2luZyBzYW1wbGU6XHJcbiAgICAgKiBgYGB0c1xyXG4gICAgY29uc3QgZ29vZCA9IFVSSS5maWxlKCcvY29kaW5nL2MjL3Byb2plY3QxJyk7XHJcbiAgICBnb29kLnNjaGVtZSA9PT0gJ2ZpbGUnO1xyXG4gICAgZ29vZC5wYXRoID09PSAnL2NvZGluZy9jIy9wcm9qZWN0MSc7XHJcbiAgICBnb29kLmZyYWdtZW50ID09PSAnJztcclxuICAgIGNvbnN0IGJhZCA9IFVSSS5wYXJzZSgnZmlsZTovLycgKyAnL2NvZGluZy9jIy9wcm9qZWN0MScpO1xyXG4gICAgYmFkLnNjaGVtZSA9PT0gJ2ZpbGUnO1xyXG4gICAgYmFkLnBhdGggPT09ICcvY29kaW5nL2MnOyAvLyBwYXRoIGlzIG5vdyBicm9rZW5cclxuICAgIGJhZC5mcmFnbWVudCA9PT0gJy9wcm9qZWN0MSc7XHJcbiAgICBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBBIGZpbGUgc3lzdGVtIHBhdGggKHNlZSBgVVJJI2ZzUGF0aGApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmaWxlKHBhdGgpIHtcclxuICAgICAgICBsZXQgYXV0aG9yaXR5ID0gX2VtcHR5O1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0byBmd2Qtc2xhc2hlcyBvbiB3aW5kb3dzLFxyXG4gICAgICAgIC8vIG9uIG90aGVyIHN5c3RlbXMgYndkLXNsYXNoZXMgYXJlIHZhbGlkXHJcbiAgICAgICAgLy8gZmlsZW5hbWUgY2hhcmFjdGVyLCBlZyAvZlxcb28vYmFcXHIudHh0XHJcbiAgICAgICAgaWYgKGlzV2luZG93cykge1xyXG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIF9zbGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGZvciBhdXRob3JpdHkgYXMgdXNlZCBpbiBVTkMgc2hhcmVzXHJcbiAgICAgICAgLy8gb3IgdXNlIHRoZSBwYXRoIGFzIGdpdmVuXHJcbiAgICAgICAgaWYgKHBhdGhbMF0gPT09IF9zbGFzaCAmJiBwYXRoWzFdID09PSBfc2xhc2gpIHtcclxuICAgICAgICAgICAgY29uc3QgaWR4ID0gcGF0aC5pbmRleE9mKF9zbGFzaCwgMik7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyKTtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyLCBpZHgpO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKGlkeCkgfHwgX3NsYXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVXJpKCdmaWxlJywgYXV0aG9yaXR5LCBwYXRoLCBfZW1wdHksIF9lbXB0eSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IFVSSSBmcm9tIHVyaSBjb21wb25lbnRzLlxyXG4gICAgICpcclxuICAgICAqIFVubGVzcyBgc3RyaWN0YCBpcyBgdHJ1ZWAgdGhlIHNjaGVtZSBpcyBkZWZhdWx0cyB0byBiZSBgZmlsZWAuIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXNcclxuICAgICAqIHZhbGlkYXRpb24gYW5kIHNob3VsZCBiZSB1c2VkIGZvciB1bnRydXN0ZWQgdXJpIGNvbXBvbmVudHMgcmV0cmlldmVkIGZyb20gc3RvcmFnZSxcclxuICAgICAqIHVzZXIgaW5wdXQsIGNvbW1hbmQgYXJndW1lbnRzIGV0Y1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShjb21wb25lbnRzLCBzdHJpY3QpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVXJpKGNvbXBvbmVudHMuc2NoZW1lLCBjb21wb25lbnRzLmF1dGhvcml0eSwgY29tcG9uZW50cy5wYXRoLCBjb21wb25lbnRzLnF1ZXJ5LCBjb21wb25lbnRzLmZyYWdtZW50LCBzdHJpY3QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEpvaW4gYSBVUkkgcGF0aCB3aXRoIHBhdGggZnJhZ21lbnRzIGFuZCBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBpbnB1dCBVUkkuXHJcbiAgICAgKiBAcGFyYW0gcGF0aEZyYWdtZW50IFRoZSBwYXRoIGZyYWdtZW50IHRvIGFkZCB0byB0aGUgVVJJIHBhdGguXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIFVSSS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGpvaW5QYXRoKHVyaSwgLi4ucGF0aEZyYWdtZW50KSB7XHJcbiAgICAgICAgaWYgKCF1cmkucGF0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtVcmlFcnJvcl06IGNhbm5vdCBjYWxsIGpvaW5QYXRoIG9uIFVSSSB3aXRob3V0IHBhdGhgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld1BhdGg7XHJcbiAgICAgICAgaWYgKGlzV2luZG93cyAmJiB1cmkuc2NoZW1lID09PSAnZmlsZScpIHtcclxuICAgICAgICAgICAgbmV3UGF0aCA9IFVSSS5maWxlKHBhdGhzLndpbjMyLmpvaW4odXJpVG9Gc1BhdGgodXJpLCB0cnVlKSwgLi4ucGF0aEZyYWdtZW50KSkucGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1BhdGggPSBwYXRocy5wb3NpeC5qb2luKHVyaS5wYXRoLCAuLi5wYXRoRnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJpLndpdGgoeyBwYXRoOiBuZXdQYXRoIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBwcmludGluZy9leHRlcm5hbGl6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgdGhpcyBVUkkuIEl0J3MgZ3VhcmFudGVlZCB0aGF0IGNhbGxpbmdcclxuICAgICAqIGBVUkkucGFyc2VgIHdpdGggdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gVVJJIHdoaWNoIGlzIGVxdWFsXHJcbiAgICAgKiB0byB0aGlzIFVSSS5cclxuICAgICAqXHJcbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGV4dGVybmFsaXphdGlvbiBvciB0cmFuc3BvcnQuXHJcbiAgICAgKiAqIFRoZSByZXN1bHQgd2lsbCBiZSBlbmNvZGVkIHVzaW5nIHRoZSBwZXJjZW50YWdlIGVuY29kaW5nIGFuZCBlbmNvZGluZyBoYXBwZW5zIG1vc3RseVxyXG4gICAgICogaWdub3JlIHRoZSBzY2hlbWUtc3BlY2lmaWMgZW5jb2RpbmcgcnVsZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNraXBFbmNvZGluZyBEbyBub3QgZW5jb2RlIHRoZSByZXN1bHQsIGRlZmF1bHQgaXMgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZyhza2lwRW5jb2RpbmcgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBfYXNGb3JtYXR0ZWQodGhpcywgc2tpcEVuY29kaW5nKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHN0YXRpYyByZXZpdmUoZGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVVJJKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShkYXRhKTtcclxuICAgICAgICAgICAgcmVzdWx0Ll9mb3JtYXR0ZWQgPSAoX2EgPSBkYXRhLmV4dGVybmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgICAgICAgICByZXN1bHQuX2ZzUGF0aCA9IGRhdGEuX3NlcCA9PT0gX3BhdGhTZXBNYXJrZXIgPyAoX2IgPSBkYXRhLmZzUGF0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCA6IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IF9wYXRoU2VwTWFya2VyID0gaXNXaW5kb3dzID8gMSA6IHVuZGVmaW5lZDtcclxuLy8gVGhpcyBjbGFzcyBleGlzdHMgc28gdGhhdCBVUkkgaXMgY29tcGF0aWJsZSB3aXRoIHZzY29kZS5VcmkgKEFQSSkuXHJcbmNsYXNzIFVyaSBleHRlbmRzIFVSSSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZnNQYXRoID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldCBmc1BhdGgoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mc1BhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnNQYXRoID0gdXJpVG9Gc1BhdGgodGhpcywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZnNQYXRoO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoc2tpcEVuY29kaW5nID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIXNraXBFbmNvZGluZykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Zvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVkID0gX2FzRm9ybWF0dGVkKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2FjaGUgdGhhdFxyXG4gICAgICAgICAgICByZXR1cm4gX2FzRm9ybWF0dGVkKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgICRtaWQ6IDEgLyogTWFyc2hhbGxlZElkLlVyaSAqL1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FjaGVkIHN0YXRlXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZzUGF0aCkge1xyXG4gICAgICAgICAgICByZXMuZnNQYXRoID0gdGhpcy5fZnNQYXRoO1xyXG4gICAgICAgICAgICByZXMuX3NlcCA9IF9wYXRoU2VwTWFya2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZm9ybWF0dGVkKSB7XHJcbiAgICAgICAgICAgIHJlcy5leHRlcm5hbCA9IHRoaXMuX2Zvcm1hdHRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8tLS0gdXJpIGNvbXBvbmVudHNcclxuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHJlcy5wYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gdGhpcyBpc24ndCBjb3JyZWN0IGFuZCBjYW4gdmlvbGF0ZSB0aGUgVXJpQ29tcG9uZW50cyBjb250cmFjdCBidXRcclxuICAgICAgICAvLyB0aGlzIGlzIHBhcnQgb2YgdGhlIHZzY29kZS5VcmkgQVBJIGFuZCB3ZSBzaG91bGRuJ3QgY2hhbmdlIGhvdyB0aGF0XHJcbiAgICAgICAgLy8gd29ya3MgYW55bW9yZVxyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZSkge1xyXG4gICAgICAgICAgICByZXMuc2NoZW1lID0gdGhpcy5zY2hlbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xyXG4gICAgICAgICAgICByZXMuYXV0aG9yaXR5ID0gdGhpcy5hdXRob3JpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJlcy5xdWVyeSA9IHRoaXMucXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJlcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cclxuLy8gcmVzZXJ2ZWQgY2hhcmFjdGVyczogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0yLjJcclxuY29uc3QgZW5jb2RlVGFibGUgPSB7XHJcbiAgICBbNTggLyogQ2hhckNvZGUuQ29sb24gKi9dOiAnJTNBJywgLy8gZ2VuLWRlbGltc1xyXG4gICAgWzQ3IC8qIENoYXJDb2RlLlNsYXNoICovXTogJyUyRicsXHJcbiAgICBbNjMgLyogQ2hhckNvZGUuUXVlc3Rpb25NYXJrICovXTogJyUzRicsXHJcbiAgICBbMzUgLyogQ2hhckNvZGUuSGFzaCAqL106ICclMjMnLFxyXG4gICAgWzkxIC8qIENoYXJDb2RlLk9wZW5TcXVhcmVCcmFja2V0ICovXTogJyU1QicsXHJcbiAgICBbOTMgLyogQ2hhckNvZGUuQ2xvc2VTcXVhcmVCcmFja2V0ICovXTogJyU1RCcsXHJcbiAgICBbNjQgLyogQ2hhckNvZGUuQXRTaWduICovXTogJyU0MCcsXHJcbiAgICBbMzMgLyogQ2hhckNvZGUuRXhjbGFtYXRpb25NYXJrICovXTogJyUyMScsIC8vIHN1Yi1kZWxpbXNcclxuICAgIFszNiAvKiBDaGFyQ29kZS5Eb2xsYXJTaWduICovXTogJyUyNCcsXHJcbiAgICBbMzggLyogQ2hhckNvZGUuQW1wZXJzYW5kICovXTogJyUyNicsXHJcbiAgICBbMzkgLyogQ2hhckNvZGUuU2luZ2xlUXVvdGUgKi9dOiAnJTI3JyxcclxuICAgIFs0MCAvKiBDaGFyQ29kZS5PcGVuUGFyZW4gKi9dOiAnJTI4JyxcclxuICAgIFs0MSAvKiBDaGFyQ29kZS5DbG9zZVBhcmVuICovXTogJyUyOScsXHJcbiAgICBbNDIgLyogQ2hhckNvZGUuQXN0ZXJpc2sgKi9dOiAnJTJBJyxcclxuICAgIFs0MyAvKiBDaGFyQ29kZS5QbHVzICovXTogJyUyQicsXHJcbiAgICBbNDQgLyogQ2hhckNvZGUuQ29tbWEgKi9dOiAnJTJDJyxcclxuICAgIFs1OSAvKiBDaGFyQ29kZS5TZW1pY29sb24gKi9dOiAnJTNCJyxcclxuICAgIFs2MSAvKiBDaGFyQ29kZS5FcXVhbHMgKi9dOiAnJTNEJyxcclxuICAgIFszMiAvKiBDaGFyQ29kZS5TcGFjZSAqL106ICclMjAnLFxyXG59O1xyXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRGYXN0KHVyaUNvbXBvbmVudCwgaXNQYXRoLCBpc0F1dGhvcml0eSkge1xyXG4gICAgbGV0IHJlcyA9IHVuZGVmaW5lZDtcclxuICAgIGxldCBuYXRpdmVFbmNvZGVQb3MgPSAtMTtcclxuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHVyaUNvbXBvbmVudC5sZW5ndGg7IHBvcysrKSB7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHVyaUNvbXBvbmVudC5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgICAgLy8gdW5yZXNlcnZlZCBjaGFyYWN0ZXJzOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuM1xyXG4gICAgICAgIGlmICgoY29kZSA+PSA5NyAvKiBDaGFyQ29kZS5hICovICYmIGNvZGUgPD0gMTIyIC8qIENoYXJDb2RlLnogKi8pXHJcbiAgICAgICAgICAgIHx8IChjb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovKVxyXG4gICAgICAgICAgICB8fCAoY29kZSA+PSA0OCAvKiBDaGFyQ29kZS5EaWdpdDAgKi8gJiYgY29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi8pXHJcbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDQ1IC8qIENoYXJDb2RlLkRhc2ggKi9cclxuICAgICAgICAgICAgfHwgY29kZSA9PT0gNDYgLyogQ2hhckNvZGUuUGVyaW9kICovXHJcbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDk1IC8qIENoYXJDb2RlLlVuZGVybGluZSAqL1xyXG4gICAgICAgICAgICB8fCBjb2RlID09PSAxMjYgLyogQ2hhckNvZGUuVGlsZGUgKi9cclxuICAgICAgICAgICAgfHwgKGlzUGF0aCAmJiBjb2RlID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLylcclxuICAgICAgICAgICAgfHwgKGlzQXV0aG9yaXR5ICYmIGNvZGUgPT09IDkxIC8qIENoYXJDb2RlLk9wZW5TcXVhcmVCcmFja2V0ICovKVxyXG4gICAgICAgICAgICB8fCAoaXNBdXRob3JpdHkgJiYgY29kZSA9PT0gOTMgLyogQ2hhckNvZGUuQ2xvc2VTcXVhcmVCcmFja2V0ICovKVxyXG4gICAgICAgICAgICB8fCAoaXNBdXRob3JpdHkgJiYgY29kZSA9PT0gNTggLyogQ2hhckNvZGUuQ29sb24gKi8pKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBkZWxheWluZyBuYXRpdmUgZW5jb2RlXHJcbiAgICAgICAgICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zLCBwb3MpKTtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZUVuY29kZVBvcyA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHdyaXRlIGludG8gYSBuZXcgc3RyaW5nIChieSBkZWZhdWx0IHdlIHRyeSB0byByZXR1cm4gdGhlIHBhcmFtKVxyXG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSB1cmlDb21wb25lbnQuY2hhckF0KHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGVuY29kaW5nIG5lZWRlZCwgd2UgbmVlZCB0byBhbGxvY2F0ZSBhIG5ldyBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB1cmlDb21wb25lbnQuc3Vic3RyKDAsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hlY2sgd2l0aCBkZWZhdWx0IHRhYmxlIGZpcnN0XHJcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWQgPSBlbmNvZGVUYWJsZVtjb2RlXTtcclxuICAgICAgICAgICAgaWYgKGVzY2FwZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGRlbGF5aW5nIG5hdGl2ZSBlbmNvZGVcclxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZVVSSUNvbXBvbmVudCh1cmlDb21wb25lbnQuc3Vic3RyaW5nKG5hdGl2ZUVuY29kZVBvcywgcG9zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgZXNjYXBlZCB2YXJpYW50IHRvIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVzY2FwZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmF0aXZlRW5jb2RlUG9zID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIG5hdGl2ZSBlbmNvZGUgb25seSB3aGVuIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gcG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcclxuICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzICE9PSB1bmRlZmluZWQgPyByZXMgOiB1cmlDb21wb25lbnQ7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50TWluaW1hbChwYXRoKSB7XHJcbiAgICBsZXQgcmVzID0gdW5kZWZpbmVkO1xyXG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgcGF0aC5sZW5ndGg7IHBvcysrKSB7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSAzNSAvKiBDaGFyQ29kZS5IYXNoICovIHx8IGNvZGUgPT09IDYzIC8qIENoYXJDb2RlLlF1ZXN0aW9uTWFyayAqLykge1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHBhdGguc3Vic3RyKDAsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzICs9IGVuY29kZVRhYmxlW2NvZGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gcGF0aFtwb3NdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkID8gcmVzIDogcGF0aDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZSBgZnNQYXRoYCBmb3IgdGhlIGdpdmVuIHVyaVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVyaVRvRnNQYXRoKHVyaSwga2VlcERyaXZlTGV0dGVyQ2FzaW5nKSB7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBpZiAodXJpLmF1dGhvcml0eSAmJiB1cmkucGF0aC5sZW5ndGggPiAxICYmIHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgIC8vIHVuYyBwYXRoOiBmaWxlOi8vc2hhcmVzL2MkL2Zhci9ib29cclxuICAgICAgICB2YWx1ZSA9IGAvLyR7dXJpLmF1dGhvcml0eX0ke3VyaS5wYXRofWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1cmkucGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqL1xyXG4gICAgICAgICYmICh1cmkucGF0aC5jaGFyQ29kZUF0KDEpID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgdXJpLnBhdGguY2hhckNvZGVBdCgxKSA8PSA5MCAvKiBDaGFyQ29kZS5aICovIHx8IHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPj0gOTcgLyogQ2hhckNvZGUuYSAqLyAmJiB1cmkucGF0aC5jaGFyQ29kZUF0KDEpIDw9IDEyMiAvKiBDaGFyQ29kZS56ICovKVxyXG4gICAgICAgICYmIHVyaS5wYXRoLmNoYXJDb2RlQXQoMikgPT09IDU4IC8qIENoYXJDb2RlLkNvbG9uICovKSB7XHJcbiAgICAgICAgaWYgKCFrZWVwRHJpdmVMZXR0ZXJDYXNpbmcpIHtcclxuICAgICAgICAgICAgLy8gd2luZG93cyBkcml2ZSBsZXR0ZXI6IGZpbGU6Ly8vYzovZmFyL2Jvb1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoWzFdLnRvTG93ZXJDYXNlKCkgKyB1cmkucGF0aC5zdWJzdHIoMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoLnN1YnN0cigxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBvdGhlciBwYXRoXHJcbiAgICAgICAgdmFsdWUgPSB1cmkucGF0aDtcclxuICAgIH1cclxuICAgIGlmIChpc1dpbmRvd3MpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgdGhlIGV4dGVybmFsIHZlcnNpb24gb2YgYSB1cmlcclxuICovXHJcbmZ1bmN0aW9uIF9hc0Zvcm1hdHRlZCh1cmksIHNraXBFbmNvZGluZykge1xyXG4gICAgY29uc3QgZW5jb2RlciA9ICFza2lwRW5jb2RpbmdcclxuICAgICAgICA/IGVuY29kZVVSSUNvbXBvbmVudEZhc3RcclxuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudE1pbmltYWw7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBsZXQgeyBzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50IH0gPSB1cmk7XHJcbiAgICBpZiAoc2NoZW1lKSB7XHJcbiAgICAgICAgcmVzICs9IHNjaGVtZTtcclxuICAgICAgICByZXMgKz0gJzonO1xyXG4gICAgfVxyXG4gICAgaWYgKGF1dGhvcml0eSB8fCBzY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgIHJlcyArPSBfc2xhc2g7XHJcbiAgICAgICAgcmVzICs9IF9zbGFzaDtcclxuICAgIH1cclxuICAgIGlmIChhdXRob3JpdHkpIHtcclxuICAgICAgICBsZXQgaWR4ID0gYXV0aG9yaXR5LmluZGV4T2YoJ0AnKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyA8dXNlcj5APGF1dGg+XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJpbmZvID0gYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpO1xyXG4gICAgICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkuc3Vic3RyKGlkeCArIDEpO1xyXG4gICAgICAgICAgICBpZHggPSB1c2VyaW5mby5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8sIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8dXNlcj46PHBhc3M+QDxhdXRoPlxyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKDAsIGlkeCksIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJzonO1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKGlkeCArIDEpLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzICs9ICdAJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWR4ID0gYXV0aG9yaXR5Lmxhc3RJbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmVzICs9IGVuY29kZXIoYXV0aG9yaXR5LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyA8YXV0aD46PHBvcnQ+XHJcbiAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKGF1dGhvcml0eS5zdWJzdHIoMCwgaWR4KSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICByZXMgKz0gYXV0aG9yaXR5LnN1YnN0cihpZHgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXRoKSB7XHJcbiAgICAgICAgLy8gbG93ZXItY2FzZSB3aW5kb3dzIGRyaXZlIGxldHRlcnMgaW4gL0M6L2ZmZiBvciBDOi9mZmZcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPj0gMyAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qIENoYXJDb2RlLlNsYXNoICovICYmIHBhdGguY2hhckNvZGVBdCgyKSA9PT0gNTggLyogQ2hhckNvZGUuQ29sb24gKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgxKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPj0gNjUgLyogQ2hhckNvZGUuQSAqLyAmJiBjb2RlIDw9IDkwIC8qIENoYXJDb2RlLlogKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBgLyR7U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgMzIpfToke3BhdGguc3Vic3RyKDMpfWA7IC8vIFwiL2M6XCIubGVuZ3RoID09PSAzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGF0aC5sZW5ndGggPj0gMiAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IDU4IC8qIENoYXJDb2RlLkNvbG9uICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gYCR7U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgMzIpfToke3BhdGguc3Vic3RyKDIpfWA7IC8vIFwiL2M6XCIubGVuZ3RoID09PSAzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBwYXRoXHJcbiAgICAgICAgcmVzICs9IGVuY29kZXIocGF0aCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgcmVzICs9ICc/JztcclxuICAgICAgICByZXMgKz0gZW5jb2RlcihxdWVyeSwgZmFsc2UsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGlmIChmcmFnbWVudCkge1xyXG4gICAgICAgIHJlcyArPSAnIyc7XHJcbiAgICAgICAgcmVzICs9ICFza2lwRW5jb2RpbmcgPyBlbmNvZGVVUklDb21wb25lbnRGYXN0KGZyYWdtZW50LCBmYWxzZSwgZmFsc2UpIDogZnJhZ21lbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIC0tLSBkZWNvZGVcclxuZnVuY3Rpb24gZGVjb2RlVVJJQ29tcG9uZW50R3JhY2VmdWwoc3RyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCAzKSArIGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKHN0ci5zdWJzdHIoMykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgX3JFbmNvZGVkQXNIZXggPSAvKCVbMC05QS1aYS16XVswLTlBLVphLXpdKSsvZztcclxuZnVuY3Rpb24gcGVyY2VudERlY29kZShzdHIpIHtcclxuICAgIGlmICghc3RyLm1hdGNoKF9yRW5jb2RlZEFzSGV4KSkge1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoX3JFbmNvZGVkQXNIZXgsIChtYXRjaCkgPT4gZGVjb2RlVVJJQ29tcG9uZW50R3JhY2VmdWwobWF0Y2gpKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/uri.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimpleWorkerClient: () => (/* binding */ SimpleWorkerClient),\n/* harmony export */   SimpleWorkerServer: () => (/* binding */ SimpleWorkerServer),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   logOnceWebWorkerWarning: () => (/* binding */ logOnceWebWorkerWarning)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects.js */ \"./node_modules/monaco-editor/esm/vs/base/common/objects.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform.js */ \"./node_modules/monaco-editor/esm/vs/base/common/platform.js\");\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst INITIALIZE = '$initialize';\r\nlet webWorkerWarningLogged = false;\r\nfunction logOnceWebWorkerWarning(err) {\r\n    if (!_platform_js__WEBPACK_IMPORTED_MODULE_4__.isWeb) {\r\n        // running tests\r\n        return;\r\n    }\r\n    if (!webWorkerWarningLogged) {\r\n        webWorkerWarningLogged = true;\r\n        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\r\n    }\r\n    console.warn(err.message);\r\n}\r\nclass RequestMessage {\r\n    constructor(vsWorker, req, method, args) {\r\n        this.vsWorker = vsWorker;\r\n        this.req = req;\r\n        this.method = method;\r\n        this.args = args;\r\n        this.type = 0 /* MessageType.Request */;\r\n    }\r\n}\r\nclass ReplyMessage {\r\n    constructor(vsWorker, seq, res, err) {\r\n        this.vsWorker = vsWorker;\r\n        this.seq = seq;\r\n        this.res = res;\r\n        this.err = err;\r\n        this.type = 1 /* MessageType.Reply */;\r\n    }\r\n}\r\nclass SubscribeEventMessage {\r\n    constructor(vsWorker, req, eventName, arg) {\r\n        this.vsWorker = vsWorker;\r\n        this.req = req;\r\n        this.eventName = eventName;\r\n        this.arg = arg;\r\n        this.type = 2 /* MessageType.SubscribeEvent */;\r\n    }\r\n}\r\nclass EventMessage {\r\n    constructor(vsWorker, req, event) {\r\n        this.vsWorker = vsWorker;\r\n        this.req = req;\r\n        this.event = event;\r\n        this.type = 3 /* MessageType.Event */;\r\n    }\r\n}\r\nclass UnsubscribeEventMessage {\r\n    constructor(vsWorker, req) {\r\n        this.vsWorker = vsWorker;\r\n        this.req = req;\r\n        this.type = 4 /* MessageType.UnsubscribeEvent */;\r\n    }\r\n}\r\nclass SimpleWorkerProtocol {\r\n    constructor(handler) {\r\n        this._workerId = -1;\r\n        this._handler = handler;\r\n        this._lastSentReq = 0;\r\n        this._pendingReplies = Object.create(null);\r\n        this._pendingEmitters = new Map();\r\n        this._pendingEvents = new Map();\r\n    }\r\n    setWorkerId(workerId) {\r\n        this._workerId = workerId;\r\n    }\r\n    sendMessage(method, args) {\r\n        const req = String(++this._lastSentReq);\r\n        return new Promise((resolve, reject) => {\r\n            this._pendingReplies[req] = {\r\n                resolve: resolve,\r\n                reject: reject\r\n            };\r\n            this._send(new RequestMessage(this._workerId, req, method, args));\r\n        });\r\n    }\r\n    listen(eventName, arg) {\r\n        let req = null;\r\n        const emitter = new _event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter({\r\n            onWillAddFirstListener: () => {\r\n                req = String(++this._lastSentReq);\r\n                this._pendingEmitters.set(req, emitter);\r\n                this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));\r\n            },\r\n            onDidRemoveLastListener: () => {\r\n                this._pendingEmitters.delete(req);\r\n                this._send(new UnsubscribeEventMessage(this._workerId, req));\r\n                req = null;\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    handleMessage(message) {\r\n        if (!message || !message.vsWorker) {\r\n            return;\r\n        }\r\n        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n            return;\r\n        }\r\n        this._handleMessage(message);\r\n    }\r\n    _handleMessage(msg) {\r\n        switch (msg.type) {\r\n            case 1 /* MessageType.Reply */:\r\n                return this._handleReplyMessage(msg);\r\n            case 0 /* MessageType.Request */:\r\n                return this._handleRequestMessage(msg);\r\n            case 2 /* MessageType.SubscribeEvent */:\r\n                return this._handleSubscribeEventMessage(msg);\r\n            case 3 /* MessageType.Event */:\r\n                return this._handleEventMessage(msg);\r\n            case 4 /* MessageType.UnsubscribeEvent */:\r\n                return this._handleUnsubscribeEventMessage(msg);\r\n        }\r\n    }\r\n    _handleReplyMessage(replyMessage) {\r\n        if (!this._pendingReplies[replyMessage.seq]) {\r\n            console.warn('Got reply to unknown seq');\r\n            return;\r\n        }\r\n        const reply = this._pendingReplies[replyMessage.seq];\r\n        delete this._pendingReplies[replyMessage.seq];\r\n        if (replyMessage.err) {\r\n            let err = replyMessage.err;\r\n            if (replyMessage.err.$isError) {\r\n                err = new Error();\r\n                err.name = replyMessage.err.name;\r\n                err.message = replyMessage.err.message;\r\n                err.stack = replyMessage.err.stack;\r\n            }\r\n            reply.reject(err);\r\n            return;\r\n        }\r\n        reply.resolve(replyMessage.res);\r\n    }\r\n    _handleRequestMessage(requestMessage) {\r\n        const req = requestMessage.req;\r\n        const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\r\n        result.then((r) => {\r\n            this._send(new ReplyMessage(this._workerId, req, r, undefined));\r\n        }, (e) => {\r\n            if (e.detail instanceof Error) {\r\n                // Loading errors have a detail property that points to the actual error\r\n                e.detail = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e.detail);\r\n            }\r\n            this._send(new ReplyMessage(this._workerId, req, undefined, (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e)));\r\n        });\r\n    }\r\n    _handleSubscribeEventMessage(msg) {\r\n        const req = msg.req;\r\n        const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {\r\n            this._send(new EventMessage(this._workerId, req, event));\r\n        });\r\n        this._pendingEvents.set(req, disposable);\r\n    }\r\n    _handleEventMessage(msg) {\r\n        if (!this._pendingEmitters.has(msg.req)) {\r\n            console.warn('Got event for unknown req');\r\n            return;\r\n        }\r\n        this._pendingEmitters.get(msg.req).fire(msg.event);\r\n    }\r\n    _handleUnsubscribeEventMessage(msg) {\r\n        if (!this._pendingEvents.has(msg.req)) {\r\n            console.warn('Got unsubscribe for unknown req');\r\n            return;\r\n        }\r\n        this._pendingEvents.get(msg.req).dispose();\r\n        this._pendingEvents.delete(msg.req);\r\n    }\r\n    _send(msg) {\r\n        const transfer = [];\r\n        if (msg.type === 0 /* MessageType.Request */) {\r\n            for (let i = 0; i < msg.args.length; i++) {\r\n                if (msg.args[i] instanceof ArrayBuffer) {\r\n                    transfer.push(msg.args[i]);\r\n                }\r\n            }\r\n        }\r\n        else if (msg.type === 1 /* MessageType.Reply */) {\r\n            if (msg.res instanceof ArrayBuffer) {\r\n                transfer.push(msg.res);\r\n            }\r\n        }\r\n        this._handler.sendMessage(msg, transfer);\r\n    }\r\n}\r\n/**\r\n * Main thread side\r\n */\r\nclass SimpleWorkerClient extends _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable {\r\n    constructor(workerFactory, moduleId, host) {\r\n        super();\r\n        let lazyProxyReject = null;\r\n        this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {\r\n            this._protocol.handleMessage(msg);\r\n        }, (err) => {\r\n            // in Firefox, web workers fail lazily :(\r\n            // we will reject the proxy\r\n            lazyProxyReject === null || lazyProxyReject === void 0 ? void 0 : lazyProxyReject(err);\r\n        }));\r\n        this._protocol = new SimpleWorkerProtocol({\r\n            sendMessage: (msg, transfer) => {\r\n                this._worker.postMessage(msg, transfer);\r\n            },\r\n            handleMessage: (method, args) => {\r\n                if (typeof host[method] !== 'function') {\r\n                    return Promise.reject(new Error('Missing method ' + method + ' on main thread host.'));\r\n                }\r\n                try {\r\n                    return Promise.resolve(host[method].apply(host, args));\r\n                }\r\n                catch (e) {\r\n                    return Promise.reject(e);\r\n                }\r\n            },\r\n            handleEvent: (eventName, arg) => {\r\n                if (propertyIsDynamicEvent(eventName)) {\r\n                    const event = host[eventName].call(host, arg);\r\n                    if (typeof event !== 'function') {\r\n                        throw new Error(`Missing dynamic event ${eventName} on main thread host.`);\r\n                    }\r\n                    return event;\r\n                }\r\n                if (propertyIsEvent(eventName)) {\r\n                    const event = host[eventName];\r\n                    if (typeof event !== 'function') {\r\n                        throw new Error(`Missing event ${eventName} on main thread host.`);\r\n                    }\r\n                    return event;\r\n                }\r\n                throw new Error(`Malformed event name ${eventName}`);\r\n            }\r\n        });\r\n        this._protocol.setWorkerId(this._worker.getId());\r\n        // Gather loader configuration\r\n        let loaderConfiguration = null;\r\n        const globalRequire = globalThis.require;\r\n        if (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\r\n            // Get the configuration from the Monaco AMD Loader\r\n            loaderConfiguration = globalRequire.getConfig();\r\n        }\r\n        else if (typeof globalThis.requirejs !== 'undefined') {\r\n            // Get the configuration from requirejs\r\n            loaderConfiguration = globalThis.requirejs.s.contexts._.config;\r\n        }\r\n        const hostMethods = (0,_objects_js__WEBPACK_IMPORTED_MODULE_3__.getAllMethodNames)(host);\r\n        // Send initialize message\r\n        this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\r\n            this._worker.getId(),\r\n            JSON.parse(JSON.stringify(loaderConfiguration)),\r\n            moduleId,\r\n            hostMethods,\r\n        ]);\r\n        // Create proxy to loaded code\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._request(method, args);\r\n        };\r\n        const proxyListen = (eventName, arg) => {\r\n            return this._protocol.listen(eventName, arg);\r\n        };\r\n        this._lazyProxy = new Promise((resolve, reject) => {\r\n            lazyProxyReject = reject;\r\n            this._onModuleLoaded.then((availableMethods) => {\r\n                resolve(createProxyObject(availableMethods, proxyMethodRequest, proxyListen));\r\n            }, (e) => {\r\n                reject(e);\r\n                this._onError('Worker failed to load ' + moduleId, e);\r\n            });\r\n        });\r\n    }\r\n    getProxyObject() {\r\n        return this._lazyProxy;\r\n    }\r\n    _request(method, args) {\r\n        return new Promise((resolve, reject) => {\r\n            this._onModuleLoaded.then(() => {\r\n                this._protocol.sendMessage(method, args).then(resolve, reject);\r\n            }, reject);\r\n        });\r\n    }\r\n    _onError(message, error) {\r\n        console.error(message);\r\n        console.info(error);\r\n    }\r\n}\r\nfunction propertyIsEvent(name) {\r\n    // Assume a property is an event if it has a form of \"onSomething\"\r\n    return name[0] === 'o' && name[1] === 'n' && _strings_js__WEBPACK_IMPORTED_MODULE_5__.isUpperAsciiLetter(name.charCodeAt(2));\r\n}\r\nfunction propertyIsDynamicEvent(name) {\r\n    // Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\r\n    return /^onDynamic/.test(name) && _strings_js__WEBPACK_IMPORTED_MODULE_5__.isUpperAsciiLetter(name.charCodeAt(9));\r\n}\r\nfunction createProxyObject(methodNames, invoke, proxyListen) {\r\n    const createProxyMethod = (method) => {\r\n        return function () {\r\n            const args = Array.prototype.slice.call(arguments, 0);\r\n            return invoke(method, args);\r\n        };\r\n    };\r\n    const createProxyDynamicEvent = (eventName) => {\r\n        return function (arg) {\r\n            return proxyListen(eventName, arg);\r\n        };\r\n    };\r\n    const result = {};\r\n    for (const methodName of methodNames) {\r\n        if (propertyIsDynamicEvent(methodName)) {\r\n            result[methodName] = createProxyDynamicEvent(methodName);\r\n            continue;\r\n        }\r\n        if (propertyIsEvent(methodName)) {\r\n            result[methodName] = proxyListen(methodName, undefined);\r\n            continue;\r\n        }\r\n        result[methodName] = createProxyMethod(methodName);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Worker side\r\n */\r\nclass SimpleWorkerServer {\r\n    constructor(postMessage, requestHandlerFactory) {\r\n        this._requestHandlerFactory = requestHandlerFactory;\r\n        this._requestHandler = null;\r\n        this._protocol = new SimpleWorkerProtocol({\r\n            sendMessage: (msg, transfer) => {\r\n                postMessage(msg, transfer);\r\n            },\r\n            handleMessage: (method, args) => this._handleMessage(method, args),\r\n            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)\r\n        });\r\n    }\r\n    onmessage(msg) {\r\n        this._protocol.handleMessage(msg);\r\n    }\r\n    _handleMessage(method, args) {\r\n        if (method === INITIALIZE) {\r\n            return this.initialize(args[0], args[1], args[2], args[3]);\r\n        }\r\n        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\r\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\r\n        }\r\n        try {\r\n            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    _handleEvent(eventName, arg) {\r\n        if (!this._requestHandler) {\r\n            throw new Error(`Missing requestHandler`);\r\n        }\r\n        if (propertyIsDynamicEvent(eventName)) {\r\n            const event = this._requestHandler[eventName].call(this._requestHandler, arg);\r\n            if (typeof event !== 'function') {\r\n                throw new Error(`Missing dynamic event ${eventName} on request handler.`);\r\n            }\r\n            return event;\r\n        }\r\n        if (propertyIsEvent(eventName)) {\r\n            const event = this._requestHandler[eventName];\r\n            if (typeof event !== 'function') {\r\n                throw new Error(`Missing event ${eventName} on request handler.`);\r\n            }\r\n            return event;\r\n        }\r\n        throw new Error(`Malformed event name ${eventName}`);\r\n    }\r\n    initialize(workerId, loaderConfig, moduleId, hostMethods) {\r\n        this._protocol.setWorkerId(workerId);\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._protocol.sendMessage(method, args);\r\n        };\r\n        const proxyListen = (eventName, arg) => {\r\n            return this._protocol.listen(eventName, arg);\r\n        };\r\n        const hostProxy = createProxyObject(hostMethods, proxyMethodRequest, proxyListen);\r\n        if (this._requestHandlerFactory) {\r\n            // static request handler\r\n            this._requestHandler = this._requestHandlerFactory(hostProxy);\r\n            return Promise.resolve((0,_objects_js__WEBPACK_IMPORTED_MODULE_3__.getAllMethodNames)(this._requestHandler));\r\n        }\r\n        if (loaderConfig) {\r\n            // Remove 'baseUrl', handling it is beyond scope for now\r\n            if (typeof loaderConfig.baseUrl !== 'undefined') {\r\n                delete loaderConfig['baseUrl'];\r\n            }\r\n            if (typeof loaderConfig.paths !== 'undefined') {\r\n                if (typeof loaderConfig.paths.vs !== 'undefined') {\r\n                    delete loaderConfig.paths['vs'];\r\n                }\r\n            }\r\n            if (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\r\n                // don't use, it has been destroyed during serialize\r\n                delete loaderConfig['trustedTypesPolicy'];\r\n            }\r\n            // Since this is in a web worker, enable catching errors\r\n            loaderConfig.catchError = true;\r\n            globalThis.require.config(loaderConfig);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            // Use the global require to be sure to get the global config\r\n            // ESM-comment-begin\r\n            // \t\t\tconst req = (globalThis.require || require);\r\n            // ESM-comment-end\r\n            // ESM-uncomment-begin\r\n            const req = globalThis.require;\r\n            // ESM-uncomment-end\r\n            req([moduleId], (module) => {\r\n                this._requestHandler = module.create(hostProxy);\r\n                if (!this._requestHandler) {\r\n                    reject(new Error(`No RequestHandler!`));\r\n                    return;\r\n                }\r\n                resolve((0,_objects_js__WEBPACK_IMPORTED_MODULE_3__.getAllMethodNames)(this._requestHandler));\r\n            }, reject);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Called on the worker side\r\n * @skipMangle\r\n */\r\nfunction create(postMessage) {\r\n    return new SimpleWorkerServer(postMessage, null);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDeEI7QUFDTztBQUNLO0FBQ1g7QUFDRTtBQUN6QztBQUNBO0FBQ087QUFDUCxTQUFTLCtDQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOENBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQThCO0FBQ3pEO0FBQ0Esd0VBQXdFLDBFQUE4QjtBQUN0RyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxxREFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJEQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkRBQTBCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4REFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFpQjtBQUN6QyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyLmpzPzFiMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbiB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XHJcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudC5qcyc7XHJcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9saWZlY3ljbGUuanMnO1xyXG5pbXBvcnQgeyBnZXRBbGxNZXRob2ROYW1lcyB9IGZyb20gJy4uL29iamVjdHMuanMnO1xyXG5pbXBvcnQgeyBpc1dlYiB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcclxuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi9zdHJpbmdzLmpzJztcclxuY29uc3QgSU5JVElBTElaRSA9ICckaW5pdGlhbGl6ZSc7XHJcbmxldCB3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkID0gZmFsc2U7XHJcbmV4cG9ydCBmdW5jdGlvbiBsb2dPbmNlV2ViV29ya2VyV2FybmluZyhlcnIpIHtcclxuICAgIGlmICghaXNXZWIpIHtcclxuICAgICAgICAvLyBydW5uaW5nIHRlc3RzXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCF3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkKSB7XHJcbiAgICAgICAgd2ViV29ya2VyV2FybmluZ0xvZ2dlZCA9IHRydWU7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgY3JlYXRlIHdlYiB3b3JrZXIocykuIEZhbGxpbmcgYmFjayB0byBsb2FkaW5nIHdlYiB3b3JrZXIgY29kZSBpbiBtYWluIHRocmVhZCwgd2hpY2ggbWlnaHQgY2F1c2UgVUkgZnJlZXplcy4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L21vbmFjby1lZGl0b3IjZmFxJyk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLndhcm4oZXJyLm1lc3NhZ2UpO1xyXG59XHJcbmNsYXNzIFJlcXVlc3RNZXNzYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIG1ldGhvZCwgYXJncykge1xyXG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcclxuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLztcclxuICAgIH1cclxufVxyXG5jbGFzcyBSZXBseU1lc3NhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHNlcSwgcmVzLCBlcnIpIHtcclxuICAgICAgICB0aGlzLnZzV29ya2VyID0gdnNXb3JrZXI7XHJcbiAgICAgICAgdGhpcy5zZXEgPSBzZXE7XHJcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XHJcbiAgICAgICAgdGhpcy5lcnIgPSBlcnI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBNZXNzYWdlVHlwZS5SZXBseSAqLztcclxuICAgIH1cclxufVxyXG5jbGFzcyBTdWJzY3JpYmVFdmVudE1lc3NhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHJlcSwgZXZlbnROYW1lLCBhcmcpIHtcclxuICAgICAgICB0aGlzLnZzV29ya2VyID0gdnNXb3JrZXI7XHJcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XHJcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XHJcbiAgICAgICAgdGhpcy5hcmcgPSBhcmc7XHJcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBNZXNzYWdlVHlwZS5TdWJzY3JpYmVFdmVudCAqLztcclxuICAgIH1cclxufVxyXG5jbGFzcyBFdmVudE1lc3NhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHJlcSwgZXZlbnQpIHtcclxuICAgICAgICB0aGlzLnZzV29ya2VyID0gdnNXb3JrZXI7XHJcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDMgLyogTWVzc2FnZVR5cGUuRXZlbnQgKi87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVW5zdWJzY3JpYmVFdmVudE1lc3NhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHJlcSkge1xyXG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcclxuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcclxuICAgICAgICB0aGlzLnR5cGUgPSA0IC8qIE1lc3NhZ2VUeXBlLlVuc3Vic2NyaWJlRXZlbnQgKi87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU2ltcGxlV29ya2VyUHJvdG9jb2wge1xyXG4gICAgY29uc3RydWN0b3IoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gLTE7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNlbnRSZXEgPSAwO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXBsaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0V2ZW50cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHNldFdvcmtlcklkKHdvcmtlcklkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VySWQgPSB3b3JrZXJJZDtcclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncykge1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IFN0cmluZygrK3RoaXMuX2xhc3RTZW50UmVxKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXFdID0ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFJlcXVlc3RNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEsIG1ldGhvZCwgYXJncykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGlzdGVuKGV2ZW50TmFtZSwgYXJnKSB7XHJcbiAgICAgICAgbGV0IHJlcSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcclxuICAgICAgICAgICAgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxID0gU3RyaW5nKCsrdGhpcy5fbGFzdFNlbnRSZXEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLnNldChyZXEsIGVtaXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZChuZXcgU3Vic2NyaWJlRXZlbnRNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEsIGV2ZW50TmFtZSwgYXJnKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMuZGVsZXRlKHJlcSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBVbnN1YnNjcmliZUV2ZW50TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxKSk7XHJcbiAgICAgICAgICAgICAgICByZXEgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIW1lc3NhZ2UgfHwgIW1lc3NhZ2UudnNXb3JrZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fd29ya2VySWQgIT09IC0xICYmIG1lc3NhZ2UudnNXb3JrZXIgIT09IHRoaXMuX3dvcmtlcklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVNZXNzYWdlKG1zZykge1xyXG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxIC8qIE1lc3NhZ2VUeXBlLlJlcGx5ICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVJlcGx5TWVzc2FnZShtc2cpO1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVSZXF1ZXN0TWVzc2FnZShtc2cpO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogTWVzc2FnZVR5cGUuU3Vic2NyaWJlRXZlbnQgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3Vic2NyaWJlRXZlbnRNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBNZXNzYWdlVHlwZS5FdmVudCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFdmVudE1lc3NhZ2UobXNnKTtcclxuICAgICAgICAgICAgY2FzZSA0IC8qIE1lc3NhZ2VUeXBlLlVuc3Vic2NyaWJlRXZlbnQgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlVW5zdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlUmVwbHlNZXNzYWdlKHJlcGx5TWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV0pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHb3QgcmVwbHkgdG8gdW5rbm93biBzZXEnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXBseSA9IHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXBseU1lc3NhZ2Uuc2VxXTtcclxuICAgICAgICBpZiAocmVwbHlNZXNzYWdlLmVycikge1xyXG4gICAgICAgICAgICBsZXQgZXJyID0gcmVwbHlNZXNzYWdlLmVycjtcclxuICAgICAgICAgICAgaWYgKHJlcGx5TWVzc2FnZS5lcnIuJGlzRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSByZXBseU1lc3NhZ2UuZXJyLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IHJlcGx5TWVzc2FnZS5lcnIubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IHJlcGx5TWVzc2FnZS5lcnIuc3RhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVwbHkucmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwbHkucmVzb2x2ZShyZXBseU1lc3NhZ2UucmVzKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVSZXF1ZXN0TWVzc2FnZShyZXF1ZXN0TWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHJlcXVlc3RNZXNzYWdlLnJlcTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZU1lc3NhZ2UocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5hcmdzKTtcclxuICAgICAgICByZXN1bHQudGhlbigocikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXBseU1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSwgciwgdW5kZWZpbmVkKSk7XHJcbiAgICAgICAgfSwgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUuZGV0YWlsIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIExvYWRpbmcgZXJyb3JzIGhhdmUgYSBkZXRhaWwgcHJvcGVydHkgdGhhdCBwb2ludHMgdG8gdGhlIGFjdHVhbCBlcnJvclxyXG4gICAgICAgICAgICAgICAgZS5kZXRhaWwgPSB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24oZS5kZXRhaWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFJlcGx5TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCB1bmRlZmluZWQsIHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVN1YnNjcmliZUV2ZW50TWVzc2FnZShtc2cpIHtcclxuICAgICAgICBjb25zdCByZXEgPSBtc2cucmVxO1xyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZUV2ZW50KG1zZy5ldmVudE5hbWUsIG1zZy5hcmcpKChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBFdmVudE1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSwgZXZlbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nRXZlbnRzLnNldChyZXEsIGRpc3Bvc2FibGUpO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZUV2ZW50TWVzc2FnZShtc2cpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdFbWl0dGVycy5oYXMobXNnLnJlcSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHb3QgZXZlbnQgZm9yIHVua25vd24gcmVxJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLmdldChtc2cucmVxKS5maXJlKG1zZy5ldmVudCk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlVW5zdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nRXZlbnRzLmhhcyhtc2cucmVxKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCB1bnN1YnNjcmliZSBmb3IgdW5rbm93biByZXEnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wZW5kaW5nRXZlbnRzLmdldChtc2cucmVxKS5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0V2ZW50cy5kZWxldGUobXNnLnJlcSk7XHJcbiAgICB9XHJcbiAgICBfc2VuZChtc2cpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IFtdO1xyXG4gICAgICAgIGlmIChtc2cudHlwZSA9PT0gMCAvKiBNZXNzYWdlVHlwZS5SZXF1ZXN0ICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtc2cuYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXIucHVzaChtc2cuYXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobXNnLnR5cGUgPT09IDEgLyogTWVzc2FnZVR5cGUuUmVwbHkgKi8pIHtcclxuICAgICAgICAgICAgaWYgKG1zZy5yZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmZXIucHVzaChtc2cucmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYW5kbGVyLnNlbmRNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNYWluIHRocmVhZCBzaWRlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2ltcGxlV29ya2VyQ2xpZW50IGV4dGVuZHMgRGlzcG9zYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXJGYWN0b3J5LCBtb2R1bGVJZCwgaG9zdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgbGV0IGxhenlQcm94eVJlamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gdGhpcy5fcmVnaXN0ZXIod29ya2VyRmFjdG9yeS5jcmVhdGUoJ3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXInLCAobXNnKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcclxuICAgICAgICB9LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGluIEZpcmVmb3gsIHdlYiB3b3JrZXJzIGZhaWwgbGF6aWx5IDooXHJcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVqZWN0IHRoZSBwcm94eVxyXG4gICAgICAgICAgICBsYXp5UHJveHlSZWplY3QgPT09IG51bGwgfHwgbGF6eVByb3h5UmVqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXp5UHJveHlSZWplY3QoZXJyKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSBuZXcgU2ltcGxlV29ya2VyUHJvdG9jb2woe1xyXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZTogKG1ldGhvZCwgYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBob3N0W21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIG1ldGhvZCAnICsgbWV0aG9kICsgJyBvbiBtYWluIHRocmVhZCBob3N0LicpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob3N0W21ldGhvZF0uYXBwbHkoaG9zdCwgYXJncykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50OiAoZXZlbnROYW1lLCBhcmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUlzRHluYW1pY0V2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGhvc3RbZXZlbnROYW1lXS5jYWxsKGhvc3QsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZHluYW1pYyBldmVudCAke2V2ZW50TmFtZX0gb24gbWFpbiB0aHJlYWQgaG9zdC5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SXNFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBob3N0W2V2ZW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZXZlbnQgJHtldmVudE5hbWV9IG9uIG1haW4gdGhyZWFkIGhvc3QuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGV2ZW50IG5hbWUgJHtldmVudE5hbWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh0aGlzLl93b3JrZXIuZ2V0SWQoKSk7XHJcbiAgICAgICAgLy8gR2F0aGVyIGxvYWRlciBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgbGV0IGxvYWRlckNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbFJlcXVpcmUgPSBnbG9iYWxUaGlzLnJlcXVpcmU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxSZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsUmVxdWlyZS5nZXRDb25maWcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIE1vbmFjbyBBTUQgTG9hZGVyXHJcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZ3VyYXRpb24gPSBnbG9iYWxSZXF1aXJlLmdldENvbmZpZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5yZXF1aXJlanMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHJlcXVpcmVqc1xyXG4gICAgICAgICAgICBsb2FkZXJDb25maWd1cmF0aW9uID0gZ2xvYmFsVGhpcy5yZXF1aXJlanMucy5jb250ZXh0cy5fLmNvbmZpZztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaG9zdE1ldGhvZHMgPSBnZXRBbGxNZXRob2ROYW1lcyhob3N0KTtcclxuICAgICAgICAvLyBTZW5kIGluaXRpYWxpemUgbWVzc2FnZVxyXG4gICAgICAgIHRoaXMuX29uTW9kdWxlTG9hZGVkID0gdGhpcy5fcHJvdG9jb2wuc2VuZE1lc3NhZ2UoSU5JVElBTElaRSwgW1xyXG4gICAgICAgICAgICB0aGlzLl93b3JrZXIuZ2V0SWQoKSxcclxuICAgICAgICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsb2FkZXJDb25maWd1cmF0aW9uKSksXHJcbiAgICAgICAgICAgIG1vZHVsZUlkLFxyXG4gICAgICAgICAgICBob3N0TWV0aG9kcyxcclxuICAgICAgICBdKTtcclxuICAgICAgICAvLyBDcmVhdGUgcHJveHkgdG8gbG9hZGVkIGNvZGVcclxuICAgICAgICBjb25zdCBwcm94eU1ldGhvZFJlcXVlc3QgPSAobWV0aG9kLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwcm94eUxpc3RlbiA9IChldmVudE5hbWUsIGFyZykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2wubGlzdGVuKGV2ZW50TmFtZSwgYXJnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2xhenlQcm94eSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGF6eVByb3h5UmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB0aGlzLl9vbk1vZHVsZUxvYWRlZC50aGVuKChhdmFpbGFibGVNZXRob2RzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNyZWF0ZVByb3h5T2JqZWN0KGF2YWlsYWJsZU1ldGhvZHMsIHByb3h5TWV0aG9kUmVxdWVzdCwgcHJveHlMaXN0ZW4pKTtcclxuICAgICAgICAgICAgfSwgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoJ1dvcmtlciBmYWlsZWQgdG8gbG9hZCAnICsgbW9kdWxlSWQsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFByb3h5T2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXp5UHJveHk7XHJcbiAgICB9XHJcbiAgICBfcmVxdWVzdChtZXRob2QsIGFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9vbk1vZHVsZUxvYWRlZC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLnNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncykudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvcGVydHlJc0V2ZW50KG5hbWUpIHtcclxuICAgIC8vIEFzc3VtZSBhIHByb3BlcnR5IGlzIGFuIGV2ZW50IGlmIGl0IGhhcyBhIGZvcm0gb2YgXCJvblNvbWV0aGluZ1wiXHJcbiAgICByZXR1cm4gbmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJyAmJiBzdHJpbmdzLmlzVXBwZXJBc2NpaUxldHRlcihuYW1lLmNoYXJDb2RlQXQoMikpO1xyXG59XHJcbmZ1bmN0aW9uIHByb3BlcnR5SXNEeW5hbWljRXZlbnQobmFtZSkge1xyXG4gICAgLy8gQXNzdW1lIGEgcHJvcGVydHkgaXMgYSBkeW5hbWljIGV2ZW50IChhIG1ldGhvZCB0aGF0IHJldHVybnMgYW4gZXZlbnQpIGlmIGl0IGhhcyBhIGZvcm0gb2YgXCJvbkR5bmFtaWNTb21ldGhpbmdcIlxyXG4gICAgcmV0dXJuIC9eb25EeW5hbWljLy50ZXN0KG5hbWUpICYmIHN0cmluZ3MuaXNVcHBlckFzY2lpTGV0dGVyKG5hbWUuY2hhckNvZGVBdCg5KSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUHJveHlPYmplY3QobWV0aG9kTmFtZXMsIGludm9rZSwgcHJveHlMaXN0ZW4pIHtcclxuICAgIGNvbnN0IGNyZWF0ZVByb3h5TWV0aG9kID0gKG1ldGhvZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjb25zdCBjcmVhdGVQcm94eUR5bmFtaWNFdmVudCA9IChldmVudE5hbWUpID0+IHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJveHlMaXN0ZW4oZXZlbnROYW1lLCBhcmcpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgbWV0aG9kTmFtZXMpIHtcclxuICAgICAgICBpZiAocHJvcGVydHlJc0R5bmFtaWNFdmVudChtZXRob2ROYW1lKSkge1xyXG4gICAgICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eUR5bmFtaWNFdmVudChtZXRob2ROYW1lKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRXZlbnQobWV0aG9kTmFtZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0W21ldGhvZE5hbWVdID0gcHJveHlMaXN0ZW4obWV0aG9kTmFtZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdFttZXRob2ROYW1lXSA9IGNyZWF0ZVByb3h5TWV0aG9kKG1ldGhvZE5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogV29ya2VyIHNpZGVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTaW1wbGVXb3JrZXJTZXJ2ZXIge1xyXG4gICAgY29uc3RydWN0b3IocG9zdE1lc3NhZ2UsIHJlcXVlc3RIYW5kbGVyRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeSA9IHJlcXVlc3RIYW5kbGVyRmFjdG9yeTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSBuZXcgU2ltcGxlV29ya2VyUHJvdG9jb2woe1xyXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYW5kbGVNZXNzYWdlOiAobWV0aG9kLCBhcmdzKSA9PiB0aGlzLl9oYW5kbGVNZXNzYWdlKG1ldGhvZCwgYXJncyksXHJcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50OiAoZXZlbnROYW1lLCBhcmcpID0+IHRoaXMuX2hhbmRsZUV2ZW50KGV2ZW50TmFtZSwgYXJnKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25tZXNzYWdlKG1zZykge1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVNZXNzYWdlKG1ldGhvZCwgYXJncykge1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09IElOSVRJQUxJWkUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0SGFuZGxlciB8fCB0eXBlb2YgdGhpcy5fcmVxdWVzdEhhbmRsZXJbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVlc3RIYW5kbGVyIG9yIG1ldGhvZDogJyArIG1ldGhvZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3JlcXVlc3RIYW5kbGVyW21ldGhvZF0uYXBwbHkodGhpcy5fcmVxdWVzdEhhbmRsZXIsIGFyZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVFdmVudChldmVudE5hbWUsIGFyZykge1xyXG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVlc3RIYW5kbGVyYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRHluYW1pY0V2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlcltldmVudE5hbWVdLmNhbGwodGhpcy5fcmVxdWVzdEhhbmRsZXIsIGFyZyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBkeW5hbWljIGV2ZW50ICR7ZXZlbnROYW1lfSBvbiByZXF1ZXN0IGhhbmRsZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcGVydHlJc0V2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlcltldmVudE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZXZlbnQgJHtldmVudE5hbWV9IG9uIHJlcXVlc3QgaGFuZGxlci5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGV2ZW50IG5hbWUgJHtldmVudE5hbWV9YCk7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKHdvcmtlcklkLCBsb2FkZXJDb25maWcsIG1vZHVsZUlkLCBob3N0TWV0aG9kcykge1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLnNldFdvcmtlcklkKHdvcmtlcklkKTtcclxuICAgICAgICBjb25zdCBwcm94eU1ldGhvZFJlcXVlc3QgPSAobWV0aG9kLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShtZXRob2QsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcHJveHlMaXN0ZW4gPSAoZXZlbnROYW1lLCBhcmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLmxpc3RlbihldmVudE5hbWUsIGFyZyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBob3N0UHJveHkgPSBjcmVhdGVQcm94eU9iamVjdChob3N0TWV0aG9kcywgcHJveHlNZXRob2RSZXF1ZXN0LCBwcm94eUxpc3Rlbik7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeSkge1xyXG4gICAgICAgICAgICAvLyBzdGF0aWMgcmVxdWVzdCBoYW5kbGVyXHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gdGhpcy5fcmVxdWVzdEhhbmRsZXJGYWN0b3J5KGhvc3RQcm94eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fcmVxdWVzdEhhbmRsZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvYWRlckNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgJ2Jhc2VVcmwnLCBoYW5kbGluZyBpdCBpcyBiZXlvbmQgc2NvcGUgZm9yIG5vd1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5iYXNlVXJsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRlckNvbmZpZ1snYmFzZVVybCddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLnBhdGhzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcucGF0aHMudnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRlckNvbmZpZy5wYXRoc1sndnMnXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy50cnVzdGVkVHlwZXNQb2xpY3kgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UsIGl0IGhhcyBiZWVuIGRlc3Ryb3llZCBkdXJpbmcgc2VyaWFsaXplXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVyQ29uZmlnWyd0cnVzdGVkVHlwZXNQb2xpY3knXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGluIGEgd2ViIHdvcmtlciwgZW5hYmxlIGNhdGNoaW5nIGVycm9yc1xyXG4gICAgICAgICAgICBsb2FkZXJDb25maWcuY2F0Y2hFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgIGdsb2JhbFRoaXMucmVxdWlyZS5jb25maWcobG9hZGVyQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBnbG9iYWwgcmVxdWlyZSB0byBiZSBzdXJlIHRvIGdldCB0aGUgZ2xvYmFsIGNvbmZpZ1xyXG4gICAgICAgICAgICAvLyBFU00tY29tbWVudC1iZWdpblxyXG4gICAgICAgICAgICAvLyBcdFx0XHRjb25zdCByZXEgPSAoZ2xvYmFsVGhpcy5yZXF1aXJlIHx8IHJlcXVpcmUpO1xyXG4gICAgICAgICAgICAvLyBFU00tY29tbWVudC1lbmRcclxuICAgICAgICAgICAgLy8gRVNNLXVuY29tbWVudC1iZWdpblxyXG4gICAgICAgICAgICBjb25zdCByZXEgPSBnbG9iYWxUaGlzLnJlcXVpcmU7XHJcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXHJcbiAgICAgICAgICAgIHJlcShbbW9kdWxlSWRdLCAobW9kdWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IG1vZHVsZS5jcmVhdGUoaG9zdFByb3h5KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBObyBSZXF1ZXN0SGFuZGxlciFgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShnZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9yZXF1ZXN0SGFuZGxlcikpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgb24gdGhlIHdvcmtlciBzaWRlXHJcbiAqIEBza2lwTWFuZ2xlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHBvc3RNZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpbXBsZVdvcmtlclNlcnZlcihwb3N0TWVzc2FnZSwgbnVsbCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterClassifier: () => (/* binding */ CharacterClassifier),\n/* harmony export */   CharacterSet: () => (/* binding */ CharacterSet)\n/* harmony export */ });\n/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/uint.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uint.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A fast character classifier that uses a compact array for ASCII values.\r\n */\r\nclass CharacterClassifier {\r\n    constructor(_defaultValue) {\r\n        const defaultValue = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_defaultValue);\r\n        this._defaultValue = defaultValue;\r\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\r\n        this._map = new Map();\r\n    }\r\n    static _createAsciiMap(defaultValue) {\r\n        const asciiMap = new Uint8Array(256);\r\n        asciiMap.fill(defaultValue);\r\n        return asciiMap;\r\n    }\r\n    set(charCode, _value) {\r\n        const value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_value);\r\n        if (charCode >= 0 && charCode < 256) {\r\n            this._asciiMap[charCode] = value;\r\n        }\r\n        else {\r\n            this._map.set(charCode, value);\r\n        }\r\n    }\r\n    get(charCode) {\r\n        if (charCode >= 0 && charCode < 256) {\r\n            return this._asciiMap[charCode];\r\n        }\r\n        else {\r\n            return (this._map.get(charCode) || this._defaultValue);\r\n        }\r\n    }\r\n    clear() {\r\n        this._asciiMap.fill(this._defaultValue);\r\n        this._map.clear();\r\n    }\r\n}\r\nclass CharacterSet {\r\n    constructor() {\r\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\r\n    }\r\n    add(charCode) {\r\n        this._actual.set(charCode, 1 /* Boolean.True */);\r\n    }\r\n    has(charCode) {\r\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\r\n    }\r\n    clear() {\r\n        return this._actual.clear();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZCQUE2Qiw2REFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvY2hhcmFjdGVyQ2xhc3NpZmllci5qcz8zMTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyB0b1VpbnQ4IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdWludC5qcyc7XHJcbi8qKlxyXG4gKiBBIGZhc3QgY2hhcmFjdGVyIGNsYXNzaWZpZXIgdGhhdCB1c2VzIGEgY29tcGFjdCBhcnJheSBmb3IgQVNDSUkgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENoYXJhY3RlckNsYXNzaWZpZXIge1xyXG4gICAgY29uc3RydWN0b3IoX2RlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRvVWludDgoX2RlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2FzY2lpTWFwID0gQ2hhcmFjdGVyQ2xhc3NpZmllci5fY3JlYXRlQXNjaWlNYXAoZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZUFzY2lpTWFwKGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGFzY2lpTWFwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcclxuICAgICAgICBhc2NpaU1hcC5maWxsKGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGFzY2lpTWFwO1xyXG4gICAgfVxyXG4gICAgc2V0KGNoYXJDb2RlLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvVWludDgoX3ZhbHVlKTtcclxuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMCAmJiBjaGFyQ29kZSA8IDI1Nikge1xyXG4gICAgICAgICAgICB0aGlzLl9hc2NpaU1hcFtjaGFyQ29kZV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoY2hhckNvZGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoY2hhckNvZGUpIHtcclxuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMCAmJiBjaGFyQ29kZSA8IDI1Nikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXNjaWlNYXBbY2hhckNvZGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9tYXAuZ2V0KGNoYXJDb2RlKSB8fCB0aGlzLl9kZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX2FzY2lpTWFwLmZpbGwodGhpcy5fZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgQ2hhcmFjdGVyU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2FjdHVhbCA9IG5ldyBDaGFyYWN0ZXJDbGFzc2lmaWVyKDAgLyogQm9vbGVhbi5GYWxzZSAqLyk7XHJcbiAgICB9XHJcbiAgICBhZGQoY2hhckNvZGUpIHtcclxuICAgICAgICB0aGlzLl9hY3R1YWwuc2V0KGNoYXJDb2RlLCAxIC8qIEJvb2xlYW4uVHJ1ZSAqLyk7XHJcbiAgICB9XHJcbiAgICBoYXMoY2hhckNvZGUpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2FjdHVhbC5nZXQoY2hhckNvZGUpID09PSAxIC8qIEJvb2xlYW4uVHJ1ZSAqLyk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsLmNsZWFyKCk7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineRange: () => (/* binding */ LineRange),\n/* harmony export */   LineRangeSet: () => (/* binding */ LineRangeSet)\n/* harmony export */ });\n/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/arraysFind.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n/**\r\n * A range of lines (1-based).\r\n */\r\nclass LineRange {\r\n    static fromRangeInclusive(range) {\r\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\r\n    }\r\n    /**\r\n     * @param lineRanges An array of sorted line ranges.\r\n     */\r\n    static joinMany(lineRanges) {\r\n        if (lineRanges.length === 0) {\r\n            return [];\r\n        }\r\n        let result = new LineRangeSet(lineRanges[0].slice());\r\n        for (let i = 1; i < lineRanges.length; i++) {\r\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\r\n        }\r\n        return result.ranges;\r\n    }\r\n    static join(lineRanges) {\r\n        if (lineRanges.length === 0) {\r\n            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('lineRanges cannot be empty');\r\n        }\r\n        let startLineNumber = lineRanges[0].startLineNumber;\r\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\r\n        for (let i = 1; i < lineRanges.length; i++) {\r\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\r\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\r\n        }\r\n        return new LineRange(startLineNumber, endLineNumberExclusive);\r\n    }\r\n    static ofLength(startLineNumber, length) {\r\n        return new LineRange(startLineNumber, startLineNumber + length);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    static deserialize(lineRange) {\r\n        return new LineRange(lineRange[0], lineRange[1]);\r\n    }\r\n    constructor(startLineNumber, endLineNumberExclusive) {\r\n        if (startLineNumber > endLineNumberExclusive) {\r\n            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\r\n        }\r\n        this.startLineNumber = startLineNumber;\r\n        this.endLineNumberExclusive = endLineNumberExclusive;\r\n    }\r\n    /**\r\n     * Indicates if this line range contains the given line number.\r\n     */\r\n    contains(lineNumber) {\r\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\r\n    }\r\n    /**\r\n     * Indicates if this line range is empty.\r\n     */\r\n    get isEmpty() {\r\n        return this.startLineNumber === this.endLineNumberExclusive;\r\n    }\r\n    /**\r\n     * Moves this line range by the given offset of line numbers.\r\n     */\r\n    delta(offset) {\r\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\r\n    }\r\n    deltaLength(offset) {\r\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\r\n    }\r\n    /**\r\n     * The number of lines this line range spans.\r\n     */\r\n    get length() {\r\n        return this.endLineNumberExclusive - this.startLineNumber;\r\n    }\r\n    /**\r\n     * Creates a line range that combines this and the given line range.\r\n     */\r\n    join(other) {\r\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\r\n    }\r\n    toString() {\r\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\r\n    }\r\n    /**\r\n     * The resulting range is empty if the ranges do not intersect, but touch.\r\n     * If the ranges don't even touch, the result is undefined.\r\n     */\r\n    intersect(other) {\r\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\r\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\r\n        if (startLineNumber <= endLineNumberExclusive) {\r\n            return new LineRange(startLineNumber, endLineNumberExclusive);\r\n        }\r\n        return undefined;\r\n    }\r\n    intersectsStrict(other) {\r\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\r\n    }\r\n    overlapOrTouch(other) {\r\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\r\n    }\r\n    equals(b) {\r\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\r\n    }\r\n    toInclusiveRange() {\r\n        if (this.isEmpty) {\r\n            return null;\r\n        }\r\n        return new _range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\r\n    }\r\n    /**\r\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\r\n    */\r\n    toExclusiveRange() {\r\n        return new _range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\r\n    }\r\n    mapToLineArray(f) {\r\n        const result = [];\r\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\r\n            result.push(f(lineNumber));\r\n        }\r\n        return result;\r\n    }\r\n    forEach(f) {\r\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\r\n            f(lineNumber);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    serialize() {\r\n        return [this.startLineNumber, this.endLineNumberExclusive];\r\n    }\r\n    includes(lineNumber) {\r\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\r\n    }\r\n    /**\r\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\r\n     * @internal\r\n     */\r\n    toOffsetRange() {\r\n        return new _offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\r\n    }\r\n}\r\nclass LineRangeSet {\r\n    constructor(\r\n    /**\r\n     * Sorted by start line number.\r\n     * No two line ranges are touching or intersecting.\r\n     */\r\n    _normalizedRanges = []) {\r\n        this._normalizedRanges = _normalizedRanges;\r\n    }\r\n    get ranges() {\r\n        return this._normalizedRanges;\r\n    }\r\n    addRange(range) {\r\n        if (range.length === 0) {\r\n            return;\r\n        }\r\n        // Idea: Find joinRange such that:\r\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\r\n        // idx of first element that touches range or that is after range\r\n        const joinRangeStartIdx = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findFirstIdxMonotonousOrArrLen)(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\r\n        // idx of element after { last element that touches range or that is before range }\r\n        const joinRangeEndIdxExclusive = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastIdxMonotonous)(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\r\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\r\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\r\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\r\n        }\r\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\r\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\r\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\r\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\r\n        }\r\n        else {\r\n            // First and last element are different - we need to replace the entire range\r\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\r\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\r\n        }\r\n    }\r\n    contains(lineNumber) {\r\n        const rangeThatStartsBeforeEnd = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\r\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\r\n    }\r\n    intersects(range) {\r\n        const rangeThatStartsBeforeEnd = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\r\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\r\n    }\r\n    getUnion(other) {\r\n        if (this._normalizedRanges.length === 0) {\r\n            return other;\r\n        }\r\n        if (other._normalizedRanges.length === 0) {\r\n            return this;\r\n        }\r\n        const result = [];\r\n        let i1 = 0;\r\n        let i2 = 0;\r\n        let current = null;\r\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\r\n            let next = null;\r\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\r\n                const lineRange1 = this._normalizedRanges[i1];\r\n                const lineRange2 = other._normalizedRanges[i2];\r\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\r\n                    next = lineRange1;\r\n                    i1++;\r\n                }\r\n                else {\r\n                    next = lineRange2;\r\n                    i2++;\r\n                }\r\n            }\r\n            else if (i1 < this._normalizedRanges.length) {\r\n                next = this._normalizedRanges[i1];\r\n                i1++;\r\n            }\r\n            else {\r\n                next = other._normalizedRanges[i2];\r\n                i2++;\r\n            }\r\n            if (current === null) {\r\n                current = next;\r\n            }\r\n            else {\r\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\r\n                    // merge\r\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\r\n                }\r\n                else {\r\n                    // push\r\n                    result.push(current);\r\n                    current = next;\r\n                }\r\n            }\r\n        }\r\n        if (current !== null) {\r\n            result.push(current);\r\n        }\r\n        return new LineRangeSet(result);\r\n    }\r\n    /**\r\n     * Subtracts all ranges in this set from `range` and returns the result.\r\n     */\r\n    subtractFrom(range) {\r\n        // idx of first element that touches range or that is after range\r\n        const joinRangeStartIdx = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findFirstIdxMonotonousOrArrLen)(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\r\n        // idx of element after { last element that touches range or that is before range }\r\n        const joinRangeEndIdxExclusive = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastIdxMonotonous)(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\r\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\r\n            return new LineRangeSet([range]);\r\n        }\r\n        const result = [];\r\n        let startLineNumber = range.startLineNumber;\r\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\r\n            const r = this._normalizedRanges[i];\r\n            if (r.startLineNumber > startLineNumber) {\r\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\r\n            }\r\n            startLineNumber = r.endLineNumberExclusive;\r\n        }\r\n        if (startLineNumber < range.endLineNumberExclusive) {\r\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\r\n        }\r\n        return new LineRangeSet(result);\r\n    }\r\n    toString() {\r\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\r\n    }\r\n    getIntersection(other) {\r\n        const result = [];\r\n        let i1 = 0;\r\n        let i2 = 0;\r\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\r\n            const r1 = this._normalizedRanges[i1];\r\n            const r2 = other._normalizedRanges[i2];\r\n            const i = r1.intersect(r2);\r\n            if (i && !i.isEmpty) {\r\n                result.push(i);\r\n            }\r\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\r\n                i1++;\r\n            }\r\n            else {\r\n                i2++;\r\n            }\r\n        }\r\n        return new LineRangeSet(result);\r\n    }\r\n    getWithDelta(value) {\r\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2xpbmVSYW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRTtBQUNyQjtBQUNaO0FBQzRGO0FBQy9IO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFrQixvQkFBb0IsaUJBQWlCLHlDQUF5Qyx1QkFBdUI7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUIsR0FBRyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQ0FBMEM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQ0FBMEM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEZBQThCO0FBQ2hFLGtDQUFrQztBQUNsQyx5Q0FBeUMsaUZBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhFQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEVBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwRkFBOEI7QUFDaEUsa0NBQWtDO0FBQ2xDLHlDQUF5QyxpRkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4QkFBOEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvbGluZVJhbmdlLmpzPzU0NzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XHJcbmltcG9ydCB7IE9mZnNldFJhbmdlIH0gZnJvbSAnLi9vZmZzZXRSYW5nZS5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbiwgZmluZExhc3RJZHhNb25vdG9ub3VzLCBmaW5kTGFzdE1vbm90b25vdXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXNGaW5kLmpzJztcclxuLyoqXHJcbiAqIEEgcmFuZ2Ugb2YgbGluZXMgKDEtYmFzZWQpLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExpbmVSYW5nZSB7XHJcbiAgICBzdGF0aWMgZnJvbVJhbmdlSW5jbHVzaXZlKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyICsgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsaW5lUmFuZ2VzIEFuIGFycmF5IG9mIHNvcnRlZCBsaW5lIHJhbmdlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGpvaW5NYW55KGxpbmVSYW5nZXMpIHtcclxuICAgICAgICBpZiAobGluZVJhbmdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IExpbmVSYW5nZVNldChsaW5lUmFuZ2VzWzBdLnNsaWNlKCkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZVJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZ2V0VW5pb24obmV3IExpbmVSYW5nZVNldChsaW5lUmFuZ2VzW2ldLnNsaWNlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yYW5nZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgam9pbihsaW5lUmFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGxpbmVSYW5nZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ2xpbmVSYW5nZXMgY2Fubm90IGJlIGVtcHR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdGFydExpbmVOdW1iZXIgPSBsaW5lUmFuZ2VzWzBdLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9IGxpbmVSYW5nZXNbMF0uZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gTWF0aC5taW4oc3RhcnRMaW5lTnVtYmVyLCBsaW5lUmFuZ2VzW2ldLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPSBNYXRoLm1heChlbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBsaW5lUmFuZ2VzW2ldLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZShzdGFydExpbmVOdW1iZXIsIGVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG9mTGVuZ3RoKHN0YXJ0TGluZU51bWJlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydExpbmVOdW1iZXIgKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGxpbmVSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKGxpbmVSYW5nZVswXSwgbGluZVJhbmdlWzFdKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xyXG4gICAgICAgIGlmIChzdGFydExpbmVOdW1iZXIgPiBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoYHN0YXJ0TGluZU51bWJlciAke3N0YXJ0TGluZU51bWJlcn0gY2Fubm90IGJlIGFmdGVyIGVuZExpbmVOdW1iZXJFeGNsdXNpdmUgJHtlbmRMaW5lTnVtYmVyRXhjbHVzaXZlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPSBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhpcyBsaW5lIHJhbmdlIGNvbnRhaW5zIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnMobGluZU51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TGluZU51bWJlciA8PSBsaW5lTnVtYmVyICYmIGxpbmVOdW1iZXIgPCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBpZiB0aGlzIGxpbmUgcmFuZ2UgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TGluZU51bWJlciA9PT0gdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGlzIGxpbmUgcmFuZ2UgYnkgdGhlIGdpdmVuIG9mZnNldCBvZiBsaW5lIG51bWJlcnMuXHJcbiAgICAgKi9cclxuICAgIGRlbHRhKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKHRoaXMuc3RhcnRMaW5lTnVtYmVyICsgb2Zmc2V0LCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgZGVsdGFMZW5ndGgob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgbGluZXMgdGhpcyBsaW5lIHJhbmdlIHNwYW5zLlxyXG4gICAgICovXHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSB0aGlzLnN0YXJ0TGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGxpbmUgcmFuZ2UgdGhhdCBjb21iaW5lcyB0aGlzIGFuZCB0aGUgZ2l2ZW4gbGluZSByYW5nZS5cclxuICAgICAqL1xyXG4gICAgam9pbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKE1hdGgubWluKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCBvdGhlci5zdGFydExpbmVOdW1iZXIpLCBNYXRoLm1heCh0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIG90aGVyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFydExpbmVOdW1iZXJ9LCR7dGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlfSlgO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVzdWx0aW5nIHJhbmdlIGlzIGVtcHR5IGlmIHRoZSByYW5nZXMgZG8gbm90IGludGVyc2VjdCwgYnV0IHRvdWNoLlxyXG4gICAgICogSWYgdGhlIHJhbmdlcyBkb24ndCBldmVuIHRvdWNoLCB0aGUgcmVzdWx0IGlzIHVuZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgaW50ZXJzZWN0KG90aGVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lTnVtYmVyID0gTWF0aC5tYXgodGhpcy5zdGFydExpbmVOdW1iZXIsIG90aGVyLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgY29uc3QgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9IE1hdGgubWluKHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgb3RoZXIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpbnRlcnNlY3RzU3RyaWN0KG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyIDwgb3RoZXIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAmJiBvdGhlci5zdGFydExpbmVOdW1iZXIgPCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICBvdmVybGFwT3JUb3VjaChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TGluZU51bWJlciA8PSBvdGhlci5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICYmIG90aGVyLnN0YXJ0TGluZU51bWJlciA8PSB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMoYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiYgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID09PSBiLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICB0b0luY2x1c2l2ZVJhbmdlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIDEsIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNpbmcgdGhpcyBmdW5jdGlvbiBpcyBkaXNjb3VyYWdlZCBiZWNhdXNlIGl0IG1pZ2h0IGxlYWQgdG8gYnVnczogVGhlIGVuZCBwb3NpdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhIHZhbGlkIHBvc2l0aW9uIVxyXG4gICAgKi9cclxuICAgIHRvRXhjbHVzaXZlUmFuZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCAxKTtcclxuICAgIH1cclxuICAgIG1hcFRvTGluZUFycmF5KGYpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gdGhpcy5zdGFydExpbmVOdW1iZXI7IGxpbmVOdW1iZXIgPCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7IGxpbmVOdW1iZXIrKykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmKGxpbmVOdW1iZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZvckVhY2goZikge1xyXG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TGluZU51bWJlcjsgbGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTsgbGluZU51bWJlcisrKSB7XHJcbiAgICAgICAgICAgIGYobGluZU51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2VyaWFsaXplKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZV07XHJcbiAgICB9XHJcbiAgICBpbmNsdWRlcyhsaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyIDw9IGxpbmVOdW1iZXIgJiYgbGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyAxLWJhc2VkIGxpbmUgcmFuZ2UgdG8gYSAwLWJhc2VkIG9mZnNldCByYW5nZSAoc3VidHJhY3RzIDEhKS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0b09mZnNldFJhbmdlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTGluZVJhbmdlU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0ZWQgYnkgc3RhcnQgbGluZSBudW1iZXIuXHJcbiAgICAgKiBObyB0d28gbGluZSByYW5nZXMgYXJlIHRvdWNoaW5nIG9yIGludGVyc2VjdGluZy5cclxuICAgICAqL1xyXG4gICAgX25vcm1hbGl6ZWRSYW5nZXMgPSBbXSkge1xyXG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMgPSBfbm9ybWFsaXplZFJhbmdlcztcclxuICAgIH1cclxuICAgIGdldCByYW5nZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRSYW5nZXM7XHJcbiAgICB9XHJcbiAgICBhZGRSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZGVhOiBGaW5kIGpvaW5SYW5nZSBzdWNoIHRoYXQ6XHJcbiAgICAgICAgLy8gcmVwbGFjZVJhbmdlID0gX25vcm1hbGl6ZWRSYW5nZXMucmVwbGFjZVJhbmdlKGpvaW5SYW5nZSwgcmFuZ2Uuam9pbkFsbChqb2luUmFuZ2UubWFwKGlkeCA9PiB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2lkeF0pKSlcclxuICAgICAgICAvLyBpZHggb2YgZmlyc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBhZnRlciByYW5nZVxyXG4gICAgICAgIGNvbnN0IGpvaW5SYW5nZVN0YXJ0SWR4ID0gZmluZEZpcnN0SWR4TW9ub3Rvbm91c09yQXJyTGVuKHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMsIHIgPT4gci5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID49IHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgLy8gaWR4IG9mIGVsZW1lbnQgYWZ0ZXIgeyBsYXN0IGVsZW1lbnQgdGhhdCB0b3VjaGVzIHJhbmdlIG9yIHRoYXQgaXMgYmVmb3JlIHJhbmdlIH1cclxuICAgICAgICBjb25zdCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSArIDE7XHJcbiAgICAgICAgaWYgKGpvaW5SYW5nZVN0YXJ0SWR4ID09PSBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2UsIHRoZW4gam9pblJhbmdlU3RhcnRJZHggPT09IGpvaW5SYW5nZUVuZElkeEV4Y2x1c2l2ZSBhbmQgdGhhdCB2YWx1ZSBpcyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgYWZ0ZXIgcmFuZ2VcclxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZFJhbmdlcy5zcGxpY2Uoam9pblJhbmdlU3RhcnRJZHgsIDAsIHJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoam9pblJhbmdlU3RhcnRJZHggPT09IGpvaW5SYW5nZUVuZElkeEV4Y2x1c2l2ZSAtIDEpIHtcclxuICAgICAgICAgICAgLy8gRWxzZSwgdGhlcmUgaXMgYW4gZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2UgYW5kIGluIHRoaXMgY2FzZSBpdCBpcyBib3RoIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50LiBUaHVzIHdlIGNhbiByZXBsYWNlIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IGpvaW5SYW5nZSA9IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbam9pblJhbmdlU3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2pvaW5SYW5nZVN0YXJ0SWR4XSA9IGpvaW5SYW5nZS5qb2luKHJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgYXJlIGRpZmZlcmVudCAtIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgZW50aXJlIHJhbmdlXHJcbiAgICAgICAgICAgIGNvbnN0IGpvaW5SYW5nZSA9IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbam9pblJhbmdlU3RhcnRJZHhdLmpvaW4odGhpcy5fbm9ybWFsaXplZFJhbmdlc1tqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgLSAxXSkuam9pbihyYW5nZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMuc3BsaWNlKGpvaW5SYW5nZVN0YXJ0SWR4LCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgLSBqb2luUmFuZ2VTdGFydElkeCwgam9pblJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb250YWlucyhsaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2VUaGF0U3RhcnRzQmVmb3JlRW5kID0gZmluZExhc3RNb25vdG9ub3VzKHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMsIHIgPT4gci5zdGFydExpbmVOdW1iZXIgPD0gbGluZU51bWJlcik7XHJcbiAgICAgICAgcmV0dXJuICEhcmFuZ2VUaGF0U3RhcnRzQmVmb3JlRW5kICYmIHJhbmdlVGhhdFN0YXJ0c0JlZm9yZUVuZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID4gbGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIGludGVyc2VjdHMocmFuZ2UpIHtcclxuICAgICAgICBjb25zdCByYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgPSBmaW5kTGFzdE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xyXG4gICAgICAgIHJldHVybiAhIXJhbmdlVGhhdFN0YXJ0c0JlZm9yZUVuZCAmJiByYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIGdldFVuaW9uKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGkxID0gMDtcclxuICAgICAgICBsZXQgaTIgPSAwO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCB8fCBpMiA8IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChpMSA8IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoICYmIGkyIDwgb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lUmFuZ2UxID0gdGhpcy5fbm9ybWFsaXplZFJhbmdlc1tpMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lUmFuZ2UyID0gb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXNbaTJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVSYW5nZTEuc3RhcnRMaW5lTnVtYmVyIDwgbGluZVJhbmdlMi5zdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbGluZVJhbmdlMTtcclxuICAgICAgICAgICAgICAgICAgICBpMSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGxpbmVSYW5nZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgaTIrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpMSA8IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5fbm9ybWFsaXplZFJhbmdlc1tpMV07XHJcbiAgICAgICAgICAgICAgICBpMSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzW2kyXTtcclxuICAgICAgICAgICAgICAgIGkyKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+PSBuZXh0LnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBMaW5lUmFuZ2UoY3VycmVudC5zdGFydExpbmVOdW1iZXIsIE1hdGgubWF4KGN1cnJlbnQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbmV4dC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlU2V0KHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyBhbGwgcmFuZ2VzIGluIHRoaXMgc2V0IGZyb20gYHJhbmdlYCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBzdWJ0cmFjdEZyb20ocmFuZ2UpIHtcclxuICAgICAgICAvLyBpZHggb2YgZmlyc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBhZnRlciByYW5nZVxyXG4gICAgICAgIGNvbnN0IGpvaW5SYW5nZVN0YXJ0SWR4ID0gZmluZEZpcnN0SWR4TW9ub3Rvbm91c09yQXJyTGVuKHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMsIHIgPT4gci5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID49IHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgLy8gaWR4IG9mIGVsZW1lbnQgYWZ0ZXIgeyBsYXN0IGVsZW1lbnQgdGhhdCB0b3VjaGVzIHJhbmdlIG9yIHRoYXQgaXMgYmVmb3JlIHJhbmdlIH1cclxuICAgICAgICBjb25zdCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSArIDE7XHJcbiAgICAgICAgaWYgKGpvaW5SYW5nZVN0YXJ0SWR4ID09PSBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VTZXQoW3JhbmdlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBzdGFydExpbmVOdW1iZXIgPSByYW5nZS5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5SYW5nZVN0YXJ0SWR4OyBpIDwgam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChyLnN0YXJ0TGluZU51bWJlciA+IHN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmVSYW5nZShzdGFydExpbmVOdW1iZXIsIHIuc3RhcnRMaW5lTnVtYmVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gci5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZVJhbmdlKHN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZVNldChyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubWFwKHIgPT4gci50b1N0cmluZygpKS5qb2luKCcsICcpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW50ZXJzZWN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGkxID0gMDtcclxuICAgICAgICBsZXQgaTIgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpMSA8IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoICYmIGkyIDwgb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHIxID0gdGhpcy5fbm9ybWFsaXplZFJhbmdlc1tpMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHIyID0gb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXNbaTJdO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gcjEuaW50ZXJzZWN0KHIyKTtcclxuICAgICAgICAgICAgaWYgKGkgJiYgIWkuaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHIxLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPCByMi5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpMSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaTIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZVNldChyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZ2V0V2l0aERlbHRhKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VTZXQodGhpcy5fbm9ybWFsaXplZFJhbmdlcy5tYXAociA9PiByLmRlbHRhKHZhbHVlKSkpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OffsetRange: () => (/* binding */ OffsetRange),\n/* harmony export */   OffsetRangeSet: () => (/* binding */ OffsetRangeSet)\n/* harmony export */ });\n/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A range of offsets (0-based).\r\n*/\r\nclass OffsetRange {\r\n    static addRange(range, sortedRanges) {\r\n        let i = 0;\r\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\r\n            i++;\r\n        }\r\n        let j = i;\r\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\r\n            j++;\r\n        }\r\n        if (i === j) {\r\n            sortedRanges.splice(i, 0, range);\r\n        }\r\n        else {\r\n            const start = Math.min(range.start, sortedRanges[i].start);\r\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\r\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\r\n        }\r\n    }\r\n    static tryCreate(start, endExclusive) {\r\n        if (start > endExclusive) {\r\n            return undefined;\r\n        }\r\n        return new OffsetRange(start, endExclusive);\r\n    }\r\n    static ofLength(length) {\r\n        return new OffsetRange(0, length);\r\n    }\r\n    static ofStartAndLength(start, length) {\r\n        return new OffsetRange(start, start + length);\r\n    }\r\n    constructor(start, endExclusive) {\r\n        this.start = start;\r\n        this.endExclusive = endExclusive;\r\n        if (start > endExclusive) {\r\n            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`Invalid range: ${this.toString()}`);\r\n        }\r\n    }\r\n    get isEmpty() {\r\n        return this.start === this.endExclusive;\r\n    }\r\n    delta(offset) {\r\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\r\n    }\r\n    deltaStart(offset) {\r\n        return new OffsetRange(this.start + offset, this.endExclusive);\r\n    }\r\n    deltaEnd(offset) {\r\n        return new OffsetRange(this.start, this.endExclusive + offset);\r\n    }\r\n    get length() {\r\n        return this.endExclusive - this.start;\r\n    }\r\n    toString() {\r\n        return `[${this.start}, ${this.endExclusive})`;\r\n    }\r\n    contains(offset) {\r\n        return this.start <= offset && offset < this.endExclusive;\r\n    }\r\n    /**\r\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\r\n     * The joined range is the smallest range that contains both ranges.\r\n     */\r\n    join(other) {\r\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\r\n    }\r\n    /**\r\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\r\n     *\r\n     * The resulting range is empty if the ranges do not intersect, but touch.\r\n     * If the ranges don't even touch, the result is undefined.\r\n     */\r\n    intersect(other) {\r\n        const start = Math.max(this.start, other.start);\r\n        const end = Math.min(this.endExclusive, other.endExclusive);\r\n        if (start <= end) {\r\n            return new OffsetRange(start, end);\r\n        }\r\n        return undefined;\r\n    }\r\n    intersects(other) {\r\n        const start = Math.max(this.start, other.start);\r\n        const end = Math.min(this.endExclusive, other.endExclusive);\r\n        return start < end;\r\n    }\r\n    isBefore(other) {\r\n        return this.endExclusive <= other.start;\r\n    }\r\n    isAfter(other) {\r\n        return this.start >= other.endExclusive;\r\n    }\r\n    slice(arr) {\r\n        return arr.slice(this.start, this.endExclusive);\r\n    }\r\n    substring(str) {\r\n        return str.substring(this.start, this.endExclusive);\r\n    }\r\n    /**\r\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\r\n     * The range must not be empty.\r\n     */\r\n    clip(value) {\r\n        if (this.isEmpty) {\r\n            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\r\n        }\r\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\r\n    }\r\n    /**\r\n     * Returns `r := value + k * length` such that `r` is contained in this range.\r\n     * The range must not be empty.\r\n     *\r\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\r\n     */\r\n    clipCyclic(value) {\r\n        if (this.isEmpty) {\r\n            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\r\n        }\r\n        if (value < this.start) {\r\n            return this.endExclusive - ((this.start - value) % this.length);\r\n        }\r\n        if (value >= this.endExclusive) {\r\n            return this.start + ((value - this.start) % this.length);\r\n        }\r\n        return value;\r\n    }\r\n    forEach(f) {\r\n        for (let i = this.start; i < this.endExclusive; i++) {\r\n            f(i);\r\n        }\r\n    }\r\n}\r\nclass OffsetRangeSet {\r\n    constructor() {\r\n        this._sortedRanges = [];\r\n    }\r\n    addRange(range) {\r\n        let i = 0;\r\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\r\n            i++;\r\n        }\r\n        let j = i;\r\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\r\n            j++;\r\n        }\r\n        if (i === j) {\r\n            this._sortedRanges.splice(i, 0, range);\r\n        }\r\n        else {\r\n            const start = Math.min(range.start, this._sortedRanges[i].start);\r\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\r\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\r\n        }\r\n    }\r\n    toString() {\r\n        return this._sortedRanges.map(r => r.toString()).join(', ');\r\n    }\r\n    /**\r\n     * Returns of there is a value that is contained in this instance and the given range.\r\n     */\r\n    intersectsStrict(other) {\r\n        // TODO use binary search\r\n        let i = 0;\r\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\r\n            i++;\r\n        }\r\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\r\n    }\r\n    intersectWithRange(other) {\r\n        // TODO use binary search + slice\r\n        const result = new OffsetRangeSet();\r\n        for (const range of this._sortedRanges) {\r\n            const intersection = range.intersect(other);\r\n            if (intersection) {\r\n                result.addRange(intersection);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    intersectWithRangeLength(other) {\r\n        return this.intersectWithRange(other).length;\r\n    }\r\n    get length() {\r\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL29mZnNldFJhbmdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQWtCLG1CQUFtQixnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVcsSUFBSSxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFrQiw0QkFBNEIsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQWtCLDRCQUE0QixnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9vZmZzZXRSYW5nZS5qcz9lZmYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBCdWdJbmRpY2F0aW5nRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xyXG4vKipcclxuICogQSByYW5nZSBvZiBvZmZzZXRzICgwLWJhc2VkKS5cclxuKi9cclxuZXhwb3J0IGNsYXNzIE9mZnNldFJhbmdlIHtcclxuICAgIHN0YXRpYyBhZGRSYW5nZShyYW5nZSwgc29ydGVkUmFuZ2VzKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgc29ydGVkUmFuZ2VzLmxlbmd0aCAmJiBzb3J0ZWRSYW5nZXNbaV0uZW5kRXhjbHVzaXZlIDwgcmFuZ2Uuc3RhcnQpIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaiA9IGk7XHJcbiAgICAgICAgd2hpbGUgKGogPCBzb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHNvcnRlZFJhbmdlc1tqXS5zdGFydCA8PSByYW5nZS5lbmRFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PT0gaikge1xyXG4gICAgICAgICAgICBzb3J0ZWRSYW5nZXMuc3BsaWNlKGksIDAsIHJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4ocmFuZ2Uuc3RhcnQsIHNvcnRlZFJhbmdlc1tpXS5zdGFydCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHJhbmdlLmVuZEV4Y2x1c2l2ZSwgc29ydGVkUmFuZ2VzW2ogLSAxXS5lbmRFeGNsdXNpdmUpO1xyXG4gICAgICAgICAgICBzb3J0ZWRSYW5nZXMuc3BsaWNlKGksIGogLSBpLCBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyB0cnlDcmVhdGUoc3RhcnQsIGVuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgIGlmIChzdGFydCA+IGVuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHN0YXJ0LCBlbmRFeGNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG9mTGVuZ3RoKGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UoMCwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBvZlN0YXJ0QW5kTGVuZ3RoKHN0YXJ0LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kRXhjbHVzaXZlID0gZW5kRXhjbHVzaXZlO1xyXG4gICAgICAgIGlmIChzdGFydCA+IGVuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKGBJbnZhbGlkIHJhbmdlOiAke3RoaXMudG9TdHJpbmcoKX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCA9PT0gdGhpcy5lbmRFeGNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICBkZWx0YShvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHRoaXMuc3RhcnQgKyBvZmZzZXQsIHRoaXMuZW5kRXhjbHVzaXZlICsgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGRlbHRhU3RhcnQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZSh0aGlzLnN0YXJ0ICsgb2Zmc2V0LCB0aGlzLmVuZEV4Y2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICBkZWx0YUVuZChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kRXhjbHVzaXZlICsgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kRXhjbHVzaXZlIC0gdGhpcy5zdGFydDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFydH0sICR7dGhpcy5lbmRFeGNsdXNpdmV9KWA7XHJcbiAgICB9XHJcbiAgICBjb250YWlucyhvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCA8PSBvZmZzZXQgJiYgb2Zmc2V0IDwgdGhpcy5lbmRFeGNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGZvciBhbGwgbnVtYmVycyBuOiByYW5nZTEuY29udGFpbnMobikgb3IgcmFuZ2UyLmNvbnRhaW5zKG4pID0+IHJhbmdlMS5qb2luKHJhbmdlMikuY29udGFpbnMobilcclxuICAgICAqIFRoZSBqb2luZWQgcmFuZ2UgaXMgdGhlIHNtYWxsZXN0IHJhbmdlIHRoYXQgY29udGFpbnMgYm90aCByYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIGpvaW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKE1hdGgubWluKHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KSwgTWF0aC5tYXgodGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBmb3IgYWxsIG51bWJlcnMgbjogcmFuZ2UxLmNvbnRhaW5zKG4pIGFuZCByYW5nZTIuY29udGFpbnMobikgPD0+IHJhbmdlMS5pbnRlcnNlY3QocmFuZ2UyKS5jb250YWlucyhuKVxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXN1bHRpbmcgcmFuZ2UgaXMgZW1wdHkgaWYgdGhlIHJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCBidXQgdG91Y2guXHJcbiAgICAgKiBJZiB0aGUgcmFuZ2VzIGRvbid0IGV2ZW4gdG91Y2gsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KTtcclxuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbih0aGlzLmVuZEV4Y2x1c2l2ZSwgb3RoZXIuZW5kRXhjbHVzaXZlKTtcclxuICAgICAgICBpZiAoc3RhcnQgPD0gZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpbnRlcnNlY3RzKG90aGVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCh0aGlzLnN0YXJ0LCBvdGhlci5zdGFydCk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0IDwgZW5kO1xyXG4gICAgfVxyXG4gICAgaXNCZWZvcmUob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRFeGNsdXNpdmUgPD0gb3RoZXIuc3RhcnQ7XHJcbiAgICB9XHJcbiAgICBpc0FmdGVyKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgPj0gb3RoZXIuZW5kRXhjbHVzaXZlO1xyXG4gICAgfVxyXG4gICAgc2xpY2UoYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZEV4Y2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICBzdWJzdHJpbmcoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpcy5zdGFydCwgdGhpcy5lbmRFeGNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZSBpZiBpdCBpcyBjb250YWluZWQgaW4gdGhpcyBpbnN0YW5jZSwgb3RoZXJ3aXNlIHRoZSBjbG9zZXN0IHZhbHVlIHRoYXQgaXMgY29udGFpbmVkLlxyXG4gICAgICogVGhlIHJhbmdlIG11c3Qgbm90IGJlIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBjbGlwKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKGBJbnZhbGlkIGNsaXBwaW5nIHJhbmdlOiAke3RoaXMudG9TdHJpbmcoKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc3RhcnQsIE1hdGgubWluKHRoaXMuZW5kRXhjbHVzaXZlIC0gMSwgdmFsdWUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgciA6PSB2YWx1ZSArIGsgKiBsZW5ndGhgIHN1Y2ggdGhhdCBgcmAgaXMgY29udGFpbmVkIGluIHRoaXMgcmFuZ2UuXHJcbiAgICAgKiBUaGUgcmFuZ2UgbXVzdCBub3QgYmUgZW1wdHkuXHJcbiAgICAgKlxyXG4gICAgICogRS5nLiBgWzUsIDEwKS5jbGlwQ3ljbGljKDEwKSA9PT0gNWAsIGBbNSwgMTApLmNsaXBDeWNsaWMoMTEpID09PSA2YCBhbmQgYFs1LCAxMCkuY2xpcEN5Y2xpYyg0KSA9PT0gOWAuXHJcbiAgICAgKi9cclxuICAgIGNsaXBDeWNsaWModmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoYEludmFsaWQgY2xpcHBpbmcgcmFuZ2U6ICR7dGhpcy50b1N0cmluZygpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZEV4Y2x1c2l2ZSAtICgodGhpcy5zdGFydCAtIHZhbHVlKSAlIHRoaXMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuZW5kRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgKCh2YWx1ZSAtIHRoaXMuc3RhcnQpICUgdGhpcy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGYpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFydDsgaSA8IHRoaXMuZW5kRXhjbHVzaXZlOyBpKyspIHtcclxuICAgICAgICAgICAgZihpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE9mZnNldFJhbmdlU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWRkUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLl9zb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHRoaXMuX3NvcnRlZFJhbmdlc1tpXS5lbmRFeGNsdXNpdmUgPCByYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBqID0gaTtcclxuICAgICAgICB3aGlsZSAoaiA8IHRoaXMuX3NvcnRlZFJhbmdlcy5sZW5ndGggJiYgdGhpcy5fc29ydGVkUmFuZ2VzW2pdLnN0YXJ0IDw9IHJhbmdlLmVuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID09PSBqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcy5zcGxpY2UoaSwgMCwgcmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihyYW5nZS5zdGFydCwgdGhpcy5fc29ydGVkUmFuZ2VzW2ldLnN0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgocmFuZ2UuZW5kRXhjbHVzaXZlLCB0aGlzLl9zb3J0ZWRSYW5nZXNbaiAtIDFdLmVuZEV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcy5zcGxpY2UoaSwgaiAtIGksIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnRlZFJhbmdlcy5tYXAociA9PiByLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb2YgdGhlcmUgaXMgYSB2YWx1ZSB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGluc3RhbmNlIGFuZCB0aGUgZ2l2ZW4gcmFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdHNTdHJpY3Qob3RoZXIpIHtcclxuICAgICAgICAvLyBUT0RPIHVzZSBiaW5hcnkgc2VhcmNoXHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fc29ydGVkUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLl9zb3J0ZWRSYW5nZXNbaV0uZW5kRXhjbHVzaXZlIDw9IG90aGVyLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLl9zb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHRoaXMuX3NvcnRlZFJhbmdlc1tpXS5zdGFydCA8IG90aGVyLmVuZEV4Y2x1c2l2ZTtcclxuICAgIH1cclxuICAgIGludGVyc2VjdFdpdGhSYW5nZShvdGhlcikge1xyXG4gICAgICAgIC8vIFRPRE8gdXNlIGJpbmFyeSBzZWFyY2ggKyBzbGljZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBPZmZzZXRSYW5nZVNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5fc29ydGVkUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHJhbmdlLmludGVyc2VjdChvdGhlcik7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRSYW5nZShpbnRlcnNlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpbnRlcnNlY3RXaXRoUmFuZ2VMZW5ndGgob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RXaXRoUmFuZ2Uob3RoZXIpLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnRlZFJhbmdlcy5yZWR1Y2UoKHByZXYsIGN1cikgPT4gcHJldiArIGN1ci5sZW5ndGgsIDApO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Position: () => (/* binding */ Position)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * A position in the editor.\r\n */\r\nclass Position {\r\n    constructor(lineNumber, column) {\r\n        this.lineNumber = lineNumber;\r\n        this.column = column;\r\n    }\r\n    /**\r\n     * Create a new position from this position.\r\n     *\r\n     * @param newLineNumber new line number\r\n     * @param newColumn new column\r\n     */\r\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\r\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\r\n            return this;\r\n        }\r\n        else {\r\n            return new Position(newLineNumber, newColumn);\r\n        }\r\n    }\r\n    /**\r\n     * Derive a new position from this position.\r\n     *\r\n     * @param deltaLineNumber line number delta\r\n     * @param deltaColumn column delta\r\n     */\r\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\r\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\r\n    }\r\n    /**\r\n     * Test if this position equals other position\r\n     */\r\n    equals(other) {\r\n        return Position.equals(this, other);\r\n    }\r\n    /**\r\n     * Test if position `a` equals position `b`\r\n     */\r\n    static equals(a, b) {\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        return (!!a &&\r\n            !!b &&\r\n            a.lineNumber === b.lineNumber &&\r\n            a.column === b.column);\r\n    }\r\n    /**\r\n     * Test if this position is before other position.\r\n     * If the two positions are equal, the result will be false.\r\n     */\r\n    isBefore(other) {\r\n        return Position.isBefore(this, other);\r\n    }\r\n    /**\r\n     * Test if position `a` is before position `b`.\r\n     * If the two positions are equal, the result will be false.\r\n     */\r\n    static isBefore(a, b) {\r\n        if (a.lineNumber < b.lineNumber) {\r\n            return true;\r\n        }\r\n        if (b.lineNumber < a.lineNumber) {\r\n            return false;\r\n        }\r\n        return a.column < b.column;\r\n    }\r\n    /**\r\n     * Test if this position is before other position.\r\n     * If the two positions are equal, the result will be true.\r\n     */\r\n    isBeforeOrEqual(other) {\r\n        return Position.isBeforeOrEqual(this, other);\r\n    }\r\n    /**\r\n     * Test if position `a` is before position `b`.\r\n     * If the two positions are equal, the result will be true.\r\n     */\r\n    static isBeforeOrEqual(a, b) {\r\n        if (a.lineNumber < b.lineNumber) {\r\n            return true;\r\n        }\r\n        if (b.lineNumber < a.lineNumber) {\r\n            return false;\r\n        }\r\n        return a.column <= b.column;\r\n    }\r\n    /**\r\n     * A function that compares positions, useful for sorting\r\n     */\r\n    static compare(a, b) {\r\n        const aLineNumber = a.lineNumber | 0;\r\n        const bLineNumber = b.lineNumber | 0;\r\n        if (aLineNumber === bLineNumber) {\r\n            const aColumn = a.column | 0;\r\n            const bColumn = b.column | 0;\r\n            return aColumn - bColumn;\r\n        }\r\n        return aLineNumber - bLineNumber;\r\n    }\r\n    /**\r\n     * Clone this position.\r\n     */\r\n    clone() {\r\n        return new Position(this.lineNumber, this.column);\r\n    }\r\n    /**\r\n     * Convert to a human-readable representation.\r\n     */\r\n    toString() {\r\n        return '(' + this.lineNumber + ',' + this.column + ')';\r\n    }\r\n    // ---\r\n    /**\r\n     * Create a `Position` from an `IPosition`.\r\n     */\r\n    static lift(pos) {\r\n        return new Position(pos.lineNumber, pos.column);\r\n    }\r\n    /**\r\n     * Test if `obj` is an `IPosition`.\r\n     */\r\n    static isIPosition(obj) {\r\n        return (obj\r\n            && (typeof obj.lineNumber === 'number')\r\n            && (typeof obj.column === 'number'));\r\n    }\r\n    toJSON() {\r\n        return {\r\n            lineNumber: this.lineNumber,\r\n            column: this.column\r\n        };\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9wb3NpdGlvbi5qcz83MDYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vKipcclxuICogQSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvc2l0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGxpbmVOdW1iZXIsIGNvbHVtbikge1xyXG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ld0xpbmVOdW1iZXIgbmV3IGxpbmUgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29sdW1uIG5ldyBjb2x1bW5cclxuICAgICAqL1xyXG4gICAgd2l0aChuZXdMaW5lTnVtYmVyID0gdGhpcy5saW5lTnVtYmVyLCBuZXdDb2x1bW4gPSB0aGlzLmNvbHVtbikge1xyXG4gICAgICAgIGlmIChuZXdMaW5lTnVtYmVyID09PSB0aGlzLmxpbmVOdW1iZXIgJiYgbmV3Q29sdW1uID09PSB0aGlzLmNvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obmV3TGluZU51bWJlciwgbmV3Q29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlcml2ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlbHRhTGluZU51bWJlciBsaW5lIG51bWJlciBkZWx0YVxyXG4gICAgICogQHBhcmFtIGRlbHRhQ29sdW1uIGNvbHVtbiBkZWx0YVxyXG4gICAgICovXHJcbiAgICBkZWx0YShkZWx0YUxpbmVOdW1iZXIgPSAwLCBkZWx0YUNvbHVtbiA9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aXRoKHRoaXMubGluZU51bWJlciArIGRlbHRhTGluZU51bWJlciwgdGhpcy5jb2x1bW4gKyBkZWx0YUNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBlcXVhbHMgb3RoZXIgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmVxdWFscyh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGVxdWFscyBwb3NpdGlvbiBgYmBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCEhYSAmJlxyXG4gICAgICAgICAgICAhIWIgJiZcclxuICAgICAgICAgICAgYS5saW5lTnVtYmVyID09PSBiLmxpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5jb2x1bW4gPT09IGIuY29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBvdGhlciBwb3NpdGlvbi5cclxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBpc0JlZm9yZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5pc0JlZm9yZSh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGlzIGJlZm9yZSBwb3NpdGlvbiBgYmAuXHJcbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQmVmb3JlKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5saW5lTnVtYmVyIDwgYi5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYi5saW5lTnVtYmVyIDwgYS5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuY29sdW1uIDwgYi5jb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXHJcbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVlLlxyXG4gICAgICovXHJcbiAgICBpc0JlZm9yZU9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gUG9zaXRpb24uaXNCZWZvcmVPckVxdWFsKHRoaXMsIG90aGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cclxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0JlZm9yZU9yRXF1YWwoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxpbmVOdW1iZXIgPCBiLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiLmxpbmVOdW1iZXIgPCBhLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS5jb2x1bW4gPD0gYi5jb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyBwb3NpdGlvbnMsIHVzZWZ1bCBmb3Igc29ydGluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYUxpbmVOdW1iZXIgPSBhLmxpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgIGNvbnN0IGJMaW5lTnVtYmVyID0gYi5saW5lTnVtYmVyIHwgMDtcclxuICAgICAgICBpZiAoYUxpbmVOdW1iZXIgPT09IGJMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFDb2x1bW4gPSBhLmNvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGJDb2x1bW4gPSBiLmNvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBhQ29sdW1uIC0gYkNvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFMaW5lTnVtYmVyIC0gYkxpbmVOdW1iZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb25lIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lTnVtYmVyLCB0aGlzLmNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdG8gYSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICcoJyArIHRoaXMubGluZU51bWJlciArICcsJyArIHRoaXMuY29sdW1uICsgJyknO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGBQb3NpdGlvbmAgZnJvbSBhbiBgSVBvc2l0aW9uYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxpZnQocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3MubGluZU51bWJlciwgcG9zLmNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYG9iamAgaXMgYW4gYElQb3NpdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0lQb3NpdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gKG9ialxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5saW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouY29sdW1uID09PSAnbnVtYmVyJykpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PositionOffsetTransformer: () => (/* binding */ PositionOffsetTransformer)\n/* harmony export */ });\n/* harmony import */ var _offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _textLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textLength.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js\");\n\r\n\r\nclass PositionOffsetTransformer {\r\n    constructor(text) {\r\n        this.text = text;\r\n        this.lineStartOffsetByLineIdx = [];\r\n        this.lineStartOffsetByLineIdx.push(0);\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (text.charAt(i) === '\\n') {\r\n                this.lineStartOffsetByLineIdx.push(i + 1);\r\n            }\r\n        }\r\n    }\r\n    getOffset(position) {\r\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\r\n    }\r\n    getOffsetRange(range) {\r\n        return new _offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\r\n    }\r\n    get textLength() {\r\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\r\n        return new _textLength_js__WEBPACK_IMPORTED_MODULE_1__.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uVG9PZmZzZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ0Y7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBVTtBQUM3QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9wb3NpdGlvblRvT2Zmc2V0LmpzPzliNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuL29mZnNldFJhbmdlLmpzJztcclxuaW1wb3J0IHsgVGV4dExlbmd0aCB9IGZyb20gJy4vdGV4dExlbmd0aC5qcyc7XHJcbmV4cG9ydCBjbGFzcyBQb3NpdGlvbk9mZnNldFRyYW5zZm9ybWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMubGluZVN0YXJ0T2Zmc2V0QnlMaW5lSWR4ID0gW107XHJcbiAgICAgICAgdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHgucHVzaCgwKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSAnXFxuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHgucHVzaChpICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRPZmZzZXQocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHhbcG9zaXRpb24ubGluZU51bWJlciAtIDFdICsgcG9zaXRpb24uY29sdW1uIC0gMTtcclxuICAgIH1cclxuICAgIGdldE9mZnNldFJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZSh0aGlzLmdldE9mZnNldChyYW5nZS5nZXRTdGFydFBvc2l0aW9uKCkpLCB0aGlzLmdldE9mZnNldChyYW5nZS5nZXRFbmRQb3NpdGlvbigpKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdGV4dExlbmd0aCgpIHtcclxuICAgICAgICBjb25zdCBsaW5lSWR4ID0gdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHgubGVuZ3RoIC0gMTtcclxuICAgICAgICByZXR1cm4gbmV3IFRleHRMZW5ndGgobGluZUlkeCwgdGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMubGluZVN0YXJ0T2Zmc2V0QnlMaW5lSWR4W2xpbmVJZHhdKTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Range: () => (/* binding */ Range)\n/* harmony export */ });\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\r\n */\r\nclass Range {\r\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\r\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\r\n            this.startLineNumber = endLineNumber;\r\n            this.startColumn = endColumn;\r\n            this.endLineNumber = startLineNumber;\r\n            this.endColumn = startColumn;\r\n        }\r\n        else {\r\n            this.startLineNumber = startLineNumber;\r\n            this.startColumn = startColumn;\r\n            this.endLineNumber = endLineNumber;\r\n            this.endColumn = endColumn;\r\n        }\r\n    }\r\n    /**\r\n     * Test if this range is empty.\r\n     */\r\n    isEmpty() {\r\n        return Range.isEmpty(this);\r\n    }\r\n    /**\r\n     * Test if `range` is empty.\r\n     */\r\n    static isEmpty(range) {\r\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\r\n    }\r\n    /**\r\n     * Test if position is in this range. If the position is at the edges, will return true.\r\n     */\r\n    containsPosition(position) {\r\n        return Range.containsPosition(this, position);\r\n    }\r\n    /**\r\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\r\n     */\r\n    static containsPosition(range, position) {\r\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\r\n     * @internal\r\n     */\r\n    static strictContainsPosition(range, position) {\r\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if range is in this range. If the range is equal to this range, will return true.\r\n     */\r\n    containsRange(range) {\r\n        return Range.containsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\r\n     */\r\n    static containsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\r\n     */\r\n    strictContainsRange(range) {\r\n        return Range.strictContainsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\r\n     */\r\n    static strictContainsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    plusRange(range) {\r\n        return Range.plusRange(this, range);\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    static plusRange(a, b) {\r\n        let startLineNumber;\r\n        let startColumn;\r\n        let endLineNumber;\r\n        let endColumn;\r\n        if (b.startLineNumber < a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = b.startColumn;\r\n        }\r\n        else if (b.startLineNumber === a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = Math.min(b.startColumn, a.startColumn);\r\n        }\r\n        else {\r\n            startLineNumber = a.startLineNumber;\r\n            startColumn = a.startColumn;\r\n        }\r\n        if (b.endLineNumber > a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = b.endColumn;\r\n        }\r\n        else if (b.endLineNumber === a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = Math.max(b.endColumn, a.endColumn);\r\n        }\r\n        else {\r\n            endLineNumber = a.endLineNumber;\r\n            endColumn = a.endColumn;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    intersectRanges(range) {\r\n        return Range.intersectRanges(this, range);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    static intersectRanges(a, b) {\r\n        let resultStartLineNumber = a.startLineNumber;\r\n        let resultStartColumn = a.startColumn;\r\n        let resultEndLineNumber = a.endLineNumber;\r\n        let resultEndColumn = a.endColumn;\r\n        const otherStartLineNumber = b.startLineNumber;\r\n        const otherStartColumn = b.startColumn;\r\n        const otherEndLineNumber = b.endLineNumber;\r\n        const otherEndColumn = b.endColumn;\r\n        if (resultStartLineNumber < otherStartLineNumber) {\r\n            resultStartLineNumber = otherStartLineNumber;\r\n            resultStartColumn = otherStartColumn;\r\n        }\r\n        else if (resultStartLineNumber === otherStartLineNumber) {\r\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\r\n        }\r\n        if (resultEndLineNumber > otherEndLineNumber) {\r\n            resultEndLineNumber = otherEndLineNumber;\r\n            resultEndColumn = otherEndColumn;\r\n        }\r\n        else if (resultEndLineNumber === otherEndLineNumber) {\r\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\r\n        }\r\n        // Check if selection is now empty\r\n        if (resultStartLineNumber > resultEndLineNumber) {\r\n            return null;\r\n        }\r\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\r\n            return null;\r\n        }\r\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\r\n    }\r\n    /**\r\n     * Test if this range equals other.\r\n     */\r\n    equalsRange(other) {\r\n        return Range.equalsRange(this, other);\r\n    }\r\n    /**\r\n     * Test if range `a` equals `b`.\r\n     */\r\n    static equalsRange(a, b) {\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        return (!!a &&\r\n            !!b &&\r\n            a.startLineNumber === b.startLineNumber &&\r\n            a.startColumn === b.startColumn &&\r\n            a.endLineNumber === b.endLineNumber &&\r\n            a.endColumn === b.endColumn);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    getEndPosition() {\r\n        return Range.getEndPosition(this);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    static getEndPosition(range) {\r\n        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    getStartPosition() {\r\n        return Range.getStartPosition(this);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    static getStartPosition(range) {\r\n        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.startLineNumber, range.startColumn);\r\n    }\r\n    /**\r\n     * Transform to a user presentable string representation.\r\n     */\r\n    toString() {\r\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\r\n    }\r\n    /**\r\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n     */\r\n    setEndPosition(endLineNumber, endColumn) {\r\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n     */\r\n    setStartPosition(startLineNumber, startColumn) {\r\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    collapseToStart() {\r\n        return Range.collapseToStart(this);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    static collapseToStart(range) {\r\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's end position.\r\n     */\r\n    collapseToEnd() {\r\n        return Range.collapseToEnd(this);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's end position.\r\n     */\r\n    static collapseToEnd(range) {\r\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Moves the range by the given amount of lines.\r\n     */\r\n    delta(lineCount) {\r\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\r\n    }\r\n    // ---\r\n    static fromPositions(start, end = start) {\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    static lift(range) {\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Test if `obj` is an `IRange`.\r\n     */\r\n    static isIRange(obj) {\r\n        return (obj\r\n            && (typeof obj.startLineNumber === 'number')\r\n            && (typeof obj.startColumn === 'number')\r\n            && (typeof obj.endLineNumber === 'number')\r\n            && (typeof obj.endColumn === 'number'));\r\n    }\r\n    /**\r\n     * Test if the two ranges are touching in any way.\r\n     */\r\n    static areIntersectingOrTouching(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\r\n     */\r\n    static areIntersecting(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the startPosition and then on the endPosition\r\n     */\r\n    static compareRangesUsingStarts(a, b) {\r\n        if (a && b) {\r\n            const aStartLineNumber = a.startLineNumber | 0;\r\n            const bStartLineNumber = b.startLineNumber | 0;\r\n            if (aStartLineNumber === bStartLineNumber) {\r\n                const aStartColumn = a.startColumn | 0;\r\n                const bStartColumn = b.startColumn | 0;\r\n                if (aStartColumn === bStartColumn) {\r\n                    const aEndLineNumber = a.endLineNumber | 0;\r\n                    const bEndLineNumber = b.endLineNumber | 0;\r\n                    if (aEndLineNumber === bEndLineNumber) {\r\n                        const aEndColumn = a.endColumn | 0;\r\n                        const bEndColumn = b.endColumn | 0;\r\n                        return aEndColumn - bEndColumn;\r\n                    }\r\n                    return aEndLineNumber - bEndLineNumber;\r\n                }\r\n                return aStartColumn - bStartColumn;\r\n            }\r\n            return aStartLineNumber - bStartLineNumber;\r\n        }\r\n        const aExists = (a ? 1 : 0);\r\n        const bExists = (b ? 1 : 0);\r\n        return aExists - bExists;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the endPosition and then on the startPosition\r\n     */\r\n    static compareRangesUsingEnds(a, b) {\r\n        if (a.endLineNumber === b.endLineNumber) {\r\n            if (a.endColumn === b.endColumn) {\r\n                if (a.startLineNumber === b.startLineNumber) {\r\n                    return a.startColumn - b.startColumn;\r\n                }\r\n                return a.startLineNumber - b.startLineNumber;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.endLineNumber - b.endLineNumber;\r\n    }\r\n    /**\r\n     * Test if the range spans multiple lines.\r\n     */\r\n    static spansMultipleLines(range) {\r\n        return range.endLineNumber > range.startLineNumber;\r\n    }\r\n    toJSON() {\r\n        return this;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3JhbmdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3JhbmdlLmpzPzZhODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi9wb3NpdGlvbi5qcyc7XHJcbi8qKlxyXG4gKiBBIHJhbmdlIGluIHRoZSBlZGl0b3IuIChzdGFydExpbmVOdW1iZXIsc3RhcnRDb2x1bW4pIGlzIDw9IChlbmRMaW5lTnVtYmVyLGVuZENvbHVtbilcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcclxuICAgICAgICBpZiAoKHN0YXJ0TGluZU51bWJlciA+IGVuZExpbmVOdW1iZXIpIHx8IChzdGFydExpbmVOdW1iZXIgPT09IGVuZExpbmVOdW1iZXIgJiYgc3RhcnRDb2x1bW4gPiBlbmRDb2x1bW4pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcclxuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IGVuZENvbHVtbjtcclxuICAgICAgICAgICAgdGhpcy5lbmRMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcclxuICAgICAgICAgICAgdGhpcy5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcclxuICAgICAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBlbmRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmlzRW1wdHkodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYHJhbmdlYCBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW1wdHkocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiByYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBjb250YWluc1Bvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBwb3NpdGlvbmAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBlZGdlcywgd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbnRhaW5zUG9zaXRpb24ocmFuZ2UsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgcG9zaXRpb24ubGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA8IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uID4gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYHBvc2l0aW9uYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiBmYWxzZS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3RyaWN0Q29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBwb3NpdGlvbi5saW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uIDw9IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uID49IHJhbmdlLmVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHJhbmdlIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSByYW5nZSBpcyBlcXVhbCB0byB0aGlzIHJhbmdlLCB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBjb250YWluc1JhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbnRhaW5zUmFuZ2UodGhpcywgcmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBvdGhlclJhbmdlYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcmFuZ2VzIGFyZSBlcXVhbCwgd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbnRhaW5zUmFuZ2UocmFuZ2UsIG90aGVyUmFuZ2UpIHtcclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlciB8fCBvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5zdGFydENvbHVtbiA8IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBvdGhlclJhbmdlLmVuZENvbHVtbiA+IHJhbmdlLmVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGByYW5nZWAgaXMgc3RyaWN0bHkgaW4gdGhpcyByYW5nZS4gYHJhbmdlYCBtdXN0IHN0YXJ0IGFmdGVyIGFuZCBlbmQgYmVmb3JlIHRoaXMgcmFuZ2UgZm9yIHRoZSByZXN1bHQgdG8gYmUgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc3RyaWN0Q29udGFpbnNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5zdHJpY3RDb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgb3RoZXJSYW5nZWAgaXMgc3RyaWN0bHkgaW4gYHJhbmdlYCAobXVzdCBzdGFydCBhZnRlciwgYW5kIGVuZCBiZWZvcmUpLiBJZiB0aGUgcmFuZ2VzIGFyZSBlcXVhbCwgd2lsbCByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdHJpY3RDb250YWluc1JhbmdlKHJhbmdlLCBvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPD0gcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2UuZW5kQ29sdW1uID49IHJhbmdlLmVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXHJcbiAgICAgKiBUaGUgc21hbGxlc3QgcG9zaXRpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBzdGFydCBwb2ludCwgYW5kIHRoZSBsYXJnZXN0IG9uZSBhcyB0aGUgZW5kIHBvaW50LlxyXG4gICAgICovXHJcbiAgICBwbHVzUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UucGx1c1JhbmdlKHRoaXMsIHJhbmdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSByZXVuaW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxyXG4gICAgICogVGhlIHNtYWxsZXN0IHBvc2l0aW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9pbnQsIGFuZCB0aGUgbGFyZ2VzdCBvbmUgYXMgdGhlIGVuZCBwb2ludC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHBsdXNSYW5nZShhLCBiKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgc3RhcnRDb2x1bW47XHJcbiAgICAgICAgbGV0IGVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IGVuZENvbHVtbjtcclxuICAgICAgICBpZiAoYi5zdGFydExpbmVOdW1iZXIgPCBhLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiLnN0YXJ0TGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYi5zdGFydENvbHVtbiwgYS5zdGFydENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBhLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBhLnN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyID4gYS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IGIuZW5kQ29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiLmVuZExpbmVOdW1iZXIgPT09IGEuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBNYXRoLm1heChiLmVuZENvbHVtbiwgYS5lbmRDb2x1bW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlcjtcclxuICAgICAgICAgICAgZW5kQ29sdW1uID0gYS5lbmRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdFJhbmdlcyhyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5pbnRlcnNlY3RSYW5nZXModGhpcywgcmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludGVyc2VjdFJhbmdlcyhhLCBiKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IGEuc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCByZXN1bHRTdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgbGV0IHJlc3VsdEVuZExpbmVOdW1iZXIgPSBhLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IHJlc3VsdEVuZENvbHVtbiA9IGEuZW5kQ29sdW1uO1xyXG4gICAgICAgIGNvbnN0IG90aGVyU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJTdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgY29uc3Qgb3RoZXJFbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGNvbnN0IG90aGVyRW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA8IG90aGVyU3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IG90aGVyU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICByZXN1bHRTdGFydENvbHVtbiA9IG90aGVyU3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0U3RhcnRDb2x1bW4gPSBNYXRoLm1heChyZXN1bHRTdGFydENvbHVtbiwgb3RoZXJTdGFydENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID4gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdEVuZExpbmVOdW1iZXIgPSBvdGhlckVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHJlc3VsdEVuZENvbHVtbiA9IG90aGVyRW5kQ29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID09PSBvdGhlckVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0RW5kQ29sdW1uID0gTWF0aC5taW4ocmVzdWx0RW5kQ29sdW1uLCBvdGhlckVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGlvbiBpcyBub3cgZW1wdHlcclxuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID4gcmVzdWx0RW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gcmVzdWx0RW5kTGluZU51bWJlciAmJiByZXN1bHRTdGFydENvbHVtbiA+IHJlc3VsdEVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHRTdGFydExpbmVOdW1iZXIsIHJlc3VsdFN0YXJ0Q29sdW1uLCByZXN1bHRFbmRMaW5lTnVtYmVyLCByZXN1bHRFbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgZXF1YWxzIG90aGVyLlxyXG4gICAgICovXHJcbiAgICBlcXVhbHNSYW5nZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5lcXVhbHNSYW5nZSh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcmFuZ2UgYGFgIGVxdWFscyBgYmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlcXVhbHNSYW5nZShhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCEhYSAmJlxyXG4gICAgICAgICAgICAhIWIgJiZcclxuICAgICAgICAgICAgYS5zdGFydExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmXHJcbiAgICAgICAgICAgIGEuc3RhcnRDb2x1bW4gPT09IGIuc3RhcnRDb2x1bW4gJiZcclxuICAgICAgICAgICAgYS5lbmRMaW5lTnVtYmVyID09PSBiLmVuZExpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5lbmRDb2x1bW4gPT09IGIuZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBlbmQgcG9zaXRpb24gKHdoaWNoIHdpbGwgYmUgYWZ0ZXIgb3IgZXF1YWwgdG8gdGhlIHN0YXJ0IHBvc2l0aW9uKVxyXG4gICAgICovXHJcbiAgICBnZXRFbmRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuZ2V0RW5kUG9zaXRpb24odGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZW5kIHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGFmdGVyIG9yIGVxdWFsIHRvIHRoZSBzdGFydCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEVuZFBvc2l0aW9uKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihyYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHN0YXJ0IHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGJlZm9yZSBvciBlcXVhbCB0byB0aGUgZW5kIHBvc2l0aW9uKVxyXG4gICAgICovXHJcbiAgICBnZXRTdGFydFBvc2l0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5nZXRTdGFydFBvc2l0aW9uKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHN0YXJ0IHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGJlZm9yZSBvciBlcXVhbCB0byB0aGUgZW5kIHBvc2l0aW9uKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U3RhcnRQb3NpdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0byBhIHVzZXIgcHJlc2VudGFibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ1snICsgdGhpcy5zdGFydExpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnN0YXJ0Q29sdW1uICsgJyAtPiAnICsgdGhpcy5lbmRMaW5lTnVtYmVyICsgJywnICsgdGhpcy5lbmRDb2x1bW4gKyAnXSc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24sIGFuZCB1c2luZyBlbmRMaW5lTnVtYmVyIGFuZCBlbmRDb2x1bW4gYXMgdGhlIGVuZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgc2V0RW5kUG9zaXRpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5zdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHJhbmdlIHVzaW5nIHRoaXMgcmFuZ2UncyBlbmQgcG9zaXRpb24sIGFuZCB1c2luZyBzdGFydExpbmVOdW1iZXIgYW5kIHN0YXJ0Q29sdW1uIGFzIHRoZSBzdGFydCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgc2V0U3RhcnRQb3NpdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCB0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGVtcHR5IHJhbmdlIHVzaW5nIHRoaXMgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29sbGFwc2VUb1N0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5jb2xsYXBzZVRvU3RhcnQodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb2xsYXBzZVRvU3RhcnQocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4sIHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIGVuZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29sbGFwc2VUb0VuZCgpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuY29sbGFwc2VUb0VuZCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGVtcHR5IHJhbmdlIHVzaW5nIHRoaXMgcmFuZ2UncyBlbmQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb2xsYXBzZVRvRW5kKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4sIHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSByYW5nZSBieSB0aGUgZ2l2ZW4gYW1vdW50IG9mIGxpbmVzLlxyXG4gICAgICovXHJcbiAgICBkZWx0YShsaW5lQ291bnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnRMaW5lTnVtYmVyICsgbGluZUNvdW50LCB0aGlzLnN0YXJ0Q29sdW1uLCB0aGlzLmVuZExpbmVOdW1iZXIgKyBsaW5lQ291bnQsIHRoaXMuZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8vIC0tLVxyXG4gICAgc3RhdGljIGZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBsaWZ0KHJhbmdlKSB7XHJcbiAgICAgICAgaWYgKCFyYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUmFuZ2VgLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJUmFuZ2Uob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5lbmRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouZW5kQ29sdW1uID09PSAnbnVtYmVyJykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gcmFuZ2VzIGFyZSB0b3VjaGluZyBpbiBhbnkgd2F5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXJlSW50ZXJzZWN0aW5nT3JUb3VjaGluZyhhLCBiKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGFgIGlzIGJlZm9yZSBgYmBcclxuICAgICAgICBpZiAoYS5lbmRMaW5lTnVtYmVyIDwgYi5zdGFydExpbmVOdW1iZXIgfHwgKGEuZW5kTGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiYgYS5lbmRDb2x1bW4gPCBiLnN0YXJ0Q29sdW1uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIGBiYCBpcyBiZWZvcmUgYGFgXHJcbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyIHx8IChiLmVuZExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyICYmIGIuZW5kQ29sdW1uIDwgYS5zdGFydENvbHVtbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHJhbmdlcyBhcmUgaW50ZXJzZWN0aW5nLiBJZiB0aGUgcmFuZ2VzIGFyZSB0b3VjaGluZyBpdCByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhcmVJbnRlcnNlY3RpbmcoYSwgYikge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGBhYCBpcyBiZWZvcmUgYGJgXHJcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA8IGIuc3RhcnRMaW5lTnVtYmVyIHx8IChhLmVuZExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmIGEuZW5kQ29sdW1uIDw9IGIuc3RhcnRDb2x1bW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGJgIGlzIGJlZm9yZSBgYWBcclxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIgfHwgKGIuZW5kTGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIgJiYgYi5lbmRDb2x1bW4gPD0gYS5zdGFydENvbHVtbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHJhbmdlcywgdXNlZnVsIGZvciBzb3J0aW5nIHJhbmdlc1xyXG4gICAgICogSXQgd2lsbCBmaXJzdCBjb21wYXJlIHJhbmdlcyBvbiB0aGUgc3RhcnRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgZW5kUG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmVSYW5nZXNVc2luZ1N0YXJ0cyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgJiYgYikge1xyXG4gICAgICAgICAgICBjb25zdCBhU3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBiU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgICAgICBpZiAoYVN0YXJ0TGluZU51bWJlciA9PT0gYlN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYVN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChhU3RhcnRDb2x1bW4gPT09IGJTdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFFbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlciB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFFbmRMaW5lTnVtYmVyID09PSBiRW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhRW5kQ29sdW1uID0gYS5lbmRDb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kQ29sdW1uID0gYi5lbmRDb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUVuZENvbHVtbiAtIGJFbmRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhRW5kTGluZU51bWJlciAtIGJFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFTdGFydENvbHVtbiAtIGJTdGFydENvbHVtbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVN0YXJ0TGluZU51bWJlciAtIGJTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFFeGlzdHMgPSAoYSA/IDEgOiAwKTtcclxuICAgICAgICBjb25zdCBiRXhpc3RzID0gKGIgPyAxIDogMCk7XHJcbiAgICAgICAgcmV0dXJuIGFFeGlzdHMgLSBiRXhpc3RzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcmFuZ2VzLCB1c2VmdWwgZm9yIHNvcnRpbmcgcmFuZ2VzXHJcbiAgICAgKiBJdCB3aWxsIGZpcnN0IGNvbXBhcmUgcmFuZ2VzIG9uIHRoZSBlbmRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgc3RhcnRQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZVJhbmdlc1VzaW5nRW5kcyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChhLmVuZENvbHVtbiA9PT0gYi5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydENvbHVtbiAtIGIuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydExpbmVOdW1iZXIgLSBiLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYS5lbmRDb2x1bW4gLSBiLmVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuZW5kTGluZU51bWJlciAtIGIuZW5kTGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgcmFuZ2Ugc3BhbnMgbXVsdGlwbGUgbGluZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzcGFuc011bHRpcGxlTGluZXMocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2UuZW5kTGluZU51bWJlciA+IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Selection: () => (/* binding */ Selection)\n/* harmony export */ });\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n/**\r\n * A selection in the editor.\r\n * The selection is a range that has an orientation.\r\n */\r\nclass Selection extends _range_js__WEBPACK_IMPORTED_MODULE_1__.Range {\r\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\r\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\r\n        this.selectionStartLineNumber = selectionStartLineNumber;\r\n        this.selectionStartColumn = selectionStartColumn;\r\n        this.positionLineNumber = positionLineNumber;\r\n        this.positionColumn = positionColumn;\r\n    }\r\n    /**\r\n     * Transform to a human-readable representation.\r\n     */\r\n    toString() {\r\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\r\n    }\r\n    /**\r\n     * Test if equals other selection.\r\n     */\r\n    equalsSelection(other) {\r\n        return (Selection.selectionsEqual(this, other));\r\n    }\r\n    /**\r\n     * Test if the two selections are equal.\r\n     */\r\n    static selectionsEqual(a, b) {\r\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\r\n            a.selectionStartColumn === b.selectionStartColumn &&\r\n            a.positionLineNumber === b.positionLineNumber &&\r\n            a.positionColumn === b.positionColumn);\r\n    }\r\n    /**\r\n     * Get directions (LTR or RTL).\r\n     */\r\n    getDirection() {\r\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\r\n            return 0 /* SelectionDirection.LTR */;\r\n        }\r\n        return 1 /* SelectionDirection.RTL */;\r\n    }\r\n    /**\r\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\r\n     */\r\n    setEndPosition(endLineNumber, endColumn) {\r\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\r\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n        }\r\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\r\n    }\r\n    /**\r\n     * Get the position at `positionLineNumber` and `positionColumn`.\r\n     */\r\n    getPosition() {\r\n        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.positionLineNumber, this.positionColumn);\r\n    }\r\n    /**\r\n     * Get the position at the start of the selection.\r\n    */\r\n    getSelectionStart() {\r\n        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.selectionStartLineNumber, this.selectionStartColumn);\r\n    }\r\n    /**\r\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\r\n     */\r\n    setStartPosition(startLineNumber, startColumn) {\r\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\r\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n        }\r\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\r\n    }\r\n    // ----\r\n    /**\r\n     * Create a `Selection` from one or two positions\r\n     */\r\n    static fromPositions(start, end = start) {\r\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    /**\r\n     * Creates a `Selection` from a range, given a direction.\r\n     */\r\n    static fromRange(range, direction) {\r\n        if (direction === 0 /* SelectionDirection.LTR */) {\r\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n        }\r\n        else {\r\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\r\n        }\r\n    }\r\n    /**\r\n     * Create a `Selection` from an `ISelection`.\r\n     */\r\n    static liftSelection(sel) {\r\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\r\n    }\r\n    /**\r\n     * `a` equals `b`.\r\n     */\r\n    static selectionsArrEqual(a, b) {\r\n        if (a && !b || !a && b) {\r\n            return false;\r\n        }\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        if (a.length !== b.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = a.length; i < len; i++) {\r\n            if (!this.selectionsEqual(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `obj` is an `ISelection`.\r\n     */\r\n    static isISelection(obj) {\r\n        return (obj\r\n            && (typeof obj.selectionStartLineNumber === 'number')\r\n            && (typeof obj.selectionStartColumn === 'number')\r\n            && (typeof obj.positionLineNumber === 'number')\r\n            && (typeof obj.positionColumn === 'number'));\r\n    }\r\n    /**\r\n     * Create with a direction.\r\n     */\r\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\r\n        if (direction === 0 /* SelectionDirection.LTR */) {\r\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\r\n        }\r\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3NlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNOO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLDRDQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvc2VsZWN0aW9uLmpzPzgwMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi9wb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XHJcbi8qKlxyXG4gKiBBIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxyXG4gKiBUaGUgc2VsZWN0aW9uIGlzIGEgcmFuZ2UgdGhhdCBoYXMgYW4gb3JpZW50YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uIGV4dGVuZHMgUmFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbikge1xyXG4gICAgICAgIHN1cGVyKHNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsZWN0aW9uU3RhcnRDb2x1bW4sIHBvc2l0aW9uTGluZU51bWJlciwgcG9zaXRpb25Db2x1bW4pO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID0gc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPSBzZWxlY3Rpb25TdGFydENvbHVtbjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uTGluZU51bWJlciA9IHBvc2l0aW9uTGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uQ29sdW1uID0gcG9zaXRpb25Db2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0byBhIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ1snICsgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uICsgJyAtPiAnICsgdGhpcy5wb3NpdGlvbkxpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnBvc2l0aW9uQ29sdW1uICsgJ10nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGVxdWFscyBvdGhlciBzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGVxdWFsc1NlbGVjdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAoU2VsZWN0aW9uLnNlbGVjdGlvbnNFcXVhbCh0aGlzLCBvdGhlcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gc2VsZWN0aW9ucyBhcmUgZXF1YWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZWxlY3Rpb25zRXF1YWwoYSwgYikge1xyXG4gICAgICAgIHJldHVybiAoYS5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPT09IGIuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyICYmXHJcbiAgICAgICAgICAgIGEuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09IGIuc2VsZWN0aW9uU3RhcnRDb2x1bW4gJiZcclxuICAgICAgICAgICAgYS5wb3NpdGlvbkxpbmVOdW1iZXIgPT09IGIucG9zaXRpb25MaW5lTnVtYmVyICYmXHJcbiAgICAgICAgICAgIGEucG9zaXRpb25Db2x1bW4gPT09IGIucG9zaXRpb25Db2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgZGlyZWN0aW9ucyAoTFRSIG9yIFJUTCkuXHJcbiAgICAgKi9cclxuICAgIGdldERpcmVjdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPT09IHRoaXMuc3RhcnRMaW5lTnVtYmVyICYmIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09IHRoaXMuc3RhcnRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogU2VsZWN0aW9uRGlyZWN0aW9uLkxUUiAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDEgLyogU2VsZWN0aW9uRGlyZWN0aW9uLlJUTCAqLztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBzZXRFbmRQb3NpdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCB0aGlzLnN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4sIHRoaXMuc3RhcnRMaW5lTnVtYmVyLCB0aGlzLnN0YXJ0Q29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBhdCBgcG9zaXRpb25MaW5lTnVtYmVyYCBhbmQgYHBvc2l0aW9uQ29sdW1uYC5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLnBvc2l0aW9uTGluZU51bWJlciwgdGhpcy5wb3NpdGlvbkNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzZWxlY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgZ2V0U2VsZWN0aW9uU3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBzZWxlY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBgc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyYCBhbmQgYHNlbGVjdGlvblN0YXJ0Q29sdW1uYC5cclxuICAgICAqL1xyXG4gICAgc2V0U3RhcnRQb3NpdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGlyZWN0aW9uKCkgPT09IDAgLyogU2VsZWN0aW9uRGlyZWN0aW9uLkxUUiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCB0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbiwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGBTZWxlY3Rpb25gIGZyb20gb25lIG9yIHR3byBwb3NpdGlvbnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnQubGluZU51bWJlciwgc3RhcnQuY29sdW1uLCBlbmQubGluZU51bWJlciwgZW5kLmNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBgU2VsZWN0aW9uYCBmcm9tIGEgcmFuZ2UsIGdpdmVuIGEgZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVJhbmdlKHJhbmdlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIC8qIFNlbGVjdGlvbkRpcmVjdGlvbi5MVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbiwgcmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbiwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIGFuIGBJU2VsZWN0aW9uYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxpZnRTZWxlY3Rpb24oc2VsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCBzZWwucG9zaXRpb25MaW5lTnVtYmVyLCBzZWwucG9zaXRpb25Db2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgYWAgZXF1YWxzIGBiYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNlbGVjdGlvbnNBcnJFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgJiYgIWIgfHwgIWEgJiYgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25zRXF1YWwoYVtpXSwgYltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgb2JqYCBpcyBhbiBgSVNlbGVjdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0lTZWxlY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkxpbmVOdW1iZXIgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkNvbHVtbiA9PT0gJ251bWJlcicpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHdpdGggYSBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVXaXRoRGlyZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbik7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractText: () => (/* binding */ AbstractText),\n/* harmony export */   SingleTextEdit: () => (/* binding */ SingleTextEdit),\n/* harmony export */   StringText: () => (/* binding */ StringText),\n/* harmony export */   TextEdit: () => (/* binding */ TextEdit)\n/* harmony export */ });\n/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/assert.js */ \"./node_modules/monaco-editor/esm/vs/base/common/assert.js\");\n/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _positionToOffset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./positionToOffset.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js\");\n/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _textLength_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./textLength.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TextEdit {\r\n    constructor(edits) {\r\n        this.edits = edits;\r\n        (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertFn)(() => (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_0__.checkAdjacentItems)(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\r\n    }\r\n    apply(text) {\r\n        let result = '';\r\n        let lastEditEnd = new _position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1);\r\n        for (const edit of this.edits) {\r\n            const editRange = edit.range;\r\n            const editStart = editRange.getStartPosition();\r\n            const editEnd = editRange.getEndPosition();\r\n            const r = rangeFromPositions(lastEditEnd, editStart);\r\n            if (!r.isEmpty()) {\r\n                result += text.getValueOfRange(r);\r\n            }\r\n            result += edit.text;\r\n            lastEditEnd = editEnd;\r\n        }\r\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\r\n        if (!r.isEmpty()) {\r\n            result += text.getValueOfRange(r);\r\n        }\r\n        return result;\r\n    }\r\n    applyToString(str) {\r\n        const strText = new StringText(str);\r\n        return this.apply(strText);\r\n    }\r\n    getNewRanges() {\r\n        const newRanges = [];\r\n        let previousEditEndLineNumber = 0;\r\n        let lineOffset = 0;\r\n        let columnOffset = 0;\r\n        for (const edit of this.edits) {\r\n            const textLength = _textLength_js__WEBPACK_IMPORTED_MODULE_5__.TextLength.ofText(edit.text);\r\n            const newRangeStart = _position_js__WEBPACK_IMPORTED_MODULE_2__.Position.lift({\r\n                lineNumber: edit.range.startLineNumber + lineOffset,\r\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\r\n            });\r\n            const newRange = textLength.createRange(newRangeStart);\r\n            newRanges.push(newRange);\r\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\r\n            columnOffset = newRange.endColumn - edit.range.endColumn;\r\n            previousEditEndLineNumber = edit.range.endLineNumber;\r\n        }\r\n        return newRanges;\r\n    }\r\n}\r\nclass SingleTextEdit {\r\n    constructor(range, text) {\r\n        this.range = range;\r\n        this.text = text;\r\n    }\r\n}\r\nfunction rangeFromPositions(start, end) {\r\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\r\n        return _range_js__WEBPACK_IMPORTED_MODULE_4__.Range.fromPositions(end, end);\r\n    }\r\n    else if (!start.isBeforeOrEqual(end)) {\r\n        throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('start must be before end');\r\n    }\r\n    return new _range_js__WEBPACK_IMPORTED_MODULE_4__.Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n}\r\nclass AbstractText {\r\n    get endPositionExclusive() {\r\n        return this.length.addToPosition(new _position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1));\r\n    }\r\n}\r\nclass StringText extends AbstractText {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n        this._t = new _positionToOffset_js__WEBPACK_IMPORTED_MODULE_3__.PositionOffsetTransformer(this.value);\r\n    }\r\n    getValueOfRange(range) {\r\n        return this._t.getOffsetRange(range).substring(this.value);\r\n    }\r\n    get length() {\r\n        return this._t.textLength;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3RleHRFZGl0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RTtBQUNWO0FBQzNCO0FBQ3lCO0FBQy9CO0FBQ1U7QUFDdEM7QUFDUDtBQUNBO0FBQ0EsUUFBUSxnRUFBUSxPQUFPLDBFQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFVO0FBQ3pDLGtDQUFrQyxrREFBUTtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFLO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQWtCO0FBQ3BDO0FBQ0EsZUFBZSw0Q0FBSztBQUNwQjtBQUNPO0FBQ1A7QUFDQSw2Q0FBNkMsa0RBQVE7QUFDckQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJFQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS90ZXh0RWRpdC5qcz8wNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBhc3NlcnRGbiwgY2hlY2tBZGphY2VudEl0ZW1zIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXNzZXJ0LmpzJztcclxuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgUG9zaXRpb25PZmZzZXRUcmFuc2Zvcm1lciB9IGZyb20gJy4vcG9zaXRpb25Ub09mZnNldC5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IFRleHRMZW5ndGggfSBmcm9tICcuL3RleHRMZW5ndGguanMnO1xyXG5leHBvcnQgY2xhc3MgVGV4dEVkaXQge1xyXG4gICAgY29uc3RydWN0b3IoZWRpdHMpIHtcclxuICAgICAgICB0aGlzLmVkaXRzID0gZWRpdHM7XHJcbiAgICAgICAgYXNzZXJ0Rm4oKCkgPT4gY2hlY2tBZGphY2VudEl0ZW1zKGVkaXRzLCAoYSwgYikgPT4gYS5yYW5nZS5nZXRFbmRQb3NpdGlvbigpLmlzQmVmb3JlT3JFcXVhbChiLnJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSkpKTtcclxuICAgIH1cclxuICAgIGFwcGx5KHRleHQpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgbGV0IGxhc3RFZGl0RW5kID0gbmV3IFBvc2l0aW9uKDEsIDEpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZWRpdCBvZiB0aGlzLmVkaXRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRSYW5nZSA9IGVkaXQucmFuZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRTdGFydCA9IGVkaXRSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRFbmQgPSBlZGl0UmFuZ2UuZ2V0RW5kUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgY29uc3QgciA9IHJhbmdlRnJvbVBvc2l0aW9ucyhsYXN0RWRpdEVuZCwgZWRpdFN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKCFyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuZ2V0VmFsdWVPZlJhbmdlKHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBlZGl0LnRleHQ7XHJcbiAgICAgICAgICAgIGxhc3RFZGl0RW5kID0gZWRpdEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgciA9IHJhbmdlRnJvbVBvc2l0aW9ucyhsYXN0RWRpdEVuZCwgdGV4dC5lbmRQb3NpdGlvbkV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgaWYgKCFyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5nZXRWYWx1ZU9mUmFuZ2Uocik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBhcHBseVRvU3RyaW5nKHN0cikge1xyXG4gICAgICAgIGNvbnN0IHN0clRleHQgPSBuZXcgU3RyaW5nVGV4dChzdHIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHN0clRleHQpO1xyXG4gICAgfVxyXG4gICAgZ2V0TmV3UmFuZ2VzKCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1JhbmdlcyA9IFtdO1xyXG4gICAgICAgIGxldCBwcmV2aW91c0VkaXRFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgbGluZU9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IGNvbHVtbk9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBlZGl0IG9mIHRoaXMuZWRpdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dExlbmd0aCA9IFRleHRMZW5ndGgub2ZUZXh0KGVkaXQudGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1JhbmdlU3RhcnQgPSBQb3NpdGlvbi5saWZ0KHtcclxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGVkaXQucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICsgbGluZU9mZnNldCxcclxuICAgICAgICAgICAgICAgIGNvbHVtbjogZWRpdC5yYW5nZS5zdGFydENvbHVtbiArIChlZGl0LnJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcHJldmlvdXNFZGl0RW5kTGluZU51bWJlciA/IGNvbHVtbk9mZnNldCA6IDApXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IHRleHRMZW5ndGguY3JlYXRlUmFuZ2UobmV3UmFuZ2VTdGFydCk7XHJcbiAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ld1JhbmdlKTtcclxuICAgICAgICAgICAgbGluZU9mZnNldCA9IG5ld1JhbmdlLmVuZExpbmVOdW1iZXIgLSBlZGl0LnJhbmdlLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIGNvbHVtbk9mZnNldCA9IG5ld1JhbmdlLmVuZENvbHVtbiAtIGVkaXQucmFuZ2UuZW5kQ29sdW1uO1xyXG4gICAgICAgICAgICBwcmV2aW91c0VkaXRFbmRMaW5lTnVtYmVyID0gZWRpdC5yYW5nZS5lbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UmFuZ2VzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBTaW5nbGVUZXh0RWRpdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgdGV4dCkge1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJhbmdlRnJvbVBvc2l0aW9ucyhzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoc3RhcnQubGluZU51bWJlciA9PT0gZW5kLmxpbmVOdW1iZXIgJiYgc3RhcnQuY29sdW1uID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9zaXRpb25zKGVuZCwgZW5kKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFzdGFydC5pc0JlZm9yZU9yRXF1YWwoZW5kKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYmVmb3JlIGVuZCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcclxufVxyXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RUZXh0IHtcclxuICAgIGdldCBlbmRQb3NpdGlvbkV4Y2x1c2l2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGguYWRkVG9Qb3NpdGlvbihuZXcgUG9zaXRpb24oMSwgMSkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdUZXh0IGV4dGVuZHMgQWJzdHJhY3RUZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdCA9IG5ldyBQb3NpdGlvbk9mZnNldFRyYW5zZm9ybWVyKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0VmFsdWVPZlJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3QuZ2V0T2Zmc2V0UmFuZ2UocmFuZ2UpLnN1YnN0cmluZyh0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3QudGV4dExlbmd0aDtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextLength: () => (/* binding */ TextLength)\n/* harmony export */ });\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n/**\r\n * Represents a non-negative length of text in terms of line and column count.\r\n*/\r\nclass TextLength {\r\n    static betweenPositions(position1, position2) {\r\n        if (position1.lineNumber === position2.lineNumber) {\r\n            return new TextLength(0, position2.column - position1.column);\r\n        }\r\n        else {\r\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\r\n        }\r\n    }\r\n    static ofRange(range) {\r\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\r\n    }\r\n    static ofText(text) {\r\n        let line = 0;\r\n        let column = 0;\r\n        for (const c of text) {\r\n            if (c === '\\n') {\r\n                line++;\r\n                column = 0;\r\n            }\r\n            else {\r\n                column++;\r\n            }\r\n        }\r\n        return new TextLength(line, column);\r\n    }\r\n    constructor(lineCount, columnCount) {\r\n        this.lineCount = lineCount;\r\n        this.columnCount = columnCount;\r\n    }\r\n    isGreaterThanOrEqualTo(other) {\r\n        if (this.lineCount !== other.lineCount) {\r\n            return this.lineCount > other.lineCount;\r\n        }\r\n        return this.columnCount >= other.columnCount;\r\n    }\r\n    createRange(startPosition) {\r\n        if (this.lineCount === 0) {\r\n            return new _range_js__WEBPACK_IMPORTED_MODULE_1__.Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\r\n        }\r\n        else {\r\n            return new _range_js__WEBPACK_IMPORTED_MODULE_1__.Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\r\n        }\r\n    }\r\n    addToPosition(position) {\r\n        if (this.lineCount === 0) {\r\n            return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(position.lineNumber, position.column + this.columnCount);\r\n        }\r\n        else {\r\n            return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(position.lineNumber + this.lineCount, this.columnCount + 1);\r\n        }\r\n    }\r\n    toString() {\r\n        return `${this.lineCount},${this.columnCount}`;\r\n    }\r\n}\r\nTextLength.zero = new TextLength(0, 0);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3RleHRMZW5ndGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDTjtBQUNuQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFLO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsNENBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQVE7QUFDL0I7QUFDQTtBQUNBLHVCQUF1QixrREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZSxHQUFHLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3RleHRMZW5ndGguanM/YzgyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL3JhbmdlLmpzJztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBub24tbmVnYXRpdmUgbGVuZ3RoIG9mIHRleHQgaW4gdGVybXMgb2YgbGluZSBhbmQgY29sdW1uIGNvdW50LlxyXG4qL1xyXG5leHBvcnQgY2xhc3MgVGV4dExlbmd0aCB7XHJcbiAgICBzdGF0aWMgYmV0d2VlblBvc2l0aW9ucyhwb3NpdGlvbjEsIHBvc2l0aW9uMikge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbjEubGluZU51bWJlciA9PT0gcG9zaXRpb24yLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVuZ3RoKDAsIHBvc2l0aW9uMi5jb2x1bW4gLSBwb3NpdGlvbjEuY29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlbmd0aChwb3NpdGlvbjIubGluZU51bWJlciAtIHBvc2l0aW9uMS5saW5lTnVtYmVyLCBwb3NpdGlvbjIuY29sdW1uIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIG9mUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gVGV4dExlbmd0aC5iZXR3ZWVuUG9zaXRpb25zKHJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSwgcmFuZ2UuZ2V0RW5kUG9zaXRpb24oKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgb2ZUZXh0KHRleHQpIHtcclxuICAgICAgICBsZXQgbGluZSA9IDA7XHJcbiAgICAgICAgbGV0IGNvbHVtbiA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lKys7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVuZ3RoKGxpbmUsIGNvbHVtbik7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihsaW5lQ291bnQsIGNvbHVtbkNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5saW5lQ291bnQgPSBsaW5lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IGNvbHVtbkNvdW50O1xyXG4gICAgfVxyXG4gICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmVDb3VudCAhPT0gb3RoZXIubGluZUNvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVDb3VudCA+IG90aGVyLmxpbmVDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uQ291bnQgPj0gb3RoZXIuY29sdW1uQ291bnQ7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVSYW5nZShzdGFydFBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGluZUNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLCBzdGFydFBvc2l0aW9uLmNvbHVtbiwgc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLCBzdGFydFBvc2l0aW9uLmNvbHVtbiArIHRoaXMuY29sdW1uQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIsIHN0YXJ0UG9zaXRpb24uY29sdW1uLCBzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIgKyB0aGlzLmxpbmVDb3VudCwgdGhpcy5jb2x1bW5Db3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZFRvUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5saW5lQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3NpdGlvbi5saW5lTnVtYmVyLCBwb3NpdGlvbi5jb2x1bW4gKyB0aGlzLmNvbHVtbkNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zaXRpb24ubGluZU51bWJlciArIHRoaXMubGluZUNvdW50LCB0aGlzLmNvbHVtbkNvdW50ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGluZUNvdW50fSwke3RoaXMuY29sdW1uQ291bnR9YDtcclxuICAgIH1cclxufVxyXG5UZXh0TGVuZ3RoLnplcm8gPSBuZXcgVGV4dExlbmd0aCgwLCAwKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WordCharacterClassifier: () => (/* binding */ WordCharacterClassifier),\n/* harmony export */   getMapForWordSeparators: () => (/* binding */ getMapForWordSeparators)\n/* harmony export */ });\n/* harmony import */ var _base_common_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/map.js */ \"./node_modules/monaco-editor/esm/vs/base/common/map.js\");\n/* harmony import */ var _characterClassifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./characterClassifier.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass WordCharacterClassifier extends _characterClassifier_js__WEBPACK_IMPORTED_MODULE_1__.CharacterClassifier {\r\n    constructor(wordSeparators, intlSegmenterLocales) {\r\n        super(0 /* WordCharacterClass.Regular */);\r\n        this._segmenter = null;\r\n        this._cachedLine = null;\r\n        this._cachedSegments = [];\r\n        this.intlSegmenterLocales = intlSegmenterLocales;\r\n        if (this.intlSegmenterLocales.length > 0) {\r\n            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\r\n        }\r\n        else {\r\n            this._segmenter = null;\r\n        }\r\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\r\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\r\n        }\r\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\r\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\r\n    }\r\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\r\n        let candidate = null;\r\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\r\n            if (segment.index > offset) {\r\n                break;\r\n            }\r\n            candidate = segment;\r\n        }\r\n        return candidate;\r\n    }\r\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\r\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\r\n            if (segment.index < offset) {\r\n                continue;\r\n            }\r\n            return segment;\r\n        }\r\n        return null;\r\n    }\r\n    _getIntlSegmenterWordsOnLine(line) {\r\n        if (!this._segmenter) {\r\n            return [];\r\n        }\r\n        // Check if the line has changed from the previous call\r\n        if (this._cachedLine === line) {\r\n            return this._cachedSegments;\r\n        }\r\n        // Update the cache with the new line\r\n        this._cachedLine = line;\r\n        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\r\n        return this._cachedSegments;\r\n    }\r\n    _filterWordSegments(segments) {\r\n        const result = [];\r\n        for (const segment of segments) {\r\n            if (this._isWordLike(segment)) {\r\n                result.push(segment);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _isWordLike(segment) {\r\n        if (segment.isWordLike) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nconst wordClassifierCache = new _base_common_map_js__WEBPACK_IMPORTED_MODULE_0__.LRUCache(10);\r\nfunction getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\r\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\r\n    let result = wordClassifierCache.get(key);\r\n    if (!result) {\r\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\r\n        wordClassifierCache.set(key, result);\r\n    }\r\n    return result;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3dvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDtBQUNRO0FBQ3hELHNDQUFzQyx3RUFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUscUJBQXFCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBUTtBQUNqQztBQUNQLG1CQUFtQixlQUFlLEdBQUcsK0JBQStCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS93b3JkQ2hhcmFjdGVyQ2xhc3NpZmllci5qcz81NjRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBMUlVDYWNoZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL21hcC5qcyc7XHJcbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xyXG5leHBvcnQgY2xhc3MgV29yZENoYXJhY3RlckNsYXNzaWZpZXIgZXh0ZW5kcyBDaGFyYWN0ZXJDbGFzc2lmaWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdvcmRTZXBhcmF0b3JzLCBpbnRsU2VnbWVudGVyTG9jYWxlcykge1xyXG4gICAgICAgIHN1cGVyKDAgLyogV29yZENoYXJhY3RlckNsYXNzLlJlZ3VsYXIgKi8pO1xyXG4gICAgICAgIHRoaXMuX3NlZ21lbnRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkTGluZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkU2VnbWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmludGxTZWdtZW50ZXJMb2NhbGVzID0gaW50bFNlZ21lbnRlckxvY2FsZXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50bFNlZ21lbnRlckxvY2FsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIodGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcywgeyBncmFudWxhcml0eTogJ3dvcmQnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VnbWVudGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHdvcmRTZXBhcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KHdvcmRTZXBhcmF0b3JzLmNoYXJDb2RlQXQoaSksIDIgLyogV29yZENoYXJhY3RlckNsYXNzLldvcmRTZXBhcmF0b3IgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldCgzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLywgMSAvKiBXb3JkQ2hhcmFjdGVyQ2xhc3MuV2hpdGVzcGFjZSAqLyk7XHJcbiAgICAgICAgdGhpcy5zZXQoOSAvKiBDaGFyQ29kZS5UYWIgKi8sIDEgLyogV29yZENoYXJhY3RlckNsYXNzLldoaXRlc3BhY2UgKi8pO1xyXG4gICAgfVxyXG4gICAgZmluZFByZXZJbnRsV29yZEJlZm9yZU9yQXRPZmZzZXQobGluZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHRoaXMuX2dldEludGxTZWdtZW50ZXJXb3Jkc09uTGluZShsaW5lKSkge1xyXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pbmRleCA+IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FuZGlkYXRlID0gc2VnbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcclxuICAgIH1cclxuICAgIGZpbmROZXh0SW50bFdvcmRBdE9yQWZ0ZXJPZmZzZXQobGluZUNvbnRlbnQsIG9mZnNldCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiB0aGlzLl9nZXRJbnRsU2VnbWVudGVyV29yZHNPbkxpbmUobGluZUNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmluZGV4IDwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBfZ2V0SW50bFNlZ21lbnRlcldvcmRzT25MaW5lKGxpbmUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3NlZ21lbnRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBsaW5lIGhhcyBjaGFuZ2VkIGZyb20gdGhlIHByZXZpb3VzIGNhbGxcclxuICAgICAgICBpZiAodGhpcy5fY2FjaGVkTGluZSA9PT0gbGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2VnbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FjaGUgd2l0aCB0aGUgbmV3IGxpbmVcclxuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lID0gbGluZTtcclxuICAgICAgICB0aGlzLl9jYWNoZWRTZWdtZW50cyA9IHRoaXMuX2ZpbHRlcldvcmRTZWdtZW50cyh0aGlzLl9zZWdtZW50ZXIuc2VnbWVudChsaW5lKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNlZ21lbnRzO1xyXG4gICAgfVxyXG4gICAgX2ZpbHRlcldvcmRTZWdtZW50cyhzZWdtZW50cykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNXb3JkTGlrZShzZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIF9pc1dvcmRMaWtlKHNlZ21lbnQpIHtcclxuICAgICAgICBpZiAoc2VnbWVudC5pc1dvcmRMaWtlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgd29yZENsYXNzaWZpZXJDYWNoZSA9IG5ldyBMUlVDYWNoZSgxMCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBGb3JXb3JkU2VwYXJhdG9ycyh3b3JkU2VwYXJhdG9ycywgaW50bFNlZ21lbnRlckxvY2FsZXMpIHtcclxuICAgIGNvbnN0IGtleSA9IGAke3dvcmRTZXBhcmF0b3JzfS8ke2ludGxTZWdtZW50ZXJMb2NhbGVzLmpvaW4oJywnKX1gO1xyXG4gICAgbGV0IHJlc3VsdCA9IHdvcmRDbGFzc2lmaWVyQ2FjaGUuZ2V0KGtleSk7XHJcbiAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBXb3JkQ2hhcmFjdGVyQ2xhc3NpZmllcih3b3JkU2VwYXJhdG9ycywgaW50bFNlZ21lbnRlckxvY2FsZXMpO1xyXG4gICAgICAgIHdvcmRDbGFzc2lmaWVyQ2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_WORD_REGEXP: () => (/* binding */ DEFAULT_WORD_REGEXP),\n/* harmony export */   USUAL_WORD_SEPARATORS: () => (/* binding */ USUAL_WORD_SEPARATORS),\n/* harmony export */   ensureValidWordDefinition: () => (/* binding */ ensureValidWordDefinition),\n/* harmony export */   getWordAtText: () => (/* binding */ getWordAtText)\n/* harmony export */ });\n/* harmony import */ var _base_common_iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/iterator.js */ \"./node_modules/monaco-editor/esm/vs/base/common/iterator.js\");\n/* harmony import */ var _base_common_linkedList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/linkedList.js */ \"./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nconst USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords = '') {\r\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (const sep of USUAL_WORD_SEPARATORS) {\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nconst DEFAULT_WORD_REGEXP = createWordRegExp();\r\nfunction ensureValidWordDefinition(wordDefinition) {\r\n    let result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            let flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nconst _defaultConfig = new _base_common_linkedList_js__WEBPACK_IMPORTED_MODULE_1__.LinkedList();\r\n_defaultConfig.unshift({\r\n    maxLen: 1000,\r\n    windowSize: 15,\r\n    timeBudget: 150\r\n});\r\nfunction getWordAtText(column, wordDefinition, text, textOffset, config) {\r\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\r\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\r\n    if (!config) {\r\n        config = _base_common_iterator_js__WEBPACK_IMPORTED_MODULE_0__.Iterable.first(_defaultConfig);\r\n    }\r\n    if (text.length > config.maxLen) {\r\n        // don't throw strings that long at the regexp\r\n        // but use a sub-string in which a word must occur\r\n        let start = column - config.maxLen / 2;\r\n        if (start < 0) {\r\n            start = 0;\r\n        }\r\n        else {\r\n            textOffset += start;\r\n        }\r\n        text = text.substring(start, column + config.maxLen / 2);\r\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\r\n    }\r\n    const t1 = Date.now();\r\n    const pos = column - 1 - textOffset;\r\n    let prevRegexIndex = -1;\r\n    let match = null;\r\n    for (let i = 1;; i++) {\r\n        // check time budget\r\n        if (Date.now() - t1 >= config.timeBudget) {\r\n            break;\r\n        }\r\n        // reset the index at which the regexp should start matching, also know where it\r\n        // should stop so that subsequent search don't repeat previous searches\r\n        const regexIndex = pos - config.windowSize * i;\r\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\r\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\r\n        if (!thisMatch && match) {\r\n            // stop: we have something\r\n            break;\r\n        }\r\n        match = thisMatch;\r\n        // stop: searched at start\r\n        if (regexIndex <= 0) {\r\n            break;\r\n        }\r\n        prevRegexIndex = regexIndex;\r\n    }\r\n    if (match) {\r\n        const result = {\r\n            word: match[0],\r\n            startColumn: textOffset + 1 + match.index,\r\n            endColumn: textOffset + 1 + match.index + match[0].length\r\n        };\r\n        wordDefinition.lastIndex = 0;\r\n        return result;\r\n    }\r\n    return null;\r\n}\r\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\r\n    let match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        const matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return match;\r\n        }\r\n        else if (stopPos > 0 && matchIndex > stopPos) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3dvcmRIZWxwZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFDSTtBQUN6RCxnREFBZ0QsRUFBRSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSSxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS93b3JkSGVscGVyLmpzPzg3OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IEl0ZXJhYmxlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vaXRlcmF0b3IuanMnO1xyXG5pbXBvcnQgeyBMaW5rZWRMaXN0IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcyc7XHJcbmV4cG9ydCBjb25zdCBVU1VBTF9XT1JEX1NFUEFSQVRPUlMgPSAnYH4hQCMkJV4mKigpLT0rW3tdfVxcXFx8OzpcXCdcIiwuPD4vPyc7XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSB3b3JkIGRlZmluaXRpb24gcmVndWxhciBleHByZXNzaW9uIGJhc2VkIG9uIGRlZmF1bHQgd29yZCBzZXBhcmF0b3JzLlxyXG4gKiBPcHRpb25hbGx5IHByb3ZpZGUgYWxsb3dlZCBzZXBhcmF0b3JzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHdvcmRzLlxyXG4gKlxyXG4gKiBUaGUgZGVmYXVsdCB3b3VsZCBsb29rIGxpa2UgdGhpczpcclxuICogLygtP1xcZCpcXC5cXGRcXHcqKXwoW15cXGBcXH5cXCFcXEBcXCNcXCRcXCVcXF5cXCZcXCpcXChcXClcXC1cXD1cXCtcXFtcXHtcXF1cXH1cXFxcXFx8XFw7XFw6XFwnXFxcIlxcLFxcLlxcPFxcPlxcL1xcP1xcc10rKS9nXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXb3JkUmVnRXhwKGFsbG93SW5Xb3JkcyA9ICcnKSB7XHJcbiAgICBsZXQgc291cmNlID0gJygtP1xcXFxkKlxcXFwuXFxcXGRcXFxcdyopfChbXic7XHJcbiAgICBmb3IgKGNvbnN0IHNlcCBvZiBVU1VBTF9XT1JEX1NFUEFSQVRPUlMpIHtcclxuICAgICAgICBpZiAoYWxsb3dJbldvcmRzLmluZGV4T2Yoc2VwKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2UgKz0gJ1xcXFwnICsgc2VwO1xyXG4gICAgfVxyXG4gICAgc291cmNlICs9ICdcXFxcc10rKSc7XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsICdnJyk7XHJcbn1cclxuLy8gY2F0Y2hlcyBudW1iZXJzIChpbmNsdWRpbmcgZmxvYXRpbmcgbnVtYmVycykgaW4gdGhlIGZpcnN0IGdyb3VwLCBhbmQgYWxwaGFudW0gaW4gdGhlIHNlY29uZFxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9XT1JEX1JFR0VYUCA9IGNyZWF0ZVdvcmRSZWdFeHAoKTtcclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVZhbGlkV29yZERlZmluaXRpb24od29yZERlZmluaXRpb24pIHtcclxuICAgIGxldCByZXN1bHQgPSBERUZBVUxUX1dPUkRfUkVHRVhQO1xyXG4gICAgaWYgKHdvcmREZWZpbml0aW9uICYmICh3b3JkRGVmaW5pdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcclxuICAgICAgICBpZiAoIXdvcmREZWZpbml0aW9uLmdsb2JhbCkge1xyXG4gICAgICAgICAgICBsZXQgZmxhZ3MgPSAnZyc7XHJcbiAgICAgICAgICAgIGlmICh3b3JkRGVmaW5pdGlvbi5pZ25vcmVDYXNlKSB7XHJcbiAgICAgICAgICAgICAgICBmbGFncyArPSAnaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLm11bHRpbGluZSkge1xyXG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ20nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh3b3JkRGVmaW5pdGlvbi51bmljb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJlZ0V4cCh3b3JkRGVmaW5pdGlvbi5zb3VyY2UsIGZsYWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHdvcmREZWZpbml0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSAwO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBfZGVmYXVsdENvbmZpZyA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbl9kZWZhdWx0Q29uZmlnLnVuc2hpZnQoe1xyXG4gICAgbWF4TGVuOiAxMDAwLFxyXG4gICAgd2luZG93U2l6ZTogMTUsXHJcbiAgICB0aW1lQnVkZ2V0OiAxNTBcclxufSk7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JkQXRUZXh0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQsIGNvbmZpZykge1xyXG4gICAgLy8gRW5zdXJlIHRoZSByZWdleCBoYXMgdGhlICdnJyBmbGFnLCBvdGhlcndpc2UgdGhpcyB3aWxsIGxvb3AgZm9yZXZlclxyXG4gICAgd29yZERlZmluaXRpb24gPSBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKTtcclxuICAgIGlmICghY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnID0gSXRlcmFibGUuZmlyc3QoX2RlZmF1bHRDb25maWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRleHQubGVuZ3RoID4gY29uZmlnLm1heExlbikge1xyXG4gICAgICAgIC8vIGRvbid0IHRocm93IHN0cmluZ3MgdGhhdCBsb25nIGF0IHRoZSByZWdleHBcclxuICAgICAgICAvLyBidXQgdXNlIGEgc3ViLXN0cmluZyBpbiB3aGljaCBhIHdvcmQgbXVzdCBvY2N1clxyXG4gICAgICAgIGxldCBzdGFydCA9IGNvbHVtbiAtIGNvbmZpZy5tYXhMZW4gLyAyO1xyXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcclxuICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dE9mZnNldCArPSBzdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBjb2x1bW4gKyBjb25maWcubWF4TGVuIC8gMik7XHJcbiAgICAgICAgcmV0dXJuIGdldFdvcmRBdFRleHQoY29sdW1uLCB3b3JkRGVmaW5pdGlvbiwgdGV4dCwgdGV4dE9mZnNldCwgY29uZmlnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHQxID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHBvcyA9IGNvbHVtbiAtIDEgLSB0ZXh0T2Zmc2V0O1xyXG4gICAgbGV0IHByZXZSZWdleEluZGV4ID0gLTE7XHJcbiAgICBsZXQgbWF0Y2ggPSBudWxsO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7OyBpKyspIHtcclxuICAgICAgICAvLyBjaGVjayB0aW1lIGJ1ZGdldFxyXG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdDEgPj0gY29uZmlnLnRpbWVCdWRnZXQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBpbmRleCBhdCB3aGljaCB0aGUgcmVnZXhwIHNob3VsZCBzdGFydCBtYXRjaGluZywgYWxzbyBrbm93IHdoZXJlIGl0XHJcbiAgICAgICAgLy8gc2hvdWxkIHN0b3Agc28gdGhhdCBzdWJzZXF1ZW50IHNlYXJjaCBkb24ndCByZXBlYXQgcHJldmlvdXMgc2VhcmNoZXNcclxuICAgICAgICBjb25zdCByZWdleEluZGV4ID0gcG9zIC0gY29uZmlnLndpbmRvd1NpemUgKiBpO1xyXG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IE1hdGgubWF4KDAsIHJlZ2V4SW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNNYXRjaCA9IF9maW5kUmVnZXhNYXRjaEVuY2xvc2luZ1Bvc2l0aW9uKHdvcmREZWZpbml0aW9uLCB0ZXh0LCBwb3MsIHByZXZSZWdleEluZGV4KTtcclxuICAgICAgICBpZiAoIXRoaXNNYXRjaCAmJiBtYXRjaCkge1xyXG4gICAgICAgICAgICAvLyBzdG9wOiB3ZSBoYXZlIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0Y2ggPSB0aGlzTWF0Y2g7XHJcbiAgICAgICAgLy8gc3RvcDogc2VhcmNoZWQgYXQgc3RhcnRcclxuICAgICAgICBpZiAocmVnZXhJbmRleCA8PSAwKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2UmVnZXhJbmRleCA9IHJlZ2V4SW5kZXg7XHJcbiAgICB9XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHdvcmQ6IG1hdGNoWzBdLFxyXG4gICAgICAgICAgICBzdGFydENvbHVtbjogdGV4dE9mZnNldCArIDEgKyBtYXRjaC5pbmRleCxcclxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXHJcbiAgICAgICAgfTtcclxuICAgICAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBzdG9wUG9zKSB7XHJcbiAgICBsZXQgbWF0Y2g7XHJcbiAgICB3aGlsZSAobWF0Y2ggPSB3b3JkRGVmaW5pdGlvbi5leGVjKHRleHQpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XHJcbiAgICAgICAgaWYgKG1hdGNoSW5kZXggPD0gcG9zICYmIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA+PSBwb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdG9wUG9zID4gMCAmJiBtYXRjaEluZGV4ID4gc3RvcFBvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTimeout: () => (/* binding */ DateTimeout),\n/* harmony export */   DiffAlgorithmResult: () => (/* binding */ DiffAlgorithmResult),\n/* harmony export */   InfiniteTimeout: () => (/* binding */ InfiniteTimeout),\n/* harmony export */   OffsetPair: () => (/* binding */ OffsetPair),\n/* harmony export */   SequenceDiff: () => (/* binding */ SequenceDiff)\n/* harmony export */ });\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../base/common/arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../base/common/errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nclass DiffAlgorithmResult {\r\n    static trivial(seq1, seq2) {\r\n        return new DiffAlgorithmResult([new SequenceDiff(_core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq1.length), _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq2.length))], false);\r\n    }\r\n    static trivialTimedOut(seq1, seq2) {\r\n        return new DiffAlgorithmResult([new SequenceDiff(_core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq1.length), _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange.ofLength(seq2.length))], true);\r\n    }\r\n    constructor(diffs, \r\n    /**\r\n     * Indicates if the time out was reached.\r\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\r\n     */\r\n    hitTimeout) {\r\n        this.diffs = diffs;\r\n        this.hitTimeout = hitTimeout;\r\n    }\r\n}\r\nclass SequenceDiff {\r\n    static invert(sequenceDiffs, doc1Length) {\r\n        const result = [];\r\n        (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.forEachAdjacent)(sequenceDiffs, (a, b) => {\r\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\r\n        });\r\n        return result;\r\n    }\r\n    static fromOffsetPairs(start, endExclusive) {\r\n        return new SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange(start.offset1, endExclusive.offset1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_2__.OffsetRange(start.offset2, endExclusive.offset2));\r\n    }\r\n    constructor(seq1Range, seq2Range) {\r\n        this.seq1Range = seq1Range;\r\n        this.seq2Range = seq2Range;\r\n    }\r\n    swap() {\r\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\r\n    }\r\n    toString() {\r\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\r\n    }\r\n    join(other) {\r\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\r\n    }\r\n    delta(offset) {\r\n        if (offset === 0) {\r\n            return this;\r\n        }\r\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\r\n    }\r\n    deltaStart(offset) {\r\n        if (offset === 0) {\r\n            return this;\r\n        }\r\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\r\n    }\r\n    deltaEnd(offset) {\r\n        if (offset === 0) {\r\n            return this;\r\n        }\r\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\r\n    }\r\n    intersect(other) {\r\n        const i1 = this.seq1Range.intersect(other.seq1Range);\r\n        const i2 = this.seq2Range.intersect(other.seq2Range);\r\n        if (!i1 || !i2) {\r\n            return undefined;\r\n        }\r\n        return new SequenceDiff(i1, i2);\r\n    }\r\n    getStarts() {\r\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\r\n    }\r\n    getEndExclusives() {\r\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\r\n    }\r\n}\r\nclass OffsetPair {\r\n    constructor(offset1, offset2) {\r\n        this.offset1 = offset1;\r\n        this.offset2 = offset2;\r\n    }\r\n    toString() {\r\n        return `${this.offset1} <-> ${this.offset2}`;\r\n    }\r\n    delta(offset) {\r\n        if (offset === 0) {\r\n            return this;\r\n        }\r\n        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\r\n    }\r\n    equals(other) {\r\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\r\n    }\r\n}\r\nOffsetPair.zero = new OffsetPair(0, 0);\r\nOffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\nclass InfiniteTimeout {\r\n    isValid() {\r\n        return true;\r\n    }\r\n}\r\nInfiniteTimeout.instance = new InfiniteTimeout();\r\nclass DateTimeout {\r\n    constructor(timeout) {\r\n        this.timeout = timeout;\r\n        this.startTime = Date.now();\r\n        this.valid = true;\r\n        if (timeout <= 0) {\r\n            throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('timeout must be positive');\r\n        }\r\n    }\r\n    // Recommendation: Set a log-point `{this.disable()}` in the body\r\n    isValid() {\r\n        const valid = Date.now() - this.startTime < this.timeout;\r\n        if (!valid && this.valid) {\r\n            this.valid = false; // timeout reached\r\n            // eslint-disable-next-line no-debugger\r\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\r\n        }\r\n        return this.valid;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9hbGdvcml0aG1zL2RpZmZBbGdvcml0aG0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RTtBQUNHO0FBQ2Y7QUFDcEQ7QUFDUDtBQUNBLHlEQUF5RCw2REFBVyx3QkFBd0IsNkRBQVc7QUFDdkc7QUFDQTtBQUNBLHlEQUF5RCw2REFBVyx3QkFBd0IsNkRBQVc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsdUVBQWU7QUFDdkI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZEQUFXLDJDQUEyQyw2REFBVztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLE1BQU0sZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLE1BQU0sYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBa0I7QUFDeEM7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2FsZ29yaXRobXMvZGlmZkFsZ29yaXRobS5qcz80ZTk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBmb3JFYWNoQWRqYWNlbnQgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xyXG5pbXBvcnQgeyBCdWdJbmRpY2F0aW5nRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xyXG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xyXG5leHBvcnQgY2xhc3MgRGlmZkFsZ29yaXRobVJlc3VsdCB7XHJcbiAgICBzdGF0aWMgdHJpdmlhbChzZXExLCBzZXEyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KFtuZXcgU2VxdWVuY2VEaWZmKE9mZnNldFJhbmdlLm9mTGVuZ3RoKHNlcTEubGVuZ3RoKSwgT2Zmc2V0UmFuZ2Uub2ZMZW5ndGgoc2VxMi5sZW5ndGgpKV0sIGZhbHNlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0cml2aWFsVGltZWRPdXQoc2VxMSwgc2VxMikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGlmZkFsZ29yaXRobVJlc3VsdChbbmV3IFNlcXVlbmNlRGlmZihPZmZzZXRSYW5nZS5vZkxlbmd0aChzZXExLmxlbmd0aCksIE9mZnNldFJhbmdlLm9mTGVuZ3RoKHNlcTIubGVuZ3RoKSldLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKGRpZmZzLCBcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSB0aW1lIG91dCB3YXMgcmVhY2hlZC5cclxuICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGRpZmZzIG1pZ2h0IGJlIGFuIGFwcHJveGltYXRpb24gYW5kIHRoZSB1c2VyIHNob3VsZCBiZSBhc2tlZCB0byByZXJ1biB0aGUgZGlmZiB3aXRoIG1vcmUgdGltZS5cclxuICAgICAqL1xyXG4gICAgaGl0VGltZW91dCkge1xyXG4gICAgICAgIHRoaXMuZGlmZnMgPSBkaWZmcztcclxuICAgICAgICB0aGlzLmhpdFRpbWVvdXQgPSBoaXRUaW1lb3V0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBTZXF1ZW5jZURpZmYge1xyXG4gICAgc3RhdGljIGludmVydChzZXF1ZW5jZURpZmZzLCBkb2MxTGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yRWFjaEFkamFjZW50KHNlcXVlbmNlRGlmZnMsIChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNlcXVlbmNlRGlmZi5mcm9tT2Zmc2V0UGFpcnMoYSA/IGEuZ2V0RW5kRXhjbHVzaXZlcygpIDogT2Zmc2V0UGFpci56ZXJvLCBiID8gYi5nZXRTdGFydHMoKSA6IG5ldyBPZmZzZXRQYWlyKGRvYzFMZW5ndGgsIChhID8gYS5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlIC0gYS5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlIDogMCkgKyBkb2MxTGVuZ3RoKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbU9mZnNldFBhaXJzKHN0YXJ0LCBlbmRFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlRGlmZihuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQub2Zmc2V0MSwgZW5kRXhjbHVzaXZlLm9mZnNldDEpLCBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQub2Zmc2V0MiwgZW5kRXhjbHVzaXZlLm9mZnNldDIpKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHNlcTFSYW5nZSwgc2VxMlJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5zZXExUmFuZ2UgPSBzZXExUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5zZXEyUmFuZ2UgPSBzZXEyUmFuZ2U7XHJcbiAgICB9XHJcbiAgICBzd2FwKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMlJhbmdlLCB0aGlzLnNlcTFSYW5nZSk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5zZXExUmFuZ2V9IDwtPiAke3RoaXMuc2VxMlJhbmdlfWA7XHJcbiAgICB9XHJcbiAgICBqb2luKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZURpZmYodGhpcy5zZXExUmFuZ2Uuam9pbihvdGhlci5zZXExUmFuZ2UpLCB0aGlzLnNlcTJSYW5nZS5qb2luKG90aGVyLnNlcTJSYW5nZSkpO1xyXG4gICAgfVxyXG4gICAgZGVsdGEob2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZURpZmYodGhpcy5zZXExUmFuZ2UuZGVsdGEob2Zmc2V0KSwgdGhpcy5zZXEyUmFuZ2UuZGVsdGEob2Zmc2V0KSk7XHJcbiAgICB9XHJcbiAgICBkZWx0YVN0YXJ0KG9mZnNldCkge1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMVJhbmdlLmRlbHRhU3RhcnQob2Zmc2V0KSwgdGhpcy5zZXEyUmFuZ2UuZGVsdGFTdGFydChvZmZzZXQpKTtcclxuICAgIH1cclxuICAgIGRlbHRhRW5kKG9mZnNldCkge1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMVJhbmdlLmRlbHRhRW5kKG9mZnNldCksIHRoaXMuc2VxMlJhbmdlLmRlbHRhRW5kKG9mZnNldCkpO1xyXG4gICAgfVxyXG4gICAgaW50ZXJzZWN0KG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgaTEgPSB0aGlzLnNlcTFSYW5nZS5pbnRlcnNlY3Qob3RoZXIuc2VxMVJhbmdlKTtcclxuICAgICAgICBjb25zdCBpMiA9IHRoaXMuc2VxMlJhbmdlLmludGVyc2VjdChvdGhlci5zZXEyUmFuZ2UpO1xyXG4gICAgICAgIGlmICghaTEgfHwgIWkyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKGkxLCBpMik7XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRQYWlyKHRoaXMuc2VxMVJhbmdlLnN0YXJ0LCB0aGlzLnNlcTJSYW5nZS5zdGFydCk7XHJcbiAgICB9XHJcbiAgICBnZXRFbmRFeGNsdXNpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UGFpcih0aGlzLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUsIHRoaXMuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE9mZnNldFBhaXIge1xyXG4gICAgY29uc3RydWN0b3Iob2Zmc2V0MSwgb2Zmc2V0Mikge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0MSA9IG9mZnNldDE7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQyID0gb2Zmc2V0MjtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9mZnNldDF9IDwtPiAke3RoaXMub2Zmc2V0Mn1gO1xyXG4gICAgfVxyXG4gICAgZGVsdGEob2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRQYWlyKHRoaXMub2Zmc2V0MSArIG9mZnNldCwgdGhpcy5vZmZzZXQyICsgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldDEgPT09IG90aGVyLm9mZnNldDEgJiYgdGhpcy5vZmZzZXQyID09PSBvdGhlci5vZmZzZXQyO1xyXG4gICAgfVxyXG59XHJcbk9mZnNldFBhaXIuemVybyA9IG5ldyBPZmZzZXRQYWlyKDAsIDApO1xyXG5PZmZzZXRQYWlyLm1heCA9IG5ldyBPZmZzZXRQYWlyKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XHJcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVRpbWVvdXQge1xyXG4gICAgaXNWYWxpZCgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5JbmZpbml0ZVRpbWVvdXQuaW5zdGFuY2UgPSBuZXcgSW5maW5pdGVUaW1lb3V0KCk7XHJcbmV4cG9ydCBjbGFzcyBEYXRlVGltZW91dCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aW1lb3V0KSB7XHJcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCd0aW1lb3V0IG11c3QgYmUgcG9zaXRpdmUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZWNvbW1lbmRhdGlvbjogU2V0IGEgbG9nLXBvaW50IGB7dGhpcy5kaXNhYmxlKCl9YCBpbiB0aGUgYm9keVxyXG4gICAgaXNWYWxpZCgpIHtcclxuICAgICAgICBjb25zdCB2YWxpZCA9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZSA8IHRoaXMudGltZW91dDtcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlOyAvLyB0aW1lb3V0IHJlYWNoZWRcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXHJcbiAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBXQVJOSU5HOiBNb3N0IGxpa2VseSBkZWJ1Z2dpbmcgY2F1c2VkIHRoZSB0aW1lb3V0LiBDYWxsIGB0aGlzLmRpc2FibGUoKWAgdG8gY29udGludWUgd2l0aG91dCB0aW1pbmcgb3V0LlxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DynamicProgrammingDiffing: () => (/* binding */ DynamicProgrammingDiffing)\n/* harmony export */ });\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n/**\r\n * A O(MN) diffing algorithm that supports a score function.\r\n * The algorithm can be improved by processing the 2d array diagonally.\r\n*/\r\nclass DynamicProgrammingDiffing {\r\n    compute(sequence1, sequence2, timeout = _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.InfiniteTimeout.instance, equalityScore) {\r\n        if (sequence1.length === 0 || sequence2.length === 0) {\r\n            return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivial(sequence1, sequence2);\r\n        }\r\n        /**\r\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\r\n         */\r\n        const lcsLengths = new _utils_js__WEBPACK_IMPORTED_MODULE_2__.Array2D(sequence1.length, sequence2.length);\r\n        const directions = new _utils_js__WEBPACK_IMPORTED_MODULE_2__.Array2D(sequence1.length, sequence2.length);\r\n        const lengths = new _utils_js__WEBPACK_IMPORTED_MODULE_2__.Array2D(sequence1.length, sequence2.length);\r\n        // ==== Initializing lcsLengths ====\r\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\r\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\r\n                if (!timeout.isValid()) {\r\n                    return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\r\n                }\r\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\r\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\r\n                let extendedSeqScore;\r\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\r\n                    if (s1 === 0 || s2 === 0) {\r\n                        extendedSeqScore = 0;\r\n                    }\r\n                    else {\r\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\r\n                    }\r\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\r\n                        // Prefer consecutive diagonals\r\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\r\n                    }\r\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\r\n                }\r\n                else {\r\n                    extendedSeqScore = -1;\r\n                }\r\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\r\n                if (newValue === extendedSeqScore) {\r\n                    // Prefer diagonals\r\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\r\n                    lengths.set(s1, s2, prevLen + 1);\r\n                    directions.set(s1, s2, 3);\r\n                }\r\n                else if (newValue === horizontalLen) {\r\n                    lengths.set(s1, s2, 0);\r\n                    directions.set(s1, s2, 1);\r\n                }\r\n                else if (newValue === verticalLen) {\r\n                    lengths.set(s1, s2, 0);\r\n                    directions.set(s1, s2, 2);\r\n                }\r\n                lcsLengths.set(s1, s2, newValue);\r\n            }\r\n        }\r\n        // ==== Backtracking ====\r\n        const result = [];\r\n        let lastAligningPosS1 = sequence1.length;\r\n        let lastAligningPosS2 = sequence2.length;\r\n        function reportDecreasingAligningPositions(s1, s2) {\r\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\r\n                result.push(new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(s1 + 1, lastAligningPosS1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(s2 + 1, lastAligningPosS2)));\r\n            }\r\n            lastAligningPosS1 = s1;\r\n            lastAligningPosS2 = s2;\r\n        }\r\n        let s1 = sequence1.length - 1;\r\n        let s2 = sequence2.length - 1;\r\n        while (s1 >= 0 && s2 >= 0) {\r\n            if (directions.get(s1, s2) === 3) {\r\n                reportDecreasingAligningPositions(s1, s2);\r\n                s1--;\r\n                s2--;\r\n            }\r\n            else {\r\n                if (directions.get(s1, s2) === 1) {\r\n                    s1--;\r\n                }\r\n                else {\r\n                    s2--;\r\n                }\r\n            }\r\n        }\r\n        reportDecreasingAligningPositions(-1, -1);\r\n        result.reverse();\r\n        return new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult(result, false);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9hbGdvcml0aG1zL2R5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEO0FBQzZCO0FBQ2xEO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0Q0FBNEMsOERBQWU7QUFDM0Q7QUFDQSxtQkFBbUIsa0VBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhDQUFPO0FBQ3RDLCtCQUErQiw4Q0FBTztBQUN0Qyw0QkFBNEIsOENBQU87QUFDbkM7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hELDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQSwyQkFBMkIsa0VBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVksS0FBSyw2REFBVyxpQ0FBaUMsNkRBQVc7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBbUI7QUFDdEM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2FsZ29yaXRobXMvZHluYW1pY1Byb2dyYW1taW5nRGlmZmluZy5qcz8xZWI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBTZXF1ZW5jZURpZmYsIEluZmluaXRlVGltZW91dCwgRGlmZkFsZ29yaXRobVJlc3VsdCB9IGZyb20gJy4vZGlmZkFsZ29yaXRobS5qcyc7XHJcbmltcG9ydCB7IEFycmF5MkQgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcbi8qKlxyXG4gKiBBIE8oTU4pIGRpZmZpbmcgYWxnb3JpdGhtIHRoYXQgc3VwcG9ydHMgYSBzY29yZSBmdW5jdGlvbi5cclxuICogVGhlIGFsZ29yaXRobSBjYW4gYmUgaW1wcm92ZWQgYnkgcHJvY2Vzc2luZyB0aGUgMmQgYXJyYXkgZGlhZ29uYWxseS5cclxuKi9cclxuZXhwb3J0IGNsYXNzIER5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcge1xyXG4gICAgY29tcHV0ZShzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgdGltZW91dCA9IEluZmluaXRlVGltZW91dC5pbnN0YW5jZSwgZXF1YWxpdHlTY29yZSkge1xyXG4gICAgICAgIGlmIChzZXF1ZW5jZTEubGVuZ3RoID09PSAwIHx8IHNlcXVlbmNlMi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIERpZmZBbGdvcml0aG1SZXN1bHQudHJpdmlhbChzZXF1ZW5jZTEsIHNlcXVlbmNlMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGxjc0xlbmd0aHMuZ2V0KGksIGopOiBMZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHN1YnNlcXVlbmNlIG9mIHNlcXVlbmNlMS5zdWJzdHJpbmcoMCwgaSArIDEpIGFuZCBzZXF1ZW5jZTIuc3Vic3RyaW5nKDAsIGogKyAxKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBsY3NMZW5ndGhzID0gbmV3IEFycmF5MkQoc2VxdWVuY2UxLmxlbmd0aCwgc2VxdWVuY2UyLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9ucyA9IG5ldyBBcnJheTJEKHNlcXVlbmNlMS5sZW5ndGgsIHNlcXVlbmNlMi5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aHMgPSBuZXcgQXJyYXkyRChzZXF1ZW5jZTEubGVuZ3RoLCBzZXF1ZW5jZTIubGVuZ3RoKTtcclxuICAgICAgICAvLyA9PT09IEluaXRpYWxpemluZyBsY3NMZW5ndGhzID09PT1cclxuICAgICAgICBmb3IgKGxldCBzMSA9IDA7IHMxIDwgc2VxdWVuY2UxLmxlbmd0aDsgczErKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzMiA9IDA7IHMyIDwgc2VxdWVuY2UyLmxlbmd0aDsgczIrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWxUaW1lZE91dChzZXF1ZW5jZTEsIHNlcXVlbmNlMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsTGVuID0gczEgPT09IDAgPyAwIDogbGNzTGVuZ3Rocy5nZXQoczEgLSAxLCBzMik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aWNhbExlbiA9IHMyID09PSAwID8gMCA6IGxjc0xlbmd0aHMuZ2V0KHMxLCBzMiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuZGVkU2VxU2NvcmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UxLmdldEVsZW1lbnQoczEpID09PSBzZXF1ZW5jZTIuZ2V0RWxlbWVudChzMikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoczEgPT09IDAgfHwgczIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRTZXFTY29yZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlID0gbGNzTGVuZ3Rocy5nZXQoczEgLSAxLCBzMiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoczEgPiAwICYmIHMyID4gMCAmJiBkaXJlY3Rpb25zLmdldChzMSAtIDEsIHMyIC0gMSkgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmVyIGNvbnNlY3V0aXZlIGRpYWdvbmFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlICs9IGxlbmd0aHMuZ2V0KHMxIC0gMSwgczIgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRTZXFTY29yZSArPSAoZXF1YWxpdHlTY29yZSA/IGVxdWFsaXR5U2NvcmUoczEsIHMyKSA6IDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRTZXFTY29yZSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBNYXRoLm1heChob3Jpem9udGFsTGVuLCB2ZXJ0aWNhbExlbiwgZXh0ZW5kZWRTZXFTY29yZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IGV4dGVuZGVkU2VxU2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgZGlhZ29uYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkxlbiA9IHMxID4gMCAmJiBzMiA+IDAgPyBsZW5ndGhzLmdldChzMSAtIDEsIHMyIC0gMSkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aHMuc2V0KHMxLCBzMiwgcHJldkxlbiArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2V0KHMxLCBzMiwgMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA9PT0gaG9yaXpvbnRhbExlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aHMuc2V0KHMxLCBzMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9ucy5zZXQoczEsIHMyLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSB2ZXJ0aWNhbExlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aHMuc2V0KHMxLCBzMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9ucy5zZXQoczEsIHMyLCAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxjc0xlbmd0aHMuc2V0KHMxLCBzMiwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vID09PT0gQmFja3RyYWNraW5nID09PT1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzEgPSBzZXF1ZW5jZTEubGVuZ3RoO1xyXG4gICAgICAgIGxldCBsYXN0QWxpZ25pbmdQb3NTMiA9IHNlcXVlbmNlMi5sZW5ndGg7XHJcbiAgICAgICAgZnVuY3Rpb24gcmVwb3J0RGVjcmVhc2luZ0FsaWduaW5nUG9zaXRpb25zKHMxLCBzMikge1xyXG4gICAgICAgICAgICBpZiAoczEgKyAxICE9PSBsYXN0QWxpZ25pbmdQb3NTMSB8fCBzMiArIDEgIT09IGxhc3RBbGlnbmluZ1Bvc1MyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShzMSArIDEsIGxhc3RBbGlnbmluZ1Bvc1MxKSwgbmV3IE9mZnNldFJhbmdlKHMyICsgMSwgbGFzdEFsaWduaW5nUG9zUzIpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzEgPSBzMTtcclxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzIgPSBzMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHMxID0gc2VxdWVuY2UxLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgbGV0IHMyID0gc2VxdWVuY2UyLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgd2hpbGUgKHMxID49IDAgJiYgczIgPj0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9ucy5nZXQoczEsIHMyKSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgcmVwb3J0RGVjcmVhc2luZ0FsaWduaW5nUG9zaXRpb25zKHMxLCBzMik7XHJcbiAgICAgICAgICAgICAgICBzMS0tO1xyXG4gICAgICAgICAgICAgICAgczItLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zLmdldChzMSwgczIpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgczEtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHMyLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb3J0RGVjcmVhc2luZ0FsaWduaW5nUG9zaXRpb25zKC0xLCAtMSk7XHJcbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERpZmZBbGdvcml0aG1SZXN1bHQocmVzdWx0LCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MyersDiffAlgorithm: () => (/* binding */ MyersDiffAlgorithm)\n/* harmony export */ });\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n/**\r\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\r\n*/\r\nclass MyersDiffAlgorithm {\r\n    compute(seq1, seq2, timeout = _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.InfiniteTimeout.instance) {\r\n        // These are common special cases.\r\n        // The early return improves performance dramatically.\r\n        if (seq1.length === 0 || seq2.length === 0) {\r\n            return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivial(seq1, seq2);\r\n        }\r\n        const seqX = seq1; // Text on the x axis\r\n        const seqY = seq2; // Text on the y axis\r\n        function getXAfterSnake(x, y) {\r\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\r\n                x++;\r\n                y++;\r\n            }\r\n            return x;\r\n        }\r\n        let d = 0;\r\n        // V[k]: X value of longest d-line that ends in diagonal k.\r\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\r\n        // diagonal k: Set of points (x,y) with x-y = k.\r\n        // k=1 -> (1,0),(2,1)\r\n        const V = new FastInt32Array();\r\n        V.set(0, getXAfterSnake(0, 0));\r\n        const paths = new FastArrayNegativeIndices();\r\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\r\n        let k = 0;\r\n        loop: while (true) {\r\n            d++;\r\n            if (!timeout.isValid()) {\r\n                return _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\r\n            }\r\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\r\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\r\n            const upperBound = Math.min(d, seqX.length + (d % 2));\r\n            for (k = lowerBound; k <= upperBound; k += 2) {\r\n                let step = 0;\r\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\r\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\r\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\r\n                step++;\r\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\r\n                const y = x - k;\r\n                step++;\r\n                if (x > seqX.length || y > seqY.length) {\r\n                    // This diagonal is irrelevant for the result.\r\n                    // TODO: Don't pay the cost for this in the next iteration.\r\n                    continue;\r\n                }\r\n                const newMaxX = getXAfterSnake(x, y);\r\n                V.set(k, newMaxX);\r\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\r\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\r\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\r\n                    break loop;\r\n                }\r\n            }\r\n        }\r\n        let path = paths.get(k);\r\n        const result = [];\r\n        let lastAligningPosS1 = seqX.length;\r\n        let lastAligningPosS2 = seqY.length;\r\n        while (true) {\r\n            const endX = path ? path.x + path.length : 0;\r\n            const endY = path ? path.y + path.length : 0;\r\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\r\n                result.push(new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(endX, lastAligningPosS1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(endY, lastAligningPosS2)));\r\n            }\r\n            if (!path) {\r\n                break;\r\n            }\r\n            lastAligningPosS1 = path.x;\r\n            lastAligningPosS2 = path.y;\r\n            path = path.prev;\r\n        }\r\n        result.reverse();\r\n        return new _diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_1__.DiffAlgorithmResult(result, false);\r\n    }\r\n}\r\nclass SnakePath {\r\n    constructor(prev, x, y, length) {\r\n        this.prev = prev;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.length = length;\r\n    }\r\n}\r\n/**\r\n * An array that supports fast negative indices.\r\n*/\r\nclass FastInt32Array {\r\n    constructor() {\r\n        this.positiveArr = new Int32Array(10);\r\n        this.negativeArr = new Int32Array(10);\r\n    }\r\n    get(idx) {\r\n        if (idx < 0) {\r\n            idx = -idx - 1;\r\n            return this.negativeArr[idx];\r\n        }\r\n        else {\r\n            return this.positiveArr[idx];\r\n        }\r\n    }\r\n    set(idx, value) {\r\n        if (idx < 0) {\r\n            idx = -idx - 1;\r\n            if (idx >= this.negativeArr.length) {\r\n                const arr = this.negativeArr;\r\n                this.negativeArr = new Int32Array(arr.length * 2);\r\n                this.negativeArr.set(arr);\r\n            }\r\n            this.negativeArr[idx] = value;\r\n        }\r\n        else {\r\n            if (idx >= this.positiveArr.length) {\r\n                const arr = this.positiveArr;\r\n                this.positiveArr = new Int32Array(arr.length * 2);\r\n                this.positiveArr.set(arr);\r\n            }\r\n            this.positiveArr[idx] = value;\r\n        }\r\n    }\r\n}\r\n/**\r\n * An array that supports fast negative indices.\r\n*/\r\nclass FastArrayNegativeIndices {\r\n    constructor() {\r\n        this.positiveArr = [];\r\n        this.negativeArr = [];\r\n    }\r\n    get(idx) {\r\n        if (idx < 0) {\r\n            idx = -idx - 1;\r\n            return this.negativeArr[idx];\r\n        }\r\n        else {\r\n            return this.positiveArr[idx];\r\n        }\r\n    }\r\n    set(idx, value) {\r\n        if (idx < 0) {\r\n            idx = -idx - 1;\r\n            this.negativeArr[idx] = value;\r\n        }\r\n        else {\r\n            this.positiveArr[idx] = value;\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9hbGdvcml0aG1zL215ZXJzRGlmZkFsZ29yaXRobS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUM2QjtBQUN4RjtBQUNBO0FBQ0E7QUFDTztBQUNQLGtDQUFrQyw4REFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQW1CO0FBQ3RDO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtFQUFtQjtBQUMxQztBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0Usa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVksS0FBSyw2REFBVywrQkFBK0IsNkRBQVc7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvYWxnb3JpdGhtcy9teWVyc0RpZmZBbGdvcml0aG0uanM/NWVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcclxuaW1wb3J0IHsgRGlmZkFsZ29yaXRobVJlc3VsdCwgSW5maW5pdGVUaW1lb3V0LCBTZXF1ZW5jZURpZmYgfSBmcm9tICcuL2RpZmZBbGdvcml0aG0uanMnO1xyXG4vKipcclxuICogQW4gTyhORCkgZGlmZiBhbGdvcml0aG0gdGhhdCBoYXMgYSBxdWFkcmF0aWMgc3BhY2Ugd29yc3QtY2FzZSBjb21wbGV4aXR5LlxyXG4qL1xyXG5leHBvcnQgY2xhc3MgTXllcnNEaWZmQWxnb3JpdGhtIHtcclxuICAgIGNvbXB1dGUoc2VxMSwgc2VxMiwgdGltZW91dCA9IEluZmluaXRlVGltZW91dC5pbnN0YW5jZSkge1xyXG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb21tb24gc3BlY2lhbCBjYXNlcy5cclxuICAgICAgICAvLyBUaGUgZWFybHkgcmV0dXJuIGltcHJvdmVzIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseS5cclxuICAgICAgICBpZiAoc2VxMS5sZW5ndGggPT09IDAgfHwgc2VxMi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIERpZmZBbGdvcml0aG1SZXN1bHQudHJpdmlhbChzZXExLCBzZXEyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VxWCA9IHNlcTE7IC8vIFRleHQgb24gdGhlIHggYXhpc1xyXG4gICAgICAgIGNvbnN0IHNlcVkgPSBzZXEyOyAvLyBUZXh0IG9uIHRoZSB5IGF4aXNcclxuICAgICAgICBmdW5jdGlvbiBnZXRYQWZ0ZXJTbmFrZSh4LCB5KSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh4IDwgc2VxWC5sZW5ndGggJiYgeSA8IHNlcVkubGVuZ3RoICYmIHNlcVguZ2V0RWxlbWVudCh4KSA9PT0gc2VxWS5nZXRFbGVtZW50KHkpKSB7XHJcbiAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICB5Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkID0gMDtcclxuICAgICAgICAvLyBWW2tdOiBYIHZhbHVlIG9mIGxvbmdlc3QgZC1saW5lIHRoYXQgZW5kcyBpbiBkaWFnb25hbCBrLlxyXG4gICAgICAgIC8vIGQtbGluZTogcGF0aCBmcm9tICgwLDApIHRvICh4LHkpIHRoYXQgdXNlcyBleGFjdGx5IGQgbm9uLWRpYWdvbmFscy5cclxuICAgICAgICAvLyBkaWFnb25hbCBrOiBTZXQgb2YgcG9pbnRzICh4LHkpIHdpdGggeC15ID0gay5cclxuICAgICAgICAvLyBrPTEgLT4gKDEsMCksKDIsMSlcclxuICAgICAgICBjb25zdCBWID0gbmV3IEZhc3RJbnQzMkFycmF5KCk7XHJcbiAgICAgICAgVi5zZXQoMCwgZ2V0WEFmdGVyU25ha2UoMCwgMCkpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhzID0gbmV3IEZhc3RBcnJheU5lZ2F0aXZlSW5kaWNlcygpO1xyXG4gICAgICAgIHBhdGhzLnNldCgwLCBWLmdldCgwKSA9PT0gMCA/IG51bGwgOiBuZXcgU25ha2VQYXRoKG51bGwsIDAsIDAsIFYuZ2V0KDApKSk7XHJcbiAgICAgICAgbGV0IGsgPSAwO1xyXG4gICAgICAgIGxvb3A6IHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGQrKztcclxuICAgICAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpZmZBbGdvcml0aG1SZXN1bHQudHJpdmlhbFRpbWVkT3V0KHNlcVgsIHNlcVkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRoZSBwYXBlciBoYXMgYGZvciAoayA9IC1kOyBrIDw9IGQ7IGsgKz0gMilgLCBidXQgd2UgY2FuIGlnbm9yZSBkaWFnb25hbHMgdGhhdCBjYW5ub3QgaW5mbHVlbmNlIHRoZSByZXN1bHQuXHJcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSAtTWF0aC5taW4oZCwgc2VxWS5sZW5ndGggKyAoZCAlIDIpKTtcclxuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IE1hdGgubWluKGQsIHNlcVgubGVuZ3RoICsgKGQgJSAyKSk7XHJcbiAgICAgICAgICAgIGZvciAoayA9IGxvd2VyQm91bmQ7IGsgPD0gdXBwZXJCb3VuZDsgayArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIHRoZSBYIHZhbHVlcyBvZiAoZC0xKS1saW5lcyB0byBjb21wdXRlIFggdmFsdWUgb2YgdGhlIGxvbmdlc3QgZC1saW5lcy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFhvZkRMaW5lVG9wID0gayA9PT0gdXBwZXJCb3VuZCA/IC0xIDogVi5nZXQoayArIDEpOyAvLyBXZSB0YWtlIGEgdmVydGljYWwgbm9uLWRpYWdvbmFsIChhZGQgYSBzeW1ib2wgaW4gc2VxWClcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFhvZkRMaW5lTGVmdCA9IGsgPT09IGxvd2VyQm91bmQgPyAtMSA6IFYuZ2V0KGsgLSAxKSArIDE7IC8vIFdlIHRha2UgYSBob3Jpem9udGFsIG5vbi1kaWFnb25hbCAoKzEgeCkgKGRlbGV0ZSBhIHN5bWJvbCBpbiBzZXFYKVxyXG4gICAgICAgICAgICAgICAgc3RlcCsrO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKE1hdGgubWF4KG1heFhvZkRMaW5lVG9wLCBtYXhYb2ZETGluZUxlZnQpLCBzZXFYLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0geCAtIGs7XHJcbiAgICAgICAgICAgICAgICBzdGVwKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IHNlcVgubGVuZ3RoIHx8IHkgPiBzZXFZLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZGlhZ29uYWwgaXMgaXJyZWxldmFudCBmb3IgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBEb24ndCBwYXkgdGhlIGNvc3QgZm9yIHRoaXMgaW4gdGhlIG5leHQgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWF4WCA9IGdldFhBZnRlclNuYWtlKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgVi5zZXQoaywgbmV3TWF4WCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGF0aCA9IHggPT09IG1heFhvZkRMaW5lVG9wID8gcGF0aHMuZ2V0KGsgKyAxKSA6IHBhdGhzLmdldChrIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBwYXRocy5zZXQoaywgbmV3TWF4WCAhPT0geCA/IG5ldyBTbmFrZVBhdGgobGFzdFBhdGgsIHgsIHksIG5ld01heFggLSB4KSA6IGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChWLmdldChrKSA9PT0gc2VxWC5sZW5ndGggJiYgVi5nZXQoaykgLSBrID09PSBzZXFZLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhdGggPSBwYXRocy5nZXQoayk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGxhc3RBbGlnbmluZ1Bvc1MxID0gc2VxWC5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGxhc3RBbGlnbmluZ1Bvc1MyID0gc2VxWS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kWCA9IHBhdGggPyBwYXRoLnggKyBwYXRoLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZFkgPSBwYXRoID8gcGF0aC55ICsgcGF0aC5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICBpZiAoZW5kWCAhPT0gbGFzdEFsaWduaW5nUG9zUzEgfHwgZW5kWSAhPT0gbGFzdEFsaWduaW5nUG9zUzIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTZXF1ZW5jZURpZmYobmV3IE9mZnNldFJhbmdlKGVuZFgsIGxhc3RBbGlnbmluZ1Bvc1MxKSwgbmV3IE9mZnNldFJhbmdlKGVuZFksIGxhc3RBbGlnbmluZ1Bvc1MyKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzEgPSBwYXRoLng7XHJcbiAgICAgICAgICAgIGxhc3RBbGlnbmluZ1Bvc1MyID0gcGF0aC55O1xyXG4gICAgICAgICAgICBwYXRoID0gcGF0aC5wcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGlmZkFsZ29yaXRobVJlc3VsdChyZXN1bHQsIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTbmFrZVBhdGgge1xyXG4gICAgY29uc3RydWN0b3IocHJldiwgeCwgeSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGFycmF5IHRoYXQgc3VwcG9ydHMgZmFzdCBuZWdhdGl2ZSBpbmRpY2VzLlxyXG4qL1xyXG5jbGFzcyBGYXN0SW50MzJBcnJheSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoMTApO1xyXG4gICAgICAgIHRoaXMubmVnYXRpdmVBcnIgPSBuZXcgSW50MzJBcnJheSgxMCk7XHJcbiAgICB9XHJcbiAgICBnZXQoaWR4KSB7XHJcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcclxuICAgICAgICAgICAgaWR4ID0gLWlkeCAtIDE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlQXJyW2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGl2ZUFycltpZHhdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldChpZHgsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcclxuICAgICAgICAgICAgaWR4ID0gLWlkeCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChpZHggPj0gdGhpcy5uZWdhdGl2ZUFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IHRoaXMubmVnYXRpdmVBcnI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5lZ2F0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoYXJyLmxlbmd0aCAqIDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZWdhdGl2ZUFyci5zZXQoYXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm5lZ2F0aXZlQXJyW2lkeF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpZHggPj0gdGhpcy5wb3NpdGl2ZUFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IHRoaXMucG9zaXRpdmVBcnI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoYXJyLmxlbmd0aCAqIDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFyci5zZXQoYXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aXZlQXJyW2lkeF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGFycmF5IHRoYXQgc3VwcG9ydHMgZmFzdCBuZWdhdGl2ZSBpbmRpY2VzLlxyXG4qL1xyXG5jbGFzcyBGYXN0QXJyYXlOZWdhdGl2ZUluZGljZXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGl2ZUFyciA9IFtdO1xyXG4gICAgICAgIHRoaXMubmVnYXRpdmVBcnIgPSBbXTtcclxuICAgIH1cclxuICAgIGdldChpZHgpIHtcclxuICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmVBcnJbaWR4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aXZlQXJyW2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0KGlkeCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcclxuICAgICAgICAgICAgdGhpcy5uZWdhdGl2ZUFycltpZHhdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aXZlQXJyW2lkeF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMovedLines: () => (/* binding */ computeMovedLines)\n/* harmony export */ });\n/* harmony import */ var _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/diffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\");\n/* harmony import */ var _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rangeMapping.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\");\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../base/common/arraysFind.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\");\n/* harmony import */ var _base_common_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../base/common/map.js */ \"./node_modules/monaco-editor/esm/vs/base/common/map.js\");\n/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/lineRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\");\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./linesSliceCharSequence.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\");\n/* harmony import */ var _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./algorithms/myersDiffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\r\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\r\n    if (!timeout.isValid()) {\r\n        return [];\r\n    }\r\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\r\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\r\n    (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.pushMany)(moves, unchangedMoves);\r\n    moves = joinCloseConsecutiveMoves(moves);\r\n    // Ignore too short moves\r\n    moves = moves.filter(current => {\r\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\r\n        const originalText = lines.join('\\n');\r\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\r\n    });\r\n    moves = removeMovesInSameDiff(changes, moves);\r\n    return moves;\r\n}\r\nfunction countWhere(arr, predicate) {\r\n    let count = 0;\r\n    for (const t of arr) {\r\n        if (predicate(t)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}\r\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\r\n    const moves = [];\r\n    const deletions = changes\r\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\r\n        .map(d => new _utils_js__WEBPACK_IMPORTED_MODULE_8__.LineRangeFragment(d.original, originalLines, d));\r\n    const insertions = new Set(changes\r\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\r\n        .map(d => new _utils_js__WEBPACK_IMPORTED_MODULE_8__.LineRangeFragment(d.modified, modifiedLines, d)));\r\n    const excludedChanges = new Set();\r\n    for (const deletion of deletions) {\r\n        let highestSimilarity = -1;\r\n        let best;\r\n        for (const insertion of insertions) {\r\n            const similarity = deletion.computeSimilarity(insertion);\r\n            if (similarity > highestSimilarity) {\r\n                highestSimilarity = similarity;\r\n                best = insertion;\r\n            }\r\n        }\r\n        if (highestSimilarity > 0.90 && best) {\r\n            insertions.delete(best);\r\n            moves.push(new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(deletion.range, best.range));\r\n            excludedChanges.add(deletion.source);\r\n            excludedChanges.add(best.source);\r\n        }\r\n        if (!timeout.isValid()) {\r\n            return { moves, excludedChanges };\r\n        }\r\n    }\r\n    return { moves, excludedChanges };\r\n}\r\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\r\n    const moves = [];\r\n    const original3LineHashes = new _base_common_map_js__WEBPACK_IMPORTED_MODULE_4__.SetMap();\r\n    for (const change of changes) {\r\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\r\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\r\n            original3LineHashes.add(key, { range: new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(i, i + 3) });\r\n        }\r\n    }\r\n    const possibleMappings = [];\r\n    changes.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(c => c.modified.startLineNumber, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator));\r\n    for (const change of changes) {\r\n        let lastMappings = [];\r\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\r\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\r\n            const currentModifiedRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(i, i + 3);\r\n            const nextMappings = [];\r\n            original3LineHashes.forEach(key, ({ range }) => {\r\n                for (const lastMapping of lastMappings) {\r\n                    // does this match extend some last match?\r\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\r\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\r\n                        lastMapping.originalLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\r\n                        lastMapping.modifiedLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\r\n                        nextMappings.push(lastMapping);\r\n                        return;\r\n                    }\r\n                }\r\n                const mapping = {\r\n                    modifiedLineRange: currentModifiedRange,\r\n                    originalLineRange: range,\r\n                };\r\n                possibleMappings.push(mapping);\r\n                nextMappings.push(mapping);\r\n            });\r\n            lastMappings = nextMappings;\r\n        }\r\n        if (!timeout.isValid()) {\r\n            return [];\r\n        }\r\n    }\r\n    possibleMappings.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.reverseOrder)((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(m => m.modifiedLineRange.length, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator)));\r\n    const modifiedSet = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRangeSet();\r\n    const originalSet = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRangeSet();\r\n    for (const mapping of possibleMappings) {\r\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\r\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\r\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\r\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\r\n        for (const s of modifiedIntersectedSections.ranges) {\r\n            if (s.length < 3) {\r\n                continue;\r\n            }\r\n            const modifiedLineRange = s;\r\n            const originalLineRange = s.delta(-diffOrigToMod);\r\n            moves.push(new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(originalLineRange, modifiedLineRange));\r\n            modifiedSet.addRange(modifiedLineRange);\r\n            originalSet.addRange(originalLineRange);\r\n        }\r\n    }\r\n    moves.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(m => m.original.startLineNumber, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator));\r\n    const monotonousChanges = new _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.MonotonousArray(changes);\r\n    for (let i = 0; i < moves.length; i++) {\r\n        const move = moves[i];\r\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\r\n        const firstTouchingChangeMod = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\r\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\r\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\r\n        const lastTouchingChangeMod = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\r\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\r\n        let extendToTop;\r\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\r\n            const origLine = move.original.startLineNumber - extendToTop - 1;\r\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\r\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\r\n                break;\r\n            }\r\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\r\n                break;\r\n            }\r\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\r\n                break;\r\n            }\r\n        }\r\n        if (extendToTop > 0) {\r\n            originalSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\r\n            modifiedSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\r\n        }\r\n        let extendToBottom;\r\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\r\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\r\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\r\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\r\n                break;\r\n            }\r\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\r\n                break;\r\n            }\r\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\r\n                break;\r\n            }\r\n        }\r\n        if (extendToBottom > 0) {\r\n            originalSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\r\n            modifiedSet.addRange(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\r\n        }\r\n        if (extendToTop > 0 || extendToBottom > 0) {\r\n            moves[i] = new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\r\n        }\r\n    }\r\n    return moves;\r\n}\r\nfunction areLinesSimilar(line1, line2, timeout) {\r\n    if (line1.trim() === line2.trim()) {\r\n        return true;\r\n    }\r\n    if (line1.length > 300 && line2.length > 300) {\r\n        return false;\r\n    }\r\n    const myersDiffingAlgorithm = new _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_9__.MyersDiffAlgorithm();\r\n    const result = myersDiffingAlgorithm.compute(new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_7__.LinesSliceCharSequence([line1], new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(0, 1), false), new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_7__.LinesSliceCharSequence([line2], new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(0, 1), false), timeout);\r\n    let commonNonSpaceCharCount = 0;\r\n    const inverted = _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_0__.SequenceDiff.invert(result.diffs, line1.length);\r\n    for (const seq of inverted) {\r\n        seq.seq1Range.forEach(idx => {\r\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_8__.isSpace)(line1.charCodeAt(idx))) {\r\n                commonNonSpaceCharCount++;\r\n            }\r\n        });\r\n    }\r\n    function countNonWsChars(str) {\r\n        let count = 0;\r\n        for (let i = 0; i < line1.length; i++) {\r\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_8__.isSpace)(str.charCodeAt(i))) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\r\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\r\n    return r;\r\n}\r\nfunction joinCloseConsecutiveMoves(moves) {\r\n    if (moves.length === 0) {\r\n        return moves;\r\n    }\r\n    moves.sort((0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.compareBy)(m => m.original.startLineNumber, _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_2__.numberComparator));\r\n    const result = [moves[0]];\r\n    for (let i = 1; i < moves.length; i++) {\r\n        const last = result[result.length - 1];\r\n        const current = moves[i];\r\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\r\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\r\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\r\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\r\n            result[result.length - 1] = last.join(current);\r\n            continue;\r\n        }\r\n        result.push(current);\r\n    }\r\n    return result;\r\n}\r\nfunction removeMovesInSameDiff(changes, moves) {\r\n    const changesMonotonous = new _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.MonotonousArray(changes);\r\n    moves = moves.filter(m => {\r\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\r\n            || new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_1__.LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(1, 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(1, 1));\r\n        const diffBeforeEndOfMoveModified = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_3__.findLastMonotonous)(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\r\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\r\n        return differentDiffs;\r\n    });\r\n    return moves;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9jb21wdXRlTW92ZWRMaW5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1A7QUFDa0Q7QUFDWjtBQUNwQztBQUNVO0FBQ1Y7QUFDYTtBQUNiO0FBQ2dCO0FBQ2pFO0FBQ1AsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1REFBTTtBQUMxQztBQUNBLHNEQUFzRCxnREFBZ0Q7QUFDdEcsMkJBQTJCLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLCtCQUErQjtBQUMxSCwyQ0FBMkMsV0FBVyx5REFBUyxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpRUFBUyxrQ0FBa0Msb0VBQWdCO0FBQzVFO0FBQ0E7QUFDQSxzREFBc0QsZ0RBQWdEO0FBQ3RHLDJCQUEyQiwyQkFBMkIsR0FBRywrQkFBK0IsR0FBRywrQkFBK0I7QUFDMUgsNkNBQTZDLHlEQUFTO0FBQ3REO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQseURBQVM7QUFDckUsNERBQTRELHlEQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBWSxDQUFDLGlFQUFTLGtDQUFrQyxvRUFBZ0I7QUFDbEcsNEJBQTRCLDREQUFZO0FBQ3hDLDRCQUE0Qiw0REFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQVMsa0NBQWtDLG9FQUFnQjtBQUMxRSxrQ0FBa0MsdUVBQWU7QUFDakQsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsdUNBQXVDLDhFQUFrQjtBQUN6RDtBQUNBO0FBQ0Esc0NBQXNDLDhFQUFrQjtBQUN4RDtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5REFBUztBQUM5QyxxQ0FBcUMseURBQVM7QUFDOUM7QUFDQTtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseURBQVM7QUFDOUMscUNBQXFDLHlEQUFTO0FBQzlDO0FBQ0E7QUFDQSwyQkFBMkIsOERBQWdCLEtBQUsseURBQVMsMEdBQTBHLHlEQUFTO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUZBQWtCO0FBQ3hELHFEQUFxRCw4RUFBc0IsY0FBYyw2REFBVyxvQkFBb0IsOEVBQXNCLGNBQWMsNkRBQVc7QUFDdks7QUFDQSxxQkFBcUIsc0VBQVk7QUFDakM7QUFDQTtBQUNBLGlCQUFpQixrREFBTztBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsaUJBQWlCLGtEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBUyxrQ0FBa0Msb0VBQWdCO0FBQzFFO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVFQUFlO0FBQ2pEO0FBQ0E7QUFDQSxtQkFBbUIsOERBQWdCLEtBQUsseURBQVMsWUFBWSx5REFBUztBQUN0RSw0Q0FBNEMsOEVBQWtCO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2NvbXB1dGVNb3ZlZExpbmVzLmpzP2U1NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IFNlcXVlbmNlRGlmZiB9IGZyb20gJy4vYWxnb3JpdGhtcy9kaWZmQWxnb3JpdGhtLmpzJztcclxuaW1wb3J0IHsgTGluZVJhbmdlTWFwcGluZyB9IGZyb20gJy4uL3JhbmdlTWFwcGluZy5qcyc7XHJcbmltcG9ydCB7IHB1c2hNYW55LCBjb21wYXJlQnksIG51bWJlckNvbXBhcmF0b3IsIHJldmVyc2VPcmRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FycmF5cy5qcyc7XHJcbmltcG9ydCB7IE1vbm90b25vdXNBcnJheSwgZmluZExhc3RNb25vdG9ub3VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcyc7XHJcbmltcG9ydCB7IFNldE1hcCB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL21hcC5qcyc7XHJcbmltcG9ydCB7IExpbmVSYW5nZSwgTGluZVJhbmdlU2V0IH0gZnJvbSAnLi4vLi4vY29yZS9saW5lUmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlIH0gZnJvbSAnLi9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzJztcclxuaW1wb3J0IHsgTGluZVJhbmdlRnJhZ21lbnQsIGlzU3BhY2UgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuaW1wb3J0IHsgTXllcnNEaWZmQWxnb3JpdGhtIH0gZnJvbSAnLi9hbGdvcml0aG1zL215ZXJzRGlmZkFsZ29yaXRobS5qcyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTW92ZWRMaW5lcyhjaGFuZ2VzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCB0aW1lb3V0KSB7XHJcbiAgICBsZXQgeyBtb3ZlcywgZXhjbHVkZWRDaGFuZ2VzIH0gPSBjb21wdXRlTW92ZXNGcm9tU2ltcGxlRGVsZXRpb25zVG9TaW1wbGVJbnNlcnRpb25zKGNoYW5nZXMsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHRpbWVvdXQpO1xyXG4gICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbHRlcmVkQ2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKGMgPT4gIWV4Y2x1ZGVkQ2hhbmdlcy5oYXMoYykpO1xyXG4gICAgY29uc3QgdW5jaGFuZ2VkTW92ZXMgPSBjb21wdXRlVW5jaGFuZ2VkTW92ZXMoZmlsdGVyZWRDaGFuZ2VzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB0aW1lb3V0KTtcclxuICAgIHB1c2hNYW55KG1vdmVzLCB1bmNoYW5nZWRNb3Zlcyk7XHJcbiAgICBtb3ZlcyA9IGpvaW5DbG9zZUNvbnNlY3V0aXZlTW92ZXMobW92ZXMpO1xyXG4gICAgLy8gSWdub3JlIHRvbyBzaG9ydCBtb3Zlc1xyXG4gICAgbW92ZXMgPSBtb3Zlcy5maWx0ZXIoY3VycmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBjdXJyZW50Lm9yaWdpbmFsLnRvT2Zmc2V0UmFuZ2UoKS5zbGljZShvcmlnaW5hbExpbmVzKS5tYXAobCA9PiBsLnRyaW0oKSk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0ID0gbGluZXMuam9pbignXFxuJyk7XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVGV4dC5sZW5ndGggPj0gMTUgJiYgY291bnRXaGVyZShsaW5lcywgbCA9PiBsLmxlbmd0aCA+PSAyKSA+PSAyO1xyXG4gICAgfSk7XHJcbiAgICBtb3ZlcyA9IHJlbW92ZU1vdmVzSW5TYW1lRGlmZihjaGFuZ2VzLCBtb3Zlcyk7XHJcbiAgICByZXR1cm4gbW92ZXM7XHJcbn1cclxuZnVuY3Rpb24gY291bnRXaGVyZShhcnIsIHByZWRpY2F0ZSkge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGZvciAoY29uc3QgdCBvZiBhcnIpIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKHQpKSB7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50O1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVNb3Zlc0Zyb21TaW1wbGVEZWxldGlvbnNUb1NpbXBsZUluc2VydGlvbnMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgdGltZW91dCkge1xyXG4gICAgY29uc3QgbW92ZXMgPSBbXTtcclxuICAgIGNvbnN0IGRlbGV0aW9ucyA9IGNoYW5nZXNcclxuICAgICAgICAuZmlsdGVyKGMgPT4gYy5tb2RpZmllZC5pc0VtcHR5ICYmIGMub3JpZ2luYWwubGVuZ3RoID49IDMpXHJcbiAgICAgICAgLm1hcChkID0+IG5ldyBMaW5lUmFuZ2VGcmFnbWVudChkLm9yaWdpbmFsLCBvcmlnaW5hbExpbmVzLCBkKSk7XHJcbiAgICBjb25zdCBpbnNlcnRpb25zID0gbmV3IFNldChjaGFuZ2VzXHJcbiAgICAgICAgLmZpbHRlcihjID0+IGMub3JpZ2luYWwuaXNFbXB0eSAmJiBjLm1vZGlmaWVkLmxlbmd0aCA+PSAzKVxyXG4gICAgICAgIC5tYXAoZCA9PiBuZXcgTGluZVJhbmdlRnJhZ21lbnQoZC5tb2RpZmllZCwgbW9kaWZpZWRMaW5lcywgZCkpKTtcclxuICAgIGNvbnN0IGV4Y2x1ZGVkQ2hhbmdlcyA9IG5ldyBTZXQoKTtcclxuICAgIGZvciAoY29uc3QgZGVsZXRpb24gb2YgZGVsZXRpb25zKSB7XHJcbiAgICAgICAgbGV0IGhpZ2hlc3RTaW1pbGFyaXR5ID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3Q7XHJcbiAgICAgICAgZm9yIChjb25zdCBpbnNlcnRpb24gb2YgaW5zZXJ0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gZGVsZXRpb24uY29tcHV0ZVNpbWlsYXJpdHkoaW5zZXJ0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiBoaWdoZXN0U2ltaWxhcml0eSkge1xyXG4gICAgICAgICAgICAgICAgaGlnaGVzdFNpbWlsYXJpdHkgPSBzaW1pbGFyaXR5O1xyXG4gICAgICAgICAgICAgICAgYmVzdCA9IGluc2VydGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGlnaGVzdFNpbWlsYXJpdHkgPiAwLjkwICYmIGJlc3QpIHtcclxuICAgICAgICAgICAgaW5zZXJ0aW9ucy5kZWxldGUoYmVzdCk7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2gobmV3IExpbmVSYW5nZU1hcHBpbmcoZGVsZXRpb24ucmFuZ2UsIGJlc3QucmFuZ2UpKTtcclxuICAgICAgICAgICAgZXhjbHVkZWRDaGFuZ2VzLmFkZChkZWxldGlvbi5zb3VyY2UpO1xyXG4gICAgICAgICAgICBleGNsdWRlZENoYW5nZXMuYWRkKGJlc3Quc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBtb3ZlcywgZXhjbHVkZWRDaGFuZ2VzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbW92ZXMsIGV4Y2x1ZGVkQ2hhbmdlcyB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVVbmNoYW5nZWRNb3ZlcyhjaGFuZ2VzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB0aW1lb3V0KSB7XHJcbiAgICBjb25zdCBtb3ZlcyA9IFtdO1xyXG4gICAgY29uc3Qgb3JpZ2luYWwzTGluZUhhc2hlcyA9IG5ldyBTZXRNYXAoKTtcclxuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcjsgaSA8IGNoYW5nZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2hhc2hlZE9yaWdpbmFsTGluZXNbaSAtIDFdfToke2hhc2hlZE9yaWdpbmFsTGluZXNbaSArIDEgLSAxXX06JHtoYXNoZWRPcmlnaW5hbExpbmVzW2kgKyAyIC0gMV19YDtcclxuICAgICAgICAgICAgb3JpZ2luYWwzTGluZUhhc2hlcy5hZGQoa2V5LCB7IHJhbmdlOiBuZXcgTGluZVJhbmdlKGksIGkgKyAzKSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb3NzaWJsZU1hcHBpbmdzID0gW107XHJcbiAgICBjaGFuZ2VzLnNvcnQoY29tcGFyZUJ5KGMgPT4gYy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIsIG51bWJlckNvbXBhcmF0b3IpKTtcclxuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcclxuICAgICAgICBsZXQgbGFzdE1hcHBpbmdzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXI7IGkgPCBjaGFuZ2UubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtoYXNoZWRNb2RpZmllZExpbmVzW2kgLSAxXX06JHtoYXNoZWRNb2RpZmllZExpbmVzW2kgKyAxIC0gMV19OiR7aGFzaGVkTW9kaWZpZWRMaW5lc1tpICsgMiAtIDFdfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb2RpZmllZFJhbmdlID0gbmV3IExpbmVSYW5nZShpLCBpICsgMyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRNYXBwaW5ncyA9IFtdO1xyXG4gICAgICAgICAgICBvcmlnaW5hbDNMaW5lSGFzaGVzLmZvckVhY2goa2V5LCAoeyByYW5nZSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxhc3RNYXBwaW5nIG9mIGxhc3RNYXBwaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgdGhpcyBtYXRjaCBleHRlbmQgc29tZSBsYXN0IG1hdGNoP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgMSA9PT0gcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWFwcGluZy5tb2RpZmllZExpbmVSYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgMSA9PT0gY3VycmVudE1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZSA9IG5ldyBMaW5lUmFuZ2UobGFzdE1hcHBpbmcub3JpZ2luYWxMaW5lUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1hcHBpbmcubW9kaWZpZWRMaW5lUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGxhc3RNYXBwaW5nLm1vZGlmaWVkTGluZVJhbmdlLnN0YXJ0TGluZU51bWJlciwgY3VycmVudE1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNYXBwaW5ncy5wdXNoKGxhc3RNYXBwaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lUmFuZ2U6IGN1cnJlbnRNb2RpZmllZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZVJhbmdlOiByYW5nZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU1hcHBpbmdzLnB1c2gobWFwcGluZyk7XHJcbiAgICAgICAgICAgICAgICBuZXh0TWFwcGluZ3MucHVzaChtYXBwaW5nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxhc3RNYXBwaW5ncyA9IG5leHRNYXBwaW5ncztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zc2libGVNYXBwaW5ncy5zb3J0KHJldmVyc2VPcmRlcihjb21wYXJlQnkobSA9PiBtLm1vZGlmaWVkTGluZVJhbmdlLmxlbmd0aCwgbnVtYmVyQ29tcGFyYXRvcikpKTtcclxuICAgIGNvbnN0IG1vZGlmaWVkU2V0ID0gbmV3IExpbmVSYW5nZVNldCgpO1xyXG4gICAgY29uc3Qgb3JpZ2luYWxTZXQgPSBuZXcgTGluZVJhbmdlU2V0KCk7XHJcbiAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgcG9zc2libGVNYXBwaW5ncykge1xyXG4gICAgICAgIGNvbnN0IGRpZmZPcmlnVG9Nb2QgPSBtYXBwaW5nLm1vZGlmaWVkTGluZVJhbmdlLnN0YXJ0TGluZU51bWJlciAtIG1hcHBpbmcub3JpZ2luYWxMaW5lUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU2VjdGlvbnMgPSBtb2RpZmllZFNldC5zdWJ0cmFjdEZyb20obWFwcGluZy5tb2RpZmllZExpbmVSYW5nZSk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUcmFuc2xhdGVkU2VjdGlvbnMgPSBvcmlnaW5hbFNldC5zdWJ0cmFjdEZyb20obWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZSkuZ2V0V2l0aERlbHRhKGRpZmZPcmlnVG9Nb2QpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkSW50ZXJzZWN0ZWRTZWN0aW9ucyA9IG1vZGlmaWVkU2VjdGlvbnMuZ2V0SW50ZXJzZWN0aW9uKG9yaWdpbmFsVHJhbnNsYXRlZFNlY3Rpb25zKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgbW9kaWZpZWRJbnRlcnNlY3RlZFNlY3Rpb25zLnJhbmdlcykge1xyXG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmVSYW5nZSA9IHM7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZVJhbmdlID0gcy5kZWx0YSgtZGlmZk9yaWdUb01vZCk7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2gobmV3IExpbmVSYW5nZU1hcHBpbmcob3JpZ2luYWxMaW5lUmFuZ2UsIG1vZGlmaWVkTGluZVJhbmdlKSk7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU2V0LmFkZFJhbmdlKG1vZGlmaWVkTGluZVJhbmdlKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxTZXQuYWRkUmFuZ2Uob3JpZ2luYWxMaW5lUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vdmVzLnNvcnQoY29tcGFyZUJ5KG0gPT4gbS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIG51bWJlckNvbXBhcmF0b3IpKTtcclxuICAgIGNvbnN0IG1vbm90b25vdXNDaGFuZ2VzID0gbmV3IE1vbm90b25vdXNBcnJheShjaGFuZ2VzKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBtb3ZlID0gbW92ZXNbaV07XHJcbiAgICAgICAgY29uc3QgZmlyc3RUb3VjaGluZ0NoYW5nZU9yaWcgPSBtb25vdG9ub3VzQ2hhbmdlcy5maW5kTGFzdE1vbm90b25vdXMoYyA9PiBjLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA8PSBtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgY29uc3QgZmlyc3RUb3VjaGluZ0NoYW5nZU1vZCA9IGZpbmRMYXN0TW9ub3Rvbm91cyhjaGFuZ2VzLCBjID0+IGMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIDw9IG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKTtcclxuICAgICAgICBjb25zdCBsaW5lc0Fib3ZlID0gTWF0aC5tYXgobW92ZS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSBmaXJzdFRvdWNoaW5nQ2hhbmdlT3JpZy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gZmlyc3RUb3VjaGluZ0NoYW5nZU1vZC5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIpO1xyXG4gICAgICAgIGNvbnN0IGxhc3RUb3VjaGluZ0NoYW5nZU9yaWcgPSBtb25vdG9ub3VzQ2hhbmdlcy5maW5kTGFzdE1vbm90b25vdXMoYyA9PiBjLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA8IG1vdmUub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XHJcbiAgICAgICAgY29uc3QgbGFzdFRvdWNoaW5nQ2hhbmdlTW9kID0gZmluZExhc3RNb25vdG9ub3VzKGNoYW5nZXMsIGMgPT4gYy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPCBtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVzQmVsb3cgPSBNYXRoLm1heChsYXN0VG91Y2hpbmdDaGFuZ2VPcmlnLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSBtb3ZlLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIGxhc3RUb3VjaGluZ0NoYW5nZU1vZC5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gbW92ZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcclxuICAgICAgICBsZXQgZXh0ZW5kVG9Ub3A7XHJcbiAgICAgICAgZm9yIChleHRlbmRUb1RvcCA9IDA7IGV4dGVuZFRvVG9wIDwgbGluZXNBYm92ZTsgZXh0ZW5kVG9Ub3ArKykge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnTGluZSA9IG1vdmUub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gZXh0ZW5kVG9Ub3AgLSAxO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RMaW5lID0gbW92ZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBleHRlbmRUb1RvcCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChvcmlnTGluZSA+IG9yaWdpbmFsTGluZXMubGVuZ3RoIHx8IG1vZExpbmUgPiBtb2RpZmllZExpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVkU2V0LmNvbnRhaW5zKG1vZExpbmUpIHx8IG9yaWdpbmFsU2V0LmNvbnRhaW5zKG9yaWdMaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhcmVMaW5lc1NpbWlsYXIob3JpZ2luYWxMaW5lc1tvcmlnTGluZSAtIDFdLCBtb2RpZmllZExpbmVzW21vZExpbmUgLSAxXSwgdGltZW91dCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbmRUb1RvcCA+IDApIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTZXQuYWRkUmFuZ2UobmV3IExpbmVSYW5nZShtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wLCBtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikpO1xyXG4gICAgICAgICAgICBtb2RpZmllZFNldC5hZGRSYW5nZShuZXcgTGluZVJhbmdlKG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gZXh0ZW5kVG9Ub3AsIG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBleHRlbmRUb0JvdHRvbTtcclxuICAgICAgICBmb3IgKGV4dGVuZFRvQm90dG9tID0gMDsgZXh0ZW5kVG9Cb3R0b20gPCBsaW5lc0JlbG93OyBleHRlbmRUb0JvdHRvbSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdMaW5lID0gbW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgZXh0ZW5kVG9Cb3R0b207XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZExpbmUgPSBtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbTtcclxuICAgICAgICAgICAgaWYgKG9yaWdMaW5lID4gb3JpZ2luYWxMaW5lcy5sZW5ndGggfHwgbW9kTGluZSA+IG1vZGlmaWVkTGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobW9kaWZpZWRTZXQuY29udGFpbnMobW9kTGluZSkgfHwgb3JpZ2luYWxTZXQuY29udGFpbnMob3JpZ0xpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFyZUxpbmVzU2ltaWxhcihvcmlnaW5hbExpbmVzW29yaWdMaW5lIC0gMV0sIG1vZGlmaWVkTGluZXNbbW9kTGluZSAtIDFdLCB0aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4dGVuZFRvQm90dG9tID4gMCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFNldC5hZGRSYW5nZShuZXcgTGluZVJhbmdlKG1vdmUub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgZXh0ZW5kVG9Cb3R0b20pKTtcclxuICAgICAgICAgICAgbW9kaWZpZWRTZXQuYWRkUmFuZ2UobmV3IExpbmVSYW5nZShtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIG1vdmUubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIGV4dGVuZFRvQm90dG9tKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbmRUb1RvcCA+IDAgfHwgZXh0ZW5kVG9Cb3R0b20gPiAwKSB7XHJcbiAgICAgICAgICAgIG1vdmVzW2ldID0gbmV3IExpbmVSYW5nZU1hcHBpbmcobmV3IExpbmVSYW5nZShtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wLCBtb3ZlLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbSksIG5ldyBMaW5lUmFuZ2UobW92ZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBleHRlbmRUb1RvcCwgbW92ZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgZXh0ZW5kVG9Cb3R0b20pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW92ZXM7XHJcbn1cclxuZnVuY3Rpb24gYXJlTGluZXNTaW1pbGFyKGxpbmUxLCBsaW5lMiwgdGltZW91dCkge1xyXG4gICAgaWYgKGxpbmUxLnRyaW0oKSA9PT0gbGluZTIudHJpbSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAobGluZTEubGVuZ3RoID4gMzAwICYmIGxpbmUyLmxlbmd0aCA+IDMwMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG15ZXJzRGlmZmluZ0FsZ29yaXRobSA9IG5ldyBNeWVyc0RpZmZBbGdvcml0aG0oKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG15ZXJzRGlmZmluZ0FsZ29yaXRobS5jb21wdXRlKG5ldyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlKFtsaW5lMV0sIG5ldyBPZmZzZXRSYW5nZSgwLCAxKSwgZmFsc2UpLCBuZXcgTGluZXNTbGljZUNoYXJTZXF1ZW5jZShbbGluZTJdLCBuZXcgT2Zmc2V0UmFuZ2UoMCwgMSksIGZhbHNlKSwgdGltZW91dCk7XHJcbiAgICBsZXQgY29tbW9uTm9uU3BhY2VDaGFyQ291bnQgPSAwO1xyXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBTZXF1ZW5jZURpZmYuaW52ZXJ0KHJlc3VsdC5kaWZmcywgbGluZTEubGVuZ3RoKTtcclxuICAgIGZvciAoY29uc3Qgc2VxIG9mIGludmVydGVkKSB7XHJcbiAgICAgICAgc2VxLnNlcTFSYW5nZS5mb3JFYWNoKGlkeCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaXNTcGFjZShsaW5lMS5jaGFyQ29kZUF0KGlkeCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tb25Ob25TcGFjZUNoYXJDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb3VudE5vbldzQ2hhcnMoc3RyKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNTcGFjZShzdHIuY2hhckNvZGVBdChpKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG9uZ2VyTGluZUxlbmd0aCA9IGNvdW50Tm9uV3NDaGFycyhsaW5lMS5sZW5ndGggPiBsaW5lMi5sZW5ndGggPyBsaW5lMSA6IGxpbmUyKTtcclxuICAgIGNvbnN0IHIgPSBjb21tb25Ob25TcGFjZUNoYXJDb3VudCAvIGxvbmdlckxpbmVMZW5ndGggPiAwLjYgJiYgbG9uZ2VyTGluZUxlbmd0aCA+IDEwO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuZnVuY3Rpb24gam9pbkNsb3NlQ29uc2VjdXRpdmVNb3Zlcyhtb3Zlcykge1xyXG4gICAgaWYgKG1vdmVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBtb3ZlcztcclxuICAgIH1cclxuICAgIG1vdmVzLnNvcnQoY29tcGFyZUJ5KG0gPT4gbS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIsIG51bWJlckNvbXBhcmF0b3IpKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFttb3Zlc1swXV07XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG1vdmVzW2ldO1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGlzdCA9IGN1cnJlbnQub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gbGFzdC5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkRGlzdCA9IGN1cnJlbnQubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gbGFzdC5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNb3ZlQWZ0ZXJMYXN0ID0gb3JpZ2luYWxEaXN0ID49IDAgJiYgbW9kaWZpZWREaXN0ID49IDA7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRNb3ZlQWZ0ZXJMYXN0ICYmIG9yaWdpbmFsRGlzdCArIG1vZGlmaWVkRGlzdCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBsYXN0LmpvaW4oY3VycmVudCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlTW92ZXNJblNhbWVEaWZmKGNoYW5nZXMsIG1vdmVzKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VzTW9ub3Rvbm91cyA9IG5ldyBNb25vdG9ub3VzQXJyYXkoY2hhbmdlcyk7XHJcbiAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcihtID0+IHtcclxuICAgICAgICBjb25zdCBkaWZmQmVmb3JlRW5kT2ZNb3ZlT3JpZ2luYWwgPSBjaGFuZ2VzTW9ub3Rvbm91cy5maW5kTGFzdE1vbm90b25vdXMoYyA9PiBjLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA8IG0ub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSlcclxuICAgICAgICAgICAgfHwgbmV3IExpbmVSYW5nZU1hcHBpbmcobmV3IExpbmVSYW5nZSgxLCAxKSwgbmV3IExpbmVSYW5nZSgxLCAxKSk7XHJcbiAgICAgICAgY29uc3QgZGlmZkJlZm9yZUVuZE9mTW92ZU1vZGlmaWVkID0gZmluZExhc3RNb25vdG9ub3VzKGNoYW5nZXMsIGMgPT4gYy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPCBtLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xyXG4gICAgICAgIGNvbnN0IGRpZmZlcmVudERpZmZzID0gZGlmZkJlZm9yZUVuZE9mTW92ZU9yaWdpbmFsICE9PSBkaWZmQmVmb3JlRW5kT2ZNb3ZlTW9kaWZpZWQ7XHJcbiAgICAgICAgcmV0dXJuIGRpZmZlcmVudERpZmZzO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbW92ZXM7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultLinesDiffComputer: () => (/* binding */ DefaultLinesDiffComputer),\n/* harmony export */   getLineRangeMapping: () => (/* binding */ getLineRangeMapping),\n/* harmony export */   lineRangeMappingFromRangeMappings: () => (/* binding */ lineRangeMappingFromRangeMappings)\n/* harmony export */ });\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../base/common/assert.js */ \"./node_modules/monaco-editor/esm/vs/base/common/assert.js\");\n/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/lineRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\");\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./algorithms/diffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\");\n/* harmony import */ var _algorithms_dynamicProgrammingDiffing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./algorithms/dynamicProgrammingDiffing.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js\");\n/* harmony import */ var _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./algorithms/myersDiffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js\");\n/* harmony import */ var _computeMovedLines_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./computeMovedLines.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js\");\n/* harmony import */ var _heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./heuristicSequenceOptimizations.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js\");\n/* harmony import */ var _lineSequence_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lineSequence.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js\");\n/* harmony import */ var _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./linesSliceCharSequence.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js\");\n/* harmony import */ var _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../linesDiffComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js\");\n/* harmony import */ var _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../rangeMapping.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass DefaultLinesDiffComputer {\r\n    constructor() {\r\n        this.dynamicProgrammingDiffing = new _algorithms_dynamicProgrammingDiffing_js__WEBPACK_IMPORTED_MODULE_6__.DynamicProgrammingDiffing();\r\n        this.myersDiffingAlgorithm = new _algorithms_myersDiffAlgorithm_js__WEBPACK_IMPORTED_MODULE_7__.MyersDiffAlgorithm();\r\n    }\r\n    computeDiff(originalLines, modifiedLines, options) {\r\n        if (originalLines.length <= 1 && (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.equals)(originalLines, modifiedLines, (a, b) => a === b)) {\r\n            return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.LinesDiff([], [], false);\r\n        }\r\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\r\n            return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.LinesDiff([\r\n                new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.DetailedLineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(1, originalLines.length + 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(1, modifiedLines.length + 1), [\r\n                    new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\r\n                ])\r\n            ], [], false);\r\n        }\r\n        const timeout = options.maxComputationTimeMs === 0 ? _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.InfiniteTimeout.instance : new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.DateTimeout(options.maxComputationTimeMs);\r\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\r\n        const perfectHashes = new Map();\r\n        function getOrCreateHash(text) {\r\n            let hash = perfectHashes.get(text);\r\n            if (hash === undefined) {\r\n                hash = perfectHashes.size;\r\n                perfectHashes.set(text, hash);\r\n            }\r\n            return hash;\r\n        }\r\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\r\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\r\n        const sequence1 = new _lineSequence_js__WEBPACK_IMPORTED_MODULE_10__.LineSequence(originalLinesHashes, originalLines);\r\n        const sequence2 = new _lineSequence_js__WEBPACK_IMPORTED_MODULE_10__.LineSequence(modifiedLinesHashes, modifiedLines);\r\n        const lineAlignmentResult = (() => {\r\n            if (sequence1.length + sequence2.length < 1700) {\r\n                // Use the improved algorithm for small files\r\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\r\n                    ? modifiedLines[offset2].length === 0\r\n                        ? 0.1\r\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\r\n                    : 0.99);\r\n            }\r\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\r\n        })();\r\n        let lineAlignments = lineAlignmentResult.diffs;\r\n        let hitTimeout = lineAlignmentResult.hitTimeout;\r\n        lineAlignments = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.optimizeSequenceDiffs)(sequence1, sequence2, lineAlignments);\r\n        lineAlignments = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.removeVeryShortMatchingLinesBetweenDiffs)(sequence1, sequence2, lineAlignments);\r\n        const alignments = [];\r\n        const scanForWhitespaceChanges = (equalLinesCount) => {\r\n            if (!considerWhitespaceChanges) {\r\n                return;\r\n            }\r\n            for (let i = 0; i < equalLinesCount; i++) {\r\n                const seq1Offset = seq1LastStart + i;\r\n                const seq2Offset = seq2LastStart + i;\r\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\r\n                    // This is because of whitespace changes, diff these lines\r\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_3__.OffsetRange(seq1Offset, seq1Offset + 1), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_3__.OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\r\n                    for (const a of characterDiffs.mappings) {\r\n                        alignments.push(a);\r\n                    }\r\n                    if (characterDiffs.hitTimeout) {\r\n                        hitTimeout = true;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        let seq1LastStart = 0;\r\n        let seq2LastStart = 0;\r\n        for (const diff of lineAlignments) {\r\n            (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\r\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\r\n            scanForWhitespaceChanges(equalLinesCount);\r\n            seq1LastStart = diff.seq1Range.endExclusive;\r\n            seq2LastStart = diff.seq2Range.endExclusive;\r\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\r\n            if (characterDiffs.hitTimeout) {\r\n                hitTimeout = true;\r\n            }\r\n            for (const a of characterDiffs.mappings) {\r\n                alignments.push(a);\r\n            }\r\n        }\r\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\r\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\r\n        let moves = [];\r\n        if (options.computeMoves) {\r\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\r\n        }\r\n        // Make sure all ranges are valid\r\n        (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => {\r\n            function validatePosition(pos, lines) {\r\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\r\n                    return false;\r\n                }\r\n                const line = lines[pos.lineNumber - 1];\r\n                if (pos.column < 1 || pos.column > line.length + 1) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            function validateRange(range, lines) {\r\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\r\n                    return false;\r\n                }\r\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            for (const c of changes) {\r\n                if (!c.innerChanges) {\r\n                    return false;\r\n                }\r\n                for (const ic of c.innerChanges) {\r\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\r\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\r\n                    if (!valid) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.LinesDiff(changes, moves, hitTimeout);\r\n    }\r\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\r\n        const moves = (0,_computeMovedLines_js__WEBPACK_IMPORTED_MODULE_8__.computeMovedLines)(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\r\n        const movesWithDiffs = moves.map(m => {\r\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\r\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\r\n            return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_12__.MovedText(m, mappings);\r\n        });\r\n        return movesWithDiffs;\r\n    }\r\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\r\n        const slice1 = new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_11__.LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\r\n        const slice2 = new _linesSliceCharSequence_js__WEBPACK_IMPORTED_MODULE_11__.LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\r\n        const diffResult = slice1.length + slice2.length < 500\r\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\r\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\r\n        let diffs = diffResult.diffs;\r\n        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.optimizeSequenceDiffs)(slice1, slice2, diffs);\r\n        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.extendDiffsToEntireWordIfAppropriate)(slice1, slice2, diffs);\r\n        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.removeShortMatches)(slice1, slice2, diffs);\r\n        diffs = (0,_heuristicSequenceOptimizations_js__WEBPACK_IMPORTED_MODULE_9__.removeVeryShortMatchingTextBetweenLongDiffs)(slice1, slice2, diffs);\r\n        const result = diffs.map((d) => new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\r\n        // Assert: result applied on original should be the same as diff applied to original\r\n        return {\r\n            mappings: result,\r\n            hitTimeout: diffResult.hitTimeout,\r\n        };\r\n    }\r\n}\r\nfunction lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\r\n    const changes = [];\r\n    for (const g of (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.groupAdjacentBy)(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\r\n        || a1.modified.overlapOrTouch(a2.modified))) {\r\n        const first = g[0];\r\n        const last = g[g.length - 1];\r\n        changes.push(new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\r\n    }\r\n    (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => {\r\n        if (!dontAssertStartLine && changes.length > 0) {\r\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\r\n                return false;\r\n            }\r\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\r\n                return false;\r\n            }\r\n        }\r\n        return (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_1__.checkAdjacentItems)(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\r\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\r\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\r\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\r\n    });\r\n    return changes;\r\n}\r\nfunction getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\r\n    let lineStartDelta = 0;\r\n    let lineEndDelta = 0;\r\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\r\n    // original: ]xxx \\n <- this line is not modified\r\n    // modified: ]xx  \\n\r\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\r\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\r\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\r\n        // We can only do this if the range is not empty yet\r\n        lineEndDelta = -1;\r\n    }\r\n    // original: xxx[ \\n <- this line is not modified\r\n    // modified: xxx[ \\n\r\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\r\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\r\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\r\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\r\n        // We can only do this if the range is not empty yet\r\n        lineStartDelta = 1;\r\n    }\r\n    const originalLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\r\n    const modifiedLineRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_2__.LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\r\n    return new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_13__.DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RTtBQUNLO0FBQzdCO0FBQ0k7QUFDWjtBQUMrQztBQUNMO0FBQ2Q7QUFDYjtBQUNrSztBQUM1SztBQUNvQjtBQUNOO0FBQ2E7QUFDckU7QUFDUDtBQUNBLDZDQUE2QywrRkFBeUI7QUFDdEUseUNBQXlDLGlGQUFrQjtBQUMzRDtBQUNBO0FBQ0EseUNBQXlDLDhEQUFNO0FBQy9DLHVCQUF1Qiw2REFBUztBQUNoQztBQUNBO0FBQ0EsdUJBQXVCLDZEQUFTO0FBQ2hDLG9CQUFvQix1RUFBd0IsS0FBSyx5REFBUyxtQ0FBbUMseURBQVM7QUFDdEcsd0JBQXdCLDJEQUFZLEtBQUssaURBQUssc0ZBQXNGLGlEQUFLO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5RUFBZSxnQkFBZ0IscUVBQVc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFZO0FBQzFDLDhCQUE4QiwyREFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHlGQUFxQjtBQUM5Qyx5QkFBeUIsNEdBQXdDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLHNFQUFZLEtBQUssNkRBQVcsa0NBQWtDLDZEQUFXO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUJBQW1CLDZEQUFTO0FBQzVCO0FBQ0E7QUFDQSxzQkFBc0Isd0VBQWlCO0FBQ3ZDO0FBQ0Esa0ZBQWtGLHNFQUFZO0FBQzlGO0FBQ0EsdUJBQXVCLDZEQUFTO0FBQ2hDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0VBQXNCO0FBQ2pELDJCQUEyQiwrRUFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUZBQXFCO0FBQ3JDLGdCQUFnQix3R0FBb0M7QUFDcEQsZ0JBQWdCLHNGQUFrQjtBQUNsQyxnQkFBZ0IsK0dBQTJDO0FBQzNELDRDQUE0QywyREFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsdUVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUF3QjtBQUNqRDtBQUNBLElBQUksZ0VBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwRUFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseURBQVM7QUFDM0Msa0NBQWtDLHlEQUFTO0FBQzNDLGVBQWUsdUVBQXdCO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyLmpzPzJiNDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IGVxdWFscywgZ3JvdXBBZGphY2VudEJ5IH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcclxuaW1wb3J0IHsgYXNzZXJ0Rm4sIGNoZWNrQWRqYWNlbnRJdGVtcyB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Fzc2VydC5qcyc7XHJcbmltcG9ydCB7IExpbmVSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvbGluZVJhbmdlLmpzJztcclxuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL3JhbmdlLmpzJztcclxuaW1wb3J0IHsgRGF0ZVRpbWVvdXQsIEluZmluaXRlVGltZW91dCwgU2VxdWVuY2VEaWZmIH0gZnJvbSAnLi9hbGdvcml0aG1zL2RpZmZBbGdvcml0aG0uanMnO1xyXG5pbXBvcnQgeyBEeW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nIH0gZnJvbSAnLi9hbGdvcml0aG1zL2R5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuanMnO1xyXG5pbXBvcnQgeyBNeWVyc0RpZmZBbGdvcml0aG0gfSBmcm9tICcuL2FsZ29yaXRobXMvbXllcnNEaWZmQWxnb3JpdGhtLmpzJztcclxuaW1wb3J0IHsgY29tcHV0ZU1vdmVkTGluZXMgfSBmcm9tICcuL2NvbXB1dGVNb3ZlZExpbmVzLmpzJztcclxuaW1wb3J0IHsgZXh0ZW5kRGlmZnNUb0VudGlyZVdvcmRJZkFwcHJvcHJpYXRlLCBvcHRpbWl6ZVNlcXVlbmNlRGlmZnMsIHJlbW92ZVNob3J0TWF0Y2hlcywgcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdMaW5lc0JldHdlZW5EaWZmcywgcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdUZXh0QmV0d2VlbkxvbmdEaWZmcyB9IGZyb20gJy4vaGV1cmlzdGljU2VxdWVuY2VPcHRpbWl6YXRpb25zLmpzJztcclxuaW1wb3J0IHsgTGluZVNlcXVlbmNlIH0gZnJvbSAnLi9saW5lU2VxdWVuY2UuanMnO1xyXG5pbXBvcnQgeyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlIH0gZnJvbSAnLi9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzJztcclxuaW1wb3J0IHsgTGluZXNEaWZmLCBNb3ZlZFRleHQgfSBmcm9tICcuLi9saW5lc0RpZmZDb21wdXRlci5qcyc7XHJcbmltcG9ydCB7IERldGFpbGVkTGluZVJhbmdlTWFwcGluZywgUmFuZ2VNYXBwaW5nIH0gZnJvbSAnLi4vcmFuZ2VNYXBwaW5nLmpzJztcclxuZXhwb3J0IGNsYXNzIERlZmF1bHRMaW5lc0RpZmZDb21wdXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmR5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcgPSBuZXcgRHluYW1pY1Byb2dyYW1taW5nRGlmZmluZygpO1xyXG4gICAgICAgIHRoaXMubXllcnNEaWZmaW5nQWxnb3JpdGhtID0gbmV3IE15ZXJzRGlmZkFsZ29yaXRobSgpO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcmlnaW5hbExpbmVzLmxlbmd0aCA8PSAxICYmIGVxdWFscyhvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCAoYSwgYikgPT4gYSA9PT0gYikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lc0RpZmYoW10sIFtdLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnaW5hbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBvcmlnaW5hbExpbmVzWzBdLmxlbmd0aCA9PT0gMCB8fCBtb2RpZmllZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBtb2RpZmllZExpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVzRGlmZihbXHJcbiAgICAgICAgICAgICAgICBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKG5ldyBMaW5lUmFuZ2UoMSwgb3JpZ2luYWxMaW5lcy5sZW5ndGggKyAxKSwgbmV3IExpbmVSYW5nZSgxLCBtb2RpZmllZExpbmVzLmxlbmd0aCArIDEpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlTWFwcGluZyhuZXcgUmFuZ2UoMSwgMSwgb3JpZ2luYWxMaW5lcy5sZW5ndGgsIG9yaWdpbmFsTGluZXNbb3JpZ2luYWxMaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAxKSwgbmV3IFJhbmdlKDEsIDEsIG1vZGlmaWVkTGluZXMubGVuZ3RoLCBtb2RpZmllZExpbmVzW21vZGlmaWVkTGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoICsgMSkpXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdLCBbXSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy5tYXhDb21wdXRhdGlvblRpbWVNcyA9PT0gMCA/IEluZmluaXRlVGltZW91dC5pbnN0YW5jZSA6IG5ldyBEYXRlVGltZW91dChvcHRpb25zLm1heENvbXB1dGF0aW9uVGltZU1zKTtcclxuICAgICAgICBjb25zdCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzID0gIW9wdGlvbnMuaWdub3JlVHJpbVdoaXRlc3BhY2U7XHJcbiAgICAgICAgY29uc3QgcGVyZmVjdEhhc2hlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBmdW5jdGlvbiBnZXRPckNyZWF0ZUhhc2godGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgaGFzaCA9IHBlcmZlY3RIYXNoZXMuZ2V0KHRleHQpO1xyXG4gICAgICAgICAgICBpZiAoaGFzaCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNoID0gcGVyZmVjdEhhc2hlcy5zaXplO1xyXG4gICAgICAgICAgICAgICAgcGVyZmVjdEhhc2hlcy5zZXQodGV4dCwgaGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZXNIYXNoZXMgPSBvcmlnaW5hbExpbmVzLm1hcCgobCkgPT4gZ2V0T3JDcmVhdGVIYXNoKGwudHJpbSgpKSk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lc0hhc2hlcyA9IG1vZGlmaWVkTGluZXMubWFwKChsKSA9PiBnZXRPckNyZWF0ZUhhc2gobC50cmltKCkpKTtcclxuICAgICAgICBjb25zdCBzZXF1ZW5jZTEgPSBuZXcgTGluZVNlcXVlbmNlKG9yaWdpbmFsTGluZXNIYXNoZXMsIG9yaWdpbmFsTGluZXMpO1xyXG4gICAgICAgIGNvbnN0IHNlcXVlbmNlMiA9IG5ldyBMaW5lU2VxdWVuY2UobW9kaWZpZWRMaW5lc0hhc2hlcywgbW9kaWZpZWRMaW5lcyk7XHJcbiAgICAgICAgY29uc3QgbGluZUFsaWdubWVudFJlc3VsdCA9ICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZTEubGVuZ3RoICsgc2VxdWVuY2UyLmxlbmd0aCA8IDE3MDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgaW1wcm92ZWQgYWxnb3JpdGhtIGZvciBzbWFsbCBmaWxlc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHluYW1pY1Byb2dyYW1taW5nRGlmZmluZy5jb21wdXRlKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCB0aW1lb3V0LCAob2Zmc2V0MSwgb2Zmc2V0MikgPT4gb3JpZ2luYWxMaW5lc1tvZmZzZXQxXSA9PT0gbW9kaWZpZWRMaW5lc1tvZmZzZXQyXVxyXG4gICAgICAgICAgICAgICAgICAgID8gbW9kaWZpZWRMaW5lc1tvZmZzZXQyXS5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAwLjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxICsgTWF0aC5sb2coMSArIG1vZGlmaWVkTGluZXNbb2Zmc2V0Ml0ubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogMC45OSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXllcnNEaWZmaW5nQWxnb3JpdGhtLmNvbXB1dGUoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHRpbWVvdXQpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgbGV0IGxpbmVBbGlnbm1lbnRzID0gbGluZUFsaWdubWVudFJlc3VsdC5kaWZmcztcclxuICAgICAgICBsZXQgaGl0VGltZW91dCA9IGxpbmVBbGlnbm1lbnRSZXN1bHQuaGl0VGltZW91dDtcclxuICAgICAgICBsaW5lQWxpZ25tZW50cyA9IG9wdGltaXplU2VxdWVuY2VEaWZmcyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgbGluZUFsaWdubWVudHMpO1xyXG4gICAgICAgIGxpbmVBbGlnbm1lbnRzID0gcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdMaW5lc0JldHdlZW5EaWZmcyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgbGluZUFsaWdubWVudHMpO1xyXG4gICAgICAgIGNvbnN0IGFsaWdubWVudHMgPSBbXTtcclxuICAgICAgICBjb25zdCBzY2FuRm9yV2hpdGVzcGFjZUNoYW5nZXMgPSAoZXF1YWxMaW5lc0NvdW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXF1YWxMaW5lc0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcTFPZmZzZXQgPSBzZXExTGFzdFN0YXJ0ICsgaTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcTJPZmZzZXQgPSBzZXEyTGFzdFN0YXJ0ICsgaTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbExpbmVzW3NlcTFPZmZzZXRdICE9PSBtb2RpZmllZExpbmVzW3NlcTJPZmZzZXRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIG9mIHdoaXRlc3BhY2UgY2hhbmdlcywgZGlmZiB0aGVzZSBsaW5lc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlckRpZmZzID0gdGhpcy5yZWZpbmVEaWZmKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG5ldyBTZXF1ZW5jZURpZmYobmV3IE9mZnNldFJhbmdlKHNlcTFPZmZzZXQsIHNlcTFPZmZzZXQgKyAxKSwgbmV3IE9mZnNldFJhbmdlKHNlcTJPZmZzZXQsIHNlcTJPZmZzZXQgKyAxKSksIHRpbWVvdXQsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBjaGFyYWN0ZXJEaWZmcy5tYXBwaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJEaWZmcy5oaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHNlcTFMYXN0U3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBzZXEyTGFzdFN0YXJ0ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGRpZmYgb2YgbGluZUFsaWdubWVudHMpIHtcclxuICAgICAgICAgICAgYXNzZXJ0Rm4oKCkgPT4gZGlmZi5zZXExUmFuZ2Uuc3RhcnQgLSBzZXExTGFzdFN0YXJ0ID09PSBkaWZmLnNlcTJSYW5nZS5zdGFydCAtIHNlcTJMYXN0U3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCBlcXVhbExpbmVzQ291bnQgPSBkaWZmLnNlcTFSYW5nZS5zdGFydCAtIHNlcTFMYXN0U3RhcnQ7XHJcbiAgICAgICAgICAgIHNjYW5Gb3JXaGl0ZXNwYWNlQ2hhbmdlcyhlcXVhbExpbmVzQ291bnQpO1xyXG4gICAgICAgICAgICBzZXExTGFzdFN0YXJ0ID0gZGlmZi5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlO1xyXG4gICAgICAgICAgICBzZXEyTGFzdFN0YXJ0ID0gZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlO1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJEaWZmcyA9IHRoaXMucmVmaW5lRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBkaWZmLCB0aW1lb3V0LCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJhY3RlckRpZmZzLmhpdFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBjaGFyYWN0ZXJEaWZmcy5tYXBwaW5ncykge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50cy5wdXNoKGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjYW5Gb3JXaGl0ZXNwYWNlQ2hhbmdlcyhvcmlnaW5hbExpbmVzLmxlbmd0aCAtIHNlcTFMYXN0U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBsaW5lUmFuZ2VNYXBwaW5nRnJvbVJhbmdlTWFwcGluZ3MoYWxpZ25tZW50cywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcyk7XHJcbiAgICAgICAgbGV0IG1vdmVzID0gW107XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcHV0ZU1vdmVzKSB7XHJcbiAgICAgICAgICAgIG1vdmVzID0gdGhpcy5jb21wdXRlTW92ZXMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3JpZ2luYWxMaW5lc0hhc2hlcywgbW9kaWZpZWRMaW5lc0hhc2hlcywgdGltZW91dCwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgcmFuZ2VzIGFyZSB2YWxpZFxyXG4gICAgICAgIGFzc2VydEZuKCgpID0+IHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGlvbihwb3MsIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmVOdW1iZXIgPCAxIHx8IHBvcy5saW5lTnVtYmVyID4gbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3Bvcy5saW5lTnVtYmVyIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zLmNvbHVtbiA8IDEgfHwgcG9zLmNvbHVtbiA+IGxpbmUubGVuZ3RoICsgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2UocmFuZ2UsIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgMSB8fCByYW5nZS5zdGFydExpbmVOdW1iZXIgPiBsaW5lcy5sZW5ndGggKyAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPCAxIHx8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPiBsaW5lcy5sZW5ndGggKyAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYy5pbm5lckNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGljIG9mIGMuaW5uZXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB2YWxpZGF0ZVBvc2l0aW9uKGljLm1vZGlmaWVkUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpLCBtb2RpZmllZExpbmVzKSAmJiB2YWxpZGF0ZVBvc2l0aW9uKGljLm1vZGlmaWVkUmFuZ2UuZ2V0RW5kUG9zaXRpb24oKSwgbW9kaWZpZWRMaW5lcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQb3NpdGlvbihpYy5vcmlnaW5hbFJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSwgb3JpZ2luYWxMaW5lcykgJiYgdmFsaWRhdGVQb3NpdGlvbihpYy5vcmlnaW5hbFJhbmdlLmdldEVuZFBvc2l0aW9uKCksIG9yaWdpbmFsTGluZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVSYW5nZShjLm1vZGlmaWVkLCBtb2RpZmllZExpbmVzKSB8fCAhdmFsaWRhdGVSYW5nZShjLm9yaWdpbmFsLCBvcmlnaW5hbExpbmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmVzRGlmZihjaGFuZ2VzLCBtb3ZlcywgaGl0VGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlTW92ZXMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgaGFzaGVkT3JpZ2luYWxMaW5lcywgaGFzaGVkTW9kaWZpZWRMaW5lcywgdGltZW91dCwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IG1vdmVzID0gY29tcHV0ZU1vdmVkTGluZXMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgaGFzaGVkT3JpZ2luYWxMaW5lcywgaGFzaGVkTW9kaWZpZWRMaW5lcywgdGltZW91dCk7XHJcbiAgICAgICAgY29uc3QgbW92ZXNXaXRoRGlmZnMgPSBtb3Zlcy5tYXAobSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVDaGFuZ2VzID0gdGhpcy5yZWZpbmVEaWZmKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG5ldyBTZXF1ZW5jZURpZmYobS5vcmlnaW5hbC50b09mZnNldFJhbmdlKCksIG0ubW9kaWZpZWQudG9PZmZzZXRSYW5nZSgpKSwgdGltZW91dCwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmdzID0gbGluZVJhbmdlTWFwcGluZ0Zyb21SYW5nZU1hcHBpbmdzKG1vdmVDaGFuZ2VzLm1hcHBpbmdzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3ZlZFRleHQobSwgbWFwcGluZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtb3Zlc1dpdGhEaWZmcztcclxuICAgIH1cclxuICAgIHJlZmluZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgZGlmZiwgdGltZW91dCwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IHNsaWNlMSA9IG5ldyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlKG9yaWdpbmFsTGluZXMsIGRpZmYuc2VxMVJhbmdlLCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKTtcclxuICAgICAgICBjb25zdCBzbGljZTIgPSBuZXcgTGluZXNTbGljZUNoYXJTZXF1ZW5jZShtb2RpZmllZExpbmVzLCBkaWZmLnNlcTJSYW5nZSwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XHJcbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IHNsaWNlMS5sZW5ndGggKyBzbGljZTIubGVuZ3RoIDwgNTAwXHJcbiAgICAgICAgICAgID8gdGhpcy5keW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nLmNvbXB1dGUoc2xpY2UxLCBzbGljZTIsIHRpbWVvdXQpXHJcbiAgICAgICAgICAgIDogdGhpcy5teWVyc0RpZmZpbmdBbGdvcml0aG0uY29tcHV0ZShzbGljZTEsIHNsaWNlMiwgdGltZW91dCk7XHJcbiAgICAgICAgbGV0IGRpZmZzID0gZGlmZlJlc3VsdC5kaWZmcztcclxuICAgICAgICBkaWZmcyA9IG9wdGltaXplU2VxdWVuY2VEaWZmcyhzbGljZTEsIHNsaWNlMiwgZGlmZnMpO1xyXG4gICAgICAgIGRpZmZzID0gZXh0ZW5kRGlmZnNUb0VudGlyZVdvcmRJZkFwcHJvcHJpYXRlKHNsaWNlMSwgc2xpY2UyLCBkaWZmcyk7XHJcbiAgICAgICAgZGlmZnMgPSByZW1vdmVTaG9ydE1hdGNoZXMoc2xpY2UxLCBzbGljZTIsIGRpZmZzKTtcclxuICAgICAgICBkaWZmcyA9IHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nVGV4dEJldHdlZW5Mb25nRGlmZnMoc2xpY2UxLCBzbGljZTIsIGRpZmZzKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBkaWZmcy5tYXAoKGQpID0+IG5ldyBSYW5nZU1hcHBpbmcoc2xpY2UxLnRyYW5zbGF0ZVJhbmdlKGQuc2VxMVJhbmdlKSwgc2xpY2UyLnRyYW5zbGF0ZVJhbmdlKGQuc2VxMlJhbmdlKSkpO1xyXG4gICAgICAgIC8vIEFzc2VydDogcmVzdWx0IGFwcGxpZWQgb24gb3JpZ2luYWwgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGRpZmYgYXBwbGllZCB0byBvcmlnaW5hbFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1hcHBpbmdzOiByZXN1bHQsXHJcbiAgICAgICAgICAgIGhpdFRpbWVvdXQ6IGRpZmZSZXN1bHQuaGl0VGltZW91dCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBsaW5lUmFuZ2VNYXBwaW5nRnJvbVJhbmdlTWFwcGluZ3MoYWxpZ25tZW50cywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgZG9udEFzc2VydFN0YXJ0TGluZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGcgb2YgZ3JvdXBBZGphY2VudEJ5KGFsaWdubWVudHMubWFwKGEgPT4gZ2V0TGluZVJhbmdlTWFwcGluZyhhLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzKSksIChhMSwgYTIpID0+IGExLm9yaWdpbmFsLm92ZXJsYXBPclRvdWNoKGEyLm9yaWdpbmFsKVxyXG4gICAgICAgIHx8IGExLm1vZGlmaWVkLm92ZXJsYXBPclRvdWNoKGEyLm1vZGlmaWVkKSkpIHtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IGdbMF07XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IGdbZy5sZW5ndGggLSAxXTtcclxuICAgICAgICBjaGFuZ2VzLnB1c2gobmV3IERldGFpbGVkTGluZVJhbmdlTWFwcGluZyhmaXJzdC5vcmlnaW5hbC5qb2luKGxhc3Qub3JpZ2luYWwpLCBmaXJzdC5tb2RpZmllZC5qb2luKGxhc3QubW9kaWZpZWQpLCBnLm1hcChhID0+IGEuaW5uZXJDaGFuZ2VzWzBdKSkpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0Rm4oKCkgPT4ge1xyXG4gICAgICAgIGlmICghZG9udEFzc2VydFN0YXJ0TGluZSAmJiBjaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZXNbMF0ubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyICE9PSBjaGFuZ2VzWzBdLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZExpbmVzLmxlbmd0aCAtIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICE9PSBvcmlnaW5hbExpbmVzLmxlbmd0aCAtIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRqYWNlbnRJdGVtcyhjaGFuZ2VzLCAobTEsIG0yKSA9PiBtMi5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSBtMS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID09PSBtMi5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBtMS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICYmXHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGhhcyB0byBiZSBhbiB1bmNoYW5nZWQgbGluZSBpbiBiZXR3ZWVuIChvdGhlcndpc2UgYm90aCBkaWZmcyBzaG91bGQgaGF2ZSBiZWVuIGpvaW5lZClcclxuICAgICAgICAgICAgbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAmJlxyXG4gICAgICAgICAgICBtMS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIDwgbTIubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNoYW5nZXM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExpbmVSYW5nZU1hcHBpbmcocmFuZ2VNYXBwaW5nLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzKSB7XHJcbiAgICBsZXQgbGluZVN0YXJ0RGVsdGEgPSAwO1xyXG4gICAgbGV0IGxpbmVFbmREZWx0YSA9IDA7XHJcbiAgICAvLyByYW5nZU1hcHBpbmcgZGVzY3JpYmVzIHRoZSBlZGl0IHRoYXQgcmVwbGFjZXMgYHJhbmdlTWFwcGluZy5vcmlnaW5hbFJhbmdlYCB3aXRoIGBuZXdUZXh0IDo9IGdldFRleHQobW9kaWZpZWRMaW5lcywgcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2UpYC5cclxuICAgIC8vIG9yaWdpbmFsOiBdeHh4IFxcbiA8LSB0aGlzIGxpbmUgaXMgbm90IG1vZGlmaWVkXHJcbiAgICAvLyBtb2RpZmllZDogXXh4ICBcXG5cclxuICAgIGlmIChyYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5lbmRDb2x1bW4gPT09IDEgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2UuZW5kQ29sdW1uID09PSAxXHJcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICsgbGluZVN0YXJ0RGVsdGEgPD0gcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2UuZW5kTGluZU51bWJlclxyXG4gICAgICAgICYmIHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLnN0YXJ0TGluZU51bWJlciArIGxpbmVTdGFydERlbHRhIDw9IHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAvLyBXZSBjYW4gb25seSBkbyB0aGlzIGlmIHRoZSByYW5nZSBpcyBub3QgZW1wdHkgeWV0XHJcbiAgICAgICAgbGluZUVuZERlbHRhID0gLTE7XHJcbiAgICB9XHJcbiAgICAvLyBvcmlnaW5hbDogeHh4WyBcXG4gPC0gdGhpcyBsaW5lIGlzIG5vdCBtb2RpZmllZFxyXG4gICAgLy8gbW9kaWZpZWQ6IHh4eFsgXFxuXHJcbiAgICBpZiAocmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxID49IG1vZGlmaWVkTGluZXNbcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0ubGVuZ3RoXHJcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxID49IG9yaWdpbmFsTGluZXNbcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0ubGVuZ3RoXHJcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDw9IHJhbmdlTWFwcGluZy5vcmlnaW5hbFJhbmdlLmVuZExpbmVOdW1iZXIgKyBsaW5lRW5kRGVsdGFcclxuICAgICAgICAmJiByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5zdGFydExpbmVOdW1iZXIgPD0gcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlciArIGxpbmVFbmREZWx0YSkge1xyXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRvIHRoaXMgaWYgdGhlIHJhbmdlIGlzIG5vdCBlbXB0eSB5ZXRcclxuICAgICAgICBsaW5lU3RhcnREZWx0YSA9IDE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcmlnaW5hbExpbmVSYW5nZSA9IG5ldyBMaW5lUmFuZ2UocmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICsgbGluZVN0YXJ0RGVsdGEsIHJhbmdlTWFwcGluZy5vcmlnaW5hbFJhbmdlLmVuZExpbmVOdW1iZXIgKyAxICsgbGluZUVuZERlbHRhKTtcclxuICAgIGNvbnN0IG1vZGlmaWVkTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShyYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSwgcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlciArIDEgKyBsaW5lRW5kRGVsdGEpO1xyXG4gICAgcmV0dXJuIG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcob3JpZ2luYWxMaW5lUmFuZ2UsIG1vZGlmaWVkTGluZVJhbmdlLCBbcmFuZ2VNYXBwaW5nXSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendDiffsToEntireWordIfAppropriate: () => (/* binding */ extendDiffsToEntireWordIfAppropriate),\n/* harmony export */   optimizeSequenceDiffs: () => (/* binding */ optimizeSequenceDiffs),\n/* harmony export */   removeShortMatches: () => (/* binding */ removeShortMatches),\n/* harmony export */   removeVeryShortMatchingLinesBetweenDiffs: () => (/* binding */ removeVeryShortMatchingLinesBetweenDiffs),\n/* harmony export */   removeVeryShortMatchingTextBetweenLongDiffs: () => (/* binding */ removeVeryShortMatchingTextBetweenLongDiffs)\n/* harmony export */ });\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./algorithms/diffAlgorithm.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nfunction optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\r\n    let result = sequenceDiffs;\r\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\r\n    // Sometimes, calling this function twice improves the result.\r\n    // Uncomment the second invocation and run the tests to see the difference.\r\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\r\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\r\n    return result;\r\n}\r\n/**\r\n * This function fixes issues like this:\r\n * ```\r\n * import { Baz, Bar } from \"foo\";\r\n * ```\r\n * <->\r\n * ```\r\n * import { Baz, Bar, Foo } from \"foo\";\r\n * ```\r\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\r\n * Improved diff: [{Add \", Foo\" after Bar}]\r\n */\r\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\r\n    if (sequenceDiffs.length === 0) {\r\n        return sequenceDiffs;\r\n    }\r\n    const result = [];\r\n    result.push(sequenceDiffs[0]);\r\n    // First move them all to the left as much as possible and join them if possible\r\n    for (let i = 1; i < sequenceDiffs.length; i++) {\r\n        const prevResult = result[result.length - 1];\r\n        let cur = sequenceDiffs[i];\r\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\r\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\r\n            let d;\r\n            for (d = 1; d <= length; d++) {\r\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\r\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\r\n                    break;\r\n                }\r\n            }\r\n            d--;\r\n            if (d === length) {\r\n                // Merge previous and current diff\r\n                result[result.length - 1] = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\r\n                continue;\r\n            }\r\n            cur = cur.delta(-d);\r\n        }\r\n        result.push(cur);\r\n    }\r\n    const result2 = [];\r\n    // Then move them all to the right and join them again if possible\r\n    for (let i = 0; i < result.length - 1; i++) {\r\n        const nextResult = result[i + 1];\r\n        let cur = result[i];\r\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\r\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\r\n            let d;\r\n            for (d = 0; d < length; d++) {\r\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\r\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\r\n                    break;\r\n                }\r\n            }\r\n            if (d === length) {\r\n                // Merge previous and current diff, write to result!\r\n                result[i + 1] = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\r\n                continue;\r\n            }\r\n            if (d > 0) {\r\n                cur = cur.delta(d);\r\n            }\r\n        }\r\n        result2.push(cur);\r\n    }\r\n    if (result.length > 0) {\r\n        result2.push(result[result.length - 1]);\r\n    }\r\n    return result2;\r\n}\r\n// align character level diffs at whitespace characters\r\n// import { IBar } from \"foo\";\r\n// import { I[Arr, I]Bar } from \"foo\";\r\n// ->\r\n// import { [IArr, ]IBar } from \"foo\";\r\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\r\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\r\n// ->\r\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\r\n// collectBrackets(level + 1, levelPerBracketType);\r\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\r\n// ->\r\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\r\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\r\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\r\n        return sequenceDiffs;\r\n    }\r\n    for (let i = 0; i < sequenceDiffs.length; i++) {\r\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\r\n        const diff = sequenceDiffs[i];\r\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\r\n        const seq1ValidRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\r\n        const seq2ValidRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\r\n        if (diff.seq1Range.isEmpty) {\r\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\r\n        }\r\n        else if (diff.seq2Range.isEmpty) {\r\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\r\n        }\r\n    }\r\n    return sequenceDiffs;\r\n}\r\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\r\n    const maxShiftLimit = 100; // To prevent performance issues\r\n    // don't touch previous or next!\r\n    let deltaBefore = 1;\r\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\r\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\r\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\r\n        deltaBefore++;\r\n    }\r\n    deltaBefore--;\r\n    let deltaAfter = 0;\r\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\r\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\r\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\r\n        deltaAfter++;\r\n    }\r\n    if (deltaBefore === 0 && deltaAfter === 0) {\r\n        return diff;\r\n    }\r\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\r\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\r\n    let bestDelta = 0;\r\n    let bestScore = -1;\r\n    // find best scored delta\r\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\r\n        const seq2OffsetStart = diff.seq2Range.start + delta;\r\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\r\n        const seq1Offset = diff.seq1Range.start + delta;\r\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\r\n        if (score > bestScore) {\r\n            bestScore = score;\r\n            bestDelta = delta;\r\n        }\r\n    }\r\n    return diff.delta(bestDelta);\r\n}\r\nfunction removeShortMatches(sequence1, sequence2, sequenceDiffs) {\r\n    const result = [];\r\n    for (const s of sequenceDiffs) {\r\n        const last = result[result.length - 1];\r\n        if (!last) {\r\n            result.push(s);\r\n            continue;\r\n        }\r\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\r\n            result[result.length - 1] = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\r\n        }\r\n        else {\r\n            result.push(s);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\r\n    const equalMappings = _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff.invert(sequenceDiffs, sequence1.length);\r\n    const additional = [];\r\n    let lastPoint = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.OffsetPair(0, 0);\r\n    function scanWord(pair, equalMapping) {\r\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\r\n            return;\r\n        }\r\n        const w1 = sequence1.findWordContaining(pair.offset1);\r\n        const w2 = sequence2.findWordContaining(pair.offset2);\r\n        if (!w1 || !w2) {\r\n            return;\r\n        }\r\n        let w = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(w1, w2);\r\n        const equalPart = w.intersect(equalMapping);\r\n        let equalChars1 = equalPart.seq1Range.length;\r\n        let equalChars2 = equalPart.seq2Range.length;\r\n        // The words do not touch previous equals mappings, as we would have processed them already.\r\n        // But they might touch the next ones.\r\n        while (equalMappings.length > 0) {\r\n            const next = equalMappings[0];\r\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\r\n            if (!intersects) {\r\n                break;\r\n            }\r\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\r\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\r\n            // Because there is an intersection, we know that the words are not empty.\r\n            const v = new _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff(v1, v2);\r\n            const equalPart = v.intersect(next);\r\n            equalChars1 += equalPart.seq1Range.length;\r\n            equalChars2 += equalPart.seq2Range.length;\r\n            w = w.join(v);\r\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\r\n                // The word extends beyond the next equal mapping.\r\n                equalMappings.shift();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\r\n            additional.push(w);\r\n        }\r\n        lastPoint = w.getEndExclusives();\r\n    }\r\n    while (equalMappings.length > 0) {\r\n        const next = equalMappings.shift();\r\n        if (next.seq1Range.isEmpty) {\r\n            continue;\r\n        }\r\n        scanWord(next.getStarts(), next);\r\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\r\n        scanWord(next.getEndExclusives().delta(-1), next);\r\n    }\r\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\r\n    return merged;\r\n}\r\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\r\n    const result = [];\r\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\r\n        const sd1 = sequenceDiffs1[0];\r\n        const sd2 = sequenceDiffs2[0];\r\n        let next;\r\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\r\n            next = sequenceDiffs1.shift();\r\n        }\r\n        else {\r\n            next = sequenceDiffs2.shift();\r\n        }\r\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\r\n            result[result.length - 1] = result[result.length - 1].join(next);\r\n        }\r\n        else {\r\n            result.push(next);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\r\n    let diffs = sequenceDiffs;\r\n    if (diffs.length === 0) {\r\n        return diffs;\r\n    }\r\n    let counter = 0;\r\n    let shouldRepeat;\r\n    do {\r\n        shouldRepeat = false;\r\n        const result = [\r\n            diffs[0]\r\n        ];\r\n        for (let i = 1; i < diffs.length; i++) {\r\n            const cur = diffs[i];\r\n            const lastResult = result[result.length - 1];\r\n            function shouldJoinDiffs(before, after) {\r\n                const unchangedRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\r\n                const unchangedText = sequence1.getText(unchangedRange);\r\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\r\n                if (unchangedTextWithoutWs.length <= 4\r\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\r\n            if (shouldJoin) {\r\n                shouldRepeat = true;\r\n                result[result.length - 1] = result[result.length - 1].join(cur);\r\n            }\r\n            else {\r\n                result.push(cur);\r\n            }\r\n        }\r\n        diffs = result;\r\n    } while (counter++ < 10 && shouldRepeat);\r\n    return diffs;\r\n}\r\nfunction removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\r\n    let diffs = sequenceDiffs;\r\n    if (diffs.length === 0) {\r\n        return diffs;\r\n    }\r\n    let counter = 0;\r\n    let shouldRepeat;\r\n    do {\r\n        shouldRepeat = false;\r\n        const result = [\r\n            diffs[0]\r\n        ];\r\n        for (let i = 1; i < diffs.length; i++) {\r\n            const cur = diffs[i];\r\n            const lastResult = result[result.length - 1];\r\n            function shouldJoinDiffs(before, after) {\r\n                const unchangedRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\r\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\r\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\r\n                    return false;\r\n                }\r\n                const unchangedText = sequence1.getText(unchangedRange).trim();\r\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\r\n                    return false;\r\n                }\r\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\r\n                const beforeSeq1Length = before.seq1Range.length;\r\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\r\n                const beforeSeq2Length = before.seq2Range.length;\r\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\r\n                const afterSeq1Length = after.seq1Range.length;\r\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\r\n                const afterSeq2Length = after.seq2Range.length;\r\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\r\n                const max = 2 * 40 + 50;\r\n                function cap(v) {\r\n                    return Math.min(v, max);\r\n                }\r\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\r\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\r\n            if (shouldJoin) {\r\n                shouldRepeat = true;\r\n                result[result.length - 1] = result[result.length - 1].join(cur);\r\n            }\r\n            else {\r\n                result.push(cur);\r\n            }\r\n        }\r\n        diffs = result;\r\n    } while (counter++ < 10 && shouldRepeat);\r\n    const newDiffs = [];\r\n    // Remove short suffixes/prefixes\r\n    (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.forEachWithNeighbors)(diffs, (prev, cur, next) => {\r\n        let newDiff = cur;\r\n        function shouldMarkAsChanged(text) {\r\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\r\n        }\r\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\r\n        const prefix = sequence1.getText(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(fullRange1.start, cur.seq1Range.start));\r\n        if (shouldMarkAsChanged(prefix)) {\r\n            newDiff = newDiff.deltaStart(-prefix.length);\r\n        }\r\n        const suffix = sequence1.getText(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\r\n        if (shouldMarkAsChanged(suffix)) {\r\n            newDiff = newDiff.deltaEnd(suffix.length);\r\n        }\r\n        const availableSpace = _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.OffsetPair.zero, next ? next.getStarts() : _algorithms_diffAlgorithm_js__WEBPACK_IMPORTED_MODULE_2__.OffsetPair.max);\r\n        const result = newDiff.intersect(availableSpace);\r\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\r\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\r\n        }\r\n        else {\r\n            newDiffs.push(result);\r\n        }\r\n    });\r\n    return newDiffs;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9oZXVyaXN0aWNTZXF1ZW5jZU9wdGltaXphdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUNqQjtBQUNpQjtBQUNsRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxxQkFBcUIsa0JBQWtCLEdBQUc7QUFDMUMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzRUFBWSxLQUFLLDZEQUFXLHVFQUF1RSw2REFBVztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0VBQVksS0FBSyw2REFBVyx1RUFBdUUsNkRBQVc7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSw2Q0FBNkM7QUFDekQsWUFBWSxvRUFBb0U7QUFDaEY7QUFDQSxZQUFZLG9FQUFvRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkRBQVc7QUFDOUMsbUNBQW1DLDZEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNFQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwwQkFBMEIsc0VBQVk7QUFDdEM7QUFDQSx3QkFBd0Isb0VBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNFQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZEQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNkRBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUksNEVBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkRBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzRUFBWSxrREFBa0Qsb0VBQVUsaUNBQWlDLG9FQUFVO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9oZXVyaXN0aWNTZXF1ZW5jZU9wdGltaXphdGlvbnMuanM/MGRkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgZm9yRWFjaFdpdGhOZWlnaGJvcnMgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xyXG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBPZmZzZXRQYWlyLCBTZXF1ZW5jZURpZmYgfSBmcm9tICcuL2FsZ29yaXRobXMvZGlmZkFsZ29yaXRobS5qcyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZVNlcXVlbmNlRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcclxuICAgIGxldCByZXN1bHQgPSBzZXF1ZW5jZURpZmZzO1xyXG4gICAgcmVzdWx0ID0gam9pblNlcXVlbmNlRGlmZnNCeVNoaWZ0aW5nKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCByZXN1bHQpO1xyXG4gICAgLy8gU29tZXRpbWVzLCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gdHdpY2UgaW1wcm92ZXMgdGhlIHJlc3VsdC5cclxuICAgIC8vIFVuY29tbWVudCB0aGUgc2Vjb25kIGludm9jYXRpb24gYW5kIHJ1biB0aGUgdGVzdHMgdG8gc2VlIHRoZSBkaWZmZXJlbmNlLlxyXG4gICAgcmVzdWx0ID0gam9pblNlcXVlbmNlRGlmZnNCeVNoaWZ0aW5nKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCByZXN1bHQpO1xyXG4gICAgcmVzdWx0ID0gc2hpZnRTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBmaXhlcyBpc3N1ZXMgbGlrZSB0aGlzOlxyXG4gKiBgYGBcclxuICogaW1wb3J0IHsgQmF6LCBCYXIgfSBmcm9tIFwiZm9vXCI7XHJcbiAqIGBgYFxyXG4gKiA8LT5cclxuICogYGBgXHJcbiAqIGltcG9ydCB7IEJheiwgQmFyLCBGb28gfSBmcm9tIFwiZm9vXCI7XHJcbiAqIGBgYFxyXG4gKiBDb21wdXRlZCBkaWZmOiBbIHtBZGQgXCIsXCIgYWZ0ZXIgQmFyfSwge0FkZCBcIkZvbyBcIiBhZnRlciBzcGFjZX0gfVxyXG4gKiBJbXByb3ZlZCBkaWZmOiBbe0FkZCBcIiwgRm9vXCIgYWZ0ZXIgQmFyfV1cclxuICovXHJcbmZ1bmN0aW9uIGpvaW5TZXF1ZW5jZURpZmZzQnlTaGlmdGluZyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xyXG4gICAgaWYgKHNlcXVlbmNlRGlmZnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlRGlmZnM7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIHJlc3VsdC5wdXNoKHNlcXVlbmNlRGlmZnNbMF0pO1xyXG4gICAgLy8gRmlyc3QgbW92ZSB0aGVtIGFsbCB0byB0aGUgbGVmdCBhcyBtdWNoIGFzIHBvc3NpYmxlIGFuZCBqb2luIHRoZW0gaWYgcG9zc2libGVcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VxdWVuY2VEaWZmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByZXZSZXN1bHQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGxldCBjdXIgPSBzZXF1ZW5jZURpZmZzW2ldO1xyXG4gICAgICAgIGlmIChjdXIuc2VxMVJhbmdlLmlzRW1wdHkgfHwgY3VyLnNlcTJSYW5nZS5pc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGN1ci5zZXExUmFuZ2Uuc3RhcnQgLSBwcmV2UmVzdWx0LnNlcTFSYW5nZS5lbmRFeGNsdXNpdmU7XHJcbiAgICAgICAgICAgIGxldCBkO1xyXG4gICAgICAgICAgICBmb3IgKGQgPSAxOyBkIDw9IGxlbmd0aDsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UxLmdldEVsZW1lbnQoY3VyLnNlcTFSYW5nZS5zdGFydCAtIGQpICE9PSBzZXF1ZW5jZTEuZ2V0RWxlbWVudChjdXIuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyLmdldEVsZW1lbnQoY3VyLnNlcTJSYW5nZS5zdGFydCAtIGQpICE9PSBzZXF1ZW5jZTIuZ2V0RWxlbWVudChjdXIuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZC0tO1xyXG4gICAgICAgICAgICBpZiAoZCA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwcmV2aW91cyBhbmQgY3VycmVudCBkaWZmXHJcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gbmV3IFNlcXVlbmNlRGlmZihuZXcgT2Zmc2V0UmFuZ2UocHJldlJlc3VsdC5zZXExUmFuZ2Uuc3RhcnQsIGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlIC0gbGVuZ3RoKSwgbmV3IE9mZnNldFJhbmdlKHByZXZSZXN1bHQuc2VxMlJhbmdlLnN0YXJ0LCBjdXIuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyID0gY3VyLmRlbHRhKC1kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2goY3VyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdDIgPSBbXTtcclxuICAgIC8vIFRoZW4gbW92ZSB0aGVtIGFsbCB0byB0aGUgcmlnaHQgYW5kIGpvaW4gdGhlbSBhZ2FpbiBpZiBwb3NzaWJsZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dFJlc3VsdCA9IHJlc3VsdFtpICsgMV07XHJcbiAgICAgICAgbGV0IGN1ciA9IHJlc3VsdFtpXTtcclxuICAgICAgICBpZiAoY3VyLnNlcTFSYW5nZS5pc0VtcHR5IHx8IGN1ci5zZXEyUmFuZ2UuaXNFbXB0eSkge1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBuZXh0UmVzdWx0LnNlcTFSYW5nZS5zdGFydCAtIGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlO1xyXG4gICAgICAgICAgICBsZXQgZDtcclxuICAgICAgICAgICAgZm9yIChkID0gMDsgZCA8IGxlbmd0aDsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlcXVlbmNlMS5pc1N0cm9uZ2x5RXF1YWwoY3VyLnNlcTFSYW5nZS5zdGFydCArIGQsIGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlICsgZCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAhc2VxdWVuY2UyLmlzU3Ryb25nbHlFcXVhbChjdXIuc2VxMlJhbmdlLnN0YXJ0ICsgZCwgY3VyLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgKyBkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHByZXZpb3VzIGFuZCBjdXJyZW50IGRpZmYsIHdyaXRlIHRvIHJlc3VsdCFcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpICsgMV0gPSBuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShjdXIuc2VxMVJhbmdlLnN0YXJ0ICsgbGVuZ3RoLCBuZXh0UmVzdWx0LnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUpLCBuZXcgT2Zmc2V0UmFuZ2UoY3VyLnNlcTJSYW5nZS5zdGFydCArIGxlbmd0aCwgbmV4dFJlc3VsdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlKSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5kZWx0YShkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQyLnB1c2goY3VyKTtcclxuICAgIH1cclxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQyO1xyXG59XHJcbi8vIGFsaWduIGNoYXJhY3RlciBsZXZlbCBkaWZmcyBhdCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcclxuLy8gaW1wb3J0IHsgSUJhciB9IGZyb20gXCJmb29cIjtcclxuLy8gaW1wb3J0IHsgSVtBcnIsIEldQmFyIH0gZnJvbSBcImZvb1wiO1xyXG4vLyAtPlxyXG4vLyBpbXBvcnQgeyBbSUFyciwgXUlCYXIgfSBmcm9tIFwiZm9vXCI7XHJcbi8vIGltcG9ydCB7IElUcmFuc2FjdGlvbiwgb2JzZXJ2YWJsZVZhbHVlLCB0cmFuc2FjdGlvbiB9IGZyb20gJ3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGUnO1xyXG4vLyBpbXBvcnQgeyBJVHJhbnNhY3Rpb24sIG9ic2VydmFibGVbRnJvbUV2ZW50LCBvYnNlcnZhYmxlXVZhbHVlLCB0cmFuc2FjdGlvbiB9IGZyb20gJ3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGUnO1xyXG4vLyAtPlxyXG4vLyBpbXBvcnQgeyBJVHJhbnNhY3Rpb24sIFtvYnNlcnZhYmxlRnJvbUV2ZW50LCBdb2JzZXJ2YWJsZVZhbHVlLCB0cmFuc2FjdGlvbiB9IGZyb20gJ3ZzL2Jhc2UvY29tbW9uL29ic2VydmFibGUnO1xyXG4vLyBjb2xsZWN0QnJhY2tldHMobGV2ZWwgKyAxLCBsZXZlbFBlckJyYWNrZXRUeXBlKTtcclxuLy8gY29sbGVjdEJyYWNrZXRzKGxldmVsICsgMSwgbGV2ZWxQZXJCcmFja2V0WyArIDEsIGxldmVsUGVyQnJhY2tldF1UeXBlKTtcclxuLy8gLT5cclxuLy8gY29sbGVjdEJyYWNrZXRzKGxldmVsICsgMSwgW2xldmVsUGVyQnJhY2tldCArIDEsIF1sZXZlbFBlckJyYWNrZXRUeXBlKTtcclxuZnVuY3Rpb24gc2hpZnRTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCBzZXF1ZW5jZURpZmZzKSB7XHJcbiAgICBpZiAoIXNlcXVlbmNlMS5nZXRCb3VuZGFyeVNjb3JlIHx8ICFzZXF1ZW5jZTIuZ2V0Qm91bmRhcnlTY29yZSkge1xyXG4gICAgICAgIHJldHVybiBzZXF1ZW5jZURpZmZzO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXF1ZW5jZURpZmZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJldkRpZmYgPSAoaSA+IDAgPyBzZXF1ZW5jZURpZmZzW2kgLSAxXSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IHNlcXVlbmNlRGlmZnNbaV07XHJcbiAgICAgICAgY29uc3QgbmV4dERpZmYgPSAoaSArIDEgPCBzZXF1ZW5jZURpZmZzLmxlbmd0aCA/IHNlcXVlbmNlRGlmZnNbaSArIDFdIDogdW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCBzZXExVmFsaWRSYW5nZSA9IG5ldyBPZmZzZXRSYW5nZShwcmV2RGlmZiA/IHByZXZEaWZmLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUgKyAxIDogMCwgbmV4dERpZmYgPyBuZXh0RGlmZi5zZXExUmFuZ2Uuc3RhcnQgLSAxIDogc2VxdWVuY2UxLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3Qgc2VxMlZhbGlkUmFuZ2UgPSBuZXcgT2Zmc2V0UmFuZ2UocHJldkRpZmYgPyBwcmV2RGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgMSA6IDAsIG5leHREaWZmID8gbmV4dERpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gMSA6IHNlcXVlbmNlMi5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChkaWZmLnNlcTFSYW5nZS5pc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHNlcXVlbmNlRGlmZnNbaV0gPSBzaGlmdERpZmZUb0JldHRlclBvc2l0aW9uKGRpZmYsIHNlcXVlbmNlMSwgc2VxdWVuY2UyLCBzZXExVmFsaWRSYW5nZSwgc2VxMlZhbGlkUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaWZmLnNlcTJSYW5nZS5pc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHNlcXVlbmNlRGlmZnNbaV0gPSBzaGlmdERpZmZUb0JldHRlclBvc2l0aW9uKGRpZmYuc3dhcCgpLCBzZXF1ZW5jZTIsIHNlcXVlbmNlMSwgc2VxMlZhbGlkUmFuZ2UsIHNlcTFWYWxpZFJhbmdlKS5zd2FwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcXVlbmNlRGlmZnM7XHJcbn1cclxuZnVuY3Rpb24gc2hpZnREaWZmVG9CZXR0ZXJQb3NpdGlvbihkaWZmLCBzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxMVZhbGlkUmFuZ2UsIHNlcTJWYWxpZFJhbmdlKSB7XHJcbiAgICBjb25zdCBtYXhTaGlmdExpbWl0ID0gMTAwOyAvLyBUbyBwcmV2ZW50IHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gICAgLy8gZG9uJ3QgdG91Y2ggcHJldmlvdXMgb3IgbmV4dCFcclxuICAgIGxldCBkZWx0YUJlZm9yZSA9IDE7XHJcbiAgICB3aGlsZSAoZGlmZi5zZXExUmFuZ2Uuc3RhcnQgLSBkZWx0YUJlZm9yZSA+PSBzZXExVmFsaWRSYW5nZS5zdGFydCAmJlxyXG4gICAgICAgIGRpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gZGVsdGFCZWZvcmUgPj0gc2VxMlZhbGlkUmFuZ2Uuc3RhcnQgJiZcclxuICAgICAgICBzZXF1ZW5jZTIuaXNTdHJvbmdseUVxdWFsKGRpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gZGVsdGFCZWZvcmUsIGRpZmYuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGRlbHRhQmVmb3JlKSAmJiBkZWx0YUJlZm9yZSA8IG1heFNoaWZ0TGltaXQpIHtcclxuICAgICAgICBkZWx0YUJlZm9yZSsrO1xyXG4gICAgfVxyXG4gICAgZGVsdGFCZWZvcmUtLTtcclxuICAgIGxldCBkZWx0YUFmdGVyID0gMDtcclxuICAgIHdoaWxlIChkaWZmLnNlcTFSYW5nZS5zdGFydCArIGRlbHRhQWZ0ZXIgPCBzZXExVmFsaWRSYW5nZS5lbmRFeGNsdXNpdmUgJiZcclxuICAgICAgICBkaWZmLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgKyBkZWx0YUFmdGVyIDwgc2VxMlZhbGlkUmFuZ2UuZW5kRXhjbHVzaXZlICYmXHJcbiAgICAgICAgc2VxdWVuY2UyLmlzU3Ryb25nbHlFcXVhbChkaWZmLnNlcTJSYW5nZS5zdGFydCArIGRlbHRhQWZ0ZXIsIGRpZmYuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSArIGRlbHRhQWZ0ZXIpICYmIGRlbHRhQWZ0ZXIgPCBtYXhTaGlmdExpbWl0KSB7XHJcbiAgICAgICAgZGVsdGFBZnRlcisrO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlbHRhQmVmb3JlID09PSAwICYmIGRlbHRhQWZ0ZXIgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgIH1cclxuICAgIC8vIFZpc3VhbGl6ZSBgW3NlcXVlbmNlMS50ZXh0LCBkaWZmLnNlcTFSYW5nZS5zdGFydCArIGRlbHRhQWZ0ZXJdYFxyXG4gICAgLy8gYW5kIGBbc2VxdWVuY2UyLnRleHQsIGRpZmYuc2VxMlJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlciwgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlcl1gXHJcbiAgICBsZXQgYmVzdERlbHRhID0gMDtcclxuICAgIGxldCBiZXN0U2NvcmUgPSAtMTtcclxuICAgIC8vIGZpbmQgYmVzdCBzY29yZWQgZGVsdGFcclxuICAgIGZvciAobGV0IGRlbHRhID0gLWRlbHRhQmVmb3JlOyBkZWx0YSA8PSBkZWx0YUFmdGVyOyBkZWx0YSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VxMk9mZnNldFN0YXJ0ID0gZGlmZi5zZXEyUmFuZ2Uuc3RhcnQgKyBkZWx0YTtcclxuICAgICAgICBjb25zdCBzZXEyT2Zmc2V0RW5kRXhjbHVzaXZlID0gZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGE7XHJcbiAgICAgICAgY29uc3Qgc2VxMU9mZnNldCA9IGRpZmYuc2VxMVJhbmdlLnN0YXJ0ICsgZGVsdGE7XHJcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBzZXF1ZW5jZTEuZ2V0Qm91bmRhcnlTY29yZShzZXExT2Zmc2V0KSArIHNlcXVlbmNlMi5nZXRCb3VuZGFyeVNjb3JlKHNlcTJPZmZzZXRTdGFydCkgKyBzZXF1ZW5jZTIuZ2V0Qm91bmRhcnlTY29yZShzZXEyT2Zmc2V0RW5kRXhjbHVzaXZlKTtcclxuICAgICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcclxuICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgIGJlc3REZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaWZmLmRlbHRhKGJlc3REZWx0YSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVNob3J0TWF0Y2hlcyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc2VxdWVuY2VEaWZmcykge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmICghbGFzdCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChzKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzLnNlcTFSYW5nZS5zdGFydCAtIGxhc3Quc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSA8PSAyIHx8IHMuc2VxMlJhbmdlLnN0YXJ0IC0gbGFzdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlIDw9IDIpIHtcclxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG5ldyBTZXF1ZW5jZURpZmYobGFzdC5zZXExUmFuZ2Uuam9pbihzLnNlcTFSYW5nZSksIGxhc3Quc2VxMlJhbmdlLmpvaW4ocy5zZXEyUmFuZ2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZERpZmZzVG9FbnRpcmVXb3JkSWZBcHByb3ByaWF0ZShzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xyXG4gICAgY29uc3QgZXF1YWxNYXBwaW5ncyA9IFNlcXVlbmNlRGlmZi5pbnZlcnQoc2VxdWVuY2VEaWZmcywgc2VxdWVuY2UxLmxlbmd0aCk7XHJcbiAgICBjb25zdCBhZGRpdGlvbmFsID0gW107XHJcbiAgICBsZXQgbGFzdFBvaW50ID0gbmV3IE9mZnNldFBhaXIoMCwgMCk7XHJcbiAgICBmdW5jdGlvbiBzY2FuV29yZChwYWlyLCBlcXVhbE1hcHBpbmcpIHtcclxuICAgICAgICBpZiAocGFpci5vZmZzZXQxIDwgbGFzdFBvaW50Lm9mZnNldDEgfHwgcGFpci5vZmZzZXQyIDwgbGFzdFBvaW50Lm9mZnNldDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB3MSA9IHNlcXVlbmNlMS5maW5kV29yZENvbnRhaW5pbmcocGFpci5vZmZzZXQxKTtcclxuICAgICAgICBjb25zdCB3MiA9IHNlcXVlbmNlMi5maW5kV29yZENvbnRhaW5pbmcocGFpci5vZmZzZXQyKTtcclxuICAgICAgICBpZiAoIXcxIHx8ICF3Mikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB3ID0gbmV3IFNlcXVlbmNlRGlmZih3MSwgdzIpO1xyXG4gICAgICAgIGNvbnN0IGVxdWFsUGFydCA9IHcuaW50ZXJzZWN0KGVxdWFsTWFwcGluZyk7XHJcbiAgICAgICAgbGV0IGVxdWFsQ2hhcnMxID0gZXF1YWxQYXJ0LnNlcTFSYW5nZS5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGVxdWFsQ2hhcnMyID0gZXF1YWxQYXJ0LnNlcTJSYW5nZS5sZW5ndGg7XHJcbiAgICAgICAgLy8gVGhlIHdvcmRzIGRvIG5vdCB0b3VjaCBwcmV2aW91cyBlcXVhbHMgbWFwcGluZ3MsIGFzIHdlIHdvdWxkIGhhdmUgcHJvY2Vzc2VkIHRoZW0gYWxyZWFkeS5cclxuICAgICAgICAvLyBCdXQgdGhleSBtaWdodCB0b3VjaCB0aGUgbmV4dCBvbmVzLlxyXG4gICAgICAgIHdoaWxlIChlcXVhbE1hcHBpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGVxdWFsTWFwcGluZ3NbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSBuZXh0LnNlcTFSYW5nZS5pbnRlcnNlY3RzKHcuc2VxMVJhbmdlKSB8fCBuZXh0LnNlcTJSYW5nZS5pbnRlcnNlY3RzKHcuc2VxMlJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKCFpbnRlcnNlY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2MSA9IHNlcXVlbmNlMS5maW5kV29yZENvbnRhaW5pbmcobmV4dC5zZXExUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCB2MiA9IHNlcXVlbmNlMi5maW5kV29yZENvbnRhaW5pbmcobmV4dC5zZXEyUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiwgd2Uga25vdyB0aGF0IHRoZSB3b3JkcyBhcmUgbm90IGVtcHR5LlxyXG4gICAgICAgICAgICBjb25zdCB2ID0gbmV3IFNlcXVlbmNlRGlmZih2MSwgdjIpO1xyXG4gICAgICAgICAgICBjb25zdCBlcXVhbFBhcnQgPSB2LmludGVyc2VjdChuZXh0KTtcclxuICAgICAgICAgICAgZXF1YWxDaGFyczEgKz0gZXF1YWxQYXJ0LnNlcTFSYW5nZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGVxdWFsQ2hhcnMyICs9IGVxdWFsUGFydC5zZXEyUmFuZ2UubGVuZ3RoO1xyXG4gICAgICAgICAgICB3ID0gdy5qb2luKHYpO1xyXG4gICAgICAgICAgICBpZiAody5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlID49IG5leHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHdvcmQgZXh0ZW5kcyBiZXlvbmQgdGhlIG5leHQgZXF1YWwgbWFwcGluZy5cclxuICAgICAgICAgICAgICAgIGVxdWFsTWFwcGluZ3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlcXVhbENoYXJzMSArIGVxdWFsQ2hhcnMyIDwgKHcuc2VxMVJhbmdlLmxlbmd0aCArIHcuc2VxMlJhbmdlLmxlbmd0aCkgKiAyIC8gMykge1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsLnB1c2godyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RQb2ludCA9IHcuZ2V0RW5kRXhjbHVzaXZlcygpO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGVxdWFsTWFwcGluZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSBlcXVhbE1hcHBpbmdzLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKG5leHQuc2VxMVJhbmdlLmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjYW5Xb3JkKG5leHQuZ2V0U3RhcnRzKCksIG5leHQpO1xyXG4gICAgICAgIC8vIFRoZSBlcXVhbCBwYXJ0cyBhcmUgbm90IGVtcHR5LCBzbyAtMSBnaXZlcyB1cyBhIGNoYXJhY3RlciB0aGF0IGlzIGVxdWFsIGluIGJvdGggcGFydHMuXHJcbiAgICAgICAgc2NhbldvcmQobmV4dC5nZXRFbmRFeGNsdXNpdmVzKCkuZGVsdGEoLTEpLCBuZXh0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlU2VxdWVuY2VEaWZmcyhzZXF1ZW5jZURpZmZzLCBhZGRpdGlvbmFsKTtcclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VTZXF1ZW5jZURpZmZzKHNlcXVlbmNlRGlmZnMxLCBzZXF1ZW5jZURpZmZzMikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICB3aGlsZSAoc2VxdWVuY2VEaWZmczEubGVuZ3RoID4gMCB8fCBzZXF1ZW5jZURpZmZzMi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3Qgc2QxID0gc2VxdWVuY2VEaWZmczFbMF07XHJcbiAgICAgICAgY29uc3Qgc2QyID0gc2VxdWVuY2VEaWZmczJbMF07XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgaWYgKHNkMSAmJiAoIXNkMiB8fCBzZDEuc2VxMVJhbmdlLnN0YXJ0IDwgc2QyLnNlcTFSYW5nZS5zdGFydCkpIHtcclxuICAgICAgICAgICAgbmV4dCA9IHNlcXVlbmNlRGlmZnMxLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0ID0gc2VxdWVuY2VEaWZmczIuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0uc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSA+PSBuZXh0LnNlcTFSYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5qb2luKG5leHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdMaW5lc0JldHdlZW5EaWZmcyhzZXF1ZW5jZTEsIF9zZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcclxuICAgIGxldCBkaWZmcyA9IHNlcXVlbmNlRGlmZnM7XHJcbiAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpZmZzO1xyXG4gICAgfVxyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG4gICAgbGV0IHNob3VsZFJlcGVhdDtcclxuICAgIGRvIHtcclxuICAgICAgICBzaG91bGRSZXBlYXQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXHJcbiAgICAgICAgICAgIGRpZmZzWzBdXHJcbiAgICAgICAgXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGRpZmZzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkSm9pbkRpZmZzKGJlZm9yZSwgYWZ0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFJhbmdlID0gbmV3IE9mZnNldFJhbmdlKGxhc3RSZXN1bHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSwgY3VyLnNlcTFSYW5nZS5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRUZXh0ID0gc2VxdWVuY2UxLmdldFRleHQodW5jaGFuZ2VkUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkVGV4dFdpdGhvdXRXcyA9IHVuY2hhbmdlZFRleHQucmVwbGFjZSgvXFxzL2csICcnKTtcclxuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWRUZXh0V2l0aG91dFdzLmxlbmd0aCA8PSA0XHJcbiAgICAgICAgICAgICAgICAgICAgJiYgKGJlZm9yZS5zZXExUmFuZ2UubGVuZ3RoICsgYmVmb3JlLnNlcTJSYW5nZS5sZW5ndGggPiA1IHx8IGFmdGVyLnNlcTFSYW5nZS5sZW5ndGggKyBhZnRlci5zZXEyUmFuZ2UubGVuZ3RoID4gNSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRKb2luID0gc2hvdWxkSm9pbkRpZmZzKGxhc3RSZXN1bHQsIGN1cik7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRKb2luKSB7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRSZXBlYXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0uam9pbihjdXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaWZmcyA9IHJlc3VsdDtcclxuICAgIH0gd2hpbGUgKGNvdW50ZXIrKyA8IDEwICYmIHNob3VsZFJlcGVhdCk7XHJcbiAgICByZXR1cm4gZGlmZnM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nVGV4dEJldHdlZW5Mb25nRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcclxuICAgIGxldCBkaWZmcyA9IHNlcXVlbmNlRGlmZnM7XHJcbiAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpZmZzO1xyXG4gICAgfVxyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG4gICAgbGV0IHNob3VsZFJlcGVhdDtcclxuICAgIGRvIHtcclxuICAgICAgICBzaG91bGRSZXBlYXQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXHJcbiAgICAgICAgICAgIGRpZmZzWzBdXHJcbiAgICAgICAgXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGRpZmZzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkSm9pbkRpZmZzKGJlZm9yZSwgYWZ0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFJhbmdlID0gbmV3IE9mZnNldFJhbmdlKGxhc3RSZXN1bHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSwgY3VyLnNlcTFSYW5nZS5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRMaW5lQ291bnQgPSBzZXF1ZW5jZTEuY291bnRMaW5lc0luKHVuY2hhbmdlZFJhbmdlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWRMaW5lQ291bnQgPiA1IHx8IHVuY2hhbmdlZFJhbmdlLmxlbmd0aCA+IDUwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFRleHQgPSBzZXF1ZW5jZTEuZ2V0VGV4dCh1bmNoYW5nZWRSYW5nZSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuY2hhbmdlZFRleHQubGVuZ3RoID4gMjAgfHwgdW5jaGFuZ2VkVGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlTGluZUNvdW50MSA9IHNlcXVlbmNlMS5jb3VudExpbmVzSW4oYmVmb3JlLnNlcTFSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVTZXExTGVuZ3RoID0gYmVmb3JlLnNlcTFSYW5nZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVMaW5lQ291bnQyID0gc2VxdWVuY2UyLmNvdW50TGluZXNJbihiZWZvcmUuc2VxMlJhbmdlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVNlcTJMZW5ndGggPSBiZWZvcmUuc2VxMlJhbmdlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyTGluZUNvdW50MSA9IHNlcXVlbmNlMS5jb3VudExpbmVzSW4oYWZ0ZXIuc2VxMVJhbmdlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyU2VxMUxlbmd0aCA9IGFmdGVyLnNlcTFSYW5nZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlckxpbmVDb3VudDIgPSBzZXF1ZW5jZTIuY291bnRMaW5lc0luKGFmdGVyLnNlcTJSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlclNlcTJMZW5ndGggPSBhZnRlci5zZXEyUmFuZ2UubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYSBuZXVyYWwgbmV0IGNhbiBiZSB1c2VkIHRvIGRlcml2ZSB0aGUgcmVzdWx0IGZyb20gdGhlc2UgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gMiAqIDQwICsgNTA7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYXAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih2LCBtYXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucG93KE1hdGgucG93KGNhcChiZWZvcmVMaW5lQ291bnQxICogNDAgKyBiZWZvcmVTZXExTGVuZ3RoKSwgMS41KSArIE1hdGgucG93KGNhcChiZWZvcmVMaW5lQ291bnQyICogNDAgKyBiZWZvcmVTZXEyTGVuZ3RoKSwgMS41KSwgMS41KVxyXG4gICAgICAgICAgICAgICAgICAgICsgTWF0aC5wb3coTWF0aC5wb3coY2FwKGFmdGVyTGluZUNvdW50MSAqIDQwICsgYWZ0ZXJTZXExTGVuZ3RoKSwgMS41KSArIE1hdGgucG93KGNhcChhZnRlckxpbmVDb3VudDIgKiA0MCArIGFmdGVyU2VxMkxlbmd0aCksIDEuNSksIDEuNSkgPiAoKG1heCAqKiAxLjUpICoqIDEuNSkgKiAxLjMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRKb2luID0gc2hvdWxkSm9pbkRpZmZzKGxhc3RSZXN1bHQsIGN1cik7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRKb2luKSB7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRSZXBlYXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0uam9pbihjdXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaWZmcyA9IHJlc3VsdDtcclxuICAgIH0gd2hpbGUgKGNvdW50ZXIrKyA8IDEwICYmIHNob3VsZFJlcGVhdCk7XHJcbiAgICBjb25zdCBuZXdEaWZmcyA9IFtdO1xyXG4gICAgLy8gUmVtb3ZlIHNob3J0IHN1ZmZpeGVzL3ByZWZpeGVzXHJcbiAgICBmb3JFYWNoV2l0aE5laWdoYm9ycyhkaWZmcywgKHByZXYsIGN1ciwgbmV4dCkgPT4ge1xyXG4gICAgICAgIGxldCBuZXdEaWZmID0gY3VyO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNob3VsZE1hcmtBc0NoYW5nZWQodGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPiAwICYmIHRleHQudHJpbSgpLmxlbmd0aCA8PSAzICYmIGN1ci5zZXExUmFuZ2UubGVuZ3RoICsgY3VyLnNlcTJSYW5nZS5sZW5ndGggPiAxMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZ1bGxSYW5nZTEgPSBzZXF1ZW5jZTEuZXh0ZW5kVG9GdWxsTGluZXMoY3VyLnNlcTFSYW5nZSk7XHJcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc2VxdWVuY2UxLmdldFRleHQobmV3IE9mZnNldFJhbmdlKGZ1bGxSYW5nZTEuc3RhcnQsIGN1ci5zZXExUmFuZ2Uuc3RhcnQpKTtcclxuICAgICAgICBpZiAoc2hvdWxkTWFya0FzQ2hhbmdlZChwcmVmaXgpKSB7XHJcbiAgICAgICAgICAgIG5ld0RpZmYgPSBuZXdEaWZmLmRlbHRhU3RhcnQoLXByZWZpeC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdWZmaXggPSBzZXF1ZW5jZTEuZ2V0VGV4dChuZXcgT2Zmc2V0UmFuZ2UoY3VyLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUsIGZ1bGxSYW5nZTEuZW5kRXhjbHVzaXZlKSk7XHJcbiAgICAgICAgaWYgKHNob3VsZE1hcmtBc0NoYW5nZWQoc3VmZml4KSkge1xyXG4gICAgICAgICAgICBuZXdEaWZmID0gbmV3RGlmZi5kZWx0YUVuZChzdWZmaXgubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBTZXF1ZW5jZURpZmYuZnJvbU9mZnNldFBhaXJzKHByZXYgPyBwcmV2LmdldEVuZEV4Y2x1c2l2ZXMoKSA6IE9mZnNldFBhaXIuemVybywgbmV4dCA/IG5leHQuZ2V0U3RhcnRzKCkgOiBPZmZzZXRQYWlyLm1heCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3RGlmZi5pbnRlcnNlY3QoYXZhaWxhYmxlU3BhY2UpO1xyXG4gICAgICAgIGlmIChuZXdEaWZmcy5sZW5ndGggPiAwICYmIHJlc3VsdC5nZXRTdGFydHMoKS5lcXVhbHMobmV3RGlmZnNbbmV3RGlmZnMubGVuZ3RoIC0gMV0uZ2V0RW5kRXhjbHVzaXZlcygpKSkge1xyXG4gICAgICAgICAgICBuZXdEaWZmc1tuZXdEaWZmcy5sZW5ndGggLSAxXSA9IG5ld0RpZmZzW25ld0RpZmZzLmxlbmd0aCAtIDFdLmpvaW4ocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0RpZmZzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdEaWZmcztcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineSequence: () => (/* binding */ LineSequence)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass LineSequence {\r\n    constructor(trimmedHash, lines) {\r\n        this.trimmedHash = trimmedHash;\r\n        this.lines = lines;\r\n    }\r\n    getElement(offset) {\r\n        return this.trimmedHash[offset];\r\n    }\r\n    get length() {\r\n        return this.trimmedHash.length;\r\n    }\r\n    getBoundaryScore(length) {\r\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\r\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\r\n        return 1000 - (indentationBefore + indentationAfter);\r\n    }\r\n    getText(range) {\r\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\r\n    }\r\n    isStronglyEqual(offset1, offset2) {\r\n        return this.lines[offset1] === this.lines[offset2];\r\n    }\r\n}\r\nfunction getIndentation(str) {\r\n    let i = 0;\r\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9saW5lU2VxdWVuY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvbGluZVNlcXVlbmNlLmpzP2I1NzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydCBjbGFzcyBMaW5lU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IodHJpbW1lZEhhc2gsIGxpbmVzKSB7XHJcbiAgICAgICAgdGhpcy50cmltbWVkSGFzaCA9IHRyaW1tZWRIYXNoO1xyXG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcclxuICAgIH1cclxuICAgIGdldEVsZW1lbnQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbW1lZEhhc2hbb2Zmc2V0XTtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbW1lZEhhc2gubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZ2V0Qm91bmRhcnlTY29yZShsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBpbmRlbnRhdGlvbkJlZm9yZSA9IGxlbmd0aCA9PT0gMCA/IDAgOiBnZXRJbmRlbnRhdGlvbih0aGlzLmxpbmVzW2xlbmd0aCAtIDFdKTtcclxuICAgICAgICBjb25zdCBpbmRlbnRhdGlvbkFmdGVyID0gbGVuZ3RoID09PSB0aGlzLmxpbmVzLmxlbmd0aCA/IDAgOiBnZXRJbmRlbnRhdGlvbih0aGlzLmxpbmVzW2xlbmd0aF0pO1xyXG4gICAgICAgIHJldHVybiAxMDAwIC0gKGluZGVudGF0aW9uQmVmb3JlICsgaW5kZW50YXRpb25BZnRlcik7XHJcbiAgICB9XHJcbiAgICBnZXRUZXh0KHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZEV4Y2x1c2l2ZSkuam9pbignXFxuJyk7XHJcbiAgICB9XHJcbiAgICBpc1N0cm9uZ2x5RXF1YWwob2Zmc2V0MSwgb2Zmc2V0Mikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzW29mZnNldDFdID09PSB0aGlzLmxpbmVzW29mZnNldDJdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKHN0cikge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoICYmIChzdHIuY2hhckNvZGVBdChpKSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gfHwgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDkgLyogQ2hhckNvZGUuVGFiICovKSkge1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiBpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinesSliceCharSequence: () => (/* binding */ LinesSliceCharSequence)\n/* harmony export */ });\n/* harmony import */ var _base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../base/common/arraysFind.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\");\n/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/offsetRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\nclass LinesSliceCharSequence {\r\n    constructor(lines, lineRange, considerWhitespaceChanges) {\r\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\r\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\r\n        this.lines = lines;\r\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\r\n        this.elements = [];\r\n        this.firstCharOffsetByLine = [];\r\n        // To account for trimming\r\n        this.additionalOffsetByLine = [];\r\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\r\n        let trimFirstLineFully = false;\r\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\r\n            lineRange = new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(lineRange.start - 1, lineRange.endExclusive);\r\n            trimFirstLineFully = true;\r\n        }\r\n        this.lineRange = lineRange;\r\n        this.firstCharOffsetByLine[0] = 0;\r\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\r\n            let line = lines[i];\r\n            let offset = 0;\r\n            if (trimFirstLineFully) {\r\n                offset = line.length;\r\n                line = '';\r\n                trimFirstLineFully = false;\r\n            }\r\n            else if (!considerWhitespaceChanges) {\r\n                const trimmedStartLine = line.trimStart();\r\n                offset = line.length - trimmedStartLine.length;\r\n                line = trimmedStartLine.trimEnd();\r\n            }\r\n            this.additionalOffsetByLine.push(offset);\r\n            for (let i = 0; i < line.length; i++) {\r\n                this.elements.push(line.charCodeAt(i));\r\n            }\r\n            // Don't add an \\n that does not exist in the document.\r\n            if (i < lines.length - 1) {\r\n                this.elements.push('\\n'.charCodeAt(0));\r\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\r\n            }\r\n        }\r\n        // To account for the last line\r\n        this.additionalOffsetByLine.push(0);\r\n    }\r\n    toString() {\r\n        return `Slice: \"${this.text}\"`;\r\n    }\r\n    get text() {\r\n        return this.getText(new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(0, this.length));\r\n    }\r\n    getText(range) {\r\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\r\n    }\r\n    getElement(offset) {\r\n        return this.elements[offset];\r\n    }\r\n    get length() {\r\n        return this.elements.length;\r\n    }\r\n    getBoundaryScore(length) {\r\n        //   a   b   c   ,           d   e   f\r\n        // 11  0   0   12  15  6   13  0   0   11\r\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\r\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\r\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\r\n            // don't break between \\r and \\n\r\n            return 0;\r\n        }\r\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\r\n            // prefer the linebreak before the change\r\n            return 150;\r\n        }\r\n        let score = 0;\r\n        if (prevCategory !== nextCategory) {\r\n            score += 10;\r\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\r\n                score += 1;\r\n            }\r\n        }\r\n        score += getCategoryBoundaryScore(prevCategory);\r\n        score += getCategoryBoundaryScore(nextCategory);\r\n        return score;\r\n    }\r\n    translateOffset(offset) {\r\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\r\n        if (this.lineRange.isEmpty) {\r\n            return new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.lineRange.start + 1, 1);\r\n        }\r\n        const i = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findLastIdxMonotonous)(this.firstCharOffsetByLine, (value) => value <= offset);\r\n        return new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\r\n    }\r\n    translateRange(range) {\r\n        return _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\r\n    }\r\n    /**\r\n     * Finds the word that contains the character at the given offset\r\n     */\r\n    findWordContaining(offset) {\r\n        if (offset < 0 || offset >= this.elements.length) {\r\n            return undefined;\r\n        }\r\n        if (!isWordChar(this.elements[offset])) {\r\n            return undefined;\r\n        }\r\n        // find start\r\n        let start = offset;\r\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\r\n            start--;\r\n        }\r\n        // find end\r\n        let end = offset;\r\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\r\n            end++;\r\n        }\r\n        return new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(start, end);\r\n    }\r\n    countLinesIn(range) {\r\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\r\n    }\r\n    isStronglyEqual(offset1, offset2) {\r\n        return this.elements[offset1] === this.elements[offset2];\r\n    }\r\n    extendToFullLines(range) {\r\n        var _a, _b;\r\n        const start = (_a = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findLastMonotonous)(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\r\n        const end = (_b = (0,_base_common_arraysFind_js__WEBPACK_IMPORTED_MODULE_0__.findFirstMonotonous)(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\r\n        return new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(start, end);\r\n    }\r\n}\r\nfunction isWordChar(charCode) {\r\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\r\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\r\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\r\n}\r\nconst score = {\r\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\r\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\r\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\r\n    [3 /* CharBoundaryCategory.End */]: 10,\r\n    [4 /* CharBoundaryCategory.Other */]: 2,\r\n    [5 /* CharBoundaryCategory.Separator */]: 30,\r\n    [6 /* CharBoundaryCategory.Space */]: 3,\r\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\r\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\r\n};\r\nfunction getCategoryBoundaryScore(category) {\r\n    return score[category];\r\n}\r\nfunction getCategory(charCode) {\r\n    if (charCode === 10 /* CharCode.LineFeed */) {\r\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\r\n    }\r\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\r\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\r\n    }\r\n    else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isSpace)(charCode)) {\r\n        return 6 /* CharBoundaryCategory.Space */;\r\n    }\r\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\r\n        return 0 /* CharBoundaryCategory.WordLower */;\r\n    }\r\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\r\n        return 1 /* CharBoundaryCategory.WordUpper */;\r\n    }\r\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\r\n        return 2 /* CharBoundaryCategory.WordNumber */;\r\n    }\r\n    else if (charCode === -1) {\r\n        return 3 /* CharBoundaryCategory.End */;\r\n    }\r\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\r\n        return 5 /* CharBoundaryCategory.Separator */;\r\n    }\r\n    else {\r\n        return 4 /* CharBoundaryCategory.Other */;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VIO0FBQy9EO0FBQ047QUFDTjtBQUNQO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyw2REFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBUTtBQUMvQjtBQUNBLGtCQUFrQixpRkFBcUI7QUFDdkMsbUJBQW1CLHVEQUFRO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGlEQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEVBQWtCO0FBQzlDLDBCQUEwQiwrRUFBbUI7QUFDN0MsbUJBQW1CLDZEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzPzU4ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IGZpbmRMYXN0SWR4TW9ub3Rvbm91cywgZmluZExhc3RNb25vdG9ub3VzLCBmaW5kRmlyc3RNb25vdG9ub3VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcyc7XHJcbmltcG9ydCB7IE9mZnNldFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9vZmZzZXRSYW5nZS5qcyc7XHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vY29yZS9wb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IGlzU3BhY2UgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuZXhwb3J0IGNsYXNzIExpbmVzU2xpY2VDaGFyU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IobGluZXMsIGxpbmVSYW5nZSwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcykge1xyXG4gICAgICAgIC8vIFRoaXMgc2xpY2UgaGFzIHRvIGhhdmUgbGluZVJhbmdlLmxlbmd0aCBtYW55IFxcbiEgKG90aGVyd2lzZSBkaWZmaW5nIGFnYWluc3QgYW4gZW1wdHkgc2xpY2Ugd2lsbCBiZSBwcm9ibGVtYXRpYylcclxuICAgICAgICAvLyAoVW5sZXNzIGl0IGNvdmVycyB0aGUgZW50aXJlIGRvY3VtZW50LCBpbiB0aGF0IGNhc2UgdGhlIG90aGVyIHNsaWNlIGFsc28gaGFzIHRvIGNvdmVyIHRoZSBlbnRpcmUgZG9jdW1lbnQgYW5kcyBpdCdzIG9rYXkpXHJcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xyXG4gICAgICAgIHRoaXMuY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyA9IGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXM7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lID0gW107XHJcbiAgICAgICAgLy8gVG8gYWNjb3VudCBmb3IgdHJpbW1pbmdcclxuICAgICAgICB0aGlzLmFkZGl0aW9uYWxPZmZzZXRCeUxpbmUgPSBbXTtcclxuICAgICAgICAvLyBJZiB0aGUgc2xpY2UgY292ZXJzIHRoZSBlbmQsIGJ1dCBkb2VzIG5vdCBzdGFydCBhdCB0aGUgYmVnaW5uaW5nLCB3ZSBpbmNsdWRlIGp1c3QgdGhlIFxcbiBvZiB0aGUgcHJldmlvdXMgbGluZS5cclxuICAgICAgICBsZXQgdHJpbUZpcnN0TGluZUZ1bGx5ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGxpbmVSYW5nZS5zdGFydCA+IDAgJiYgbGluZVJhbmdlLmVuZEV4Y2x1c2l2ZSA+PSBsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGluZVJhbmdlID0gbmV3IE9mZnNldFJhbmdlKGxpbmVSYW5nZS5zdGFydCAtIDEsIGxpbmVSYW5nZS5lbmRFeGNsdXNpdmUpO1xyXG4gICAgICAgICAgICB0cmltRmlyc3RMaW5lRnVsbHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpbmVSYW5nZSA9IGxpbmVSYW5nZTtcclxuICAgICAgICB0aGlzLmZpcnN0Q2hhck9mZnNldEJ5TGluZVswXSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGluZVJhbmdlLnN0YXJ0OyBpIDwgdGhpcy5saW5lUmFuZ2UuZW5kRXhjbHVzaXZlOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0cmltRmlyc3RMaW5lRnVsbHkpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxpbmUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGluZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdHJpbUZpcnN0TGluZUZ1bGx5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRTdGFydExpbmUgPSBsaW5lLnRyaW1TdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGluZS5sZW5ndGggLSB0cmltbWVkU3RhcnRMaW5lLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxpbmUgPSB0cmltbWVkU3RhcnRMaW5lLnRyaW1FbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxPZmZzZXRCeUxpbmUucHVzaChvZmZzZXQpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChsaW5lLmNoYXJDb2RlQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvbid0IGFkZCBhbiBcXG4gdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKCdcXG4nLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdENoYXJPZmZzZXRCeUxpbmVbaSAtIHRoaXMubGluZVJhbmdlLnN0YXJ0ICsgMV0gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUbyBhY2NvdW50IGZvciB0aGUgbGFzdCBsaW5lXHJcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsT2Zmc2V0QnlMaW5lLnB1c2goMCk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYFNsaWNlOiBcIiR7dGhpcy50ZXh0fVwiYDtcclxuICAgIH1cclxuICAgIGdldCB0ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRleHQobmV3IE9mZnNldFJhbmdlKDAsIHRoaXMubGVuZ3RoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRUZXh0KHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZEV4Y2x1c2l2ZSkubWFwKGUgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShlKSkuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICBnZXRFbGVtZW50KG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW29mZnNldF07XHJcbiAgICB9XHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldEJvdW5kYXJ5U2NvcmUobGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gICBhICAgYiAgIGMgICAsICAgICAgICAgICBkICAgZSAgIGZcclxuICAgICAgICAvLyAxMSAgMCAgIDAgICAxMiAgMTUgIDYgICAxMyAgMCAgIDAgICAxMVxyXG4gICAgICAgIGNvbnN0IHByZXZDYXRlZ29yeSA9IGdldENhdGVnb3J5KGxlbmd0aCA+IDAgPyB0aGlzLmVsZW1lbnRzW2xlbmd0aCAtIDFdIDogLTEpO1xyXG4gICAgICAgIGNvbnN0IG5leHRDYXRlZ29yeSA9IGdldENhdGVnb3J5KGxlbmd0aCA8IHRoaXMuZWxlbWVudHMubGVuZ3RoID8gdGhpcy5lbGVtZW50c1tsZW5ndGhdIDogLTEpO1xyXG4gICAgICAgIGlmIChwcmV2Q2F0ZWdvcnkgPT09IDcgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrQ1IgKi8gJiYgbmV4dENhdGVnb3J5ID09PSA4IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0xGICovKSB7XHJcbiAgICAgICAgICAgIC8vIGRvbid0IGJyZWFrIGJldHdlZW4gXFxyIGFuZCBcXG5cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2Q2F0ZWdvcnkgPT09IDggLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrTEYgKi8pIHtcclxuICAgICAgICAgICAgLy8gcHJlZmVyIHRoZSBsaW5lYnJlYWsgYmVmb3JlIHRoZSBjaGFuZ2VcclxuICAgICAgICAgICAgcmV0dXJuIDE1MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNjb3JlID0gMDtcclxuICAgICAgICBpZiAocHJldkNhdGVnb3J5ICE9PSBuZXh0Q2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgc2NvcmUgKz0gMTA7XHJcbiAgICAgICAgICAgIGlmIChwcmV2Q2F0ZWdvcnkgPT09IDAgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZExvd2VyICovICYmIG5leHRDYXRlZ29yeSA9PT0gMSAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkVXBwZXIgKi8pIHtcclxuICAgICAgICAgICAgICAgIHNjb3JlICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2NvcmUgKz0gZ2V0Q2F0ZWdvcnlCb3VuZGFyeVNjb3JlKHByZXZDYXRlZ29yeSk7XHJcbiAgICAgICAgc2NvcmUgKz0gZ2V0Q2F0ZWdvcnlCb3VuZGFyeVNjb3JlKG5leHRDYXRlZ29yeSk7XHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlT2Zmc2V0KG9mZnNldCkge1xyXG4gICAgICAgIC8vIGZpbmQgc21hbGxlc3QgaSwgc28gdGhhdCBsaW5lQnJlYWtPZmZzZXRzW2ldIDw9IG9mZnNldCB1c2luZyBiaW5hcnkgc2VhcmNoXHJcbiAgICAgICAgaWYgKHRoaXMubGluZVJhbmdlLmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmVSYW5nZS5zdGFydCArIDEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpID0gZmluZExhc3RJZHhNb25vdG9ub3VzKHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lLCAodmFsdWUpID0+IHZhbHVlIDw9IG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmVSYW5nZS5zdGFydCArIGkgKyAxLCBvZmZzZXQgLSB0aGlzLmZpcnN0Q2hhck9mZnNldEJ5TGluZVtpXSArIHRoaXMuYWRkaXRpb25hbE9mZnNldEJ5TGluZVtpXSArIDEpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvc2l0aW9ucyh0aGlzLnRyYW5zbGF0ZU9mZnNldChyYW5nZS5zdGFydCksIHRoaXMudHJhbnNsYXRlT2Zmc2V0KHJhbmdlLmVuZEV4Y2x1c2l2ZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgd29yZCB0aGF0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGdpdmVuIG9mZnNldFxyXG4gICAgICovXHJcbiAgICBmaW5kV29yZENvbnRhaW5pbmcob2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID49IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNXb3JkQ2hhcih0aGlzLmVsZW1lbnRzW29mZnNldF0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmQgc3RhcnRcclxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBpc1dvcmRDaGFyKHRoaXMuZWxlbWVudHNbc3RhcnQgLSAxXSkpIHtcclxuICAgICAgICAgICAgc3RhcnQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmluZCBlbmRcclxuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0O1xyXG4gICAgICAgIHdoaWxlIChlbmQgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aCAmJiBpc1dvcmRDaGFyKHRoaXMuZWxlbWVudHNbZW5kXSkpIHtcclxuICAgICAgICAgICAgZW5kKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcbiAgICBjb3VudExpbmVzSW4ocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2UuZW5kRXhjbHVzaXZlKS5saW5lTnVtYmVyIC0gdGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2Uuc3RhcnQpLmxpbmVOdW1iZXI7XHJcbiAgICB9XHJcbiAgICBpc1N0cm9uZ2x5RXF1YWwob2Zmc2V0MSwgb2Zmc2V0Mikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW29mZnNldDFdID09PSB0aGlzLmVsZW1lbnRzW29mZnNldDJdO1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kVG9GdWxsTGluZXMocmFuZ2UpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKF9hID0gZmluZExhc3RNb25vdG9ub3VzKHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lLCB4ID0+IHggPD0gcmFuZ2Uuc3RhcnQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IChfYiA9IGZpbmRGaXJzdE1vbm90b25vdXModGhpcy5maXJzdENoYXJPZmZzZXRCeUxpbmUsIHggPT4gcmFuZ2UuZW5kRXhjbHVzaXZlIDw9IHgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzV29yZENoYXIoY2hhckNvZGUpIHtcclxuICAgIHJldHVybiBjaGFyQ29kZSA+PSA5NyAvKiBDaGFyQ29kZS5hICovICYmIGNoYXJDb2RlIDw9IDEyMiAvKiBDaGFyQ29kZS56ICovXHJcbiAgICAgICAgfHwgY2hhckNvZGUgPj0gNjUgLyogQ2hhckNvZGUuQSAqLyAmJiBjaGFyQ29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovXHJcbiAgICAgICAgfHwgY2hhckNvZGUgPj0gNDggLyogQ2hhckNvZGUuRGlnaXQwICovICYmIGNoYXJDb2RlIDw9IDU3IC8qIENoYXJDb2RlLkRpZ2l0OSAqLztcclxufVxyXG5jb25zdCBzY29yZSA9IHtcclxuICAgIFswIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmRMb3dlciAqL106IDAsXHJcbiAgICBbMSAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkVXBwZXIgKi9dOiAwLFxyXG4gICAgWzIgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZE51bWJlciAqL106IDAsXHJcbiAgICBbMyAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5FbmQgKi9dOiAxMCxcclxuICAgIFs0IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5Lk90aGVyICovXTogMixcclxuICAgIFs1IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LlNlcGFyYXRvciAqL106IDMwLFxyXG4gICAgWzYgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuU3BhY2UgKi9dOiAzLFxyXG4gICAgWzcgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrQ1IgKi9dOiAxMCxcclxuICAgIFs4IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0xGICovXTogMTAsXHJcbn07XHJcbmZ1bmN0aW9uIGdldENhdGVnb3J5Qm91bmRhcnlTY29yZShjYXRlZ29yeSkge1xyXG4gICAgcmV0dXJuIHNjb3JlW2NhdGVnb3J5XTtcclxufVxyXG5mdW5jdGlvbiBnZXRDYXRlZ29yeShjaGFyQ29kZSkge1xyXG4gICAgaWYgKGNoYXJDb2RlID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xyXG4gICAgICAgIHJldHVybiA4IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0xGICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovKSB7XHJcbiAgICAgICAgcmV0dXJuIDcgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrQ1IgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NwYWNlKGNoYXJDb2RlKSkge1xyXG4gICAgICAgIHJldHVybiA2IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LlNwYWNlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPj0gOTcgLyogQ2hhckNvZGUuYSAqLyAmJiBjaGFyQ29kZSA8PSAxMjIgLyogQ2hhckNvZGUueiAqLykge1xyXG4gICAgICAgIHJldHVybiAwIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmRMb3dlciAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY2hhckNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLykge1xyXG4gICAgICAgIHJldHVybiAxIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmRVcHBlciAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID49IDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLyAmJiBjaGFyQ29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi8pIHtcclxuICAgICAgICByZXR1cm4gMiAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkTnVtYmVyICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIDMgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuRW5kICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hhckNvZGUgPT09IDQ0IC8qIENoYXJDb2RlLkNvbW1hICovIHx8IGNoYXJDb2RlID09PSA1OSAvKiBDaGFyQ29kZS5TZW1pY29sb24gKi8pIHtcclxuICAgICAgICByZXR1cm4gNSAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5TZXBhcmF0b3IgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gNCAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5PdGhlciAqLztcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Array2D: () => (/* binding */ Array2D),\n/* harmony export */   LineRangeFragment: () => (/* binding */ LineRangeFragment),\n/* harmony export */   isSpace: () => (/* binding */ isSpace)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Array2D {\r\n    constructor(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.array = [];\r\n        this.array = new Array(width * height);\r\n    }\r\n    get(x, y) {\r\n        return this.array[x + y * this.width];\r\n    }\r\n    set(x, y, value) {\r\n        this.array[x + y * this.width] = value;\r\n    }\r\n}\r\nfunction isSpace(charCode) {\r\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\r\n}\r\nclass LineRangeFragment {\r\n    static getKey(chr) {\r\n        let key = this.chrKeys.get(chr);\r\n        if (key === undefined) {\r\n            key = this.chrKeys.size;\r\n            this.chrKeys.set(chr, key);\r\n        }\r\n        return key;\r\n    }\r\n    constructor(range, lines, source) {\r\n        this.range = range;\r\n        this.lines = lines;\r\n        this.source = source;\r\n        this.histogram = [];\r\n        let counter = 0;\r\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\r\n            const line = lines[i];\r\n            for (let j = 0; j < line.length; j++) {\r\n                counter++;\r\n                const chr = line[j];\r\n                const key = LineRangeFragment.getKey(chr);\r\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\r\n            }\r\n            counter++;\r\n            const key = LineRangeFragment.getKey('\\n');\r\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\r\n        }\r\n        this.totalCount = counter;\r\n    }\r\n    computeSimilarity(other) {\r\n        var _a, _b;\r\n        let sumDifferences = 0;\r\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\r\n        for (let i = 0; i < maxLength; i++) {\r\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\r\n        }\r\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\r\n    }\r\n}\r\nLineRangeFragment.chrKeys = new Map();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0NBQXNDO0FBQ3RGO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci91dGlscy5qcz9jNDJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgY2xhc3MgQXJyYXkyRCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEFycmF5KHdpZHRoICogaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGdldCh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbeCArIHkgKiB0aGlzLndpZHRoXTtcclxuICAgIH1cclxuICAgIHNldCh4LCB5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYXJyYXlbeCArIHkgKiB0aGlzLndpZHRoXSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1NwYWNlKGNoYXJDb2RlKSB7XHJcbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDMyIC8qIENoYXJDb2RlLlNwYWNlICovIHx8IGNoYXJDb2RlID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLztcclxufVxyXG5leHBvcnQgY2xhc3MgTGluZVJhbmdlRnJhZ21lbnQge1xyXG4gICAgc3RhdGljIGdldEtleShjaHIpIHtcclxuICAgICAgICBsZXQga2V5ID0gdGhpcy5jaHJLZXlzLmdldChjaHIpO1xyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBrZXkgPSB0aGlzLmNocktleXMuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5jaHJLZXlzLnNldChjaHIsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgbGluZXMsIHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5oaXN0b2dyYW0gPSBbXTtcclxuICAgICAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDE7IGkgPCByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHIgPSBsaW5lW2pdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gTGluZVJhbmdlRnJhZ21lbnQuZ2V0S2V5KGNocik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvZ3JhbVtrZXldID0gKHRoaXMuaGlzdG9ncmFtW2tleV0gfHwgMCkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gTGluZVJhbmdlRnJhZ21lbnQuZ2V0S2V5KCdcXG4nKTtcclxuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1ba2V5XSA9ICh0aGlzLmhpc3RvZ3JhbVtrZXldIHx8IDApICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b3RhbENvdW50ID0gY291bnRlcjtcclxuICAgIH1cclxuICAgIGNvbXB1dGVTaW1pbGFyaXR5KG90aGVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBsZXQgc3VtRGlmZmVyZW5jZXMgPSAwO1xyXG4gICAgICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KHRoaXMuaGlzdG9ncmFtLmxlbmd0aCwgb3RoZXIuaGlzdG9ncmFtLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzdW1EaWZmZXJlbmNlcyArPSBNYXRoLmFicygoKF9hID0gdGhpcy5oaXN0b2dyYW1baV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC0gKChfYiA9IG90aGVyLmhpc3RvZ3JhbVtpXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMSAtIChzdW1EaWZmZXJlbmNlcyAvICh0aGlzLnRvdGFsQ291bnQgKyBvdGhlci50b3RhbENvdW50KSk7XHJcbiAgICB9XHJcbn1cclxuTGluZVJhbmdlRnJhZ21lbnQuY2hyS2V5cyA9IG5ldyBNYXAoKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiffComputer: () => (/* binding */ DiffComputer),\n/* harmony export */   LegacyLinesDiffComputer: () => (/* binding */ LegacyLinesDiffComputer)\n/* harmony export */ });\n/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ \"./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\");\n/* harmony import */ var _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linesDiffComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js\");\n/* harmony import */ var _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rangeMapping.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\");\n/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../base/common/assert.js */ \"./node_modules/monaco-editor/esm/vs/base/common/assert.js\");\n/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/lineRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\r\nclass LegacyLinesDiffComputer {\r\n    computeDiff(originalLines, modifiedLines, options) {\r\n        var _a;\r\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\r\n            maxComputationTime: options.maxComputationTimeMs,\r\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\r\n            shouldComputeCharChanges: true,\r\n            shouldMakePrettyDiff: true,\r\n            shouldPostProcessCharChanges: true,\r\n        });\r\n        const result = diffComputer.computeDiff();\r\n        const changes = [];\r\n        let lastChange = null;\r\n        for (const c of result.changes) {\r\n            let originalRange;\r\n            if (c.originalEndLineNumber === 0) {\r\n                // Insertion\r\n                originalRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\r\n            }\r\n            else {\r\n                originalRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\r\n            }\r\n            let modifiedRange;\r\n            if (c.modifiedEndLineNumber === 0) {\r\n                // Deletion\r\n                modifiedRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\r\n            }\r\n            else {\r\n                modifiedRange = new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_6__.LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\r\n            }\r\n            let change = new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__.DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__.RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\r\n            if (lastChange) {\r\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\r\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\r\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\r\n                    change = new _rangeMapping_js__WEBPACK_IMPORTED_MODULE_2__.DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\r\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\r\n                    changes.pop();\r\n                }\r\n            }\r\n            changes.push(change);\r\n            lastChange = change;\r\n        }\r\n        (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_5__.assertFn)(() => {\r\n            return (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_5__.checkAdjacentItems)(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\r\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\r\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\r\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\r\n        });\r\n        return new _linesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__.LinesDiff(changes, [], result.quitEarly);\r\n    }\r\n}\r\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\r\n    const diffAlgo = new _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\r\n    return diffAlgo.ComputeDiff(pretty);\r\n}\r\nclass LineSequence {\r\n    constructor(lines) {\r\n        const startColumns = [];\r\n        const endColumns = [];\r\n        for (let i = 0, length = lines.length; i < length; i++) {\r\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\r\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\r\n        }\r\n        this.lines = lines;\r\n        this._startColumns = startColumns;\r\n        this._endColumns = endColumns;\r\n    }\r\n    getElements() {\r\n        const elements = [];\r\n        for (let i = 0, len = this.lines.length; i < len; i++) {\r\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\r\n        }\r\n        return elements;\r\n    }\r\n    getStrictElement(index) {\r\n        return this.lines[index];\r\n    }\r\n    getStartLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    getEndLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\r\n        const charCodes = [];\r\n        const lineNumbers = [];\r\n        const columns = [];\r\n        let len = 0;\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            const lineContent = this.lines[index];\r\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\r\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\r\n            for (let col = startColumn; col < endColumn; col++) {\r\n                charCodes[len] = lineContent.charCodeAt(col - 1);\r\n                lineNumbers[len] = index + 1;\r\n                columns[len] = col;\r\n                len++;\r\n            }\r\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\r\n                // Add \\n if trim whitespace is not ignored\r\n                charCodes[len] = 10 /* CharCode.LineFeed */;\r\n                lineNumbers[len] = index + 1;\r\n                columns[len] = lineContent.length + 1;\r\n                len++;\r\n            }\r\n        }\r\n        return new CharSequence(charCodes, lineNumbers, columns);\r\n    }\r\n}\r\nclass CharSequence {\r\n    constructor(charCodes, lineNumbers, columns) {\r\n        this._charCodes = charCodes;\r\n        this._lineNumbers = lineNumbers;\r\n        this._columns = columns;\r\n    }\r\n    toString() {\r\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\r\n    }\r\n    _assertIndex(index, arr) {\r\n        if (index < 0 || index >= arr.length) {\r\n            throw new Error(`Illegal index`);\r\n        }\r\n    }\r\n    getElements() {\r\n        return this._charCodes;\r\n    }\r\n    getStartLineNumber(i) {\r\n        if (i > 0 && i === this._lineNumbers.length) {\r\n            // the start line number of the element after the last element\r\n            // is the end line number of the last element\r\n            return this.getEndLineNumber(i - 1);\r\n        }\r\n        this._assertIndex(i, this._lineNumbers);\r\n        return this._lineNumbers[i];\r\n    }\r\n    getEndLineNumber(i) {\r\n        if (i === -1) {\r\n            // the end line number of the element before the first element\r\n            // is the start line number of the first element\r\n            return this.getStartLineNumber(i + 1);\r\n        }\r\n        this._assertIndex(i, this._lineNumbers);\r\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\r\n            return this._lineNumbers[i] + 1;\r\n        }\r\n        return this._lineNumbers[i];\r\n    }\r\n    getStartColumn(i) {\r\n        if (i > 0 && i === this._columns.length) {\r\n            // the start column of the element after the last element\r\n            // is the end column of the last element\r\n            return this.getEndColumn(i - 1);\r\n        }\r\n        this._assertIndex(i, this._columns);\r\n        return this._columns[i];\r\n    }\r\n    getEndColumn(i) {\r\n        if (i === -1) {\r\n            // the end column of the element before the first element\r\n            // is the start column of the first element\r\n            return this.getStartColumn(i + 1);\r\n        }\r\n        this._assertIndex(i, this._columns);\r\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\r\n            return 1;\r\n        }\r\n        return this._columns[i] + 1;\r\n    }\r\n}\r\nclass CharChange {\r\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalStartColumn = originalStartColumn;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.originalEndColumn = originalEndColumn;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedStartColumn = modifiedStartColumn;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.modifiedEndColumn = modifiedEndColumn;\r\n    }\r\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\r\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\r\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\r\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\r\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\r\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\r\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\r\n    }\r\n}\r\nfunction postProcessCharChanges(rawChanges) {\r\n    if (rawChanges.length <= 1) {\r\n        return rawChanges;\r\n    }\r\n    const result = [rawChanges[0]];\r\n    let prevChange = result[0];\r\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\r\n        const currChange = rawChanges[i];\r\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\r\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\r\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\r\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\r\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\r\n            // Merge the current change into the previous one\r\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\r\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\r\n        }\r\n        else {\r\n            // Add the current change\r\n            result.push(currChange);\r\n            prevChange = currChange;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nclass LineChange {\r\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.charChanges = charChanges;\r\n    }\r\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\r\n        let originalStartLineNumber;\r\n        let originalEndLineNumber;\r\n        let modifiedStartLineNumber;\r\n        let modifiedEndLineNumber;\r\n        let charChanges = undefined;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\r\n            originalEndLineNumber = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\r\n            modifiedEndLineNumber = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\r\n            // Compute character changes for diff chunks of at most 20 lines...\r\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\r\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\r\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\r\n                if (shouldPostProcessCharChanges) {\r\n                    rawChanges = postProcessCharChanges(rawChanges);\r\n                }\r\n                charChanges = [];\r\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\r\n                }\r\n            }\r\n        }\r\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\r\n    }\r\n}\r\nclass DiffComputer {\r\n    constructor(originalLines, modifiedLines, opts) {\r\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\r\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\r\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\r\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\r\n        this.originalLines = originalLines;\r\n        this.modifiedLines = modifiedLines;\r\n        this.original = new LineSequence(originalLines);\r\n        this.modified = new LineSequence(modifiedLines);\r\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\r\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\r\n    }\r\n    computeDiff() {\r\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\r\n            // empty original => fast path\r\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n                return {\r\n                    quitEarly: false,\r\n                    changes: []\r\n                };\r\n            }\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: 1,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: this.modified.lines.length,\r\n                        charChanges: undefined\r\n                    }]\r\n            };\r\n        }\r\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n            // empty modified => fast path\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: this.original.lines.length,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: 1,\r\n                        charChanges: undefined\r\n                    }]\r\n            };\r\n        }\r\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\r\n        const rawChanges = diffResult.changes;\r\n        const quitEarly = diffResult.quitEarly;\r\n        // The diff is always computed with ignoring trim whitespace\r\n        // This ensures we get the prettiest diff\r\n        if (this.shouldIgnoreTrimWhitespace) {\r\n            const lineChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n            }\r\n            return {\r\n                quitEarly: quitEarly,\r\n                changes: lineChanges\r\n            };\r\n        }\r\n        // Need to post-process and introduce changes where the trim whitespace is different\r\n        // Note that we are looping starting at -1 to also cover the lines before the first change\r\n        const result = [];\r\n        let originalLineIndex = 0;\r\n        let modifiedLineIndex = 0;\r\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\r\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\r\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\r\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\r\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\r\n                const originalLine = this.originalLines[originalLineIndex];\r\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\r\n                if (originalLine !== modifiedLine) {\r\n                    // These lines differ only in trim whitespace\r\n                    // Check the leading whitespace\r\n                    {\r\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\r\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\r\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\r\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\r\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalStartColumn--;\r\n                            modifiedStartColumn--;\r\n                        }\r\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\r\n                        }\r\n                    }\r\n                    // Check the trailing whitespace\r\n                    {\r\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\r\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\r\n                        const originalMaxColumn = originalLine.length + 1;\r\n                        const modifiedMaxColumn = modifiedLine.length + 1;\r\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\r\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\r\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalEndColumn++;\r\n                            modifiedEndColumn++;\r\n                        }\r\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\r\n                        }\r\n                    }\r\n                }\r\n                originalLineIndex++;\r\n                modifiedLineIndex++;\r\n            }\r\n            if (nextChange) {\r\n                // Emit the actual change\r\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n                originalLineIndex += nextChange.originalLength;\r\n                modifiedLineIndex += nextChange.modifiedLength;\r\n            }\r\n        }\r\n        return {\r\n            quitEarly: quitEarly,\r\n            changes: result\r\n        };\r\n    }\r\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\r\n            // Merged into previous\r\n            return;\r\n        }\r\n        let charChanges = undefined;\r\n        if (this.shouldComputeCharChanges) {\r\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\r\n        }\r\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\r\n    }\r\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        const len = result.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const prevChange = result[len - 1];\r\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\r\n            // Don't merge with inserts/deletes\r\n            return false;\r\n        }\r\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\r\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\r\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\r\n            }\r\n            return true;\r\n        }\r\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\r\n            prevChange.originalEndLineNumber = originalLineNumber;\r\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\r\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\r\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction getFirstNonBlankColumn(txt, defaultValue) {\r\n    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_3__.firstNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 1;\r\n}\r\nfunction getLastNonBlankColumn(txt, defaultValue) {\r\n    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_3__.lastNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 2;\r\n}\r\nfunction createContinueProcessingPredicate(maximumRuntime) {\r\n    if (maximumRuntime === 0) {\r\n        return () => true;\r\n    }\r\n    const startTime = Date.now();\r\n    return () => {\r\n        return Date.now() - startTime < maximumRuntime;\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2xlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzREO0FBQ1Q7QUFDd0I7QUFDaEI7QUFDbEI7QUFDcUM7QUFDN0I7QUFDakQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQVM7QUFDN0M7QUFDQTtBQUNBLG9DQUFvQyx5REFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5REFBUztBQUM3QztBQUNBO0FBQ0Esb0NBQW9DLHlEQUFTO0FBQzdDO0FBQ0EsNkJBQTZCLHNFQUF3Qix5R0FBeUcsMERBQVksS0FBSyxpREFBSyxzR0FBc0csaURBQUs7QUFDL1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0VBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBUTtBQUNoQixtQkFBbUIsMEVBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsNERBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLHVCQUF1QixHQUFHLG1CQUFtQjtBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEVBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkVBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2xlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyLmpzP2IxMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IExjc0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xyXG5pbXBvcnQgeyBMaW5lc0RpZmYgfSBmcm9tICcuL2xpbmVzRGlmZkNvbXB1dGVyLmpzJztcclxuaW1wb3J0IHsgUmFuZ2VNYXBwaW5nLCBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcgfSBmcm9tICcuL3JhbmdlTWFwcGluZy5qcyc7XHJcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IGFzc2VydEZuLCBjaGVja0FkamFjZW50SXRlbXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBMaW5lUmFuZ2UgfSBmcm9tICcuLi9jb3JlL2xpbmVSYW5nZS5qcyc7XHJcbmNvbnN0IE1JTklNVU1fTUFUQ0hJTkdfQ0hBUkFDVEVSX0xFTkdUSCA9IDM7XHJcbmV4cG9ydCBjbGFzcyBMZWdhY3lMaW5lc0RpZmZDb21wdXRlciB7XHJcbiAgICBjb21wdXRlRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGRpZmZDb21wdXRlciA9IG5ldyBEaWZmQ29tcHV0ZXIob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywge1xyXG4gICAgICAgICAgICBtYXhDb21wdXRhdGlvblRpbWU6IG9wdGlvbnMubWF4Q29tcHV0YXRpb25UaW1lTXMsXHJcbiAgICAgICAgICAgIHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlOiBvcHRpb25zLmlnbm9yZVRyaW1XaGl0ZXNwYWNlLFxyXG4gICAgICAgICAgICBzaG91bGRDb21wdXRlQ2hhckNoYW5nZXM6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3VsZE1ha2VQcmV0dHlEaWZmOiB0cnVlLFxyXG4gICAgICAgICAgICBzaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpZmZDb21wdXRlci5jb21wdXRlRGlmZigpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgbGFzdENoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHJlc3VsdC5jaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFJhbmdlO1xyXG4gICAgICAgICAgICBpZiAoYy5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEluc2VydGlvblxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxSYW5nZSA9IG5ldyBMaW5lUmFuZ2UoYy5vcmlnaW5hbFN0YXJ0TGluZU51bWJlciArIDEsIGMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIGMub3JpZ2luYWxFbmRMaW5lTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkUmFuZ2U7XHJcbiAgICAgICAgICAgIGlmIChjLm1vZGlmaWVkRW5kTGluZU51bWJlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGVsZXRpb25cclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIgKyAxLCBjLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZFJhbmdlID0gbmV3IExpbmVSYW5nZShjLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBjLm1vZGlmaWVkRW5kTGluZU51bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2UgPSBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UsIChfYSA9IGMuY2hhckNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoYyA9PiBuZXcgUmFuZ2VNYXBwaW5nKG5ldyBSYW5nZShjLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBjLm9yaWdpbmFsU3RhcnRDb2x1bW4sIGMub3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBjLm9yaWdpbmFsRW5kQ29sdW1uKSwgbmV3IFJhbmdlKGMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIGMubW9kaWZpZWRTdGFydENvbHVtbiwgYy5tb2RpZmllZEVuZExpbmVOdW1iZXIsIGMubW9kaWZpZWRFbmRDb2x1bW4pKSkpO1xyXG4gICAgICAgICAgICBpZiAobGFzdENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDaGFuZ2UubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9PT0gY2hhbmdlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGxhc3RDaGFuZ2Uub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9PT0gY2hhbmdlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGpvaW4gdG91Y2hpbmcgZGlmZnMuIFByb2JhYmx5IG1vdmluZyBkaWZmcyB1cC9kb3duIGluIHRoZSBhbGdvcml0aG0gY2F1c2VzIHRvdWNoaW5nIGRpZmZzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcobGFzdENoYW5nZS5vcmlnaW5hbC5qb2luKGNoYW5nZS5vcmlnaW5hbCksIGxhc3RDaGFuZ2UubW9kaWZpZWQuam9pbihjaGFuZ2UubW9kaWZpZWQpLCBsYXN0Q2hhbmdlLmlubmVyQ2hhbmdlcyAmJiBjaGFuZ2UuaW5uZXJDaGFuZ2VzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYW5nZS5pbm5lckNoYW5nZXMuY29uY2F0KGNoYW5nZS5pbm5lckNoYW5nZXMpIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xyXG4gICAgICAgICAgICBsYXN0Q2hhbmdlID0gY2hhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRGbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGVja0FkamFjZW50SXRlbXMoY2hhbmdlcywgKG0xLCBtMikgPT4gbTIub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9PT0gbTIubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gbTEubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAmJlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaGFzIHRvIGJlIGFuIHVuY2hhbmdlZCBsaW5lIGluIGJldHdlZW4gKG90aGVyd2lzZSBib3RoIGRpZmZzIHNob3VsZCBoYXZlIGJlZW4gam9pbmVkKVxyXG4gICAgICAgICAgICAgICAgbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAmJlxyXG4gICAgICAgICAgICAgICAgbTEubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lc0RpZmYoY2hhbmdlcywgW10sIHJlc3VsdC5xdWl0RWFybHkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSwgcHJldHR5KSB7XHJcbiAgICBjb25zdCBkaWZmQWxnbyA9IG5ldyBMY3NEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSk7XHJcbiAgICByZXR1cm4gZGlmZkFsZ28uQ29tcHV0ZURpZmYocHJldHR5KTtcclxufVxyXG5jbGFzcyBMaW5lU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IobGluZXMpIHtcclxuICAgICAgICBjb25zdCBzdGFydENvbHVtbnMgPSBbXTtcclxuICAgICAgICBjb25zdCBlbmRDb2x1bW5zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uc1tpXSA9IGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xyXG4gICAgICAgICAgICBlbmRDb2x1bW5zW2ldID0gZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKGxpbmVzW2ldLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0Q29sdW1ucyA9IHN0YXJ0Q29sdW1ucztcclxuICAgICAgICB0aGlzLl9lbmRDb2x1bW5zID0gZW5kQ29sdW1ucztcclxuICAgIH1cclxuICAgIGdldEVsZW1lbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgZWxlbWVudHNbaV0gPSB0aGlzLmxpbmVzW2ldLnN1YnN0cmluZyh0aGlzLl9zdGFydENvbHVtbnNbaV0gLSAxLCB0aGlzLl9lbmRDb2x1bW5zW2ldIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgIH1cclxuICAgIGdldFN0cmljdEVsZW1lbnQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tpbmRleF07XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydExpbmVOdW1iZXIoaSkge1xyXG4gICAgICAgIHJldHVybiBpICsgMTtcclxuICAgIH1cclxuICAgIGdldEVuZExpbmVOdW1iZXIoaSkge1xyXG4gICAgICAgIHJldHVybiBpICsgMTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUNoYXJTZXF1ZW5jZShzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcclxuICAgICAgICBjb25zdCBjaGFyQ29kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBsaW5lTnVtYmVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcclxuICAgICAgICBsZXQgbGVuID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDw9IGVuZEluZGV4OyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGhpcy5saW5lc1tpbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fc3RhcnRDb2x1bW5zW2luZGV4XSA6IDEpO1xyXG4gICAgICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSAoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgPyB0aGlzLl9lbmRDb2x1bW5zW2luZGV4XSA6IGxpbmVDb250ZW50Lmxlbmd0aCArIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSBzdGFydENvbHVtbjsgY29sIDwgZW5kQ29sdW1uOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgY2hhckNvZGVzW2xlbl0gPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNvbCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcnNbbGVuXSA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbnNbbGVuXSA9IGNvbDtcclxuICAgICAgICAgICAgICAgIGxlbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgJiYgaW5kZXggPCBlbmRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIFxcbiBpZiB0cmltIHdoaXRlc3BhY2UgaXMgbm90IGlnbm9yZWRcclxuICAgICAgICAgICAgICAgIGNoYXJDb2Rlc1tsZW5dID0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi87XHJcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyc1tsZW5dID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uc1tsZW5dID0gbGluZUNvbnRlbnQubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgIGxlbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhclNlcXVlbmNlKGNoYXJDb2RlcywgbGluZU51bWJlcnMsIGNvbHVtbnMpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENoYXJTZXF1ZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFyQ29kZXMsIGxpbmVOdW1iZXJzLCBjb2x1bW5zKSB7XHJcbiAgICAgICAgdGhpcy5fY2hhckNvZGVzID0gY2hhckNvZGVzO1xyXG4gICAgICAgIHRoaXMuX2xpbmVOdW1iZXJzID0gbGluZU51bWJlcnM7XHJcbiAgICAgICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKCdbJyArIHRoaXMuX2NoYXJDb2Rlcy5tYXAoKHMsIGlkeCkgPT4gKHMgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovID8gJ1xcXFxuJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUocykpICsgYC0oJHt0aGlzLl9saW5lTnVtYmVyc1tpZHhdfSwke3RoaXMuX2NvbHVtbnNbaWR4XX0pYCkuam9pbignLCAnKSArICddJyk7XHJcbiAgICB9XHJcbiAgICBfYXNzZXJ0SW5kZXgoaW5kZXgsIGFycikge1xyXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgaW5kZXhgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFbGVtZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2hhckNvZGVzO1xyXG4gICAgfVxyXG4gICAgZ2V0U3RhcnRMaW5lTnVtYmVyKGkpIHtcclxuICAgICAgICBpZiAoaSA+IDAgJiYgaSA9PT0gdGhpcy5fbGluZU51bWJlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBzdGFydCBsaW5lIG51bWJlciBvZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgbGFzdCBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIGlzIHRoZSBlbmQgbGluZSBudW1iZXIgb2YgdGhlIGxhc3QgZWxlbWVudFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmRMaW5lTnVtYmVyKGkgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXNzZXJ0SW5kZXgoaSwgdGhpcy5fbGluZU51bWJlcnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lTnVtYmVyc1tpXTtcclxuICAgIH1cclxuICAgIGdldEVuZExpbmVOdW1iZXIoaSkge1xyXG4gICAgICAgIGlmIChpID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyB0aGUgZW5kIGxpbmUgbnVtYmVyIG9mIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBpcyB0aGUgc3RhcnQgbGluZSBudW1iZXIgb2YgdGhlIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRMaW5lTnVtYmVyKGkgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXNzZXJ0SW5kZXgoaSwgdGhpcy5fbGluZU51bWJlcnMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGFyQ29kZXNbaV0gPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lTnVtYmVyc1tpXSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lTnVtYmVyc1tpXTtcclxuICAgIH1cclxuICAgIGdldFN0YXJ0Q29sdW1uKGkpIHtcclxuICAgICAgICBpZiAoaSA+IDAgJiYgaSA9PT0gdGhpcy5fY29sdW1ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IGNvbHVtbiBvZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgbGFzdCBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIGlzIHRoZSBlbmQgY29sdW1uIG9mIHRoZSBsYXN0IGVsZW1lbnRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5kQ29sdW1uKGkgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXNzZXJ0SW5kZXgoaSwgdGhpcy5fY29sdW1ucyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNbaV07XHJcbiAgICB9XHJcbiAgICBnZXRFbmRDb2x1bW4oaSkge1xyXG4gICAgICAgIGlmIChpID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyB0aGUgZW5kIGNvbHVtbiBvZiB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gaXMgdGhlIHN0YXJ0IGNvbHVtbiBvZiB0aGUgZmlyc3QgZWxlbWVudFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFydENvbHVtbihpICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Fzc2VydEluZGV4KGksIHRoaXMuX2NvbHVtbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGFyQ29kZXNbaV0gPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uc1tpXSArIDE7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ2hhckNoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxTdGFydENvbHVtbjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsRW5kTGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kQ29sdW1uID0gb3JpZ2luYWxFbmRDb2x1bW47XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkU3RhcnRDb2x1bW47XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZENvbHVtbiA9IG1vZGlmaWVkRW5kQ29sdW1uO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmQ2hhbmdlKGRpZmZDaGFuZ2UsIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydENvbHVtbiA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmRDb2x1bW4gPSBvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRFbmRDb2x1bW4oZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRFbmRDb2x1bW4gPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRDb2x1bW4oZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhckNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcykge1xyXG4gICAgaWYgKHJhd0NoYW5nZXMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICByZXR1cm4gcmF3Q2hhbmdlcztcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IFtyYXdDaGFuZ2VzWzBdXTtcclxuICAgIGxldCBwcmV2Q2hhbmdlID0gcmVzdWx0WzBdO1xyXG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjdXJyQ2hhbmdlID0gcmF3Q2hhbmdlc1tpXTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbE1hdGNoaW5nTGVuZ3RoID0gY3VyckNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gKHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgLSAocHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCk7XHJcbiAgICAgICAgLy8gQm90aCBvZiB0aGUgYWJvdmUgc2hvdWxkIGJlIGVxdWFsLCBidXQgdGhlIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSBtYXkgcHJldmVudCB0aGlzIGZyb20gYmVpbmcgdHJ1ZVxyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nTGVuZ3RoID0gTWF0aC5taW4ob3JpZ2luYWxNYXRjaGluZ0xlbmd0aCwgbW9kaWZpZWRNYXRjaGluZ0xlbmd0aCk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nTGVuZ3RoIDwgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBjdXJyZW50IGNoYW5nZSBpbnRvIHRoZSBwcmV2aW91cyBvbmVcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9IChjdXJyQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjdXJyQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSAtIHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IChjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjdXJyQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSAtIHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjaGFuZ2VcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyckNoYW5nZSk7XHJcbiAgICAgICAgICAgIHByZXZDaGFuZ2UgPSBjdXJyQ2hhbmdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY2xhc3MgTGluZUNoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsRW5kTGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5jaGFyQ2hhbmdlcyA9IGNoYXJDaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmUmVzdWx0KHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLCBvcmlnaW5hbExpbmVTZXF1ZW5jZSwgbW9kaWZpZWRMaW5lU2VxdWVuY2UsIGNvbnRpbnVlQ2hhckRpZmYsIHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xyXG4gICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBjaGFyQ2hhbmdlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQpIC0gMTtcclxuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpIC0gMTtcclxuICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzICYmIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwICYmIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPCAyMCAmJiBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID4gMCAmJiBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIDwgMjAgJiYgY29udGludWVDaGFyRGlmZigpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2hhcmFjdGVyIGNoYW5nZXMgZm9yIGRpZmYgY2h1bmtzIG9mIGF0IG1vc3QgMjAgbGluZXMuLi5cclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFyU2VxdWVuY2UgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCwgZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZENoYXJTZXF1ZW5jZSA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmNyZWF0ZUNoYXJTZXF1ZW5jZShzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0LCBkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRFbGVtZW50cygpLmxlbmd0aCA+IDAgJiYgbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0RWxlbWVudHMoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmF3Q2hhbmdlcyA9IGNvbXB1dGVEaWZmKG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSwgY29udGludWVDaGFyRGlmZiwgdHJ1ZSkuY2hhbmdlcztcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Q2hhbmdlcyA9IHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlcy5wdXNoKENoYXJDaGFuZ2UuY3JlYXRlRnJvbURpZmZDaGFuZ2UocmF3Q2hhbmdlc1tpXSwgb3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ2hhbmdlKG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIGNoYXJDaGFuZ2VzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRGlmZkNvbXB1dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG9wdHMpIHtcclxuICAgICAgICB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcztcclxuICAgICAgICB0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID0gb3B0cy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZTtcclxuICAgICAgICB0aGlzLnNob3VsZE1ha2VQcmV0dHlEaWZmID0gb3B0cy5zaG91bGRNYWtlUHJldHR5RGlmZjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsTGluZXMgPSBvcmlnaW5hbExpbmVzO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkTGluZXM7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG5ldyBMaW5lU2VxdWVuY2Uob3JpZ2luYWxMaW5lcyk7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG5ldyBMaW5lU2VxdWVuY2UobW9kaWZpZWRMaW5lcyk7XHJcbiAgICAgICAgdGhpcy5jb250aW51ZUxpbmVEaWZmID0gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG9wdHMubWF4Q29tcHV0YXRpb25UaW1lKTtcclxuICAgICAgICB0aGlzLmNvbnRpbnVlQ2hhckRpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUgPT09IDAgPyAwIDogTWF0aC5taW4ob3B0cy5tYXhDb21wdXRhdGlvblRpbWUsIDUwMDApKTsgLy8gbmV2ZXIgcnVuIGFmdGVyIDVzIGZvciBjaGFyYWN0ZXIgY2hhbmdlcy4uLlxyXG4gICAgfVxyXG4gICAgY29tcHV0ZURpZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWwubGluZXMubGVuZ3RoID09PSAxICYmIHRoaXMub3JpZ2luYWwubGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGVtcHR5IG9yaWdpbmFsID0+IGZhc3QgcGF0aFxyXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGggPT09IDEgJiYgdGhpcy5tb2RpZmllZC5saW5lc1swXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IHRoaXMubW9kaWZpZWQubGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubW9kaWZpZWQubGluZXMubGVuZ3RoID09PSAxICYmIHRoaXMubW9kaWZpZWQubGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGVtcHR5IG1vZGlmaWVkID0+IGZhc3QgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IHRoaXMub3JpZ2luYWwubGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGNvbXB1dGVEaWZmKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVMaW5lRGlmZiwgdGhpcy5zaG91bGRNYWtlUHJldHR5RGlmZik7XHJcbiAgICAgICAgY29uc3QgcmF3Q2hhbmdlcyA9IGRpZmZSZXN1bHQuY2hhbmdlcztcclxuICAgICAgICBjb25zdCBxdWl0RWFybHkgPSBkaWZmUmVzdWx0LnF1aXRFYXJseTtcclxuICAgICAgICAvLyBUaGUgZGlmZiBpcyBhbHdheXMgY29tcHV0ZWQgd2l0aCBpZ25vcmluZyB0cmltIHdoaXRlc3BhY2VcclxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZ2V0IHRoZSBwcmV0dGllc3QgZGlmZlxyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lQ2hhbmdlcy5wdXNoKExpbmVDaGFuZ2UuY3JlYXRlRnJvbURpZmZSZXN1bHQodGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgcmF3Q2hhbmdlc1tpXSwgdGhpcy5vcmlnaW5hbCwgdGhpcy5tb2RpZmllZCwgdGhpcy5jb250aW51ZUNoYXJEaWZmLCB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHF1aXRFYXJseTogcXVpdEVhcmx5LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlczogbGluZUNoYW5nZXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTmVlZCB0byBwb3N0LXByb2Nlc3MgYW5kIGludHJvZHVjZSBjaGFuZ2VzIHdoZXJlIHRoZSB0cmltIHdoaXRlc3BhY2UgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFyZSBsb29waW5nIHN0YXJ0aW5nIGF0IC0xIHRvIGFsc28gY292ZXIgdGhlIGxpbmVzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsTGluZUluZGV4ID0gMDtcclxuICAgICAgICBsZXQgbW9kaWZpZWRMaW5lSW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAtMSAvKiAhISEhICovLCBsZW4gPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFuZ2UgPSAoaSArIDEgPCBsZW4gPyByYXdDaGFuZ2VzW2kgKyAxXSA6IG51bGwpO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSAobmV4dENoYW5nZSA/IG5leHRDaGFuZ2Uub3JpZ2luYWxTdGFydCA6IHRoaXMub3JpZ2luYWxMaW5lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0b3AgPSAobmV4dENoYW5nZSA/IG5leHRDaGFuZ2UubW9kaWZpZWRTdGFydCA6IHRoaXMubW9kaWZpZWRMaW5lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxMaW5lSW5kZXggPCBvcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRMaW5lSW5kZXggPCBtb2RpZmllZFN0b3ApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZSA9IHRoaXMub3JpZ2luYWxMaW5lc1tvcmlnaW5hbExpbmVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmUgPSB0aGlzLm1vZGlmaWVkTGluZXNbbW9kaWZpZWRMaW5lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZSAhPT0gbW9kaWZpZWRMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgbGluZXMgZGlmZmVyIG9ubHkgaW4gdHJpbSB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRDb2x1bW4gPSBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZFN0YXJ0Q29sdW1uID0gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbihtb2RpZmllZExpbmUsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydENvbHVtbiA+IDEgJiYgbW9kaWZpZWRTdGFydENvbHVtbiA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG9yaWdpbmFsU3RhcnRDb2x1bW4gLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkQ2hhciA9IG1vZGlmaWVkTGluZS5jaGFyQ29kZUF0KG1vZGlmaWVkU3RhcnRDb2x1bW4gLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0Q29sdW1uID4gMSB8fCBtb2RpZmllZFN0YXJ0Q29sdW1uID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgMSwgb3JpZ2luYWxTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lSW5kZXggKyAxLCAxLCBtb2RpZmllZFN0YXJ0Q29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsRW5kQ29sdW1uID0gZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZEVuZENvbHVtbiA9IGdldExhc3ROb25CbGFua0NvbHVtbihtb2RpZmllZExpbmUsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbE1heENvbHVtbiA9IG9yaWdpbmFsTGluZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZE1heENvbHVtbiA9IG1vZGlmaWVkTGluZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxFbmRDb2x1bW4gPCBvcmlnaW5hbE1heENvbHVtbiAmJiBtb2RpZmllZEVuZENvbHVtbiA8IG1vZGlmaWVkTWF4Q29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoYXIgPSBvcmlnaW5hbExpbmUuY2hhckNvZGVBdChvcmlnaW5hbEVuZENvbHVtbiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQobW9kaWZpZWRFbmRDb2x1bW4gLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRW5kQ29sdW1uIDwgb3JpZ2luYWxNYXhDb2x1bW4gfHwgbW9kaWZpZWRFbmRDb2x1bW4gPCBtb2RpZmllZE1heENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgb3JpZ2luYWxFbmRDb2x1bW4sIG9yaWdpbmFsTWF4Q29sdW1uLCBtb2RpZmllZExpbmVJbmRleCArIDEsIG1vZGlmaWVkRW5kQ29sdW1uLCBtb2RpZmllZE1heENvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgYWN0dWFsIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTGluZUNoYW5nZS5jcmVhdGVGcm9tRGlmZlJlc3VsdCh0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBuZXh0Q2hhbmdlLCB0aGlzLm9yaWdpbmFsLCB0aGlzLm1vZGlmaWVkLCB0aGlzLmNvbnRpbnVlQ2hhckRpZmYsIHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzLCB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZUluZGV4ICs9IG5leHRDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZExpbmVJbmRleCArPSBuZXh0Q2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1aXRFYXJseTogcXVpdEVhcmx5LFxyXG4gICAgICAgICAgICBjaGFuZ2VzOiByZXN1bHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lcmdlVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikpIHtcclxuICAgICAgICAgICAgLy8gTWVyZ2VkIGludG8gcHJldmlvdXNcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2hhckNoYW5nZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGNoYXJDaGFuZ2VzID0gW25ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkTGluZU51bWJlciwgY2hhckNoYW5nZXMpKTtcclxuICAgIH1cclxuICAgIF9tZXJnZVRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcclxuICAgICAgICBjb25zdCBsZW4gPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlID0gcmVzdWx0W2xlbiAtIDFdO1xyXG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciA9PT0gMCB8fCBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBtZXJnZSB3aXRoIGluc2VydHMvZGVsZXRlc1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciA9PT0gb3JpZ2luYWxMaW5lTnVtYmVyICYmIHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID09PSBtb2RpZmllZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzICYmIHByZXZDaGFuZ2UuY2hhckNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHByZXZDaGFuZ2UuY2hhckNoYW5nZXMucHVzaChuZXcgQ2hhckNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgKyAxID09PSBvcmlnaW5hbExpbmVOdW1iZXIgJiYgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgKyAxID09PSBtb2RpZmllZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMgJiYgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcy5wdXNoKG5ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKHR4dCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBjb25zdCByID0gc3RyaW5ncy5maXJzdE5vbldoaXRlc3BhY2VJbmRleCh0eHQpO1xyXG4gICAgaWYgKHIgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByICsgMTtcclxufVxyXG5mdW5jdGlvbiBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4odHh0LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmxhc3ROb25XaGl0ZXNwYWNlSW5kZXgodHh0KTtcclxuICAgIGlmIChyID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gciArIDI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG1heGltdW1SdW50aW1lKSB7XHJcbiAgICBpZiAobWF4aW11bVJ1bnRpbWUgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgbWF4aW11bVJ1bnRpbWU7XHJcbiAgICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinesDiff: () => (/* binding */ LinesDiff),\n/* harmony export */   MovedText: () => (/* binding */ MovedText)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass LinesDiff {\r\n    constructor(changes, \r\n    /**\r\n     * Sorted by original line ranges.\r\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\r\n     */\r\n    moves, \r\n    /**\r\n     * Indicates if the time out was reached.\r\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\r\n     */\r\n    hitTimeout) {\r\n        this.changes = changes;\r\n        this.moves = moves;\r\n        this.hitTimeout = hitTimeout;\r\n    }\r\n}\r\nclass MovedText {\r\n    constructor(lineRangeMapping, changes) {\r\n        this.lineRangeMapping = lineRangeMapping;\r\n        this.changes = changes;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2xpbmVzRGlmZkNvbXB1dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9saW5lc0RpZmZDb21wdXRlci5qcz84ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgY2xhc3MgTGluZXNEaWZmIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5nZXMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0ZWQgYnkgb3JpZ2luYWwgbGluZSByYW5nZXMuXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwgbGluZSByYW5nZXMgYW5kIHRoZSBtb2RpZmllZCBsaW5lIHJhbmdlcyBtdXN0IGJlIGRpc2pvaW50IChidXQgY2FuIGJlIHRvdWNoaW5nKS5cclxuICAgICAqL1xyXG4gICAgbW92ZXMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHRpbWUgb3V0IHdhcyByZWFjaGVkLlxyXG4gICAgICogSW4gdGhhdCBjYXNlLCB0aGUgZGlmZnMgbWlnaHQgYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgdGhlIHVzZXIgc2hvdWxkIGJlIGFza2VkIHRvIHJlcnVuIHRoZSBkaWZmIHdpdGggbW9yZSB0aW1lLlxyXG4gICAgICovXHJcbiAgICBoaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcclxuICAgICAgICB0aGlzLm1vdmVzID0gbW92ZXM7XHJcbiAgICAgICAgdGhpcy5oaXRUaW1lb3V0ID0gaGl0VGltZW91dDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTW92ZWRUZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKGxpbmVSYW5nZU1hcHBpbmcsIGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLmxpbmVSYW5nZU1hcHBpbmcgPSBsaW5lUmFuZ2VNYXBwaW5nO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   linesDiffComputers: () => (/* binding */ linesDiffComputers)\n/* harmony export */ });\n/* harmony import */ var _legacyLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacyLinesDiffComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js\");\n/* harmony import */ var _defaultLinesDiffComputer_defaultLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultLinesDiffComputer/defaultLinesDiffComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nconst linesDiffComputers = {\r\n    getLegacy: () => new _legacyLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_0__.LegacyLinesDiffComputer(),\r\n    getDefault: () => new _defaultLinesDiffComputer_defaultLinesDiffComputer_js__WEBPACK_IMPORTED_MODULE_1__.DefaultLinesDiffComputer(),\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2xpbmVzRGlmZkNvbXB1dGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RTtBQUMyQjtBQUMzRjtBQUNQLHlCQUF5QixnRkFBdUI7QUFDaEQsMEJBQTBCLDJHQUF3QjtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvbGluZXNEaWZmQ29tcHV0ZXJzLmpzPzBiODMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IExlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyIH0gZnJvbSAnLi9sZWdhY3lMaW5lc0RpZmZDb21wdXRlci5qcyc7XHJcbmltcG9ydCB7IERlZmF1bHRMaW5lc0RpZmZDb21wdXRlciB9IGZyb20gJy4vZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci5qcyc7XHJcbmV4cG9ydCBjb25zdCBsaW5lc0RpZmZDb21wdXRlcnMgPSB7XHJcbiAgICBnZXRMZWdhY3k6ICgpID0+IG5ldyBMZWdhY3lMaW5lc0RpZmZDb21wdXRlcigpLFxyXG4gICAgZ2V0RGVmYXVsdDogKCkgPT4gbmV3IERlZmF1bHRMaW5lc0RpZmZDb21wdXRlcigpLFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DetailedLineRangeMapping: () => (/* binding */ DetailedLineRangeMapping),\n/* harmony export */   LineRangeMapping: () => (/* binding */ LineRangeMapping),\n/* harmony export */   RangeMapping: () => (/* binding */ RangeMapping)\n/* harmony export */ });\n/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/lineRange.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _core_textEdit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/textEdit.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n/**\r\n * Maps a line range in the original text model to a line range in the modified text model.\r\n */\r\nclass LineRangeMapping {\r\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\r\n        const result = [];\r\n        let lastOriginalEndLineNumber = 1;\r\n        let lastModifiedEndLineNumber = 1;\r\n        for (const m of mapping) {\r\n            const r = new LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\r\n            if (!r.modified.isEmpty) {\r\n                result.push(r);\r\n            }\r\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\r\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\r\n        }\r\n        const r = new LineRangeMapping(new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\r\n        if (!r.modified.isEmpty) {\r\n            result.push(r);\r\n        }\r\n        return result;\r\n    }\r\n    static clip(mapping, originalRange, modifiedRange) {\r\n        const result = [];\r\n        for (const m of mapping) {\r\n            const original = m.original.intersect(originalRange);\r\n            const modified = m.modified.intersect(modifiedRange);\r\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\r\n                result.push(new LineRangeMapping(original, modified));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    constructor(originalRange, modifiedRange) {\r\n        this.original = originalRange;\r\n        this.modified = modifiedRange;\r\n    }\r\n    toString() {\r\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\r\n    }\r\n    flip() {\r\n        return new LineRangeMapping(this.modified, this.original);\r\n    }\r\n    join(other) {\r\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\r\n    }\r\n    /**\r\n     * This method assumes that the LineRangeMapping describes a valid diff!\r\n     * I.e. if one range is empty, the other range cannot be the entire document.\r\n     * It avoids various problems when the line range points to non-existing line-numbers.\r\n    */\r\n    toRangeMapping() {\r\n        const origInclusiveRange = this.original.toInclusiveRange();\r\n        const modInclusiveRange = this.modified.toInclusiveRange();\r\n        if (origInclusiveRange && modInclusiveRange) {\r\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\r\n        }\r\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\r\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\r\n                // If one line range starts at 1, the other one must start at 1 as well.\r\n                throw new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('not a valid diff');\r\n            }\r\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\r\n            // Thus, `endLineNumberExclusive` is a valid line number.\r\n            return new RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\r\n        }\r\n        else {\r\n            // We can assume here that both startLineNumbers are greater than 1.\r\n            return new RangeMapping(new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Maps a line range in the original text model to a line range in the modified text model.\r\n * Also contains inner range mappings.\r\n */\r\nclass DetailedLineRangeMapping extends LineRangeMapping {\r\n    static fromRangeMappings(rangeMappings) {\r\n        const originalRange = _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.join(rangeMappings.map(r => _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.fromRangeInclusive(r.originalRange)));\r\n        const modifiedRange = _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.join(rangeMappings.map(r => _core_lineRange_js__WEBPACK_IMPORTED_MODULE_1__.LineRange.fromRangeInclusive(r.modifiedRange)));\r\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\r\n    }\r\n    constructor(originalRange, modifiedRange, innerChanges) {\r\n        super(originalRange, modifiedRange);\r\n        this.innerChanges = innerChanges;\r\n    }\r\n    flip() {\r\n        var _a;\r\n        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\r\n    }\r\n    withInnerChangesFromLineRanges() {\r\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\r\n    }\r\n}\r\n/**\r\n * Maps a range in the original text model to a range in the modified text model.\r\n */\r\nclass RangeMapping {\r\n    constructor(originalRange, modifiedRange) {\r\n        this.originalRange = originalRange;\r\n        this.modifiedRange = modifiedRange;\r\n    }\r\n    toString() {\r\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\r\n    }\r\n    flip() {\r\n        return new RangeMapping(this.modifiedRange, this.originalRange);\r\n    }\r\n    /**\r\n     * Creates a single text edit that describes the change from the original to the modified text.\r\n    */\r\n    toTextEdit(modified) {\r\n        const newText = modified.getValueOfRange(this.modifiedRange);\r\n        return new _core_textEdit_js__WEBPACK_IMPORTED_MODULE_3__.SingleTextEdit(this.originalRange, newText);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL3JhbmdlTWFwcGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDb0U7QUFDbkI7QUFDUjtBQUNZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBUyw2REFBNkQseURBQVM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlEQUFTLHdEQUF3RCx5REFBUztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSx5QkFBeUIsSUFBSSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNFQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaURBQUssaUZBQWlGLGlEQUFLO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBSyxxSUFBcUksaURBQUs7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEJBQThCLHlEQUFTLDZCQUE2Qix5REFBUztBQUM3RSw4QkFBOEIseURBQVMsNkJBQTZCLHlEQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSw4QkFBOEIsSUFBSSwrQkFBK0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFjO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL3JhbmdlTWFwcGluZy5qcz81NTllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBCdWdJbmRpY2F0aW5nRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xyXG5pbXBvcnQgeyBMaW5lUmFuZ2UgfSBmcm9tICcuLi9jb3JlL2xpbmVSYW5nZS5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IFNpbmdsZVRleHRFZGl0IH0gZnJvbSAnLi4vY29yZS90ZXh0RWRpdC5qcyc7XHJcbi8qKlxyXG4gKiBNYXBzIGEgbGluZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgdGV4dCBtb2RlbCB0byBhIGxpbmUgcmFuZ2UgaW4gdGhlIG1vZGlmaWVkIHRleHQgbW9kZWwuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGluZVJhbmdlTWFwcGluZyB7XHJcbiAgICBzdGF0aWMgaW52ZXJzZShtYXBwaW5nLCBvcmlnaW5hbExpbmVDb3VudCwgbW9kaWZpZWRMaW5lQ291bnQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgbGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciA9IDE7XHJcbiAgICAgICAgbGV0IGxhc3RNb2RpZmllZEVuZExpbmVOdW1iZXIgPSAxO1xyXG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBtYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBuZXcgTGluZVJhbmdlTWFwcGluZyhuZXcgTGluZVJhbmdlKGxhc3RPcmlnaW5hbEVuZExpbmVOdW1iZXIsIG0ub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyKSwgbmV3IExpbmVSYW5nZShsYXN0TW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBtLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcikpO1xyXG4gICAgICAgICAgICBpZiAoIXIubW9kaWZpZWQuaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciA9IG0ub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcclxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkRW5kTGluZU51bWJlciA9IG0ubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgciA9IG5ldyBMaW5lUmFuZ2VNYXBwaW5nKG5ldyBMaW5lUmFuZ2UobGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxMaW5lQ291bnQgKyAxKSwgbmV3IExpbmVSYW5nZShsYXN0TW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVDb3VudCArIDEpKTtcclxuICAgICAgICBpZiAoIXIubW9kaWZpZWQuaXNFbXB0eSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjbGlwKG1hcHBpbmcsIG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbWFwcGluZykge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG0ub3JpZ2luYWwuaW50ZXJzZWN0KG9yaWdpbmFsUmFuZ2UpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZCA9IG0ubW9kaWZpZWQuaW50ZXJzZWN0KG1vZGlmaWVkUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWwgJiYgIW9yaWdpbmFsLmlzRW1wdHkgJiYgbW9kaWZpZWQgJiYgIW1vZGlmaWVkLmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lUmFuZ2VNYXBwaW5nKG9yaWdpbmFsLCBtb2RpZmllZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG1vZGlmaWVkUmFuZ2U7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYHske3RoaXMub3JpZ2luYWwudG9TdHJpbmcoKX0tPiR7dGhpcy5tb2RpZmllZC50b1N0cmluZygpfX1gO1xyXG4gICAgfVxyXG4gICAgZmxpcCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZU1hcHBpbmcodGhpcy5tb2RpZmllZCwgdGhpcy5vcmlnaW5hbCk7XHJcbiAgICB9XHJcbiAgICBqb2luKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VNYXBwaW5nKHRoaXMub3JpZ2luYWwuam9pbihvdGhlci5vcmlnaW5hbCksIHRoaXMubW9kaWZpZWQuam9pbihvdGhlci5tb2RpZmllZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXQgdGhlIExpbmVSYW5nZU1hcHBpbmcgZGVzY3JpYmVzIGEgdmFsaWQgZGlmZiFcclxuICAgICAqIEkuZS4gaWYgb25lIHJhbmdlIGlzIGVtcHR5LCB0aGUgb3RoZXIgcmFuZ2UgY2Fubm90IGJlIHRoZSBlbnRpcmUgZG9jdW1lbnQuXHJcbiAgICAgKiBJdCBhdm9pZHMgdmFyaW91cyBwcm9ibGVtcyB3aGVuIHRoZSBsaW5lIHJhbmdlIHBvaW50cyB0byBub24tZXhpc3RpbmcgbGluZS1udW1iZXJzLlxyXG4gICAgKi9cclxuICAgIHRvUmFuZ2VNYXBwaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdJbmNsdXNpdmVSYW5nZSA9IHRoaXMub3JpZ2luYWwudG9JbmNsdXNpdmVSYW5nZSgpO1xyXG4gICAgICAgIGNvbnN0IG1vZEluY2x1c2l2ZVJhbmdlID0gdGhpcy5tb2RpZmllZC50b0luY2x1c2l2ZVJhbmdlKCk7XHJcbiAgICAgICAgaWYgKG9yaWdJbmNsdXNpdmVSYW5nZSAmJiBtb2RJbmNsdXNpdmVSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyhvcmlnSW5jbHVzaXZlUmFuZ2UsIG1vZEluY2x1c2l2ZVJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgPT09IDEgfHwgdGhpcy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKCEodGhpcy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPT09IDEgJiYgdGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgPT09IDEpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBvbmUgbGluZSByYW5nZSBzdGFydHMgYXQgMSwgdGhlIG90aGVyIG9uZSBtdXN0IHN0YXJ0IGF0IDEgYXMgd2VsbC5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ25vdCBhIHZhbGlkIGRpZmYnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9uZSByYW5nZSBpcyBlbXB0eSBhbmQgYm90aCByYW5nZXMgc3RhcnQgYXQgbGluZSAxLCBub25lIG9mIHRoZSByYW5nZXMgY2FuIGNvdmVyIGFsbCBsaW5lcy5cclxuICAgICAgICAgICAgLy8gVGh1cywgYGVuZExpbmVOdW1iZXJFeGNsdXNpdmVgIGlzIGEgdmFsaWQgbGluZSBudW1iZXIuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VNYXBwaW5nKG5ldyBSYW5nZSh0aGlzLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCAxKSwgbmV3IFJhbmdlKHRoaXMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyLCAxLCB0aGlzLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBhc3N1bWUgaGVyZSB0aGF0IGJvdGggc3RhcnRMaW5lTnVtYmVycyBhcmUgZ3JlYXRlciB0aGFuIDEuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VNYXBwaW5nKG5ldyBSYW5nZSh0aGlzLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCB0aGlzLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksIG5ldyBSYW5nZSh0aGlzLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIDEsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCB0aGlzLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFwcyBhIGxpbmUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIHRleHQgbW9kZWwgdG8gYSBsaW5lIHJhbmdlIGluIHRoZSBtb2RpZmllZCB0ZXh0IG1vZGVsLlxyXG4gKiBBbHNvIGNvbnRhaW5zIGlubmVyIHJhbmdlIG1hcHBpbmdzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERldGFpbGVkTGluZVJhbmdlTWFwcGluZyBleHRlbmRzIExpbmVSYW5nZU1hcHBpbmcge1xyXG4gICAgc3RhdGljIGZyb21SYW5nZU1hcHBpbmdzKHJhbmdlTWFwcGluZ3MpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFJhbmdlID0gTGluZVJhbmdlLmpvaW4ocmFuZ2VNYXBwaW5ncy5tYXAociA9PiBMaW5lUmFuZ2UuZnJvbVJhbmdlSW5jbHVzaXZlKHIub3JpZ2luYWxSYW5nZSkpKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllZFJhbmdlID0gTGluZVJhbmdlLmpvaW4ocmFuZ2VNYXBwaW5ncy5tYXAociA9PiBMaW5lUmFuZ2UuZnJvbVJhbmdlSW5jbHVzaXZlKHIubW9kaWZpZWRSYW5nZSkpKTtcclxuICAgICAgICByZXR1cm4gbmV3IERldGFpbGVkTGluZVJhbmdlTWFwcGluZyhvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlLCByYW5nZU1hcHBpbmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UsIGlubmVyQ2hhbmdlcykge1xyXG4gICAgICAgIHN1cGVyKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJDaGFuZ2VzID0gaW5uZXJDaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgZmxpcCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcodGhpcy5tb2RpZmllZCwgdGhpcy5vcmlnaW5hbCwgKF9hID0gdGhpcy5pbm5lckNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoYyA9PiBjLmZsaXAoKSkpO1xyXG4gICAgfVxyXG4gICAgd2l0aElubmVyQ2hhbmdlc0Zyb21MaW5lUmFuZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIFt0aGlzLnRvUmFuZ2VNYXBwaW5nKCldKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFwcyBhIHJhbmdlIGluIHRoZSBvcmlnaW5hbCB0ZXh0IG1vZGVsIHRvIGEgcmFuZ2UgaW4gdGhlIG1vZGlmaWVkIHRleHQgbW9kZWwuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmFuZ2VNYXBwaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UpIHtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsUmFuZ2UgPSBvcmlnaW5hbFJhbmdlO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRSYW5nZSA9IG1vZGlmaWVkUmFuZ2U7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYHske3RoaXMub3JpZ2luYWxSYW5nZS50b1N0cmluZygpfS0+JHt0aGlzLm1vZGlmaWVkUmFuZ2UudG9TdHJpbmcoKX19YDtcclxuICAgIH1cclxuICAgIGZsaXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZU1hcHBpbmcodGhpcy5tb2RpZmllZFJhbmdlLCB0aGlzLm9yaWdpbmFsUmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlIHRleHQgZWRpdCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBtb2RpZmllZCB0ZXh0LlxyXG4gICAgKi9cclxuICAgIHRvVGV4dEVkaXQobW9kaWZpZWQpIHtcclxuICAgICAgICBjb25zdCBuZXdUZXh0ID0gbW9kaWZpZWQuZ2V0VmFsdWVPZlJhbmdlKHRoaXMubW9kaWZpZWRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVUZXh0RWRpdCh0aGlzLm9yaWdpbmFsUmFuZ2UsIG5ld1RleHQpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages.js":
/*!**********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Command: () => (/* binding */ Command),\n/* harmony export */   CompletionItemKinds: () => (/* binding */ CompletionItemKinds),\n/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),\n/* harmony export */   DocumentPasteTriggerKind: () => (/* binding */ DocumentPasteTriggerKind),\n/* harmony export */   EncodedTokenizationResult: () => (/* binding */ EncodedTokenizationResult),\n/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),\n/* harmony export */   HoverVerbosityAction: () => (/* binding */ HoverVerbosityAction),\n/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),\n/* harmony export */   InlineCompletionTriggerKind: () => (/* binding */ InlineCompletionTriggerKind),\n/* harmony export */   InlineEditTriggerKind: () => (/* binding */ InlineEditTriggerKind),\n/* harmony export */   LazyTokenizationSupport: () => (/* binding */ LazyTokenizationSupport),\n/* harmony export */   NewSymbolNameTag: () => (/* binding */ NewSymbolNameTag),\n/* harmony export */   NewSymbolNameTriggerKind: () => (/* binding */ NewSymbolNameTriggerKind),\n/* harmony export */   SelectedSuggestionInfo: () => (/* binding */ SelectedSuggestionInfo),\n/* harmony export */   SignatureHelpTriggerKind: () => (/* binding */ SignatureHelpTriggerKind),\n/* harmony export */   SymbolKinds: () => (/* binding */ SymbolKinds),\n/* harmony export */   TextEdit: () => (/* binding */ TextEdit),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenizationRegistry: () => (/* binding */ TokenizationRegistry),\n/* harmony export */   TokenizationResult: () => (/* binding */ TokenizationResult),\n/* harmony export */   getAriaLabelForSymbol: () => (/* binding */ getAriaLabelForSymbol),\n/* harmony export */   isLocationLink: () => (/* binding */ isLocationLink),\n/* harmony export */   symbolKindNames: () => (/* binding */ symbolKindNames)\n/* harmony export */ });\n/* harmony import */ var _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/codicons.js */ \"./node_modules/monaco-editor/esm/vs/base/common/codicons.js\");\n/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base/common/uri.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uri.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokenizationRegistry.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js\");\n/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../nls.js */ \"./node_modules/monaco-editor/esm/vs/nls.js\");\n\r\n\r\n\r\n\r\n\r\nclass Token {\r\n    constructor(offset, type, language) {\r\n        this.offset = offset;\r\n        this.type = type;\r\n        this.language = language;\r\n        this._tokenBrand = undefined;\r\n    }\r\n    toString() {\r\n        return '(' + this.offset + ', ' + this.type + ')';\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass TokenizationResult {\r\n    constructor(tokens, endState) {\r\n        this.tokens = tokens;\r\n        this.endState = endState;\r\n        this._tokenizationResultBrand = undefined;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass EncodedTokenizationResult {\r\n    constructor(\r\n    /**\r\n     * The tokens in binary format. Each token occupies two array indices. For token i:\r\n     *  - at offset 2*i => startIndex\r\n     *  - at offset 2*i + 1 => metadata\r\n     *\r\n     */\r\n    tokens, endState) {\r\n        this.tokens = tokens;\r\n        this.endState = endState;\r\n        this._encodedTokenizationResultBrand = undefined;\r\n    }\r\n}\r\nvar HoverVerbosityAction;\r\n(function (HoverVerbosityAction) {\r\n    /**\r\n     * Increase the verbosity of the hover\r\n     */\r\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\r\n    /**\r\n     * Decrease the verbosity of the hover\r\n     */\r\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\r\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\r\n/**\r\n * @internal\r\n */\r\nvar CompletionItemKinds;\r\n(function (CompletionItemKinds) {\r\n    const byKind = new Map();\r\n    byKind.set(0 /* CompletionItemKind.Method */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolMethod);\r\n    byKind.set(1 /* CompletionItemKind.Function */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFunction);\r\n    byKind.set(2 /* CompletionItemKind.Constructor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstructor);\r\n    byKind.set(3 /* CompletionItemKind.Field */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolField);\r\n    byKind.set(4 /* CompletionItemKind.Variable */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolVariable);\r\n    byKind.set(5 /* CompletionItemKind.Class */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolClass);\r\n    byKind.set(6 /* CompletionItemKind.Struct */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolStruct);\r\n    byKind.set(7 /* CompletionItemKind.Interface */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolInterface);\r\n    byKind.set(8 /* CompletionItemKind.Module */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolModule);\r\n    byKind.set(9 /* CompletionItemKind.Property */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty);\r\n    byKind.set(10 /* CompletionItemKind.Event */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEvent);\r\n    byKind.set(11 /* CompletionItemKind.Operator */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolOperator);\r\n    byKind.set(12 /* CompletionItemKind.Unit */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolUnit);\r\n    byKind.set(13 /* CompletionItemKind.Value */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolValue);\r\n    byKind.set(15 /* CompletionItemKind.Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnum);\r\n    byKind.set(14 /* CompletionItemKind.Constant */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstant);\r\n    byKind.set(15 /* CompletionItemKind.Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnum);\r\n    byKind.set(16 /* CompletionItemKind.EnumMember */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnumMember);\r\n    byKind.set(17 /* CompletionItemKind.Keyword */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolKeyword);\r\n    byKind.set(27 /* CompletionItemKind.Snippet */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolSnippet);\r\n    byKind.set(18 /* CompletionItemKind.Text */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolText);\r\n    byKind.set(19 /* CompletionItemKind.Color */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolColor);\r\n    byKind.set(20 /* CompletionItemKind.File */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFile);\r\n    byKind.set(21 /* CompletionItemKind.Reference */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolReference);\r\n    byKind.set(22 /* CompletionItemKind.Customcolor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolCustomColor);\r\n    byKind.set(23 /* CompletionItemKind.Folder */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFolder);\r\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolTypeParameter);\r\n    byKind.set(25 /* CompletionItemKind.User */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.account);\r\n    byKind.set(26 /* CompletionItemKind.Issue */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.issues);\r\n    /**\r\n     * @internal\r\n     */\r\n    function toIcon(kind) {\r\n        let codicon = byKind.get(kind);\r\n        if (!codicon) {\r\n            console.info('No codicon found for CompletionItemKind ' + kind);\r\n            codicon = _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty;\r\n        }\r\n        return codicon;\r\n    }\r\n    CompletionItemKinds.toIcon = toIcon;\r\n    const data = new Map();\r\n    data.set('method', 0 /* CompletionItemKind.Method */);\r\n    data.set('function', 1 /* CompletionItemKind.Function */);\r\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\r\n    data.set('field', 3 /* CompletionItemKind.Field */);\r\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\r\n    data.set('class', 5 /* CompletionItemKind.Class */);\r\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\r\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\r\n    data.set('module', 8 /* CompletionItemKind.Module */);\r\n    data.set('property', 9 /* CompletionItemKind.Property */);\r\n    data.set('event', 10 /* CompletionItemKind.Event */);\r\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\r\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\r\n    data.set('value', 13 /* CompletionItemKind.Value */);\r\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\r\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\r\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\r\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\r\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\r\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\r\n    data.set('text', 18 /* CompletionItemKind.Text */);\r\n    data.set('color', 19 /* CompletionItemKind.Color */);\r\n    data.set('file', 20 /* CompletionItemKind.File */);\r\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\r\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\r\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\r\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\r\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\r\n    data.set('account', 25 /* CompletionItemKind.User */);\r\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\r\n    /**\r\n     * @internal\r\n     */\r\n    function fromString(value, strict) {\r\n        let res = data.get(value);\r\n        if (typeof res === 'undefined' && !strict) {\r\n            res = 9 /* CompletionItemKind.Property */;\r\n        }\r\n        return res;\r\n    }\r\n    CompletionItemKinds.fromString = fromString;\r\n})(CompletionItemKinds || (CompletionItemKinds = {}));\r\n/**\r\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\r\n */\r\nvar InlineCompletionTriggerKind;\r\n(function (InlineCompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered automatically while editing.\r\n     * It is sufficient to return a single completion item in this case.\r\n     */\r\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\r\n    /**\r\n     * Completion was triggered explicitly by a user gesture.\r\n     * Return multiple completion items to enable cycling through them.\r\n     */\r\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\r\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\r\nclass SelectedSuggestionInfo {\r\n    constructor(range, text, completionKind, isSnippetText) {\r\n        this.range = range;\r\n        this.text = text;\r\n        this.completionKind = completionKind;\r\n        this.isSnippetText = isSnippetText;\r\n    }\r\n    equals(other) {\r\n        return _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.lift(this.range).equalsRange(other.range)\r\n            && this.text === other.text\r\n            && this.completionKind === other.completionKind\r\n            && this.isSnippetText === other.isSnippetText;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nvar DocumentPasteTriggerKind;\r\n(function (DocumentPasteTriggerKind) {\r\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\r\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"PasteAs\"] = 1] = \"PasteAs\";\r\n})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));\r\nvar SignatureHelpTriggerKind;\r\n(function (SignatureHelpTriggerKind) {\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\r\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nvar DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * @internal\r\n */\r\nfunction isLocationLink(thing) {\r\n    return thing\r\n        && _base_common_uri_js__WEBPACK_IMPORTED_MODULE_1__.URI.isUri(thing.uri)\r\n        && _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.isIRange(thing.range)\r\n        && (_core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.isIRange(thing.originSelectionRange) || _core_range_js__WEBPACK_IMPORTED_MODULE_2__.Range.isIRange(thing.targetSelectionRange));\r\n}\r\n/**\r\n * @internal\r\n */\r\nconst symbolKindNames = {\r\n    [17 /* SymbolKind.Array */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Array', \"array\"),\r\n    [16 /* SymbolKind.Boolean */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Boolean', \"boolean\"),\r\n    [4 /* SymbolKind.Class */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Class', \"class\"),\r\n    [13 /* SymbolKind.Constant */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Constant', \"constant\"),\r\n    [8 /* SymbolKind.Constructor */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Constructor', \"constructor\"),\r\n    [9 /* SymbolKind.Enum */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Enum', \"enumeration\"),\r\n    [21 /* SymbolKind.EnumMember */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('EnumMember', \"enumeration member\"),\r\n    [23 /* SymbolKind.Event */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Event', \"event\"),\r\n    [7 /* SymbolKind.Field */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Field', \"field\"),\r\n    [0 /* SymbolKind.File */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('File', \"file\"),\r\n    [11 /* SymbolKind.Function */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Function', \"function\"),\r\n    [10 /* SymbolKind.Interface */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Interface', \"interface\"),\r\n    [19 /* SymbolKind.Key */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Key', \"key\"),\r\n    [5 /* SymbolKind.Method */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Method', \"method\"),\r\n    [1 /* SymbolKind.Module */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Module', \"module\"),\r\n    [2 /* SymbolKind.Namespace */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Namespace', \"namespace\"),\r\n    [20 /* SymbolKind.Null */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Null', \"null\"),\r\n    [15 /* SymbolKind.Number */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Number', \"number\"),\r\n    [18 /* SymbolKind.Object */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Object', \"object\"),\r\n    [24 /* SymbolKind.Operator */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Operator', \"operator\"),\r\n    [3 /* SymbolKind.Package */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Package', \"package\"),\r\n    [6 /* SymbolKind.Property */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Property', \"property\"),\r\n    [14 /* SymbolKind.String */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('String', \"string\"),\r\n    [22 /* SymbolKind.Struct */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Struct', \"struct\"),\r\n    [25 /* SymbolKind.TypeParameter */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('TypeParameter', \"type parameter\"),\r\n    [12 /* SymbolKind.Variable */]: (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('Variable', \"variable\"),\r\n};\r\n/**\r\n * @internal\r\n */\r\nfunction getAriaLabelForSymbol(symbolName, kind) {\r\n    return (0,_nls_js__WEBPACK_IMPORTED_MODULE_4__.localize)('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);\r\n}\r\n/**\r\n * @internal\r\n */\r\nvar SymbolKinds;\r\n(function (SymbolKinds) {\r\n    const byKind = new Map();\r\n    byKind.set(0 /* SymbolKind.File */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFile);\r\n    byKind.set(1 /* SymbolKind.Module */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolModule);\r\n    byKind.set(2 /* SymbolKind.Namespace */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolNamespace);\r\n    byKind.set(3 /* SymbolKind.Package */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolPackage);\r\n    byKind.set(4 /* SymbolKind.Class */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolClass);\r\n    byKind.set(5 /* SymbolKind.Method */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolMethod);\r\n    byKind.set(6 /* SymbolKind.Property */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty);\r\n    byKind.set(7 /* SymbolKind.Field */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolField);\r\n    byKind.set(8 /* SymbolKind.Constructor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstructor);\r\n    byKind.set(9 /* SymbolKind.Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnum);\r\n    byKind.set(10 /* SymbolKind.Interface */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolInterface);\r\n    byKind.set(11 /* SymbolKind.Function */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolFunction);\r\n    byKind.set(12 /* SymbolKind.Variable */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolVariable);\r\n    byKind.set(13 /* SymbolKind.Constant */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolConstant);\r\n    byKind.set(14 /* SymbolKind.String */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolString);\r\n    byKind.set(15 /* SymbolKind.Number */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolNumber);\r\n    byKind.set(16 /* SymbolKind.Boolean */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolBoolean);\r\n    byKind.set(17 /* SymbolKind.Array */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolArray);\r\n    byKind.set(18 /* SymbolKind.Object */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolObject);\r\n    byKind.set(19 /* SymbolKind.Key */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolKey);\r\n    byKind.set(20 /* SymbolKind.Null */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolNull);\r\n    byKind.set(21 /* SymbolKind.EnumMember */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEnumMember);\r\n    byKind.set(22 /* SymbolKind.Struct */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolStruct);\r\n    byKind.set(23 /* SymbolKind.Event */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolEvent);\r\n    byKind.set(24 /* SymbolKind.Operator */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolOperator);\r\n    byKind.set(25 /* SymbolKind.TypeParameter */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolTypeParameter);\r\n    /**\r\n     * @internal\r\n     */\r\n    function toIcon(kind) {\r\n        let icon = byKind.get(kind);\r\n        if (!icon) {\r\n            console.info('No codicon found for SymbolKind ' + kind);\r\n            icon = _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_0__.Codicon.symbolProperty;\r\n        }\r\n        return icon;\r\n    }\r\n    SymbolKinds.toIcon = toIcon;\r\n})(SymbolKinds || (SymbolKinds = {}));\r\n/** @internal */\r\nclass TextEdit {\r\n}\r\nclass FoldingRangeKind {\r\n    /**\r\n     * Returns a {@link FoldingRangeKind} for the given value.\r\n     *\r\n     * @param value of the kind.\r\n     */\r\n    static fromValue(value) {\r\n        switch (value) {\r\n            case 'comment': return FoldingRangeKind.Comment;\r\n            case 'imports': return FoldingRangeKind.Imports;\r\n            case 'region': return FoldingRangeKind.Region;\r\n        }\r\n        return new FoldingRangeKind(value);\r\n    }\r\n    /**\r\n     * Creates a new {@link FoldingRangeKind}.\r\n     *\r\n     * @param value of the kind.\r\n     */\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n}\r\n/**\r\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\r\n */\r\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\r\n/**\r\n * Kind for folding range representing a import. The value of the kind is 'imports'.\r\n */\r\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\r\n/**\r\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\r\n * The value of the kind is 'region'.\r\n */\r\nFoldingRangeKind.Region = new FoldingRangeKind('region');\r\nvar NewSymbolNameTag;\r\n(function (NewSymbolNameTag) {\r\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\r\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\r\nvar NewSymbolNameTriggerKind;\r\n(function (NewSymbolNameTriggerKind) {\r\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\r\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\r\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\r\n/**\r\n * @internal\r\n */\r\nvar Command;\r\n(function (Command) {\r\n    /**\r\n     * @internal\r\n     */\r\n    function is(obj) {\r\n        if (!obj || typeof obj !== 'object') {\r\n            return false;\r\n        }\r\n        return typeof obj.id === 'string' &&\r\n            typeof obj.title === 'string';\r\n    }\r\n    Command.is = is;\r\n})(Command || (Command = {}));\r\nvar InlayHintKind;\r\n(function (InlayHintKind) {\r\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\r\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\r\n})(InlayHintKind || (InlayHintKind = {}));\r\n/**\r\n * @internal\r\n */\r\nclass LazyTokenizationSupport {\r\n    constructor(createSupport) {\r\n        this.createSupport = createSupport;\r\n        this._tokenizationSupport = null;\r\n    }\r\n    dispose() {\r\n        if (this._tokenizationSupport) {\r\n            this._tokenizationSupport.then((support) => {\r\n                if (support) {\r\n                    support.dispose();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    get tokenizationSupport() {\r\n        if (!this._tokenizationSupport) {\r\n            this._tokenizationSupport = this.createSupport();\r\n        }\r\n        return this._tokenizationSupport;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nconst TokenizationRegistry = new _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_3__.TokenizationRegistry();\r\nvar InlineEditTriggerKind;\r\n(function (InlineEditTriggerKind) {\r\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\r\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\r\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNUO0FBQ1A7QUFDcUQ7QUFDckQ7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0RBQWtELDZEQUFPO0FBQ3pELG9EQUFvRCw2REFBTztBQUMzRCx1REFBdUQsNkRBQU87QUFDOUQsaURBQWlELDZEQUFPO0FBQ3hELG9EQUFvRCw2REFBTztBQUMzRCxpREFBaUQsNkRBQU87QUFDeEQsa0RBQWtELDZEQUFPO0FBQ3pELHFEQUFxRCw2REFBTztBQUM1RCxrREFBa0QsNkRBQU87QUFDekQsb0RBQW9ELDZEQUFPO0FBQzNELGtEQUFrRCw2REFBTztBQUN6RCxxREFBcUQsNkRBQU87QUFDNUQsaURBQWlELDZEQUFPO0FBQ3hELGtEQUFrRCw2REFBTztBQUN6RCxpREFBaUQsNkRBQU87QUFDeEQscURBQXFELDZEQUFPO0FBQzVELGlEQUFpRCw2REFBTztBQUN4RCx1REFBdUQsNkRBQU87QUFDOUQsb0RBQW9ELDZEQUFPO0FBQzNELG9EQUFvRCw2REFBTztBQUMzRCxpREFBaUQsNkRBQU87QUFDeEQsa0RBQWtELDZEQUFPO0FBQ3pELGlEQUFpRCw2REFBTztBQUN4RCxzREFBc0QsNkRBQU87QUFDN0Qsd0RBQXdELDZEQUFPO0FBQy9ELG1EQUFtRCw2REFBTztBQUMxRCwwREFBMEQsNkRBQU87QUFDakUsaURBQWlELDZEQUFPO0FBQ3hELGtEQUFrRCw2REFBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRTtBQUM1RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLG9EQUFHO0FBQ2QsV0FBVyxpREFBSztBQUNoQixZQUFZLGlEQUFLLHlDQUF5QyxpREFBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLGlEQUFRO0FBQ3pDLG1DQUFtQyxpREFBUTtBQUMzQyxnQ0FBZ0MsaURBQVE7QUFDeEMsb0NBQW9DLGlEQUFRO0FBQzVDLHNDQUFzQyxpREFBUTtBQUM5QywrQkFBK0IsaURBQVE7QUFDdkMsc0NBQXNDLGlEQUFRO0FBQzlDLGlDQUFpQyxpREFBUTtBQUN6QyxnQ0FBZ0MsaURBQVE7QUFDeEMsK0JBQStCLGlEQUFRO0FBQ3ZDLG9DQUFvQyxpREFBUTtBQUM1QyxxQ0FBcUMsaURBQVE7QUFDN0MsK0JBQStCLGlEQUFRO0FBQ3ZDLGlDQUFpQyxpREFBUTtBQUN6QyxpQ0FBaUMsaURBQVE7QUFDekMsb0NBQW9DLGlEQUFRO0FBQzVDLGdDQUFnQyxpREFBUTtBQUN4QyxrQ0FBa0MsaURBQVE7QUFDMUMsa0NBQWtDLGlEQUFRO0FBQzFDLG9DQUFvQyxpREFBUTtBQUM1QyxrQ0FBa0MsaURBQVE7QUFDMUMsbUNBQW1DLGlEQUFRO0FBQzNDLGtDQUFrQyxpREFBUTtBQUMxQyxrQ0FBa0MsaURBQVE7QUFDMUMseUNBQXlDLGlEQUFRO0FBQ2pELG9DQUFvQyxpREFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxpREFBUSxzQkFBc0IsR0FBRyxFQUFFLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQU87QUFDL0MsMENBQTBDLDZEQUFPO0FBQ2pELDZDQUE2Qyw2REFBTztBQUNwRCwyQ0FBMkMsNkRBQU87QUFDbEQseUNBQXlDLDZEQUFPO0FBQ2hELDBDQUEwQyw2REFBTztBQUNqRCw0Q0FBNEMsNkRBQU87QUFDbkQseUNBQXlDLDZEQUFPO0FBQ2hELCtDQUErQyw2REFBTztBQUN0RCx3Q0FBd0MsNkRBQU87QUFDL0MsOENBQThDLDZEQUFPO0FBQ3JELDZDQUE2Qyw2REFBTztBQUNwRCw2Q0FBNkMsNkRBQU87QUFDcEQsNkNBQTZDLDZEQUFPO0FBQ3BELDJDQUEyQyw2REFBTztBQUNsRCwyQ0FBMkMsNkRBQU87QUFDbEQsNENBQTRDLDZEQUFPO0FBQ25ELDBDQUEwQyw2REFBTztBQUNqRCwyQ0FBMkMsNkRBQU87QUFDbEQsd0NBQXdDLDZEQUFPO0FBQy9DLHlDQUF5Qyw2REFBTztBQUNoRCwrQ0FBK0MsNkRBQU87QUFDdEQsMkNBQTJDLDZEQUFPO0FBQ2xELDBDQUEwQyw2REFBTztBQUNqRCw2Q0FBNkMsNkRBQU87QUFDcEQsa0RBQWtELDZEQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQ3BCO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsMEVBQXdCO0FBQ3pEO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMuanM/MmU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RpY29uIH0gZnJvbSAnLi4vLi4vYmFzZS9jb21tb24vY29kaWNvbnMuanMnO1xyXG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xyXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IFRva2VuaXphdGlvblJlZ2lzdHJ5IGFzIFRva2VuaXphdGlvblJlZ2lzdHJ5SW1wbCB9IGZyb20gJy4vdG9rZW5pemF0aW9uUmVnaXN0cnkuanMnO1xyXG5pbXBvcnQgeyBsb2NhbGl6ZSB9IGZyb20gJy4uLy4uL25scy5qcyc7XHJcbmV4cG9ydCBjbGFzcyBUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihvZmZzZXQsIHR5cGUsIGxhbmd1YWdlKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XHJcbiAgICAgICAgdGhpcy5fdG9rZW5CcmFuZCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLm9mZnNldCArICcsICcgKyB0aGlzLnR5cGUgKyAnKSc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRva2VuaXphdGlvblJlc3VsdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVuZFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XHJcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblJlc3VsdEJyYW5kID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFbmNvZGVkVG9rZW5pemF0aW9uUmVzdWx0IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdG9rZW5zIGluIGJpbmFyeSBmb3JtYXQuIEVhY2ggdG9rZW4gb2NjdXBpZXMgdHdvIGFycmF5IGluZGljZXMuIEZvciB0b2tlbiBpOlxyXG4gICAgICogIC0gYXQgb2Zmc2V0IDIqaSA9PiBzdGFydEluZGV4XHJcbiAgICAgKiAgLSBhdCBvZmZzZXQgMippICsgMSA9PiBtZXRhZGF0YVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdG9rZW5zLCBlbmRTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG4gICAgICAgIHRoaXMuZW5kU3RhdGUgPSBlbmRTdGF0ZTtcclxuICAgICAgICB0aGlzLl9lbmNvZGVkVG9rZW5pemF0aW9uUmVzdWx0QnJhbmQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IHZhciBIb3ZlclZlcmJvc2l0eUFjdGlvbjtcclxuKGZ1bmN0aW9uIChIb3ZlclZlcmJvc2l0eUFjdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxyXG4gICAgICovXHJcbiAgICBIb3ZlclZlcmJvc2l0eUFjdGlvbltIb3ZlclZlcmJvc2l0eUFjdGlvbltcIkluY3JlYXNlXCJdID0gMF0gPSBcIkluY3JlYXNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIERlY3JlYXNlIHRoZSB2ZXJib3NpdHkgb2YgdGhlIGhvdmVyXHJcbiAgICAgKi9cclxuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiRGVjcmVhc2VcIl0gPSAxXSA9IFwiRGVjcmVhc2VcIjtcclxufSkoSG92ZXJWZXJib3NpdHlBY3Rpb24gfHwgKEhvdmVyVmVyYm9zaXR5QWN0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbUtpbmRzO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZHMpIHtcclxuICAgIGNvbnN0IGJ5S2luZCA9IG5ldyBNYXAoKTtcclxuICAgIGJ5S2luZC5zZXQoMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kICovLCBDb2RpY29uLnN5bWJvbE1ldGhvZCk7XHJcbiAgICBieUtpbmQuc2V0KDEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uICovLCBDb2RpY29uLnN5bWJvbEZ1bmN0aW9uKTtcclxuICAgIGJ5S2luZC5zZXQoMiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgKi8sIENvZGljb24uc3ltYm9sQ29uc3RydWN0b3IpO1xyXG4gICAgYnlLaW5kLnNldCgzIC8qIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCAqLywgQ29kaWNvbi5zeW1ib2xGaWVsZCk7XHJcbiAgICBieUtpbmQuc2V0KDQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlICovLCBDb2RpY29uLnN5bWJvbFZhcmlhYmxlKTtcclxuICAgIGJ5S2luZC5zZXQoNSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgKi8sIENvZGljb24uc3ltYm9sQ2xhc3MpO1xyXG4gICAgYnlLaW5kLnNldCg2IC8qIENvbXBsZXRpb25JdGVtS2luZC5TdHJ1Y3QgKi8sIENvZGljb24uc3ltYm9sU3RydWN0KTtcclxuICAgIGJ5S2luZC5zZXQoNyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlICovLCBDb2RpY29uLnN5bWJvbEludGVyZmFjZSk7XHJcbiAgICBieUtpbmQuc2V0KDggLyogQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSAqLywgQ29kaWNvbi5zeW1ib2xNb2R1bGUpO1xyXG4gICAgYnlLaW5kLnNldCg5IC8qIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSAqLywgQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eSk7XHJcbiAgICBieUtpbmQuc2V0KDEwIC8qIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCAqLywgQ29kaWNvbi5zeW1ib2xFdmVudCk7XHJcbiAgICBieUtpbmQuc2V0KDExIC8qIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciAqLywgQ29kaWNvbi5zeW1ib2xPcGVyYXRvcik7XHJcbiAgICBieUtpbmQuc2V0KDEyIC8qIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ICovLCBDb2RpY29uLnN5bWJvbFVuaXQpO1xyXG4gICAgYnlLaW5kLnNldCgxMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgKi8sIENvZGljb24uc3ltYm9sVmFsdWUpO1xyXG4gICAgYnlLaW5kLnNldCgxNSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSAqLywgQ29kaWNvbi5zeW1ib2xFbnVtKTtcclxuICAgIGJ5S2luZC5zZXQoMTQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ICovLCBDb2RpY29uLnN5bWJvbENvbnN0YW50KTtcclxuICAgIGJ5S2luZC5zZXQoMTUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gKi8sIENvZGljb24uc3ltYm9sRW51bSk7XHJcbiAgICBieUtpbmQuc2V0KDE2IC8qIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyICovLCBDb2RpY29uLnN5bWJvbEVudW1NZW1iZXIpO1xyXG4gICAgYnlLaW5kLnNldCgxNyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCAqLywgQ29kaWNvbi5zeW1ib2xLZXl3b3JkKTtcclxuICAgIGJ5S2luZC5zZXQoMjcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgKi8sIENvZGljb24uc3ltYm9sU25pcHBldCk7XHJcbiAgICBieUtpbmQuc2V0KDE4IC8qIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ICovLCBDb2RpY29uLnN5bWJvbFRleHQpO1xyXG4gICAgYnlLaW5kLnNldCgxOSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgKi8sIENvZGljb24uc3ltYm9sQ29sb3IpO1xyXG4gICAgYnlLaW5kLnNldCgyMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSAqLywgQ29kaWNvbi5zeW1ib2xGaWxlKTtcclxuICAgIGJ5S2luZC5zZXQoMjEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlJlZmVyZW5jZSAqLywgQ29kaWNvbi5zeW1ib2xSZWZlcmVuY2UpO1xyXG4gICAgYnlLaW5kLnNldCgyMiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ3VzdG9tY29sb3IgKi8sIENvZGljb24uc3ltYm9sQ3VzdG9tQ29sb3IpO1xyXG4gICAgYnlLaW5kLnNldCgyMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyICovLCBDb2RpY29uLnN5bWJvbEZvbGRlcik7XHJcbiAgICBieUtpbmQuc2V0KDI0IC8qIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyICovLCBDb2RpY29uLnN5bWJvbFR5cGVQYXJhbWV0ZXIpO1xyXG4gICAgYnlLaW5kLnNldCgyNSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVXNlciAqLywgQ29kaWNvbi5hY2NvdW50KTtcclxuICAgIGJ5S2luZC5zZXQoMjYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLklzc3VlICovLCBDb2RpY29uLmlzc3Vlcyk7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0ljb24oa2luZCkge1xyXG4gICAgICAgIGxldCBjb2RpY29uID0gYnlLaW5kLmdldChraW5kKTtcclxuICAgICAgICBpZiAoIWNvZGljb24pIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdObyBjb2RpY29uIGZvdW5kIGZvciBDb21wbGV0aW9uSXRlbUtpbmQgJyArIGtpbmQpO1xyXG4gICAgICAgICAgICBjb2RpY29uID0gQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGljb247XHJcbiAgICB9XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRzLnRvSWNvbiA9IHRvSWNvbjtcclxuICAgIGNvbnN0IGRhdGEgPSBuZXcgTWFwKCk7XHJcbiAgICBkYXRhLnNldCgnbWV0aG9kJywgMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kICovKTtcclxuICAgIGRhdGEuc2V0KCdmdW5jdGlvbicsIDEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uICovKTtcclxuICAgIGRhdGEuc2V0KCdjb25zdHJ1Y3RvcicsIDIgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0cnVjdG9yICovKTtcclxuICAgIGRhdGEuc2V0KCdmaWVsZCcsIDMgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkICovKTtcclxuICAgIGRhdGEuc2V0KCd2YXJpYWJsZScsIDQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlICovKTtcclxuICAgIGRhdGEuc2V0KCdjbGFzcycsIDUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNsYXNzICovKTtcclxuICAgIGRhdGEuc2V0KCdzdHJ1Y3QnLCA2IC8qIENvbXBsZXRpb25JdGVtS2luZC5TdHJ1Y3QgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ2ludGVyZmFjZScsIDcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSAqLyk7XHJcbiAgICBkYXRhLnNldCgnbW9kdWxlJywgOCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlICovKTtcclxuICAgIGRhdGEuc2V0KCdwcm9wZXJ0eScsIDkgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ICovKTtcclxuICAgIGRhdGEuc2V0KCdldmVudCcsIDEwIC8qIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCAqLyk7XHJcbiAgICBkYXRhLnNldCgnb3BlcmF0b3InLCAxMSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuT3BlcmF0b3IgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ3VuaXQnLCAxMiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVW5pdCAqLyk7XHJcbiAgICBkYXRhLnNldCgndmFsdWUnLCAxMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ2NvbnN0YW50JywgMTQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ICovKTtcclxuICAgIGRhdGEuc2V0KCdlbnVtJywgMTUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gKi8pO1xyXG4gICAgZGF0YS5zZXQoJ2VudW0tbWVtYmVyJywgMTYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ2VudW1NZW1iZXInLCAxNiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRW51bU1lbWJlciAqLyk7XHJcbiAgICBkYXRhLnNldCgna2V5d29yZCcsIDE3IC8qIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkICovKTtcclxuICAgIGRhdGEuc2V0KCdzbmlwcGV0JywgMjcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ3RleHQnLCAxOCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCAqLyk7XHJcbiAgICBkYXRhLnNldCgnY29sb3InLCAxOSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ2ZpbGUnLCAyMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSAqLyk7XHJcbiAgICBkYXRhLnNldCgncmVmZXJlbmNlJywgMjEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlJlZmVyZW5jZSAqLyk7XHJcbiAgICBkYXRhLnNldCgnY3VzdG9tY29sb3InLCAyMiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ3VzdG9tY29sb3IgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ2ZvbGRlcicsIDIzIC8qIENvbXBsZXRpb25JdGVtS2luZC5Gb2xkZXIgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ3R5cGUtcGFyYW1ldGVyJywgMjQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgKi8pO1xyXG4gICAgZGF0YS5zZXQoJ3R5cGVQYXJhbWV0ZXInLCAyNCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlciAqLyk7XHJcbiAgICBkYXRhLnNldCgnYWNjb3VudCcsIDI1IC8qIENvbXBsZXRpb25JdGVtS2luZC5Vc2VyICovKTtcclxuICAgIGRhdGEuc2V0KCdpc3N1ZScsIDI2IC8qIENvbXBsZXRpb25JdGVtS2luZC5Jc3N1ZSAqLyk7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBzdHJpY3QpIHtcclxuICAgICAgICBsZXQgcmVzID0gZGF0YS5nZXQodmFsdWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAndW5kZWZpbmVkJyAmJiAhc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHJlcyA9IDkgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kcy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxufSkoQ29tcGxldGlvbkl0ZW1LaW5kcyB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBIb3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25zUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgd2hpbGUgZWRpdGluZy5cclxuICAgICAqIEl0IGlzIHN1ZmZpY2llbnQgdG8gcmV0dXJuIGEgc2luZ2xlIGNvbXBsZXRpb24gaXRlbSBpbiB0aGlzIGNhc2UuXHJcbiAgICAgKi9cclxuICAgIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAwXSA9IFwiQXV0b21hdGljXCI7XHJcbiAgICAvKipcclxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGEgdXNlciBnZXN0dXJlLlxyXG4gICAgICogUmV0dXJuIG11bHRpcGxlIGNvbXBsZXRpb24gaXRlbXMgdG8gZW5hYmxlIGN5Y2xpbmcgdGhyb3VnaCB0aGVtLlxyXG4gICAgICovXHJcbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiRXhwbGljaXRcIl0gPSAxXSA9IFwiRXhwbGljaXRcIjtcclxufSkoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xyXG5leHBvcnQgY2xhc3MgU2VsZWN0ZWRTdWdnZXN0aW9uSW5mbyB7XHJcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgdGV4dCwgY29tcGxldGlvbktpbmQsIGlzU25pcHBldFRleHQpIHtcclxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLmNvbXBsZXRpb25LaW5kID0gY29tcGxldGlvbktpbmQ7XHJcbiAgICAgICAgdGhpcy5pc1NuaXBwZXRUZXh0ID0gaXNTbmlwcGV0VGV4dDtcclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5saWZ0KHRoaXMucmFuZ2UpLmVxdWFsc1JhbmdlKG90aGVyLnJhbmdlKVxyXG4gICAgICAgICAgICAmJiB0aGlzLnRleHQgPT09IG90aGVyLnRleHRcclxuICAgICAgICAgICAgJiYgdGhpcy5jb21wbGV0aW9uS2luZCA9PT0gb3RoZXIuY29tcGxldGlvbktpbmRcclxuICAgICAgICAgICAgJiYgdGhpcy5pc1NuaXBwZXRUZXh0ID09PSBvdGhlci5pc1NuaXBwZXRUZXh0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCB2YXIgRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKERvY3VtZW50UGFzdGVUcmlnZ2VyS2luZCkge1xyXG4gICAgRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kW0RvY3VtZW50UGFzdGVUcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDBdID0gXCJBdXRvbWF0aWNcIjtcclxuICAgIERvY3VtZW50UGFzdGVUcmlnZ2VyS2luZFtEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmRbXCJQYXN0ZUFzXCJdID0gMV0gPSBcIlBhc3RlQXNcIjtcclxufSkoRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kIHx8IChEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmQgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQpIHtcclxuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiVHJpZ2dlckNoYXJhY3RlclwiXSA9IDJdID0gXCJUcmlnZ2VyQ2hhcmFjdGVyXCI7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiQ29udGVudENoYW5nZVwiXSA9IDNdID0gXCJDb250ZW50Q2hhbmdlXCI7XHJcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcclxuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxyXG4gICAgICovXHJcbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiUmVhZFwiXSA9IDFdID0gXCJSZWFkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJXcml0ZVwiXSA9IDJdID0gXCJXcml0ZVwiO1xyXG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2F0aW9uTGluayh0aGluZykge1xyXG4gICAgcmV0dXJuIHRoaW5nXHJcbiAgICAgICAgJiYgVVJJLmlzVXJpKHRoaW5nLnVyaSlcclxuICAgICAgICAmJiBSYW5nZS5pc0lSYW5nZSh0aGluZy5yYW5nZSlcclxuICAgICAgICAmJiAoUmFuZ2UuaXNJUmFuZ2UodGhpbmcub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IFJhbmdlLmlzSVJhbmdlKHRoaW5nLnRhcmdldFNlbGVjdGlvblJhbmdlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN5bWJvbEtpbmROYW1lcyA9IHtcclxuICAgIFsxNyAvKiBTeW1ib2xLaW5kLkFycmF5ICovXTogbG9jYWxpemUoJ0FycmF5JywgXCJhcnJheVwiKSxcclxuICAgIFsxNiAvKiBTeW1ib2xLaW5kLkJvb2xlYW4gKi9dOiBsb2NhbGl6ZSgnQm9vbGVhbicsIFwiYm9vbGVhblwiKSxcclxuICAgIFs0IC8qIFN5bWJvbEtpbmQuQ2xhc3MgKi9dOiBsb2NhbGl6ZSgnQ2xhc3MnLCBcImNsYXNzXCIpLFxyXG4gICAgWzEzIC8qIFN5bWJvbEtpbmQuQ29uc3RhbnQgKi9dOiBsb2NhbGl6ZSgnQ29uc3RhbnQnLCBcImNvbnN0YW50XCIpLFxyXG4gICAgWzggLyogU3ltYm9sS2luZC5Db25zdHJ1Y3RvciAqL106IGxvY2FsaXplKCdDb25zdHJ1Y3RvcicsIFwiY29uc3RydWN0b3JcIiksXHJcbiAgICBbOSAvKiBTeW1ib2xLaW5kLkVudW0gKi9dOiBsb2NhbGl6ZSgnRW51bScsIFwiZW51bWVyYXRpb25cIiksXHJcbiAgICBbMjEgLyogU3ltYm9sS2luZC5FbnVtTWVtYmVyICovXTogbG9jYWxpemUoJ0VudW1NZW1iZXInLCBcImVudW1lcmF0aW9uIG1lbWJlclwiKSxcclxuICAgIFsyMyAvKiBTeW1ib2xLaW5kLkV2ZW50ICovXTogbG9jYWxpemUoJ0V2ZW50JywgXCJldmVudFwiKSxcclxuICAgIFs3IC8qIFN5bWJvbEtpbmQuRmllbGQgKi9dOiBsb2NhbGl6ZSgnRmllbGQnLCBcImZpZWxkXCIpLFxyXG4gICAgWzAgLyogU3ltYm9sS2luZC5GaWxlICovXTogbG9jYWxpemUoJ0ZpbGUnLCBcImZpbGVcIiksXHJcbiAgICBbMTEgLyogU3ltYm9sS2luZC5GdW5jdGlvbiAqL106IGxvY2FsaXplKCdGdW5jdGlvbicsIFwiZnVuY3Rpb25cIiksXHJcbiAgICBbMTAgLyogU3ltYm9sS2luZC5JbnRlcmZhY2UgKi9dOiBsb2NhbGl6ZSgnSW50ZXJmYWNlJywgXCJpbnRlcmZhY2VcIiksXHJcbiAgICBbMTkgLyogU3ltYm9sS2luZC5LZXkgKi9dOiBsb2NhbGl6ZSgnS2V5JywgXCJrZXlcIiksXHJcbiAgICBbNSAvKiBTeW1ib2xLaW5kLk1ldGhvZCAqL106IGxvY2FsaXplKCdNZXRob2QnLCBcIm1ldGhvZFwiKSxcclxuICAgIFsxIC8qIFN5bWJvbEtpbmQuTW9kdWxlICovXTogbG9jYWxpemUoJ01vZHVsZScsIFwibW9kdWxlXCIpLFxyXG4gICAgWzIgLyogU3ltYm9sS2luZC5OYW1lc3BhY2UgKi9dOiBsb2NhbGl6ZSgnTmFtZXNwYWNlJywgXCJuYW1lc3BhY2VcIiksXHJcbiAgICBbMjAgLyogU3ltYm9sS2luZC5OdWxsICovXTogbG9jYWxpemUoJ051bGwnLCBcIm51bGxcIiksXHJcbiAgICBbMTUgLyogU3ltYm9sS2luZC5OdW1iZXIgKi9dOiBsb2NhbGl6ZSgnTnVtYmVyJywgXCJudW1iZXJcIiksXHJcbiAgICBbMTggLyogU3ltYm9sS2luZC5PYmplY3QgKi9dOiBsb2NhbGl6ZSgnT2JqZWN0JywgXCJvYmplY3RcIiksXHJcbiAgICBbMjQgLyogU3ltYm9sS2luZC5PcGVyYXRvciAqL106IGxvY2FsaXplKCdPcGVyYXRvcicsIFwib3BlcmF0b3JcIiksXHJcbiAgICBbMyAvKiBTeW1ib2xLaW5kLlBhY2thZ2UgKi9dOiBsb2NhbGl6ZSgnUGFja2FnZScsIFwicGFja2FnZVwiKSxcclxuICAgIFs2IC8qIFN5bWJvbEtpbmQuUHJvcGVydHkgKi9dOiBsb2NhbGl6ZSgnUHJvcGVydHknLCBcInByb3BlcnR5XCIpLFxyXG4gICAgWzE0IC8qIFN5bWJvbEtpbmQuU3RyaW5nICovXTogbG9jYWxpemUoJ1N0cmluZycsIFwic3RyaW5nXCIpLFxyXG4gICAgWzIyIC8qIFN5bWJvbEtpbmQuU3RydWN0ICovXTogbG9jYWxpemUoJ1N0cnVjdCcsIFwic3RydWN0XCIpLFxyXG4gICAgWzI1IC8qIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciAqL106IGxvY2FsaXplKCdUeXBlUGFyYW1ldGVyJywgXCJ0eXBlIHBhcmFtZXRlclwiKSxcclxuICAgIFsxMiAvKiBTeW1ib2xLaW5kLlZhcmlhYmxlICovXTogbG9jYWxpemUoJ1ZhcmlhYmxlJywgXCJ2YXJpYWJsZVwiKSxcclxufTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFyaWFMYWJlbEZvclN5bWJvbChzeW1ib2xOYW1lLCBraW5kKSB7XHJcbiAgICByZXR1cm4gbG9jYWxpemUoJ3N5bWJvbEFyaWFMYWJlbCcsICd7MH0gKHsxfSknLCBzeW1ib2xOYW1lLCBzeW1ib2xLaW5kTmFtZXNba2luZF0pO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCB2YXIgU3ltYm9sS2luZHM7XHJcbihmdW5jdGlvbiAoU3ltYm9sS2luZHMpIHtcclxuICAgIGNvbnN0IGJ5S2luZCA9IG5ldyBNYXAoKTtcclxuICAgIGJ5S2luZC5zZXQoMCAvKiBTeW1ib2xLaW5kLkZpbGUgKi8sIENvZGljb24uc3ltYm9sRmlsZSk7XHJcbiAgICBieUtpbmQuc2V0KDEgLyogU3ltYm9sS2luZC5Nb2R1bGUgKi8sIENvZGljb24uc3ltYm9sTW9kdWxlKTtcclxuICAgIGJ5S2luZC5zZXQoMiAvKiBTeW1ib2xLaW5kLk5hbWVzcGFjZSAqLywgQ29kaWNvbi5zeW1ib2xOYW1lc3BhY2UpO1xyXG4gICAgYnlLaW5kLnNldCgzIC8qIFN5bWJvbEtpbmQuUGFja2FnZSAqLywgQ29kaWNvbi5zeW1ib2xQYWNrYWdlKTtcclxuICAgIGJ5S2luZC5zZXQoNCAvKiBTeW1ib2xLaW5kLkNsYXNzICovLCBDb2RpY29uLnN5bWJvbENsYXNzKTtcclxuICAgIGJ5S2luZC5zZXQoNSAvKiBTeW1ib2xLaW5kLk1ldGhvZCAqLywgQ29kaWNvbi5zeW1ib2xNZXRob2QpO1xyXG4gICAgYnlLaW5kLnNldCg2IC8qIFN5bWJvbEtpbmQuUHJvcGVydHkgKi8sIENvZGljb24uc3ltYm9sUHJvcGVydHkpO1xyXG4gICAgYnlLaW5kLnNldCg3IC8qIFN5bWJvbEtpbmQuRmllbGQgKi8sIENvZGljb24uc3ltYm9sRmllbGQpO1xyXG4gICAgYnlLaW5kLnNldCg4IC8qIFN5bWJvbEtpbmQuQ29uc3RydWN0b3IgKi8sIENvZGljb24uc3ltYm9sQ29uc3RydWN0b3IpO1xyXG4gICAgYnlLaW5kLnNldCg5IC8qIFN5bWJvbEtpbmQuRW51bSAqLywgQ29kaWNvbi5zeW1ib2xFbnVtKTtcclxuICAgIGJ5S2luZC5zZXQoMTAgLyogU3ltYm9sS2luZC5JbnRlcmZhY2UgKi8sIENvZGljb24uc3ltYm9sSW50ZXJmYWNlKTtcclxuICAgIGJ5S2luZC5zZXQoMTEgLyogU3ltYm9sS2luZC5GdW5jdGlvbiAqLywgQ29kaWNvbi5zeW1ib2xGdW5jdGlvbik7XHJcbiAgICBieUtpbmQuc2V0KDEyIC8qIFN5bWJvbEtpbmQuVmFyaWFibGUgKi8sIENvZGljb24uc3ltYm9sVmFyaWFibGUpO1xyXG4gICAgYnlLaW5kLnNldCgxMyAvKiBTeW1ib2xLaW5kLkNvbnN0YW50ICovLCBDb2RpY29uLnN5bWJvbENvbnN0YW50KTtcclxuICAgIGJ5S2luZC5zZXQoMTQgLyogU3ltYm9sS2luZC5TdHJpbmcgKi8sIENvZGljb24uc3ltYm9sU3RyaW5nKTtcclxuICAgIGJ5S2luZC5zZXQoMTUgLyogU3ltYm9sS2luZC5OdW1iZXIgKi8sIENvZGljb24uc3ltYm9sTnVtYmVyKTtcclxuICAgIGJ5S2luZC5zZXQoMTYgLyogU3ltYm9sS2luZC5Cb29sZWFuICovLCBDb2RpY29uLnN5bWJvbEJvb2xlYW4pO1xyXG4gICAgYnlLaW5kLnNldCgxNyAvKiBTeW1ib2xLaW5kLkFycmF5ICovLCBDb2RpY29uLnN5bWJvbEFycmF5KTtcclxuICAgIGJ5S2luZC5zZXQoMTggLyogU3ltYm9sS2luZC5PYmplY3QgKi8sIENvZGljb24uc3ltYm9sT2JqZWN0KTtcclxuICAgIGJ5S2luZC5zZXQoMTkgLyogU3ltYm9sS2luZC5LZXkgKi8sIENvZGljb24uc3ltYm9sS2V5KTtcclxuICAgIGJ5S2luZC5zZXQoMjAgLyogU3ltYm9sS2luZC5OdWxsICovLCBDb2RpY29uLnN5bWJvbE51bGwpO1xyXG4gICAgYnlLaW5kLnNldCgyMSAvKiBTeW1ib2xLaW5kLkVudW1NZW1iZXIgKi8sIENvZGljb24uc3ltYm9sRW51bU1lbWJlcik7XHJcbiAgICBieUtpbmQuc2V0KDIyIC8qIFN5bWJvbEtpbmQuU3RydWN0ICovLCBDb2RpY29uLnN5bWJvbFN0cnVjdCk7XHJcbiAgICBieUtpbmQuc2V0KDIzIC8qIFN5bWJvbEtpbmQuRXZlbnQgKi8sIENvZGljb24uc3ltYm9sRXZlbnQpO1xyXG4gICAgYnlLaW5kLnNldCgyNCAvKiBTeW1ib2xLaW5kLk9wZXJhdG9yICovLCBDb2RpY29uLnN5bWJvbE9wZXJhdG9yKTtcclxuICAgIGJ5S2luZC5zZXQoMjUgLyogU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyICovLCBDb2RpY29uLnN5bWJvbFR5cGVQYXJhbWV0ZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9JY29uKGtpbmQpIHtcclxuICAgICAgICBsZXQgaWNvbiA9IGJ5S2luZC5nZXQoa2luZCk7XHJcbiAgICAgICAgaWYgKCFpY29uKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnTm8gY29kaWNvbiBmb3VuZCBmb3IgU3ltYm9sS2luZCAnICsga2luZCk7XHJcbiAgICAgICAgICAgIGljb24gPSBDb2RpY29uLnN5bWJvbFByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWNvbjtcclxuICAgIH1cclxuICAgIFN5bWJvbEtpbmRzLnRvSWNvbiA9IHRvSWNvbjtcclxufSkoU3ltYm9sS2luZHMgfHwgKFN5bWJvbEtpbmRzID0ge30pKTtcclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgY2xhc3MgVGV4dEVkaXQge1xyXG59XHJcbmV4cG9ydCBjbGFzcyBGb2xkaW5nUmFuZ2VLaW5kIHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBGb2xkaW5nUmFuZ2VLaW5kfSBmb3IgdGhlIGdpdmVuIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUga2luZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHJldHVybiBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ltcG9ydHMnOiByZXR1cm4gRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzO1xyXG4gICAgICAgICAgICBjYXNlICdyZWdpb24nOiByZXR1cm4gRm9sZGluZ1JhbmdlS2luZC5SZWdpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRm9sZGluZ1JhbmdlS2luZCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEZvbGRpbmdSYW5nZUtpbmR9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUga2luZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEtpbmQgZm9yIGZvbGRpbmcgcmFuZ2UgcmVwcmVzZW50aW5nIGEgY29tbWVudC4gVGhlIHZhbHVlIG9mIHRoZSBraW5kIGlzICdjb21tZW50Jy5cclxuICovXHJcbkZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudCA9IG5ldyBGb2xkaW5nUmFuZ2VLaW5kKCdjb21tZW50Jyk7XHJcbi8qKlxyXG4gKiBLaW5kIGZvciBmb2xkaW5nIHJhbmdlIHJlcHJlc2VudGluZyBhIGltcG9ydC4gVGhlIHZhbHVlIG9mIHRoZSBraW5kIGlzICdpbXBvcnRzJy5cclxuICovXHJcbkZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cyA9IG5ldyBGb2xkaW5nUmFuZ2VLaW5kKCdpbXBvcnRzJyk7XHJcbi8qKlxyXG4gKiBLaW5kIGZvciBmb2xkaW5nIHJhbmdlIHJlcHJlc2VudGluZyByZWdpb25zIChmb3IgZXhhbXBsZSBtYXJrZWQgYnkgYCNyZWdpb25gLCBgI2VuZHJlZ2lvbmApLlxyXG4gKiBUaGUgdmFsdWUgb2YgdGhlIGtpbmQgaXMgJ3JlZ2lvbicuXHJcbiAqL1xyXG5Gb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9IG5ldyBGb2xkaW5nUmFuZ2VLaW5kKCdyZWdpb24nKTtcclxuZXhwb3J0IHZhciBOZXdTeW1ib2xOYW1lVGFnO1xyXG4oZnVuY3Rpb24gKE5ld1N5bWJvbE5hbWVUYWcpIHtcclxuICAgIE5ld1N5bWJvbE5hbWVUYWdbTmV3U3ltYm9sTmFtZVRhZ1tcIkFJR2VuZXJhdGVkXCJdID0gMV0gPSBcIkFJR2VuZXJhdGVkXCI7XHJcbn0pKE5ld1N5bWJvbE5hbWVUYWcgfHwgKE5ld1N5bWJvbE5hbWVUYWcgPSB7fSkpO1xyXG5leHBvcnQgdmFyIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmQpIHtcclxuICAgIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAwXSA9IFwiSW52b2tlXCI7XHJcbiAgICBOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMV0gPSBcIkF1dG9tYXRpY1wiO1xyXG59KShOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmQgfHwgKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCB2YXIgQ29tbWFuZDtcclxuKGZ1bmN0aW9uIChDb21tYW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpcyhvYmopIHtcclxuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqLmlkID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnRpdGxlID09PSAnc3RyaW5nJztcclxuICAgIH1cclxuICAgIENvbW1hbmQuaXMgPSBpcztcclxufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgSW5sYXlIaW50S2luZDtcclxuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XHJcbiAgICBJbmxheUhpbnRLaW5kW0lubGF5SGludEtpbmRbXCJUeXBlXCJdID0gMV0gPSBcIlR5cGVcIjtcclxuICAgIElubGF5SGludEtpbmRbSW5sYXlIaW50S2luZFtcIlBhcmFtZXRlclwiXSA9IDJdID0gXCJQYXJhbWV0ZXJcIjtcclxufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMYXp5VG9rZW5pemF0aW9uU3VwcG9ydCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVTdXBwb3J0KSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTdXBwb3J0ID0gY3JlYXRlU3VwcG9ydDtcclxuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydC50aGVuKChzdXBwb3J0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgdG9rZW5pemF0aW9uU3VwcG9ydCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydCA9IHRoaXMuY3JlYXRlU3VwcG9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVG9rZW5pemF0aW9uUmVnaXN0cnkgPSBuZXcgVG9rZW5pemF0aW9uUmVnaXN0cnlJbXBsKCk7XHJcbmV4cG9ydCB2YXIgSW5saW5lRWRpdFRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKElubGluZUVkaXRUcmlnZ2VyS2luZCkge1xyXG4gICAgSW5saW5lRWRpdFRyaWdnZXJLaW5kW0lubGluZUVkaXRUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcclxuICAgIElubGluZUVkaXRUcmlnZ2VyS2luZFtJbmxpbmVFZGl0VHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAxXSA9IFwiQXV0b21hdGljXCI7XHJcbn0pKElubGluZUVkaXRUcmlnZ2VyS2luZCB8fCAoSW5saW5lRWRpdFRyaWdnZXJLaW5kID0ge30pKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/languages.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeDefaultDocumentColors: () => (/* binding */ computeDefaultDocumentColors)\n/* harmony export */ });\n/* harmony import */ var _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/color.js */ \"./node_modules/monaco-editor/esm/vs/base/common/color.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nfunction _parseCaptureGroups(captureGroups) {\r\n    const values = [];\r\n    for (const captureGroup of captureGroups) {\r\n        const parsedNumber = Number(captureGroup);\r\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\r\n            values.push(parsedNumber);\r\n        }\r\n    }\r\n    return values;\r\n}\r\nfunction _toIColor(r, g, b, a) {\r\n    return {\r\n        red: r / 255,\r\n        blue: b / 255,\r\n        green: g / 255,\r\n        alpha: a\r\n    };\r\n}\r\nfunction _findRange(model, match) {\r\n    const index = match.index;\r\n    const length = match[0].length;\r\n    if (!index) {\r\n        return;\r\n    }\r\n    const startPosition = model.positionAt(index);\r\n    const range = {\r\n        startLineNumber: startPosition.lineNumber,\r\n        startColumn: startPosition.column,\r\n        endLineNumber: startPosition.lineNumber,\r\n        endColumn: startPosition.column + length\r\n    };\r\n    return range;\r\n}\r\nfunction _findHexColorInformation(range, hexValue) {\r\n    if (!range) {\r\n        return;\r\n    }\r\n    const parsedHexColor = _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__.Color.Format.CSS.parseHex(hexValue);\r\n    if (!parsedHexColor) {\r\n        return;\r\n    }\r\n    return {\r\n        range: range,\r\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\r\n    };\r\n}\r\nfunction _findRGBColorInformation(range, matches, isAlpha) {\r\n    if (!range || matches.length !== 1) {\r\n        return;\r\n    }\r\n    const match = matches[0];\r\n    const captureGroups = match.values();\r\n    const parsedRegex = _parseCaptureGroups(captureGroups);\r\n    return {\r\n        range: range,\r\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\r\n    };\r\n}\r\nfunction _findHSLColorInformation(range, matches, isAlpha) {\r\n    if (!range || matches.length !== 1) {\r\n        return;\r\n    }\r\n    const match = matches[0];\r\n    const captureGroups = match.values();\r\n    const parsedRegex = _parseCaptureGroups(captureGroups);\r\n    const colorEquivalent = new _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__.Color(new _base_common_color_js__WEBPACK_IMPORTED_MODULE_0__.HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\r\n    return {\r\n        range: range,\r\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\r\n    };\r\n}\r\nfunction _findMatches(model, regex) {\r\n    if (typeof model === 'string') {\r\n        return [...model.matchAll(regex)];\r\n    }\r\n    else {\r\n        return model.findMatches(regex);\r\n    }\r\n}\r\nfunction computeColors(model) {\r\n    const result = [];\r\n    // Early validation for RGB and HSL\r\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\r\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\r\n    // Potential colors have been found, validate the parameters\r\n    if (initialValidationMatches.length > 0) {\r\n        for (const initialMatch of initialValidationMatches) {\r\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\r\n            const colorScheme = initialCaptureGroups[1];\r\n            const colorParameters = initialCaptureGroups[2];\r\n            if (!colorParameters) {\r\n                continue;\r\n            }\r\n            let colorInformation;\r\n            if (colorScheme === 'rgb') {\r\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\r\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\r\n            }\r\n            else if (colorScheme === 'rgba') {\r\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\r\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\r\n            }\r\n            else if (colorScheme === 'hsl') {\r\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\r\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\r\n            }\r\n            else if (colorScheme === 'hsla') {\r\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\r\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\r\n            }\r\n            else if (colorScheme === '#') {\r\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\r\n            }\r\n            if (colorInformation) {\r\n                result.push(colorInformation);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Returns an array of all default document colors in the provided document\r\n */\r\nfunction computeDefaultDocumentColors(model) {\r\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\r\n        // Unknown caller!\r\n        return [];\r\n    }\r\n    return computeColors(model);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvZGVmYXVsdERvY3VtZW50Q29sb3JzQ29tcHV0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUssS0FBSyx1REFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxFQUFFLHFEQUFxRCxFQUFFLHFEQUFxRCxFQUFFO0FBQzNMO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxFQUFFLHFEQUFxRCxFQUFFLHFEQUFxRCxFQUFFO0FBQzNMO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxJQUFJLFVBQVUsSUFBSSxpQkFBaUIsSUFBSSxVQUFVLElBQUk7QUFDaks7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLElBQUksVUFBVSxJQUFJLGlCQUFpQixJQUFJLFVBQVUsSUFBSTtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy9kZWZhdWx0RG9jdW1lbnRDb2xvcnNDb21wdXRlci5qcz9iYjFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBDb2xvciwgSFNMQSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2NvbG9yLmpzJztcclxuZnVuY3Rpb24gX3BhcnNlQ2FwdHVyZUdyb3VwcyhjYXB0dXJlR3JvdXBzKSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgY2FwdHVyZUdyb3VwIG9mIGNhcHR1cmVHcm91cHMpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWROdW1iZXIgPSBOdW1iZXIoY2FwdHVyZUdyb3VwKTtcclxuICAgICAgICBpZiAocGFyc2VkTnVtYmVyIHx8IHBhcnNlZE51bWJlciA9PT0gMCAmJiBjYXB0dXJlR3JvdXAucmVwbGFjZSgvXFxzL2csICcnKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIF90b0lDb2xvcihyLCBnLCBiLCBhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZDogciAvIDI1NSxcclxuICAgICAgICBibHVlOiBiIC8gMjU1LFxyXG4gICAgICAgIGdyZWVuOiBnIC8gMjU1LFxyXG4gICAgICAgIGFscGhhOiBhXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIF9maW5kUmFuZ2UobW9kZWwsIG1hdGNoKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IG1hdGNoLmluZGV4O1xyXG4gICAgY29uc3QgbGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgaWYgKCFpbmRleCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbkF0KGluZGV4KTtcclxuICAgIGNvbnN0IHJhbmdlID0ge1xyXG4gICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLFxyXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydFBvc2l0aW9uLmNvbHVtbixcclxuICAgICAgICBlbmRMaW5lTnVtYmVyOiBzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIsXHJcbiAgICAgICAgZW5kQ29sdW1uOiBzdGFydFBvc2l0aW9uLmNvbHVtbiArIGxlbmd0aFxyXG4gICAgfTtcclxuICAgIHJldHVybiByYW5nZTtcclxufVxyXG5mdW5jdGlvbiBfZmluZEhleENvbG9ySW5mb3JtYXRpb24ocmFuZ2UsIGhleFZhbHVlKSB7XHJcbiAgICBpZiAoIXJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyc2VkSGV4Q29sb3IgPSBDb2xvci5Gb3JtYXQuQ1NTLnBhcnNlSGV4KGhleFZhbHVlKTtcclxuICAgIGlmICghcGFyc2VkSGV4Q29sb3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJhbmdlOiByYW5nZSxcclxuICAgICAgICBjb2xvcjogX3RvSUNvbG9yKHBhcnNlZEhleENvbG9yLnJnYmEuciwgcGFyc2VkSGV4Q29sb3IucmdiYS5nLCBwYXJzZWRIZXhDb2xvci5yZ2JhLmIsIHBhcnNlZEhleENvbG9yLnJnYmEuYSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gX2ZpbmRSR0JDb2xvckluZm9ybWF0aW9uKHJhbmdlLCBtYXRjaGVzLCBpc0FscGhhKSB7XHJcbiAgICBpZiAoIXJhbmdlIHx8IG1hdGNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzWzBdO1xyXG4gICAgY29uc3QgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnZhbHVlcygpO1xyXG4gICAgY29uc3QgcGFyc2VkUmVnZXggPSBfcGFyc2VDYXB0dXJlR3JvdXBzKGNhcHR1cmVHcm91cHMpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgY29sb3I6IF90b0lDb2xvcihwYXJzZWRSZWdleFswXSwgcGFyc2VkUmVnZXhbMV0sIHBhcnNlZFJlZ2V4WzJdLCBpc0FscGhhID8gcGFyc2VkUmVnZXhbM10gOiAxKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBfZmluZEhTTENvbG9ySW5mb3JtYXRpb24ocmFuZ2UsIG1hdGNoZXMsIGlzQWxwaGEpIHtcclxuICAgIGlmICghcmFuZ2UgfHwgbWF0Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbMF07XHJcbiAgICBjb25zdCBjYXB0dXJlR3JvdXBzID0gbWF0Y2gudmFsdWVzKCk7XHJcbiAgICBjb25zdCBwYXJzZWRSZWdleCA9IF9wYXJzZUNhcHR1cmVHcm91cHMoY2FwdHVyZUdyb3Vwcyk7XHJcbiAgICBjb25zdCBjb2xvckVxdWl2YWxlbnQgPSBuZXcgQ29sb3IobmV3IEhTTEEocGFyc2VkUmVnZXhbMF0sIHBhcnNlZFJlZ2V4WzFdIC8gMTAwLCBwYXJzZWRSZWdleFsyXSAvIDEwMCwgaXNBbHBoYSA/IHBhcnNlZFJlZ2V4WzNdIDogMSkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgY29sb3I6IF90b0lDb2xvcihjb2xvckVxdWl2YWxlbnQucmdiYS5yLCBjb2xvckVxdWl2YWxlbnQucmdiYS5nLCBjb2xvckVxdWl2YWxlbnQucmdiYS5iLCBjb2xvckVxdWl2YWxlbnQucmdiYS5hKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBfZmluZE1hdGNoZXMobW9kZWwsIHJlZ2V4KSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBbLi4ubW9kZWwubWF0Y2hBbGwocmVnZXgpXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtb2RlbC5maW5kTWF0Y2hlcyhyZWdleCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUNvbG9ycyhtb2RlbCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAvLyBFYXJseSB2YWxpZGF0aW9uIGZvciBSR0IgYW5kIEhTTFxyXG4gICAgY29uc3QgaW5pdGlhbFZhbGlkYXRpb25SZWdleCA9IC9cXGIocmdifHJnYmF8aHNsfGhzbGEpKFxcKFswLTlcXHMsLlxcJV0qXFwpKXwoIykoW0EtRmEtZjAtOV17M30pXFxifCgjKShbQS1GYS1mMC05XXs0fSlcXGJ8KCMpKFtBLUZhLWYwLTldezZ9KVxcYnwoIykoW0EtRmEtZjAtOV17OH0pXFxiL2dtO1xyXG4gICAgY29uc3QgaW5pdGlhbFZhbGlkYXRpb25NYXRjaGVzID0gX2ZpbmRNYXRjaGVzKG1vZGVsLCBpbml0aWFsVmFsaWRhdGlvblJlZ2V4KTtcclxuICAgIC8vIFBvdGVudGlhbCBjb2xvcnMgaGF2ZSBiZWVuIGZvdW5kLCB2YWxpZGF0ZSB0aGUgcGFyYW1ldGVyc1xyXG4gICAgaWYgKGluaXRpYWxWYWxpZGF0aW9uTWF0Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpbml0aWFsTWF0Y2ggb2YgaW5pdGlhbFZhbGlkYXRpb25NYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxDYXB0dXJlR3JvdXBzID0gaW5pdGlhbE1hdGNoLmZpbHRlcihjYXB0dXJlR3JvdXAgPT4gY2FwdHVyZUdyb3VwICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvclNjaGVtZSA9IGluaXRpYWxDYXB0dXJlR3JvdXBzWzFdO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvclBhcmFtZXRlcnMgPSBpbml0aWFsQ2FwdHVyZUdyb3Vwc1syXTtcclxuICAgICAgICAgICAgaWYgKCFjb2xvclBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjb2xvckluZm9ybWF0aW9uO1xyXG4gICAgICAgICAgICBpZiAoY29sb3JTY2hlbWUgPT09ICdyZ2InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFBhcmFtZXRlcnMgPSAvXlxcKFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqXFwpJC9nbTtcclxuICAgICAgICAgICAgICAgIGNvbG9ySW5mb3JtYXRpb24gPSBfZmluZFJHQkNvbG9ySW5mb3JtYXRpb24oX2ZpbmRSYW5nZShtb2RlbCwgaW5pdGlhbE1hdGNoKSwgX2ZpbmRNYXRjaGVzKGNvbG9yUGFyYW1ldGVycywgcmVnZXhQYXJhbWV0ZXJzKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yU2NoZW1lID09PSAncmdiYScpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4UGFyYW1ldGVycyA9IC9eXFwoXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigyNVswLTVdfDJbMC00XVswLTldfDFbMC05XXsyfXxbMS05XVswLTldfFswLTldKVxccyosXFxzKigwWy5dWzAtOV0rfFsuXVswLTldK3xbMDFdWy5dfFswMV0pXFxzKlxcKSQvZ207XHJcbiAgICAgICAgICAgICAgICBjb2xvckluZm9ybWF0aW9uID0gX2ZpbmRSR0JDb2xvckluZm9ybWF0aW9uKF9maW5kUmFuZ2UobW9kZWwsIGluaXRpYWxNYXRjaCksIF9maW5kTWF0Y2hlcyhjb2xvclBhcmFtZXRlcnMsIHJlZ2V4UGFyYW1ldGVycyksIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yU2NoZW1lID09PSAnaHNsJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXhQYXJhbWV0ZXJzID0gL15cXChcXHMqKDM2WzBdfDNbMC01XVswLTldfFsxMl1bMC05XVswLTldfFsxLTldP1swLTldKVxccyosXFxzKigxMDB8XFxkezEsMn1bLl1cXGQqfFxcZHsxLDJ9KSVcXHMqLFxccyooMTAwfFxcZHsxLDJ9Wy5dXFxkKnxcXGR7MSwyfSklXFxzKlxcKSQvZ207XHJcbiAgICAgICAgICAgICAgICBjb2xvckluZm9ybWF0aW9uID0gX2ZpbmRIU0xDb2xvckluZm9ybWF0aW9uKF9maW5kUmFuZ2UobW9kZWwsIGluaXRpYWxNYXRjaCksIF9maW5kTWF0Y2hlcyhjb2xvclBhcmFtZXRlcnMsIHJlZ2V4UGFyYW1ldGVycyksIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvclNjaGVtZSA9PT0gJ2hzbGEnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFBhcmFtZXRlcnMgPSAvXlxcKFxccyooMzZbMF18M1swLTVdWzAtOV18WzEyXVswLTldWzAtOV18WzEtOV0/WzAtOV0pXFxzKixcXHMqKDEwMHxcXGR7MSwyfVsuXVxcZCp8XFxkezEsMn0pJVxccyosXFxzKigxMDB8XFxkezEsMn1bLl1cXGQqfFxcZHsxLDJ9KSVcXHMqLFxccyooMFsuXVswLTldK3xbLl1bMC05XSt8WzAxXVsuXXxbMDFdKVxccypcXCkkL2dtO1xyXG4gICAgICAgICAgICAgICAgY29sb3JJbmZvcm1hdGlvbiA9IF9maW5kSFNMQ29sb3JJbmZvcm1hdGlvbihfZmluZFJhbmdlKG1vZGVsLCBpbml0aWFsTWF0Y2gpLCBfZmluZE1hdGNoZXMoY29sb3JQYXJhbWV0ZXJzLCByZWdleFBhcmFtZXRlcnMpLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvclNjaGVtZSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvckluZm9ybWF0aW9uID0gX2ZpbmRIZXhDb2xvckluZm9ybWF0aW9uKF9maW5kUmFuZ2UobW9kZWwsIGluaXRpYWxNYXRjaCksIGNvbG9yU2NoZW1lICsgY29sb3JQYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29sb3JJbmZvcm1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29sb3JJbmZvcm1hdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkZWZhdWx0IGRvY3VtZW50IGNvbG9ycyBpbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzKG1vZGVsKSB7XHJcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbC5nZXRWYWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbW9kZWwucG9zaXRpb25BdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIFVua25vd24gY2FsbGVyIVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb21wdXRlQ29sb3JzKG1vZGVsKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinkComputer: () => (/* binding */ LinkComputer),\n/* harmony export */   StateMachine: () => (/* binding */ StateMachine),\n/* harmony export */   computeLinks: () => (/* binding */ computeLinks)\n/* harmony export */ });\n/* harmony import */ var _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/characterClassifier.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass Uint8Matrix {\r\n    constructor(rows, cols, defaultValue) {\r\n        const data = new Uint8Array(rows * cols);\r\n        for (let i = 0, len = rows * cols; i < len; i++) {\r\n            data[i] = defaultValue;\r\n        }\r\n        this._data = data;\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n    }\r\n    get(row, col) {\r\n        return this._data[row * this.cols + col];\r\n    }\r\n    set(row, col, value) {\r\n        this._data[row * this.cols + col] = value;\r\n    }\r\n}\r\nclass StateMachine {\r\n    constructor(edges) {\r\n        let maxCharCode = 0;\r\n        let maxState = 0 /* State.Invalid */;\r\n        for (let i = 0, len = edges.length; i < len; i++) {\r\n            const [from, chCode, to] = edges[i];\r\n            if (chCode > maxCharCode) {\r\n                maxCharCode = chCode;\r\n            }\r\n            if (from > maxState) {\r\n                maxState = from;\r\n            }\r\n            if (to > maxState) {\r\n                maxState = to;\r\n            }\r\n        }\r\n        maxCharCode++;\r\n        maxState++;\r\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\r\n        for (let i = 0, len = edges.length; i < len; i++) {\r\n            const [from, chCode, to] = edges[i];\r\n            states.set(from, chCode, to);\r\n        }\r\n        this._states = states;\r\n        this._maxCharCode = maxCharCode;\r\n    }\r\n    nextState(currentState, chCode) {\r\n        if (chCode < 0 || chCode >= this._maxCharCode) {\r\n            return 0 /* State.Invalid */;\r\n        }\r\n        return this._states.get(currentState, chCode);\r\n    }\r\n}\r\n// State machine for http:// or https:// or file://\r\nlet _stateMachine = null;\r\nfunction getStateMachine() {\r\n    if (_stateMachine === null) {\r\n        _stateMachine = new StateMachine([\r\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\r\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\r\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\r\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\r\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\r\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\r\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\r\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\r\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\r\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\r\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\r\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\r\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\r\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\r\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\r\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\r\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\r\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\r\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\r\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\r\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\r\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\r\n        ]);\r\n    }\r\n    return _stateMachine;\r\n}\r\nlet _classifier = null;\r\nfunction getClassifier() {\r\n    if (_classifier === null) {\r\n        _classifier = new _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__.CharacterClassifier(0 /* CharacterClass.None */);\r\n        // allow-any-unicode-next-line\r\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…';\r\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\r\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\r\n        }\r\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\r\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\r\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\r\n        }\r\n    }\r\n    return _classifier;\r\n}\r\nclass LinkComputer {\r\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\r\n        // Do not allow to end link in certain characters...\r\n        let lastIncludedCharIndex = linkEndIndex - 1;\r\n        do {\r\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\r\n            const chClass = classifier.get(chCode);\r\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\r\n                break;\r\n            }\r\n            lastIncludedCharIndex--;\r\n        } while (lastIncludedCharIndex > linkBeginIndex);\r\n        // Handle links enclosed in parens, square brackets and curlys.\r\n        if (linkBeginIndex > 0) {\r\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\r\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\r\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\r\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\r\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\r\n                // Do not end in ) if ( is before the link start\r\n                // Do not end in ] if [ is before the link start\r\n                // Do not end in } if { is before the link start\r\n                lastIncludedCharIndex--;\r\n            }\r\n        }\r\n        return {\r\n            range: {\r\n                startLineNumber: lineNumber,\r\n                startColumn: linkBeginIndex + 1,\r\n                endLineNumber: lineNumber,\r\n                endColumn: lastIncludedCharIndex + 2\r\n            },\r\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\r\n        };\r\n    }\r\n    static computeLinks(model, stateMachine = getStateMachine()) {\r\n        const classifier = getClassifier();\r\n        const result = [];\r\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\r\n            const line = model.getLineContent(i);\r\n            const len = line.length;\r\n            let j = 0;\r\n            let linkBeginIndex = 0;\r\n            let linkBeginChCode = 0;\r\n            let state = 1 /* State.Start */;\r\n            let hasOpenParens = false;\r\n            let hasOpenSquareBracket = false;\r\n            let inSquareBrackets = false;\r\n            let hasOpenCurlyBracket = false;\r\n            while (j < len) {\r\n                let resetStateMachine = false;\r\n                const chCode = line.charCodeAt(j);\r\n                if (state === 13 /* State.Accept */) {\r\n                    let chClass;\r\n                    switch (chCode) {\r\n                        case 40 /* CharCode.OpenParen */:\r\n                            hasOpenParens = true;\r\n                            chClass = 0 /* CharacterClass.None */;\r\n                            break;\r\n                        case 41 /* CharCode.CloseParen */:\r\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\r\n                            break;\r\n                        case 91 /* CharCode.OpenSquareBracket */:\r\n                            inSquareBrackets = true;\r\n                            hasOpenSquareBracket = true;\r\n                            chClass = 0 /* CharacterClass.None */;\r\n                            break;\r\n                        case 93 /* CharCode.CloseSquareBracket */:\r\n                            inSquareBrackets = false;\r\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\r\n                            break;\r\n                        case 123 /* CharCode.OpenCurlyBrace */:\r\n                            hasOpenCurlyBracket = true;\r\n                            chClass = 0 /* CharacterClass.None */;\r\n                            break;\r\n                        case 125 /* CharCode.CloseCurlyBrace */:\r\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\r\n                            break;\r\n                        // The following three rules make it that ' or \" or ` are allowed inside links\r\n                        // only if the link is wrapped by some other quote character\r\n                        case 39 /* CharCode.SingleQuote */:\r\n                        case 34 /* CharCode.DoubleQuote */:\r\n                        case 96 /* CharCode.BackTick */:\r\n                            if (linkBeginChCode === chCode) {\r\n                                chClass = 1 /* CharacterClass.ForceTermination */;\r\n                            }\r\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\r\n                                chClass = 0 /* CharacterClass.None */;\r\n                            }\r\n                            else {\r\n                                chClass = 1 /* CharacterClass.ForceTermination */;\r\n                            }\r\n                            break;\r\n                        case 42 /* CharCode.Asterisk */:\r\n                            // `*` terminates a link if the link began with `*`\r\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\r\n                            break;\r\n                        case 124 /* CharCode.Pipe */:\r\n                            // `|` terminates a link if the link began with `|`\r\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\r\n                            break;\r\n                        case 32 /* CharCode.Space */:\r\n                            // ` ` allow space in between [ and ]\r\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\r\n                            break;\r\n                        default:\r\n                            chClass = classifier.get(chCode);\r\n                    }\r\n                    // Check if character terminates link\r\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\r\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\r\n                        resetStateMachine = true;\r\n                    }\r\n                }\r\n                else if (state === 12 /* State.End */) {\r\n                    let chClass;\r\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\r\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\r\n                        hasOpenSquareBracket = true;\r\n                        chClass = 0 /* CharacterClass.None */;\r\n                    }\r\n                    else {\r\n                        chClass = classifier.get(chCode);\r\n                    }\r\n                    // Check if character terminates link\r\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\r\n                        resetStateMachine = true;\r\n                    }\r\n                    else {\r\n                        state = 13 /* State.Accept */;\r\n                    }\r\n                }\r\n                else {\r\n                    state = stateMachine.nextState(state, chCode);\r\n                    if (state === 0 /* State.Invalid */) {\r\n                        resetStateMachine = true;\r\n                    }\r\n                }\r\n                if (resetStateMachine) {\r\n                    state = 1 /* State.Start */;\r\n                    hasOpenParens = false;\r\n                    hasOpenSquareBracket = false;\r\n                    hasOpenCurlyBracket = false;\r\n                    // Record where the link started\r\n                    linkBeginIndex = j + 1;\r\n                    linkBeginChCode = chCode;\r\n                }\r\n                j++;\r\n            }\r\n            if (state === 13 /* State.Accept */) {\r\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * Returns an array of all links contains in the provided\r\n * document. *Note* that this operation is computational\r\n * expensive and should not run in the UI thread.\r\n */\r\nfunction computeLinks(model) {\r\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\r\n        // Unknown caller!\r\n        return [];\r\n    }\r\n    return LinkComputer.computeLinks(model);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvbGlua0NvbXB1dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkVBQW1CO0FBQzdDO0FBQ0E7QUFDQSx3QkFBd0IseUNBQXlDO0FBQ2pFO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0Msd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvbGlua0NvbXB1dGVyLmpzPzk3YmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuLi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xyXG5jbGFzcyBVaW50OE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb3dzLCBjb2xzLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocm93cyAqIGNvbHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByb3dzICogY29sczsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XHJcbiAgICAgICAgdGhpcy5jb2xzID0gY29scztcclxuICAgIH1cclxuICAgIGdldChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhW3JvdyAqIHRoaXMuY29scyArIGNvbF07XHJcbiAgICB9XHJcbiAgICBzZXQocm93LCBjb2wsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiB0aGlzLmNvbHMgKyBjb2xdID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFN0YXRlTWFjaGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlZGdlcykge1xyXG4gICAgICAgIGxldCBtYXhDaGFyQ29kZSA9IDA7XHJcbiAgICAgICAgbGV0IG1heFN0YXRlID0gMCAvKiBTdGF0ZS5JbnZhbGlkICovO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlZGdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBbZnJvbSwgY2hDb2RlLCB0b10gPSBlZGdlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGNoQ29kZSA+IG1heENoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhDaGFyQ29kZSA9IGNoQ29kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnJvbSA+IG1heFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhTdGF0ZSA9IGZyb207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRvID4gbWF4U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIG1heFN0YXRlID0gdG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWF4Q2hhckNvZGUrKztcclxuICAgICAgICBtYXhTdGF0ZSsrO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IG5ldyBVaW50OE1hdHJpeChtYXhTdGF0ZSwgbWF4Q2hhckNvZGUsIDAgLyogU3RhdGUuSW52YWxpZCAqLyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtmcm9tLCBjaENvZGUsIHRvXSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgICAgICBzdGF0ZXMuc2V0KGZyb20sIGNoQ29kZSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBzdGF0ZXM7XHJcbiAgICAgICAgdGhpcy5fbWF4Q2hhckNvZGUgPSBtYXhDaGFyQ29kZTtcclxuICAgIH1cclxuICAgIG5leHRTdGF0ZShjdXJyZW50U3RhdGUsIGNoQ29kZSkge1xyXG4gICAgICAgIGlmIChjaENvZGUgPCAwIHx8IGNoQ29kZSA+PSB0aGlzLl9tYXhDaGFyQ29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBTdGF0ZS5JbnZhbGlkICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmdldChjdXJyZW50U3RhdGUsIGNoQ29kZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gU3RhdGUgbWFjaGluZSBmb3IgaHR0cDovLyBvciBodHRwczovLyBvciBmaWxlOi8vXHJcbmxldCBfc3RhdGVNYWNoaW5lID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0U3RhdGVNYWNoaW5lKCkge1xyXG4gICAgaWYgKF9zdGF0ZU1hY2hpbmUgPT09IG51bGwpIHtcclxuICAgICAgICBfc3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZShbXHJcbiAgICAgICAgICAgIFsxIC8qIFN0YXRlLlN0YXJ0ICovLCAxMDQgLyogQ2hhckNvZGUuaCAqLywgMiAvKiBTdGF0ZS5IICovXSxcclxuICAgICAgICAgICAgWzEgLyogU3RhdGUuU3RhcnQgKi8sIDcyIC8qIENoYXJDb2RlLkggKi8sIDIgLyogU3RhdGUuSCAqL10sXHJcbiAgICAgICAgICAgIFsxIC8qIFN0YXRlLlN0YXJ0ICovLCAxMDIgLyogQ2hhckNvZGUuZiAqLywgNiAvKiBTdGF0ZS5GICovXSxcclxuICAgICAgICAgICAgWzEgLyogU3RhdGUuU3RhcnQgKi8sIDcwIC8qIENoYXJDb2RlLkYgKi8sIDYgLyogU3RhdGUuRiAqL10sXHJcbiAgICAgICAgICAgIFsyIC8qIFN0YXRlLkggKi8sIDExNiAvKiBDaGFyQ29kZS50ICovLCAzIC8qIFN0YXRlLkhUICovXSxcclxuICAgICAgICAgICAgWzIgLyogU3RhdGUuSCAqLywgODQgLyogQ2hhckNvZGUuVCAqLywgMyAvKiBTdGF0ZS5IVCAqL10sXHJcbiAgICAgICAgICAgIFszIC8qIFN0YXRlLkhUICovLCAxMTYgLyogQ2hhckNvZGUudCAqLywgNCAvKiBTdGF0ZS5IVFQgKi9dLFxyXG4gICAgICAgICAgICBbMyAvKiBTdGF0ZS5IVCAqLywgODQgLyogQ2hhckNvZGUuVCAqLywgNCAvKiBTdGF0ZS5IVFQgKi9dLFxyXG4gICAgICAgICAgICBbNCAvKiBTdGF0ZS5IVFQgKi8sIDExMiAvKiBDaGFyQ29kZS5wICovLCA1IC8qIFN0YXRlLkhUVFAgKi9dLFxyXG4gICAgICAgICAgICBbNCAvKiBTdGF0ZS5IVFQgKi8sIDgwIC8qIENoYXJDb2RlLlAgKi8sIDUgLyogU3RhdGUuSFRUUCAqL10sXHJcbiAgICAgICAgICAgIFs1IC8qIFN0YXRlLkhUVFAgKi8sIDExNSAvKiBDaGFyQ29kZS5zICovLCA5IC8qIFN0YXRlLkJlZm9yZUNvbG9uICovXSxcclxuICAgICAgICAgICAgWzUgLyogU3RhdGUuSFRUUCAqLywgODMgLyogQ2hhckNvZGUuUyAqLywgOSAvKiBTdGF0ZS5CZWZvcmVDb2xvbiAqL10sXHJcbiAgICAgICAgICAgIFs1IC8qIFN0YXRlLkhUVFAgKi8sIDU4IC8qIENoYXJDb2RlLkNvbG9uICovLCAxMCAvKiBTdGF0ZS5BZnRlckNvbG9uICovXSxcclxuICAgICAgICAgICAgWzYgLyogU3RhdGUuRiAqLywgMTA1IC8qIENoYXJDb2RlLmkgKi8sIDcgLyogU3RhdGUuRkkgKi9dLFxyXG4gICAgICAgICAgICBbNiAvKiBTdGF0ZS5GICovLCA3MyAvKiBDaGFyQ29kZS5JICovLCA3IC8qIFN0YXRlLkZJICovXSxcclxuICAgICAgICAgICAgWzcgLyogU3RhdGUuRkkgKi8sIDEwOCAvKiBDaGFyQ29kZS5sICovLCA4IC8qIFN0YXRlLkZJTCAqL10sXHJcbiAgICAgICAgICAgIFs3IC8qIFN0YXRlLkZJICovLCA3NiAvKiBDaGFyQ29kZS5MICovLCA4IC8qIFN0YXRlLkZJTCAqL10sXHJcbiAgICAgICAgICAgIFs4IC8qIFN0YXRlLkZJTCAqLywgMTAxIC8qIENoYXJDb2RlLmUgKi8sIDkgLyogU3RhdGUuQmVmb3JlQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbOCAvKiBTdGF0ZS5GSUwgKi8sIDY5IC8qIENoYXJDb2RlLkUgKi8sIDkgLyogU3RhdGUuQmVmb3JlQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbOSAvKiBTdGF0ZS5CZWZvcmVDb2xvbiAqLywgNTggLyogQ2hhckNvZGUuQ29sb24gKi8sIDEwIC8qIFN0YXRlLkFmdGVyQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbMTAgLyogU3RhdGUuQWZ0ZXJDb2xvbiAqLywgNDcgLyogQ2hhckNvZGUuU2xhc2ggKi8sIDExIC8qIFN0YXRlLkFsbW9zdFRoZXJlICovXSxcclxuICAgICAgICAgICAgWzExIC8qIFN0YXRlLkFsbW9zdFRoZXJlICovLCA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLywgMTIgLyogU3RhdGUuRW5kICovXSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfc3RhdGVNYWNoaW5lO1xyXG59XHJcbmxldCBfY2xhc3NpZmllciA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldENsYXNzaWZpZXIoKSB7XHJcbiAgICBpZiAoX2NsYXNzaWZpZXIgPT09IG51bGwpIHtcclxuICAgICAgICBfY2xhc3NpZmllciA9IG5ldyBDaGFyYWN0ZXJDbGFzc2lmaWVyKDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyk7XHJcbiAgICAgICAgLy8gYWxsb3ctYW55LXVuaWNvZGUtbmV4dC1saW5lXHJcbiAgICAgICAgY29uc3QgRk9SQ0VfVEVSTUlOQVRJT05fQ0hBUkFDVEVSUyA9ICcgXFx0PD5cXCdcXFwi44CB44CC772h772k77yM77yO77ya77yb4oCY44CI44CM44CO44CU77yI77y7772b772i772j772d77y977yJ44CV44CP44CN44CJ4oCZ772A772e4oCmJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMgPSAnLiw7Oic7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBfY2xhc3NpZmllci5zZXQoQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMiAvKiBDaGFyYWN0ZXJDbGFzcy5DYW5ub3RFbmRJbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9jbGFzc2lmaWVyO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBMaW5rQ29tcHV0ZXIge1xyXG4gICAgc3RhdGljIF9jcmVhdGVMaW5rKGNsYXNzaWZpZXIsIGxpbmUsIGxpbmVOdW1iZXIsIGxpbmtCZWdpbkluZGV4LCBsaW5rRW5kSW5kZXgpIHtcclxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgdG8gZW5kIGxpbmsgaW4gY2VydGFpbiBjaGFyYWN0ZXJzLi4uXHJcbiAgICAgICAgbGV0IGxhc3RJbmNsdWRlZENoYXJJbmRleCA9IGxpbmtFbmRJbmRleCAtIDE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjb25zdCBjaENvZGUgPSBsaW5lLmNoYXJDb2RlQXQobGFzdEluY2x1ZGVkQ2hhckluZGV4KTtcclxuICAgICAgICAgICAgY29uc3QgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XHJcbiAgICAgICAgICAgIGlmIChjaENsYXNzICE9PSAyIC8qIENoYXJhY3RlckNsYXNzLkNhbm5vdEVuZEluICovKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0SW5jbHVkZWRDaGFySW5kZXgtLTtcclxuICAgICAgICB9IHdoaWxlIChsYXN0SW5jbHVkZWRDaGFySW5kZXggPiBsaW5rQmVnaW5JbmRleCk7XHJcbiAgICAgICAgLy8gSGFuZGxlIGxpbmtzIGVuY2xvc2VkIGluIHBhcmVucywgc3F1YXJlIGJyYWNrZXRzIGFuZCBjdXJseXMuXHJcbiAgICAgICAgaWYgKGxpbmtCZWdpbkluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZUJlZm9yZUxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGlua0JlZ2luSW5kZXggLSAxKTtcclxuICAgICAgICAgICAgY29uc3QgbGFzdENoYXJDb2RlSW5MaW5rID0gbGluZS5jaGFyQ29kZUF0KGxhc3RJbmNsdWRlZENoYXJJbmRleCk7XHJcbiAgICAgICAgICAgIGlmICgoY2hhckNvZGVCZWZvcmVMaW5rID09PSA0MCAvKiBDaGFyQ29kZS5PcGVuUGFyZW4gKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSA0MSAvKiBDaGFyQ29kZS5DbG9zZVBhcmVuICovKVxyXG4gICAgICAgICAgICAgICAgfHwgKGNoYXJDb2RlQmVmb3JlTGluayA9PT0gOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSA5MyAvKiBDaGFyQ29kZS5DbG9zZVNxdWFyZUJyYWNrZXQgKi8pXHJcbiAgICAgICAgICAgICAgICB8fCAoY2hhckNvZGVCZWZvcmVMaW5rID09PSAxMjMgLyogQ2hhckNvZGUuT3BlbkN1cmx5QnJhY2UgKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSAxMjUgLyogQ2hhckNvZGUuQ2xvc2VDdXJseUJyYWNlICovKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiApIGlmICggaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZW5kIGluIF0gaWYgWyBpcyBiZWZvcmUgdGhlIGxpbmsgc3RhcnRcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBlbmQgaW4gfSBpZiB7IGlzIGJlZm9yZSB0aGUgbGluayBzdGFydFxyXG4gICAgICAgICAgICAgICAgbGFzdEluY2x1ZGVkQ2hhckluZGV4LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogbGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBsaW5rQmVnaW5JbmRleCArIDEsXHJcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBsYXN0SW5jbHVkZWRDaGFySW5kZXggKyAyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVybDogbGluZS5zdWJzdHJpbmcobGlua0JlZ2luSW5kZXgsIGxhc3RJbmNsdWRlZENoYXJJbmRleCArIDEpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21wdXRlTGlua3MobW9kZWwsIHN0YXRlTWFjaGluZSA9IGdldFN0YXRlTWFjaGluZSgpKSB7XHJcbiAgICAgICAgY29uc3QgY2xhc3NpZmllciA9IGdldENsYXNzaWZpZXIoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMSwgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7IGkgPD0gbGluZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IG1vZGVsLmdldExpbmVDb250ZW50KGkpO1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGogPSAwO1xyXG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luQ2hDb2RlID0gMDtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gMSAvKiBTdGF0ZS5TdGFydCAqLztcclxuICAgICAgICAgICAgbGV0IGhhc09wZW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBpblNxdWFyZUJyYWNrZXRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzZXRTdGF0ZU1hY2hpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChqKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogU3RhdGUuQWNjZXB0ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaENvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MCAvKiBDaGFyQ29kZS5PcGVuUGFyZW4gKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MSAvKiBDaGFyQ29kZS5DbG9zZVBhcmVuICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuUGFyZW5zID8gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovIDogMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkxIC8qIENoYXJDb2RlLk9wZW5TcXVhcmVCcmFja2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTMgLyogQ2hhckNvZGUuQ2xvc2VTcXVhcmVCcmFja2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuU3F1YXJlQnJhY2tldCA/IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyA6IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjMgLyogQ2hhckNvZGUuT3BlbkN1cmx5QnJhY2UgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjUgLyogQ2hhckNvZGUuQ2xvc2VDdXJseUJyYWNlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuQ3VybHlCcmFja2V0ID8gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovIDogMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRocmVlIHJ1bGVzIG1ha2UgaXQgdGhhdCAnIG9yIFwiIG9yIGAgYXJlIGFsbG93ZWQgaW5zaWRlIGxpbmtzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaWYgdGhlIGxpbmsgaXMgd3JhcHBlZCBieSBzb21lIG90aGVyIHF1b3RlIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM5IC8qIENoYXJDb2RlLlNpbmdsZVF1b3RlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0IC8qIENoYXJDb2RlLkRvdWJsZVF1b3RlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk2IC8qIENoYXJDb2RlLkJhY2tUaWNrICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmtCZWdpbkNoQ29kZSA9PT0gY2hDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmtCZWdpbkNoQ29kZSA9PT0gMzkgLyogQ2hhckNvZGUuU2luZ2xlUXVvdGUgKi8gfHwgbGlua0JlZ2luQ2hDb2RlID09PSAzNCAvKiBDaGFyQ29kZS5Eb3VibGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDk2IC8qIENoYXJDb2RlLkJhY2tUaWNrICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MiAvKiBDaGFyQ29kZS5Bc3RlcmlzayAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGAqYCB0ZXJtaW5hdGVzIGEgbGluayBpZiB0aGUgbGluayBiZWdhbiB3aXRoIGAqYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDQyIC8qIENoYXJDb2RlLkFzdGVyaXNrICovKSA/IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyNCAvKiBDaGFyQ29kZS5QaXBlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHxgIHRlcm1pbmF0ZXMgYSBsaW5rIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYHxgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gMTI0IC8qIENoYXJDb2RlLlBpcGUgKi8pID8gMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovIDogMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzIgLyogQ2hhckNvZGUuU3BhY2UgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgIGAgYWxsb3cgc3BhY2UgaW4gYmV0d2VlbiBbIGFuZCBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGluU3F1YXJlQnJhY2tldHMgPyAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi8gOiAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY2hhcmFjdGVyIHRlcm1pbmF0ZXMgbGlua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENsYXNzID09PSAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTGlua0NvbXB1dGVyLl9jcmVhdGVMaW5rKGNsYXNzaWZpZXIsIGxpbmUsIGksIGxpbmtCZWdpbkluZGV4LCBqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMTIgLyogU3RhdGUuRW5kICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoQ29kZSA9PT0gOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgZm9yIHRoZSBhdXRob3JpdHkgcGFydCB0byBjb250YWluIGlwdjYgYWRkcmVzc2VzIHdoaWNoIGNvbnRhaW4gWyBhbmQgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY2hhcmFjdGVyIHRlcm1pbmF0ZXMgbGlua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENsYXNzID09PSAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTdGF0ZU1hY2hpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxMyAvKiBTdGF0ZS5BY2NlcHQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZU1hY2hpbmUubmV4dFN0YXRlKHN0YXRlLCBjaENvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCAvKiBTdGF0ZS5JbnZhbGlkICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzZXRTdGF0ZU1hY2hpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDEgLyogU3RhdGUuU3RhcnQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzT3BlblBhcmVucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzT3BlbkN1cmx5QnJhY2tldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB3aGVyZSB0aGUgbGluayBzdGFydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgbGlua0JlZ2luSW5kZXggPSBqICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rQmVnaW5DaENvZGUgPSBjaENvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxMyAvKiBTdGF0ZS5BY2NlcHQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmtDb21wdXRlci5fY3JlYXRlTGluayhjbGFzc2lmaWVyLCBsaW5lLCBpLCBsaW5rQmVnaW5JbmRleCwgbGVuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgbGlua3MgY29udGFpbnMgaW4gdGhlIHByb3ZpZGVkXHJcbiAqIGRvY3VtZW50LiAqTm90ZSogdGhhdCB0aGlzIG9wZXJhdGlvbiBpcyBjb21wdXRhdGlvbmFsXHJcbiAqIGV4cGVuc2l2ZSBhbmQgc2hvdWxkIG5vdCBydW4gaW4gdGhlIFVJIHRocmVhZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTGlua3MobW9kZWwpIHtcclxuICAgIGlmICghbW9kZWwgfHwgdHlwZW9mIG1vZGVsLmdldExpbmVDb3VudCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbW9kZWwuZ2V0TGluZUNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBVbmtub3duIGNhbGxlciFcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTGlua0NvbXB1dGVyLmNvbXB1dGVMaW5rcyhtb2RlbCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicInplaceReplace: () => (/* binding */ BasicInplaceReplace)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass BasicInplaceReplace {\r\n    constructor() {\r\n        this._defaultValueSet = [\r\n            ['true', 'false'],\r\n            ['True', 'False'],\r\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\r\n            ['public', 'protected', 'private'],\r\n        ];\r\n    }\r\n    navigateValueSet(range1, text1, range2, text2, up) {\r\n        if (range1 && text1) {\r\n            const result = this.doNavigateValueSet(text1, up);\r\n            if (result) {\r\n                return {\r\n                    range: range1,\r\n                    value: result\r\n                };\r\n            }\r\n        }\r\n        if (range2 && text2) {\r\n            const result = this.doNavigateValueSet(text2, up);\r\n            if (result) {\r\n                return {\r\n                    range: range2,\r\n                    value: result\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    doNavigateValueSet(text, up) {\r\n        const numberResult = this.numberReplace(text, up);\r\n        if (numberResult !== null) {\r\n            return numberResult;\r\n        }\r\n        return this.textReplace(text, up);\r\n    }\r\n    numberReplace(value, up) {\r\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\r\n        let n1 = Number(value);\r\n        const n2 = parseFloat(value);\r\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\r\n            if (n1 === 0 && !up) {\r\n                return null; // don't do negative\r\n                //\t\t\t} else if(n1 === 9 && up) {\r\n                //\t\t\t\treturn null; // don't insert 10 into a number\r\n            }\r\n            else {\r\n                n1 = Math.floor(n1 * precision);\r\n                n1 += up ? precision : -precision;\r\n                return String(n1 / precision);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    textReplace(value, up) {\r\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\r\n    }\r\n    valueSetsReplace(valueSets, value, up) {\r\n        let result = null;\r\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\r\n            result = this.valueSetReplace(valueSets[i], value, up);\r\n        }\r\n        return result;\r\n    }\r\n    valueSetReplace(valueSet, value, up) {\r\n        let idx = valueSet.indexOf(value);\r\n        if (idx >= 0) {\r\n            idx += up ? +1 : -1;\r\n            if (idx < 0) {\r\n                idx = valueSet.length - 1;\r\n            }\r\n            else {\r\n                idx %= valueSet.length;\r\n            }\r\n            return valueSet[idx];\r\n        }\r\n        return null;\r\n    }\r\n}\r\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvc3VwcG9ydHMvaW5wbGFjZVJlcGxhY2VTdXBwb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanM/ZWY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGNsYXNzIEJhc2ljSW5wbGFjZVJlcGxhY2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlU2V0ID0gW1xyXG4gICAgICAgICAgICBbJ3RydWUnLCAnZmFsc2UnXSxcclxuICAgICAgICAgICAgWydUcnVlJywgJ0ZhbHNlJ10sXHJcbiAgICAgICAgICAgIFsnUHJpdmF0ZScsICdQdWJsaWMnLCAnRnJpZW5kJywgJ1JlYWRPbmx5JywgJ1BhcnRpYWwnLCAnUHJvdGVjdGVkJywgJ1dyaXRlT25seSddLFxyXG4gICAgICAgICAgICBbJ3B1YmxpYycsICdwcm90ZWN0ZWQnLCAncHJpdmF0ZSddLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBuYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlMSwgdGV4dDEsIHJhbmdlMiwgdGV4dDIsIHVwKSB7XHJcbiAgICAgICAgaWYgKHJhbmdlMSAmJiB0ZXh0MSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0MSwgdXApO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZTEsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFuZ2UyICYmIHRleHQyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQyLCB1cCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlMixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQsIHVwKSB7XHJcbiAgICAgICAgY29uc3QgbnVtYmVyUmVzdWx0ID0gdGhpcy5udW1iZXJSZXBsYWNlKHRleHQsIHVwKTtcclxuICAgICAgICBpZiAobnVtYmVyUmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHRSZXBsYWNlKHRleHQsIHVwKTtcclxuICAgIH1cclxuICAgIG51bWJlclJlcGxhY2UodmFsdWUsIHVwKSB7XHJcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHZhbHVlLmxlbmd0aCAtICh2YWx1ZS5sYXN0SW5kZXhPZignLicpICsgMSkpO1xyXG4gICAgICAgIGxldCBuMSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgbjIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICBpZiAoIWlzTmFOKG4xKSAmJiAhaXNOYU4objIpICYmIG4xID09PSBuMikge1xyXG4gICAgICAgICAgICBpZiAobjEgPT09IDAgJiYgIXVwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgZG8gbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgIC8vXHRcdFx0fSBlbHNlIGlmKG4xID09PSA5ICYmIHVwKSB7XHJcbiAgICAgICAgICAgICAgICAvL1x0XHRcdFx0cmV0dXJuIG51bGw7IC8vIGRvbid0IGluc2VydCAxMCBpbnRvIGEgbnVtYmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuMSA9IE1hdGguZmxvb3IobjEgKiBwcmVjaXNpb24pO1xyXG4gICAgICAgICAgICAgICAgbjEgKz0gdXAgPyBwcmVjaXNpb24gOiAtcHJlY2lzaW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhuMSAvIHByZWNpc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB0ZXh0UmVwbGFjZSh2YWx1ZSwgdXApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVNldHNSZXBsYWNlKHRoaXMuX2RlZmF1bHRWYWx1ZVNldCwgdmFsdWUsIHVwKTtcclxuICAgIH1cclxuICAgIHZhbHVlU2V0c1JlcGxhY2UodmFsdWVTZXRzLCB2YWx1ZSwgdXApIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWVTZXRzLmxlbmd0aDsgcmVzdWx0ID09PSBudWxsICYmIGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZhbHVlU2V0UmVwbGFjZSh2YWx1ZVNldHNbaV0sIHZhbHVlLCB1cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB2YWx1ZVNldFJlcGxhY2UodmFsdWVTZXQsIHZhbHVlLCB1cCkge1xyXG4gICAgICAgIGxldCBpZHggPSB2YWx1ZVNldC5pbmRleE9mKHZhbHVlKTtcclxuICAgICAgICBpZiAoaWR4ID49IDApIHtcclxuICAgICAgICAgICAgaWR4ICs9IHVwID8gKzEgOiAtMTtcclxuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlkeCA9IHZhbHVlU2V0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZHggJT0gdmFsdWVTZXQubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVNldFtpZHhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5CYXNpY0lucGxhY2VSZXBsYWNlLklOU1RBTkNFID0gbmV3IEJhc2ljSW5wbGFjZVJlcGxhY2UoKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApplyEditsResult: () => (/* binding */ ApplyEditsResult),\n/* harmony export */   FindMatch: () => (/* binding */ FindMatch),\n/* harmony export */   GlyphMarginLane: () => (/* binding */ GlyphMarginLane),\n/* harmony export */   InjectedTextCursorStops: () => (/* binding */ InjectedTextCursorStops),\n/* harmony export */   OverviewRulerLane: () => (/* binding */ OverviewRulerLane),\n/* harmony export */   SearchData: () => (/* binding */ SearchData),\n/* harmony export */   TextModelResolvedOptions: () => (/* binding */ TextModelResolvedOptions),\n/* harmony export */   ValidAnnotatedEditOperation: () => (/* binding */ ValidAnnotatedEditOperation),\n/* harmony export */   isITextSnapshot: () => (/* binding */ isITextSnapshot),\n/* harmony export */   shouldSynchronizeModel: () => (/* binding */ shouldSynchronizeModel)\n/* harmony export */ });\n/* harmony import */ var _base_common_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/objects.js */ \"./node_modules/monaco-editor/esm/vs/base/common/objects.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Vertical Lane in the overview ruler of the editor.\r\n */\r\nvar OverviewRulerLane;\r\n(function (OverviewRulerLane) {\r\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\r\n})(OverviewRulerLane || (OverviewRulerLane = {}));\r\n/**\r\n * Vertical Lane in the glyph margin of the editor.\r\n */\r\nvar GlyphMarginLane;\r\n(function (GlyphMarginLane) {\r\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\r\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\r\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\r\n})(GlyphMarginLane || (GlyphMarginLane = {}));\r\nvar InjectedTextCursorStops;\r\n(function (InjectedTextCursorStops) {\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\r\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\r\nclass TextModelResolvedOptions {\r\n    get originalIndentSize() {\r\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(src) {\r\n        this._textModelResolvedOptionsBrand = undefined;\r\n        this.tabSize = Math.max(1, src.tabSize | 0);\r\n        if (src.indentSize === 'tabSize') {\r\n            this.indentSize = this.tabSize;\r\n            this._indentSizeIsTabSize = true;\r\n        }\r\n        else {\r\n            this.indentSize = Math.max(1, src.indentSize | 0);\r\n            this._indentSizeIsTabSize = false;\r\n        }\r\n        this.insertSpaces = Boolean(src.insertSpaces);\r\n        this.defaultEOL = src.defaultEOL | 0;\r\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\r\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    equals(other) {\r\n        return (this.tabSize === other.tabSize\r\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\r\n            && this.indentSize === other.indentSize\r\n            && this.insertSpaces === other.insertSpaces\r\n            && this.defaultEOL === other.defaultEOL\r\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\r\n            && (0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    createChangeEvent(newOpts) {\r\n        return {\r\n            tabSize: this.tabSize !== newOpts.tabSize,\r\n            indentSize: this.indentSize !== newOpts.indentSize,\r\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\r\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\r\n        };\r\n    }\r\n}\r\nclass FindMatch {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(range, matches) {\r\n        this._findMatchBrand = undefined;\r\n        this.range = range;\r\n        this.matches = matches;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction isITextSnapshot(obj) {\r\n    return (obj && typeof obj.read === 'function');\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass ValidAnnotatedEditOperation {\r\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\r\n        this.identifier = identifier;\r\n        this.range = range;\r\n        this.text = text;\r\n        this.forceMoveMarkers = forceMoveMarkers;\r\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\r\n        this._isTracked = _isTracked;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass SearchData {\r\n    constructor(regex, wordSeparators, simpleSearch) {\r\n        this.regex = regex;\r\n        this.wordSeparators = wordSeparators;\r\n        this.simpleSearch = simpleSearch;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass ApplyEditsResult {\r\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\r\n        this.reverseEdits = reverseEdits;\r\n        this.changes = changes;\r\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction shouldSynchronizeModel(model) {\r\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUNwQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUNwRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC5qcz8zMzUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBlcXVhbHMgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9vYmplY3RzLmpzJztcclxuLyoqXHJcbiAqIFZlcnRpY2FsIExhbmUgaW4gdGhlIG92ZXJ2aWV3IHJ1bGVyIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xyXG5leHBvcnQgdmFyIE92ZXJ2aWV3UnVsZXJMYW5lO1xyXG4oZnVuY3Rpb24gKE92ZXJ2aWV3UnVsZXJMYW5lKSB7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkxlZnRcIl0gPSAxXSA9IFwiTGVmdFwiO1xyXG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkZ1bGxcIl0gPSA3XSA9IFwiRnVsbFwiO1xyXG59KShPdmVydmlld1J1bGVyTGFuZSB8fCAoT3ZlcnZpZXdSdWxlckxhbmUgPSB7fSkpO1xyXG4vKipcclxuICogVmVydGljYWwgTGFuZSBpbiB0aGUgZ2x5cGggbWFyZ2luIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEdseXBoTWFyZ2luTGFuZTtcclxuKGZ1bmN0aW9uIChHbHlwaE1hcmdpbkxhbmUpIHtcclxuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcclxuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBHbHlwaE1hcmdpbkxhbmVbR2x5cGhNYXJnaW5MYW5lW1wiUmlnaHRcIl0gPSAzXSA9IFwiUmlnaHRcIjtcclxufSkoR2x5cGhNYXJnaW5MYW5lIHx8IChHbHlwaE1hcmdpbkxhbmUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIEluamVjdGVkVGV4dEN1cnNvclN0b3BzO1xyXG4oZnVuY3Rpb24gKEluamVjdGVkVGV4dEN1cnNvclN0b3BzKSB7XHJcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkJvdGhcIl0gPSAwXSA9IFwiQm90aFwiO1xyXG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xyXG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJMZWZ0XCJdID0gMl0gPSBcIkxlZnRcIjtcclxuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiTm9uZVwiXSA9IDNdID0gXCJOb25lXCI7XHJcbn0pKEluamVjdGVkVGV4dEN1cnNvclN0b3BzIHx8IChJbmplY3RlZFRleHRDdXJzb3JTdG9wcyA9IHt9KSk7XHJcbmV4cG9ydCBjbGFzcyBUZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnMge1xyXG4gICAgZ2V0IG9yaWdpbmFsSW5kZW50U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZW50U2l6ZUlzVGFiU2l6ZSA/ICd0YWJTaXplJyA6IHRoaXMuaW5kZW50U2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNyYykge1xyXG4gICAgICAgIHRoaXMuX3RleHRNb2RlbFJlc29sdmVkT3B0aW9uc0JyYW5kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IE1hdGgubWF4KDEsIHNyYy50YWJTaXplIHwgMCk7XHJcbiAgICAgICAgaWYgKHNyYy5pbmRlbnRTaXplID09PSAndGFiU2l6ZScpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRlbnRTaXplID0gdGhpcy50YWJTaXplO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmRlbnRTaXplSXNUYWJTaXplID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZW50U2l6ZSA9IE1hdGgubWF4KDEsIHNyYy5pbmRlbnRTaXplIHwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZGVudFNpemVJc1RhYlNpemUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbnNlcnRTcGFjZXMgPSBCb29sZWFuKHNyYy5pbnNlcnRTcGFjZXMpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEVPTCA9IHNyYy5kZWZhdWx0RU9MIHwgMDtcclxuICAgICAgICB0aGlzLnRyaW1BdXRvV2hpdGVzcGFjZSA9IEJvb2xlYW4oc3JjLnRyaW1BdXRvV2hpdGVzcGFjZSk7XHJcbiAgICAgICAgdGhpcy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMgPSBzcmMuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhYlNpemUgPT09IG90aGVyLnRhYlNpemVcclxuICAgICAgICAgICAgJiYgdGhpcy5faW5kZW50U2l6ZUlzVGFiU2l6ZSA9PT0gb3RoZXIuX2luZGVudFNpemVJc1RhYlNpemVcclxuICAgICAgICAgICAgJiYgdGhpcy5pbmRlbnRTaXplID09PSBvdGhlci5pbmRlbnRTaXplXHJcbiAgICAgICAgICAgICYmIHRoaXMuaW5zZXJ0U3BhY2VzID09PSBvdGhlci5pbnNlcnRTcGFjZXNcclxuICAgICAgICAgICAgJiYgdGhpcy5kZWZhdWx0RU9MID09PSBvdGhlci5kZWZhdWx0RU9MXHJcbiAgICAgICAgICAgICYmIHRoaXMudHJpbUF1dG9XaGl0ZXNwYWNlID09PSBvdGhlci50cmltQXV0b1doaXRlc3BhY2VcclxuICAgICAgICAgICAgJiYgZXF1YWxzKHRoaXMuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zLCBvdGhlci5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNoYW5nZUV2ZW50KG5ld09wdHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0YWJTaXplOiB0aGlzLnRhYlNpemUgIT09IG5ld09wdHMudGFiU2l6ZSxcclxuICAgICAgICAgICAgaW5kZW50U2l6ZTogdGhpcy5pbmRlbnRTaXplICE9PSBuZXdPcHRzLmluZGVudFNpemUsXHJcbiAgICAgICAgICAgIGluc2VydFNwYWNlczogdGhpcy5pbnNlcnRTcGFjZXMgIT09IG5ld09wdHMuaW5zZXJ0U3BhY2VzLFxyXG4gICAgICAgICAgICB0cmltQXV0b1doaXRlc3BhY2U6IHRoaXMudHJpbUF1dG9XaGl0ZXNwYWNlICE9PSBuZXdPcHRzLnRyaW1BdXRvV2hpdGVzcGFjZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBGaW5kTWF0Y2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmFuZ2UsIG1hdGNoZXMpIHtcclxuICAgICAgICB0aGlzLl9maW5kTWF0Y2hCcmFuZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2hlcztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNJVGV4dFNuYXBzaG90KG9iaikge1xyXG4gICAgcmV0dXJuIChvYmogJiYgdHlwZW9mIG9iai5yZWFkID09PSAnZnVuY3Rpb24nKTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVmFsaWRBbm5vdGF0ZWRFZGl0T3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGlkZW50aWZpZXIsIHJhbmdlLCB0ZXh0LCBmb3JjZU1vdmVNYXJrZXJzLCBpc0F1dG9XaGl0ZXNwYWNlRWRpdCwgX2lzVHJhY2tlZCkge1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5mb3JjZU1vdmVNYXJrZXJzID0gZm9yY2VNb3ZlTWFya2VycztcclxuICAgICAgICB0aGlzLmlzQXV0b1doaXRlc3BhY2VFZGl0ID0gaXNBdXRvV2hpdGVzcGFjZUVkaXQ7XHJcbiAgICAgICAgdGhpcy5faXNUcmFja2VkID0gX2lzVHJhY2tlZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZWdleCwgd29yZFNlcGFyYXRvcnMsIHNpbXBsZVNlYXJjaCkge1xyXG4gICAgICAgIHRoaXMucmVnZXggPSByZWdleDtcclxuICAgICAgICB0aGlzLndvcmRTZXBhcmF0b3JzID0gd29yZFNlcGFyYXRvcnM7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVTZWFyY2ggPSBzaW1wbGVTZWFyY2g7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFwcGx5RWRpdHNSZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IocmV2ZXJzZUVkaXRzLCBjaGFuZ2VzLCB0cmltQXV0b1doaXRlc3BhY2VMaW5lTnVtYmVycykge1xyXG4gICAgICAgIHRoaXMucmV2ZXJzZUVkaXRzID0gcmV2ZXJzZUVkaXRzO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XHJcbiAgICAgICAgdGhpcy50cmltQXV0b1doaXRlc3BhY2VMaW5lTnVtYmVycyA9IHRyaW1BdXRvV2hpdGVzcGFjZUxpbmVOdW1iZXJzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRTeW5jaHJvbml6ZU1vZGVsKG1vZGVsKSB7XHJcbiAgICByZXR1cm4gKCFtb2RlbC5pc1Rvb0xhcmdlRm9yU3luY2luZygpICYmICFtb2RlbC5pc0ZvclNpbXBsZVdpZGdldCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/model.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MirrorTextModel: () => (/* binding */ MirrorTextModel)\n/* harmony export */ });\n/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prefixSumComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nclass MirrorTextModel {\r\n    constructor(uri, lines, eol, versionId) {\r\n        this._uri = uri;\r\n        this._lines = lines;\r\n        this._eol = eol;\r\n        this._versionId = versionId;\r\n        this._lineStarts = null;\r\n        this._cachedTextValue = null;\r\n    }\r\n    dispose() {\r\n        this._lines.length = 0;\r\n    }\r\n    get version() {\r\n        return this._versionId;\r\n    }\r\n    getText() {\r\n        if (this._cachedTextValue === null) {\r\n            this._cachedTextValue = this._lines.join(this._eol);\r\n        }\r\n        return this._cachedTextValue;\r\n    }\r\n    onEvents(e) {\r\n        if (e.eol && e.eol !== this._eol) {\r\n            this._eol = e.eol;\r\n            this._lineStarts = null;\r\n        }\r\n        // Update my lines\r\n        const changes = e.changes;\r\n        for (const change of changes) {\r\n            this._acceptDeleteRange(change.range);\r\n            this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_1__.Position(change.range.startLineNumber, change.range.startColumn), change.text);\r\n        }\r\n        this._versionId = e.versionId;\r\n        this._cachedTextValue = null;\r\n    }\r\n    _ensureLineStarts() {\r\n        if (!this._lineStarts) {\r\n            const eolLength = this._eol.length;\r\n            const linesLength = this._lines.length;\r\n            const lineStartValues = new Uint32Array(linesLength);\r\n            for (let i = 0; i < linesLength; i++) {\r\n                lineStartValues[i] = this._lines[i].length + eolLength;\r\n            }\r\n            this._lineStarts = new _prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_2__.PrefixSumComputer(lineStartValues);\r\n        }\r\n    }\r\n    /**\r\n     * All changes to a line's text go through this method\r\n     */\r\n    _setLineText(lineIndex, newValue) {\r\n        this._lines[lineIndex] = newValue;\r\n        if (this._lineStarts) {\r\n            // update prefix sum\r\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\r\n        }\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            // Delete text on the affected line\r\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\r\n            return;\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\r\n        // Delete middle lines\r\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n        if (this._lineStarts) {\r\n            // update prefix sum\r\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n        }\r\n    }\r\n    _acceptInsertText(position, insertText) {\r\n        if (insertText.length === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        const insertLines = (0,_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitLines)(insertText);\r\n        if (insertLines.length === 1) {\r\n            // Inserting text on one line\r\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n                + insertLines[0]\r\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\r\n            return;\r\n        }\r\n        // Append overflowing text from first line to the end of text to insert\r\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\r\n        // Delete overflowing text from first line and insert text on first line\r\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n            + insertLines[0]);\r\n        // Insert new lines & store lengths\r\n        const newLengths = new Uint32Array(insertLines.length - 1);\r\n        for (let i = 1; i < insertLines.length; i++) {\r\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\r\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\r\n        }\r\n        if (this._lineStarts) {\r\n            // update prefix sum\r\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ2Q7QUFDWTtBQUNwRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdURBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0EsbUNBQW1DLG9FQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1FQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL21pcnJvclRleHRNb2RlbC5qcz9hNDExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBzcGxpdExpbmVzIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IFByZWZpeFN1bUNvbXB1dGVyIH0gZnJvbSAnLi9wcmVmaXhTdW1Db21wdXRlci5qcyc7XHJcbmV4cG9ydCBjbGFzcyBNaXJyb3JUZXh0TW9kZWwge1xyXG4gICAgY29uc3RydWN0b3IodXJpLCBsaW5lcywgZW9sLCB2ZXJzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XHJcbiAgICAgICAgdGhpcy5fbGluZXMgPSBsaW5lcztcclxuICAgICAgICB0aGlzLl9lb2wgPSBlb2w7XHJcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gdmVyc2lvbklkO1xyXG4gICAgICAgIHRoaXMuX2xpbmVTdGFydHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2xpbmVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgdmVyc2lvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbklkO1xyXG4gICAgfVxyXG4gICAgZ2V0VGV4dCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FjaGVkVGV4dFZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IHRoaXMuX2xpbmVzLmpvaW4odGhpcy5fZW9sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRleHRWYWx1ZTtcclxuICAgIH1cclxuICAgIG9uRXZlbnRzKGUpIHtcclxuICAgICAgICBpZiAoZS5lb2wgJiYgZS5lb2wgIT09IHRoaXMuX2VvbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lb2wgPSBlLmVvbDtcclxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBteSBsaW5lc1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBlLmNoYW5nZXM7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9hY2NlcHREZWxldGVSYW5nZShjaGFuZ2UucmFuZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY2NlcHRJbnNlcnRUZXh0KG5ldyBQb3NpdGlvbihjaGFuZ2UucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBjaGFuZ2UucmFuZ2Uuc3RhcnRDb2x1bW4pLCBjaGFuZ2UudGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZlcnNpb25JZCA9IGUudmVyc2lvbklkO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBfZW5zdXJlTGluZVN0YXJ0cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2xpbmVTdGFydHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZW9sTGVuZ3RoID0gdGhpcy5fZW9sLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbGluZXNMZW5ndGggPSB0aGlzLl9saW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVTdGFydFZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShsaW5lc0xlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0VmFsdWVzW2ldID0gdGhpcy5fbGluZXNbaV0ubGVuZ3RoICsgZW9sTGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMgPSBuZXcgUHJlZml4U3VtQ29tcHV0ZXIobGluZVN0YXJ0VmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbCBjaGFuZ2VzIHRvIGEgbGluZSdzIHRleHQgZ28gdGhyb3VnaCB0aGlzIG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBfc2V0TGluZVRleHQobGluZUluZGV4LCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0gPSBuZXdWYWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxyXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLnNldFZhbHVlKGxpbmVJbmRleCwgdGhpcy5fbGluZXNbbGluZUluZGV4XS5sZW5ndGggKyB0aGlzLl9lb2wubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWNjZXB0RGVsZXRlUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRlbGV0ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0ZXh0IG9uIHRoZSBhZmZlY3RlZCBsaW5lXHJcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDEsIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCByYW5nZS5zdGFydENvbHVtbiAtIDEpXHJcbiAgICAgICAgICAgICAgICArIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5lbmRDb2x1bW4gLSAxKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGFrZSByZW1haW5pbmcgdGV4dCBvbiBsYXN0IGxpbmUgYW5kIGFwcGVuZCBpdCB0byByZW1haW5pbmcgdGV4dCBvbiBmaXJzdCBsaW5lXHJcbiAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSlcclxuICAgICAgICAgICAgKyB0aGlzLl9saW5lc1tyYW5nZS5lbmRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcclxuICAgICAgICAvLyBEZWxldGUgbWlkZGxlIGxpbmVzXHJcbiAgICAgICAgdGhpcy5fbGluZXMuc3BsaWNlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlciAtIHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVTdGFydHMpIHtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHByZWZpeCBzdW1cclxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cy5yZW1vdmVWYWx1ZXMocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWNjZXB0SW5zZXJ0VGV4dChwb3NpdGlvbiwgaW5zZXJ0VGV4dCkge1xyXG4gICAgICAgIGlmIChpbnNlcnRUZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGluc2VydFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluc2VydExpbmVzID0gc3BsaXRMaW5lcyhpbnNlcnRUZXh0KTtcclxuICAgICAgICBpZiAoaW5zZXJ0TGluZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydGluZyB0ZXh0IG9uIG9uZSBsaW5lXHJcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXHJcbiAgICAgICAgICAgICAgICArIGluc2VydExpbmVzWzBdXHJcbiAgICAgICAgICAgICAgICArIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uIC0gMSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGVuZCBvdmVyZmxvd2luZyB0ZXh0IGZyb20gZmlyc3QgbGluZSB0byB0aGUgZW5kIG9mIHRleHQgdG8gaW5zZXJ0XHJcbiAgICAgICAgaW5zZXJ0TGluZXNbaW5zZXJ0TGluZXMubGVuZ3RoIC0gMV0gKz0gdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKTtcclxuICAgICAgICAvLyBEZWxldGUgb3ZlcmZsb3dpbmcgdGV4dCBmcm9tIGZpcnN0IGxpbmUgYW5kIGluc2VydCB0ZXh0IG9uIGZpcnN0IGxpbmVcclxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCBwb3NpdGlvbi5jb2x1bW4gLSAxKVxyXG4gICAgICAgICAgICArIGluc2VydExpbmVzWzBdKTtcclxuICAgICAgICAvLyBJbnNlcnQgbmV3IGxpbmVzICYgc3RvcmUgbGVuZ3Roc1xyXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aHMgPSBuZXcgVWludDMyQXJyYXkoaW5zZXJ0TGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnRMaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lcy5zcGxpY2UocG9zaXRpb24ubGluZU51bWJlciArIGkgLSAxLCAwLCBpbnNlcnRMaW5lc1tpXSk7XHJcbiAgICAgICAgICAgIG5ld0xlbmd0aHNbaSAtIDFdID0gaW5zZXJ0TGluZXNbaV0ubGVuZ3RoICsgdGhpcy5fZW9sLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVTdGFydHMpIHtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHByZWZpeCBzdW1cclxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cy5pbnNlcnRWYWx1ZXMocG9zaXRpb24ubGluZU51bWJlciwgbmV3TGVuZ3Rocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstantTimePrefixSumComputer: () => (/* binding */ ConstantTimePrefixSumComputer),\n/* harmony export */   PrefixSumComputer: () => (/* binding */ PrefixSumComputer),\n/* harmony export */   PrefixSumIndexOfResult: () => (/* binding */ PrefixSumIndexOfResult)\n/* harmony export */ });\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ \"./node_modules/monaco-editor/esm/vs/base/common/arrays.js\");\n/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/uint.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uint.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass PrefixSumComputer {\r\n    constructor(values) {\r\n        this.values = values;\r\n        this.prefixSum = new Uint32Array(values.length);\r\n        this.prefixSumValidIndex = new Int32Array(1);\r\n        this.prefixSumValidIndex[0] = -1;\r\n    }\r\n    insertValues(insertIndex, insertValues) {\r\n        insertIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(insertIndex);\r\n        const oldValues = this.values;\r\n        const oldPrefixSum = this.prefixSum;\r\n        const insertValuesLen = insertValues.length;\r\n        if (insertValuesLen === 0) {\r\n            return false;\r\n        }\r\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\r\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\r\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\r\n        this.values.set(insertValues, insertIndex);\r\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\r\n            this.prefixSumValidIndex[0] = insertIndex - 1;\r\n        }\r\n        this.prefixSum = new Uint32Array(this.values.length);\r\n        if (this.prefixSumValidIndex[0] >= 0) {\r\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\r\n        }\r\n        return true;\r\n    }\r\n    setValue(index, value) {\r\n        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(index);\r\n        value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(value);\r\n        if (this.values[index] === value) {\r\n            return false;\r\n        }\r\n        this.values[index] = value;\r\n        if (index - 1 < this.prefixSumValidIndex[0]) {\r\n            this.prefixSumValidIndex[0] = index - 1;\r\n        }\r\n        return true;\r\n    }\r\n    removeValues(startIndex, count) {\r\n        startIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(startIndex);\r\n        count = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(count);\r\n        const oldValues = this.values;\r\n        const oldPrefixSum = this.prefixSum;\r\n        if (startIndex >= oldValues.length) {\r\n            return false;\r\n        }\r\n        const maxCount = oldValues.length - startIndex;\r\n        if (count >= maxCount) {\r\n            count = maxCount;\r\n        }\r\n        if (count === 0) {\r\n            return false;\r\n        }\r\n        this.values = new Uint32Array(oldValues.length - count);\r\n        this.values.set(oldValues.subarray(0, startIndex), 0);\r\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\r\n        this.prefixSum = new Uint32Array(this.values.length);\r\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\r\n            this.prefixSumValidIndex[0] = startIndex - 1;\r\n        }\r\n        if (this.prefixSumValidIndex[0] >= 0) {\r\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\r\n        }\r\n        return true;\r\n    }\r\n    getTotalSum() {\r\n        if (this.values.length === 0) {\r\n            return 0;\r\n        }\r\n        return this._getPrefixSum(this.values.length - 1);\r\n    }\r\n    /**\r\n     * Returns the sum of the first `index + 1` many items.\r\n     * @returns `SUM(0 <= j <= index, values[j])`.\r\n     */\r\n    getPrefixSum(index) {\r\n        if (index < 0) {\r\n            return 0;\r\n        }\r\n        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(index);\r\n        return this._getPrefixSum(index);\r\n    }\r\n    _getPrefixSum(index) {\r\n        if (index <= this.prefixSumValidIndex[0]) {\r\n            return this.prefixSum[index];\r\n        }\r\n        let startIndex = this.prefixSumValidIndex[0] + 1;\r\n        if (startIndex === 0) {\r\n            this.prefixSum[0] = this.values[0];\r\n            startIndex++;\r\n        }\r\n        if (index >= this.values.length) {\r\n            index = this.values.length - 1;\r\n        }\r\n        for (let i = startIndex; i <= index; i++) {\r\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\r\n        }\r\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\r\n        return this.prefixSum[index];\r\n    }\r\n    getIndexOf(sum) {\r\n        sum = Math.floor(sum);\r\n        // Compute all sums (to get a fully valid prefixSum)\r\n        this.getTotalSum();\r\n        let low = 0;\r\n        let high = this.values.length - 1;\r\n        let mid = 0;\r\n        let midStop = 0;\r\n        let midStart = 0;\r\n        while (low <= high) {\r\n            mid = low + ((high - low) / 2) | 0;\r\n            midStop = this.prefixSum[mid];\r\n            midStart = midStop - this.values[mid];\r\n            if (sum < midStart) {\r\n                high = mid - 1;\r\n            }\r\n            else if (sum >= midStop) {\r\n                low = mid + 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\r\n    }\r\n}\r\n/**\r\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\r\n *\r\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\r\n*/\r\nclass ConstantTimePrefixSumComputer {\r\n    constructor(values) {\r\n        this._values = values;\r\n        this._isValid = false;\r\n        this._validEndIndex = -1;\r\n        this._prefixSum = [];\r\n        this._indexBySum = [];\r\n    }\r\n    /**\r\n     * @returns SUM(0 <= j < values.length, values[j])\r\n     */\r\n    getTotalSum() {\r\n        this._ensureValid();\r\n        return this._indexBySum.length;\r\n    }\r\n    /**\r\n     * Returns the sum of the first `count` many items.\r\n     * @returns `SUM(0 <= j < count, values[j])`.\r\n     */\r\n    getPrefixSum(count) {\r\n        this._ensureValid();\r\n        if (count === 0) {\r\n            return 0;\r\n        }\r\n        return this._prefixSum[count - 1];\r\n    }\r\n    /**\r\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\r\n     */\r\n    getIndexOf(sum) {\r\n        this._ensureValid();\r\n        const idx = this._indexBySum[sum];\r\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\r\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\r\n    }\r\n    removeValues(start, deleteCount) {\r\n        this._values.splice(start, deleteCount);\r\n        this._invalidate(start);\r\n    }\r\n    insertValues(insertIndex, insertArr) {\r\n        this._values = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert)(this._values, insertIndex, insertArr);\r\n        this._invalidate(insertIndex);\r\n    }\r\n    _invalidate(index) {\r\n        this._isValid = false;\r\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\r\n    }\r\n    _ensureValid() {\r\n        if (this._isValid) {\r\n            return;\r\n        }\r\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\r\n            const value = this._values[i];\r\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\r\n            this._prefixSum[i] = sumAbove + value;\r\n            for (let j = 0; j < value; j++) {\r\n                this._indexBySum[sumAbove + j] = i;\r\n            }\r\n        }\r\n        // trim things\r\n        this._prefixSum.length = this._values.length;\r\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\r\n        // mark as valid\r\n        this._isValid = true;\r\n        this._validEndIndex = this._values.length - 1;\r\n    }\r\n    setValue(index, value) {\r\n        if (this._values[index] === value) {\r\n            // no change\r\n            return;\r\n        }\r\n        this._values[index] = value;\r\n        this._invalidate(index);\r\n    }\r\n}\r\nclass PrefixSumIndexOfResult {\r\n    constructor(index, remainder) {\r\n        this.index = index;\r\n        this.remainder = remainder;\r\n        this._prefixSumIndexOfResultBrand = undefined;\r\n        this.index = index;\r\n        this.remainder = remainder;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9wcmVmaXhTdW1Db21wdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ0w7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFRO0FBQ3hCLGdCQUFnQiw4REFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBUTtBQUM3QixnQkFBZ0IsOERBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0EsS0FBSyxvQ0FBb0M7QUFDekM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvcHJlZml4U3VtQ29tcHV0ZXIuanM/NGZmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgYXJyYXlJbnNlcnQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xyXG5pbXBvcnQgeyB0b1VpbnQzMiB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VpbnQuanMnO1xyXG5leHBvcnQgY2xhc3MgUHJlZml4U3VtQ29tcHV0ZXIge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4ID0gbmV3IEludDMyQXJyYXkoMSk7XHJcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gLTE7XHJcbiAgICB9XHJcbiAgICBpbnNlcnRWYWx1ZXMoaW5zZXJ0SW5kZXgsIGluc2VydFZhbHVlcykge1xyXG4gICAgICAgIGluc2VydEluZGV4ID0gdG9VaW50MzIoaW5zZXJ0SW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlcyA9IHRoaXMudmFsdWVzO1xyXG4gICAgICAgIGNvbnN0IG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xyXG4gICAgICAgIGNvbnN0IGluc2VydFZhbHVlc0xlbiA9IGluc2VydFZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGluc2VydFZhbHVlc0xlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggKyBpbnNlcnRWYWx1ZXNMZW4pO1xyXG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgaW5zZXJ0SW5kZXgpLCAwKTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KGluc2VydEluZGV4KSwgaW5zZXJ0SW5kZXggKyBpbnNlcnRWYWx1ZXNMZW4pO1xyXG4gICAgICAgIHRoaXMudmFsdWVzLnNldChpbnNlcnRWYWx1ZXMsIGluc2VydEluZGV4KTtcclxuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IGluc2VydEluZGV4IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodGhpcy52YWx1ZXMubGVuZ3RoKTtcclxuICAgICAgICBpZiAodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaW5kZXggPSB0b1VpbnQzMihpbmRleCk7XHJcbiAgICAgICAgdmFsdWUgPSB0b1VpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzW2luZGV4XSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAoaW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IGluZGV4IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVWYWx1ZXMoc3RhcnRJbmRleCwgY291bnQpIHtcclxuICAgICAgICBzdGFydEluZGV4ID0gdG9VaW50MzIoc3RhcnRJbmRleCk7XHJcbiAgICAgICAgY291bnQgPSB0b1VpbnQzMihjb3VudCk7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XHJcbiAgICAgICAgY29uc3Qgb2xkUHJlZml4U3VtID0gdGhpcy5wcmVmaXhTdW07XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gb2xkVmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1heENvdW50ID0gb2xkVmFsdWVzLmxlbmd0aCAtIHN0YXJ0SW5kZXg7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gbWF4Q291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggLSBjb3VudCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheSgwLCBzdGFydEluZGV4KSwgMCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheShzdGFydEluZGV4ICsgY291bnQpLCBzdGFydEluZGV4KTtcclxuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZhbHVlcy5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBzdGFydEluZGV4IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtLnNldChvbGRQcmVmaXhTdW0uc3ViYXJyYXkoMCwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldFRvdGFsU3VtKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcmVmaXhTdW0odGhpcy52YWx1ZXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGUgZmlyc3QgYGluZGV4ICsgMWAgbWFueSBpdGVtcy5cclxuICAgICAqIEByZXR1cm5zIGBTVU0oMCA8PSBqIDw9IGluZGV4LCB2YWx1ZXNbal0pYC5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZml4U3VtKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kZXggPSB0b1VpbnQzMihpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByZWZpeFN1bShpbmRleCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UHJlZml4U3VtKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDw9IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXhTdW1baW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSArIDE7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1bMF0gPSB0aGlzLnZhbHVlc1swXTtcclxuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gaW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVtpXSA9IHRoaXMucHJlZml4U3VtW2kgLSAxXSArIHRoaXMudmFsdWVzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBNYXRoLm1heCh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0sIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXhTdW1baW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhPZihzdW0pIHtcclxuICAgICAgICBzdW0gPSBNYXRoLmZsb29yKHN1bSk7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBhbGwgc3VtcyAodG8gZ2V0IGEgZnVsbHkgdmFsaWQgcHJlZml4U3VtKVxyXG4gICAgICAgIHRoaXMuZ2V0VG90YWxTdW0oKTtcclxuICAgICAgICBsZXQgbG93ID0gMDtcclxuICAgICAgICBsZXQgaGlnaCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgbGV0IG1pZCA9IDA7XHJcbiAgICAgICAgbGV0IG1pZFN0b3AgPSAwO1xyXG4gICAgICAgIGxldCBtaWRTdGFydCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcbiAgICAgICAgICAgIG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgIG1pZFN0b3AgPSB0aGlzLnByZWZpeFN1bVttaWRdO1xyXG4gICAgICAgICAgICBtaWRTdGFydCA9IG1pZFN0b3AgLSB0aGlzLnZhbHVlc1ttaWRdO1xyXG4gICAgICAgICAgICBpZiAoc3VtIDwgbWlkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN1bSA+PSBtaWRTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhTdW1JbmRleE9mUmVzdWx0KG1pZCwgc3VtIC0gbWlkU3RhcnQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiB7QGxpbmsgZ2V0SW5kZXhPZn0gaGFzIGFuIGFtb3J0aXplZCBydW50aW1lIGNvbXBsZXhpdHkgb2YgTygxKS5cclxuICpcclxuICogKHtAbGluayBQcmVmaXhTdW1Db21wdXRlci5nZXRJbmRleE9mfSBpcyBqdXN0ICBPKGxvZyBuKSlcclxuKi9cclxuZXhwb3J0IGNsYXNzIENvbnN0YW50VGltZVByZWZpeFN1bUNvbXB1dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdmFsaWRFbmRJbmRleCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnlTdW0gPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU1VNKDAgPD0gaiA8IHZhbHVlcy5sZW5ndGgsIHZhbHVlc1tqXSlcclxuICAgICAqL1xyXG4gICAgZ2V0VG90YWxTdW0oKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhCeVN1bS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGUgZmlyc3QgYGNvdW50YCBtYW55IGl0ZW1zLlxyXG4gICAgICogQHJldHVybnMgYFNVTSgwIDw9IGogPCBjb3VudCwgdmFsdWVzW2pdKWAuXHJcbiAgICAgKi9cclxuICAgIGdldFByZWZpeFN1bShjb3VudCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkKCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4U3VtW2NvdW50IC0gMV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGByZXN1bHRgLCBzdWNoIHRoYXQgYGdldFByZWZpeFN1bShyZXN1bHQuaW5kZXgpICsgcmVzdWx0LnJlbWFpbmRlciA9IHN1bWBcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhPZihzdW0pIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZCgpO1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2luZGV4QnlTdW1bc3VtXTtcclxuICAgICAgICBjb25zdCB2aWV3TGluZXNBYm92ZSA9IGlkeCA+IDAgPyB0aGlzLl9wcmVmaXhTdW1baWR4IC0gMV0gOiAwO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4U3VtSW5kZXhPZlJlc3VsdChpZHgsIHN1bSAtIHZpZXdMaW5lc0Fib3ZlKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVZhbHVlcyhzdGFydCwgZGVsZXRlQ291bnQpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZXMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XHJcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZShzdGFydCk7XHJcbiAgICB9XHJcbiAgICBpbnNlcnRWYWx1ZXMoaW5zZXJ0SW5kZXgsIGluc2VydEFycikge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5SW5zZXJ0KHRoaXMuX3ZhbHVlcywgaW5zZXJ0SW5kZXgsIGluc2VydEFycik7XHJcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZShpbnNlcnRJbmRleCk7XHJcbiAgICB9XHJcbiAgICBfaW52YWxpZGF0ZShpbmRleCkge1xyXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl92YWxpZEVuZEluZGV4ID0gTWF0aC5taW4odGhpcy5fdmFsaWRFbmRJbmRleCwgaW5kZXggLSAxKTtcclxuICAgIH1cclxuICAgIF9lbnN1cmVWYWxpZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNWYWxpZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl92YWxpZEVuZEluZGV4ICsgMSwgbGVuID0gdGhpcy5fdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBzdW1BYm92ZSA9IGkgPiAwID8gdGhpcy5fcHJlZml4U3VtW2kgLSAxXSA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZWZpeFN1bVtpXSA9IHN1bUFib3ZlICsgdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXhCeVN1bVtzdW1BYm92ZSArIGpdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cmltIHRoaW5nc1xyXG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bS5sZW5ndGggPSB0aGlzLl92YWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnlTdW0ubGVuZ3RoID0gdGhpcy5fcHJlZml4U3VtW3RoaXMuX3ByZWZpeFN1bS5sZW5ndGggLSAxXTtcclxuICAgICAgICAvLyBtYXJrIGFzIHZhbGlkXHJcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdmFsaWRFbmRJbmRleCA9IHRoaXMuX3ZhbHVlcy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG4gICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpbmRleF0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKGluZGV4KTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgUHJlZml4U3VtSW5kZXhPZlJlc3VsdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleCwgcmVtYWluZGVyKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gcmVtYWluZGVyO1xyXG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bUluZGV4T2ZSZXN1bHRCcmFuZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZW1haW5kZXIgPSByZW1haW5kZXI7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchParams: () => (/* binding */ SearchParams),\n/* harmony export */   Searcher: () => (/* binding */ Searcher),\n/* harmony export */   TextModelSearch: () => (/* binding */ TextModelSearch),\n/* harmony export */   createFindMatch: () => (/* binding */ createFindMatch),\n/* harmony export */   isMultilineRegexSource: () => (/* binding */ isMultilineRegexSource),\n/* harmony export */   isValidMatch: () => (/* binding */ isValidMatch)\n/* harmony export */ });\n/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/* harmony import */ var _core_wordCharacterClassifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/wordCharacterClassifier.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/model.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\nconst LIMIT_FIND_COUNT = 999;\r\nclass SearchParams {\r\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\r\n        this.searchString = searchString;\r\n        this.isRegex = isRegex;\r\n        this.matchCase = matchCase;\r\n        this.wordSeparators = wordSeparators;\r\n    }\r\n    parseSearchRequest() {\r\n        if (this.searchString === '') {\r\n            return null;\r\n        }\r\n        // Try to create a RegExp out of the params\r\n        let multiline;\r\n        if (this.isRegex) {\r\n            multiline = isMultilineRegexSource(this.searchString);\r\n        }\r\n        else {\r\n            multiline = (this.searchString.indexOf('\\n') >= 0);\r\n        }\r\n        let regex = null;\r\n        try {\r\n            regex = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.createRegExp(this.searchString, this.isRegex, {\r\n                matchCase: this.matchCase,\r\n                wholeWord: false,\r\n                multiline: multiline,\r\n                global: true,\r\n                unicode: true\r\n            });\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        if (!regex) {\r\n            return null;\r\n        }\r\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\r\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\r\n            // casing might make a difference\r\n            canUseSimpleSearch = this.matchCase;\r\n        }\r\n        return new _model_js__WEBPACK_IMPORTED_MODULE_4__.SearchData(regex, this.wordSeparators ? (0,_core_wordCharacterClassifier_js__WEBPACK_IMPORTED_MODULE_1__.getMapForWordSeparators)(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\r\n    }\r\n}\r\nfunction isMultilineRegexSource(searchString) {\r\n    if (!searchString || searchString.length === 0) {\r\n        return false;\r\n    }\r\n    for (let i = 0, len = searchString.length; i < len; i++) {\r\n        const chCode = searchString.charCodeAt(i);\r\n        if (chCode === 10 /* CharCode.LineFeed */) {\r\n            return true;\r\n        }\r\n        if (chCode === 92 /* CharCode.Backslash */) {\r\n            // move to next char\r\n            i++;\r\n            if (i >= len) {\r\n                // string ends with a \\\r\n                break;\r\n            }\r\n            const nextChCode = searchString.charCodeAt(i);\r\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction createFindMatch(range, rawMatches, captureMatches) {\r\n    if (!captureMatches) {\r\n        return new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(range, null);\r\n    }\r\n    const matches = [];\r\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\r\n        matches[i] = rawMatches[i];\r\n    }\r\n    return new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(range, matches);\r\n}\r\nclass LineFeedCounter {\r\n    constructor(text) {\r\n        const lineFeedsOffsets = [];\r\n        let lineFeedsOffsetsLen = 0;\r\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\r\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\r\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\r\n            }\r\n        }\r\n        this._lineFeedsOffsets = lineFeedsOffsets;\r\n    }\r\n    findLineFeedCountBeforeOffset(offset) {\r\n        const lineFeedsOffsets = this._lineFeedsOffsets;\r\n        let min = 0;\r\n        let max = lineFeedsOffsets.length - 1;\r\n        if (max === -1) {\r\n            // no line feeds\r\n            return 0;\r\n        }\r\n        if (offset <= lineFeedsOffsets[0]) {\r\n            // before first line feed\r\n            return 0;\r\n        }\r\n        while (min < max) {\r\n            const mid = min + ((max - min) / 2 >> 0);\r\n            if (lineFeedsOffsets[mid] >= offset) {\r\n                max = mid - 1;\r\n            }\r\n            else {\r\n                if (lineFeedsOffsets[mid + 1] >= offset) {\r\n                    // bingo!\r\n                    min = mid;\r\n                    max = mid;\r\n                }\r\n                else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n        }\r\n        return min + 1;\r\n    }\r\n}\r\nclass TextModelSearch {\r\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return [];\r\n        }\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\r\n        }\r\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\r\n    }\r\n    /**\r\n     * Multiline search always executes on the lines concatenated with \\n.\r\n     * We must therefore compensate for the count of \\n in case the model is CRLF\r\n     */\r\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\r\n        let startOffset;\r\n        let lineFeedCountBeforeMatch = 0;\r\n        if (lfCounter) {\r\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\r\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            startOffset = deltaOffset + matchIndex;\r\n        }\r\n        let endOffset;\r\n        if (lfCounter) {\r\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\r\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\r\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            endOffset = startOffset + match0.length;\r\n        }\r\n        const startPosition = model.getPositionAt(startOffset);\r\n        const endPosition = model.getPositionAt(endOffset);\r\n        return new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    }\r\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\r\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\r\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        const result = [];\r\n        let counter = 0;\r\n        let m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n            if (counter >= limitResultCount) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\r\n        const result = [];\r\n        let resultLen = 0;\r\n        // Early case for a search range that starts & stops on the same line number\r\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\r\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        // Collect results from first line\r\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\r\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n        // Collect results from middle lines\r\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\r\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        // Collect results from last line\r\n        if (resultLen < limitResultCount) {\r\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        return result;\r\n    }\r\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        const wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            const searchString = searchData.simpleSearch;\r\n            const searchStringLen = searchString.length;\r\n            const textLength = text.length;\r\n            let lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        let m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    }\r\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    }\r\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\r\n        const searchTextStart = new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(searchStart.lineNumber, 1);\r\n        const deltaOffset = model.getOffsetAt(searchTextStart);\r\n        const lineCount = model.getLineCount();\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        const text = model.getValueInRange(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\r\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        searcher.reset(searchStart.column - 1);\r\n        const m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n        }\r\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\r\n            // Try again from the top\r\n            return this._doFindNextMatchMultiline(model, new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    }\r\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\r\n        const lineCount = model.getLineCount();\r\n        const startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        const text = model.getLineContent(startLineNumber);\r\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (let i = 1; i <= lineCount; i++) {\r\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\r\n            const text = model.getLineContent(lineIndex + 1);\r\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\r\n        // Set regex to search from column\r\n        searcher.reset(fromColumn - 1);\r\n        const m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return null;\r\n    }\r\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    }\r\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\r\n        const matches = this._doFindMatchesMultiline(model, new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\r\n        if (matches.length > 0) {\r\n            return matches[matches.length - 1];\r\n        }\r\n        const lineCount = model.getLineCount();\r\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\r\n            // Try again with all content\r\n            return this._doFindPreviousMatchMultiline(model, new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    }\r\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\r\n        const lineCount = model.getLineCount();\r\n        const startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\r\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (let i = 1; i <= lineCount; i++) {\r\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\r\n            const text = model.getLineContent(lineIndex + 1);\r\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\r\n        let bestResult = null;\r\n        let m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            bestResult = createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return bestResult;\r\n    }\r\n}\r\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex === 0) {\r\n        // Match starts at start of string\r\n        return true;\r\n    }\r\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\r\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\r\n        // The character before the match is a word separator\r\n        return true;\r\n    }\r\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\r\n        // The character before the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\r\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\r\n            // The first character inside the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex + matchLength === textLength) {\r\n        // Match ends at end of string\r\n        return true;\r\n    }\r\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\r\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\r\n        // The character after the match is a word separator\r\n        return true;\r\n    }\r\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\r\n        // The character after the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\r\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\r\n            // The last character in the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\r\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\r\n}\r\nclass Searcher {\r\n    constructor(wordSeparators, searchRegex) {\r\n        this._wordSeparators = wordSeparators;\r\n        this._searchRegex = searchRegex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    reset(lastIndex) {\r\n        this._searchRegex.lastIndex = lastIndex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    next(text) {\r\n        const textLength = text.length;\r\n        let m;\r\n        do {\r\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\r\n                // Reached the end of the line\r\n                return null;\r\n            }\r\n            m = this._searchRegex.exec(text);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            const matchStartIndex = m.index;\r\n            const matchLength = m[0].length;\r\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\r\n                if (matchLength === 0) {\r\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\r\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\r\n                    if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\r\n                        this._searchRegex.lastIndex += 2;\r\n                    }\r\n                    else {\r\n                        this._searchRegex.lastIndex += 1;\r\n                    }\r\n                    continue;\r\n                }\r\n                // Exit early if the regex matches the same range twice\r\n                return null;\r\n            }\r\n            this._prevMatchStartIndex = matchStartIndex;\r\n            this._prevMatchLength = matchLength;\r\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\r\n                return m;\r\n            }\r\n        } while (m);\r\n        return null;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC90ZXh0TW9kZWxTZWFyY2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUNrQjtBQUM5QjtBQUNOO0FBQ1c7QUFDcEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUVBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFVLDhCQUE4Qix5RkFBdUI7QUFDbEY7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsbUJBQW1CLGdEQUFTO0FBQzVCO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdFQUF3RTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0RBQVMsS0FBSyxpREFBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlEQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpREFBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHVEQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaURBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVEQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpREFBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUVBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC90ZXh0TW9kZWxTZWFyY2guanM/OGMwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcclxuaW1wb3J0IHsgZ2V0TWFwRm9yV29yZFNlcGFyYXRvcnMgfSBmcm9tICcuLi9jb3JlL3dvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyLmpzJztcclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcclxuaW1wb3J0IHsgRmluZE1hdGNoLCBTZWFyY2hEYXRhIH0gZnJvbSAnLi4vbW9kZWwuanMnO1xyXG5jb25zdCBMSU1JVF9GSU5EX0NPVU5UID0gOTk5O1xyXG5leHBvcnQgY2xhc3MgU2VhcmNoUGFyYW1zIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlYXJjaFN0cmluZywgaXNSZWdleCwgbWF0Y2hDYXNlLCB3b3JkU2VwYXJhdG9ycykge1xyXG4gICAgICAgIHRoaXMuc2VhcmNoU3RyaW5nID0gc2VhcmNoU3RyaW5nO1xyXG4gICAgICAgIHRoaXMuaXNSZWdleCA9IGlzUmVnZXg7XHJcbiAgICAgICAgdGhpcy5tYXRjaENhc2UgPSBtYXRjaENhc2U7XHJcbiAgICAgICAgdGhpcy53b3JkU2VwYXJhdG9ycyA9IHdvcmRTZXBhcmF0b3JzO1xyXG4gICAgfVxyXG4gICAgcGFyc2VTZWFyY2hSZXF1ZXN0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlYXJjaFN0cmluZyA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSB0byBjcmVhdGUgYSBSZWdFeHAgb3V0IG9mIHRoZSBwYXJhbXNcclxuICAgICAgICBsZXQgbXVsdGlsaW5lO1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmVnZXgpIHtcclxuICAgICAgICAgICAgbXVsdGlsaW5lID0gaXNNdWx0aWxpbmVSZWdleFNvdXJjZSh0aGlzLnNlYXJjaFN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtdWx0aWxpbmUgPSAodGhpcy5zZWFyY2hTdHJpbmcuaW5kZXhPZignXFxuJykgPj0gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZWdleCA9IG51bGw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVnZXggPSBzdHJpbmdzLmNyZWF0ZVJlZ0V4cCh0aGlzLnNlYXJjaFN0cmluZywgdGhpcy5pc1JlZ2V4LCB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaENhc2U6IHRoaXMubWF0Y2hDYXNlLFxyXG4gICAgICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG11bHRpbGluZTogbXVsdGlsaW5lLFxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdW5pY29kZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZWdleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNhblVzZVNpbXBsZVNlYXJjaCA9ICghdGhpcy5pc1JlZ2V4ICYmICFtdWx0aWxpbmUpO1xyXG4gICAgICAgIGlmIChjYW5Vc2VTaW1wbGVTZWFyY2ggJiYgdGhpcy5zZWFyY2hTdHJpbmcudG9Mb3dlckNhc2UoKSAhPT0gdGhpcy5zZWFyY2hTdHJpbmcudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAvLyBjYXNpbmcgbWlnaHQgbWFrZSBhIGRpZmZlcmVuY2VcclxuICAgICAgICAgICAgY2FuVXNlU2ltcGxlU2VhcmNoID0gdGhpcy5tYXRjaENhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoRGF0YShyZWdleCwgdGhpcy53b3JkU2VwYXJhdG9ycyA/IGdldE1hcEZvcldvcmRTZXBhcmF0b3JzKHRoaXMud29yZFNlcGFyYXRvcnMsIFtdKSA6IG51bGwsIGNhblVzZVNpbXBsZVNlYXJjaCA/IHRoaXMuc2VhcmNoU3RyaW5nIDogbnVsbCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTXVsdGlsaW5lUmVnZXhTb3VyY2Uoc2VhcmNoU3RyaW5nKSB7XHJcbiAgICBpZiAoIXNlYXJjaFN0cmluZyB8fCBzZWFyY2hTdHJpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlYXJjaFN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHNlYXJjaFN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjaENvZGUgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hDb2RlID09PSA5MiAvKiBDaGFyQ29kZS5CYWNrc2xhc2ggKi8pIHtcclxuICAgICAgICAgICAgLy8gbW92ZSB0byBuZXh0IGNoYXJcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0cmluZyBlbmRzIHdpdGggYSBcXFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV4dENoQ29kZSA9IHNlYXJjaFN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobmV4dENoQ29kZSA9PT0gMTEwIC8qIENoYXJDb2RlLm4gKi8gfHwgbmV4dENoQ29kZSA9PT0gMTE0IC8qIENoYXJDb2RlLnIgKi8gfHwgbmV4dENoQ29kZSA9PT0gODcgLyogQ2hhckNvZGUuVyAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpbmRNYXRjaChyYW5nZSwgcmF3TWF0Y2hlcywgY2FwdHVyZU1hdGNoZXMpIHtcclxuICAgIGlmICghY2FwdHVyZU1hdGNoZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpbmRNYXRjaChyYW5nZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXRjaGVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmF3TWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIG1hdGNoZXNbaV0gPSByYXdNYXRjaGVzW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBGaW5kTWF0Y2gocmFuZ2UsIG1hdGNoZXMpO1xyXG59XHJcbmNsYXNzIExpbmVGZWVkQ291bnRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbGluZUZlZWRzT2Zmc2V0cyA9IFtdO1xyXG4gICAgICAgIGxldCBsaW5lRmVlZHNPZmZzZXRzTGVuID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgdGV4dExlbiA9IHRleHQubGVuZ3RoOyBpIDwgdGV4dExlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lRmVlZHNPZmZzZXRzW2xpbmVGZWVkc09mZnNldHNMZW4rK10gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpbmVGZWVkc09mZnNldHMgPSBsaW5lRmVlZHNPZmZzZXRzO1xyXG4gICAgfVxyXG4gICAgZmluZExpbmVGZWVkQ291bnRCZWZvcmVPZmZzZXQob2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgbGluZUZlZWRzT2Zmc2V0cyA9IHRoaXMuX2xpbmVGZWVkc09mZnNldHM7XHJcbiAgICAgICAgbGV0IG1pbiA9IDA7XHJcbiAgICAgICAgbGV0IG1heCA9IGxpbmVGZWVkc09mZnNldHMubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAobWF4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBubyBsaW5lIGZlZWRzXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2Zmc2V0IDw9IGxpbmVGZWVkc09mZnNldHNbMF0pIHtcclxuICAgICAgICAgICAgLy8gYmVmb3JlIGZpcnN0IGxpbmUgZmVlZFxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xyXG4gICAgICAgICAgICBjb25zdCBtaWQgPSBtaW4gKyAoKG1heCAtIG1pbikgLyAyID4+IDApO1xyXG4gICAgICAgICAgICBpZiAobGluZUZlZWRzT2Zmc2V0c1ttaWRdID49IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gbWlkIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lRmVlZHNPZmZzZXRzW21pZCArIDFdID49IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbmdvIVxyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBtaWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaW4gKyAxO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUZXh0TW9kZWxTZWFyY2gge1xyXG4gICAgc3RhdGljIGZpbmRNYXRjaGVzKG1vZGVsLCBzZWFyY2hQYXJhbXMsIHNlYXJjaFJhbmdlLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XHJcbiAgICAgICAgaWYgKCFzZWFyY2hEYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlYXJjaERhdGEucmVnZXgubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRNYXRjaGVzTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hSYW5nZSwgbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRNYXRjaGVzTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoUmFuZ2UsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlsaW5lIHNlYXJjaCBhbHdheXMgZXhlY3V0ZXMgb24gdGhlIGxpbmVzIGNvbmNhdGVuYXRlZCB3aXRoIFxcbi5cclxuICAgICAqIFdlIG11c3QgdGhlcmVmb3JlIGNvbXBlbnNhdGUgZm9yIHRoZSBjb3VudCBvZiBcXG4gaW4gY2FzZSB0aGUgbW9kZWwgaXMgQ1JMRlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX2dldE11bHRpbGluZU1hdGNoUmFuZ2UobW9kZWwsIGRlbHRhT2Zmc2V0LCB0ZXh0LCBsZkNvdW50ZXIsIG1hdGNoSW5kZXgsIG1hdGNoMCkge1xyXG4gICAgICAgIGxldCBzdGFydE9mZnNldDtcclxuICAgICAgICBsZXQgbGluZUZlZWRDb3VudEJlZm9yZU1hdGNoID0gMDtcclxuICAgICAgICBpZiAobGZDb3VudGVyKSB7XHJcbiAgICAgICAgICAgIGxpbmVGZWVkQ291bnRCZWZvcmVNYXRjaCA9IGxmQ291bnRlci5maW5kTGluZUZlZWRDb3VudEJlZm9yZU9mZnNldChtYXRjaEluZGV4KTtcclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBkZWx0YU9mZnNldCArIG1hdGNoSW5kZXggKyBsaW5lRmVlZENvdW50QmVmb3JlTWF0Y2ggLyogYWRkIGFzIG1hbnkgXFxyIGFzIHRoZXJlIHdlcmUgXFxuICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBkZWx0YU9mZnNldCArIG1hdGNoSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlbmRPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxmQ291bnRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lRmVlZENvdW50QmVmb3JlRW5kT2ZNYXRjaCA9IGxmQ291bnRlci5maW5kTGluZUZlZWRDb3VudEJlZm9yZU9mZnNldChtYXRjaEluZGV4ICsgbWF0Y2gwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVGZWVkQ291bnRJbk1hdGNoID0gbGluZUZlZWRDb3VudEJlZm9yZUVuZE9mTWF0Y2ggLSBsaW5lRmVlZENvdW50QmVmb3JlTWF0Y2g7XHJcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgbWF0Y2gwLmxlbmd0aCArIGxpbmVGZWVkQ291bnRJbk1hdGNoIC8qIGFkZCBhcyBtYW55IFxcciBhcyB0aGVyZSB3ZXJlIFxcbiAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgbWF0Y2gwLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IG1vZGVsLmdldFBvc2l0aW9uQXQoc3RhcnRPZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gbW9kZWwuZ2V0UG9zaXRpb25BdChlbmRPZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLCBzdGFydFBvc2l0aW9uLmNvbHVtbiwgZW5kUG9zaXRpb24ubGluZU51bWJlciwgZW5kUG9zaXRpb24uY29sdW1uKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZG9GaW5kTWF0Y2hlc011bHRpbGluZShtb2RlbCwgc2VhcmNoUmFuZ2UsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQoc2VhcmNoUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpKTtcclxuICAgICAgICAvLyBXZSBhbHdheXMgZXhlY3V0ZSBtdWx0aWxpbmUgc2VhcmNoIG92ZXIgdGhlIGxpbmVzIGpvaW5lZCB3aXRoIFxcblxyXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgaXQgdGhhdCBcXG4gd2lsbCBtYXRjaCB0aGUgRU9MIGZvciBib3RoIENSTEYgYW5kIExGIG1vZGVsc1xyXG4gICAgICAgIC8vIFdlIGNvbXBlbnNhdGUgZm9yIG9mZnNldCBlcnJvcnMgaW4gYF9nZXRNdWx0aWxpbmVNYXRjaFJhbmdlYFxyXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2Uoc2VhcmNoUmFuZ2UsIDEgLyogRW5kT2ZMaW5lUHJlZmVyZW5jZS5MRiAqLyk7XHJcbiAgICAgICAgY29uc3QgbGZDb3VudGVyID0gKG1vZGVsLmdldEVPTCgpID09PSAnXFxyXFxuJyA/IG5ldyBMaW5lRmVlZENvdW50ZXIodGV4dCkgOiBudWxsKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XHJcbiAgICAgICAgd2hpbGUgKChtID0gc2VhcmNoZXIubmV4dCh0ZXh0KSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2NvdW50ZXIrK10gPSBjcmVhdGVGaW5kTWF0Y2godGhpcy5fZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZShtb2RlbCwgZGVsdGFPZmZzZXQsIHRleHQsIGxmQ291bnRlciwgbS5pbmRleCwgbVswXSksIG0sIGNhcHR1cmVNYXRjaGVzKTtcclxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPj0gbGltaXRSZXN1bHRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9kb0ZpbmRNYXRjaGVzTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoUmFuZ2UsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IHJlc3VsdExlbiA9IDA7XHJcbiAgICAgICAgLy8gRWFybHkgY2FzZSBmb3IgYSBzZWFyY2ggcmFuZ2UgdGhhdCBzdGFydHMgJiBzdG9wcyBvbiB0aGUgc2FtZSBsaW5lIG51bWJlclxyXG4gICAgICAgIGlmIChzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHNlYXJjaFJhbmdlLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgc2VhcmNoUmFuZ2UuZW5kQ29sdW1uIC0gMSk7XHJcbiAgICAgICAgICAgIHJlc3VsdExlbiA9IHRoaXMuX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIHRleHQsIHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciwgc2VhcmNoUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByZXN1bHRMZW4sIHJlc3VsdCwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb2xsZWN0IHJlc3VsdHMgZnJvbSBmaXJzdCBsaW5lXHJcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSk7XHJcbiAgICAgICAgcmVzdWx0TGVuID0gdGhpcy5fZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBzZWFyY2hSYW5nZS5zdGFydENvbHVtbiAtIDEsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XHJcbiAgICAgICAgLy8gQ29sbGVjdCByZXN1bHRzIGZyb20gbWlkZGxlIGxpbmVzXHJcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciArIDE7IGxpbmVOdW1iZXIgPCBzZWFyY2hSYW5nZS5lbmRMaW5lTnVtYmVyICYmIHJlc3VsdExlbiA8IGxpbWl0UmVzdWx0Q291bnQ7IGxpbmVOdW1iZXIrKykge1xyXG4gICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKSwgbGluZU51bWJlciwgMCwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29sbGVjdCByZXN1bHRzIGZyb20gbGFzdCBsaW5lXHJcbiAgICAgICAgaWYgKHJlc3VsdExlbiA8IGxpbWl0UmVzdWx0Q291bnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHNlYXJjaFJhbmdlLmVuZExpbmVOdW1iZXIpLnN1YnN0cmluZygwLCBzZWFyY2hSYW5nZS5lbmRDb2x1bW4gLSAxKTtcclxuICAgICAgICAgICAgcmVzdWx0TGVuID0gdGhpcy5fZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlciwgMCwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgbGluZU51bWJlciwgZGVsdGFPZmZzZXQsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHdvcmRTZXBhcmF0b3JzID0gc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycztcclxuICAgICAgICBpZiAoIWNhcHR1cmVNYXRjaGVzICYmIHNlYXJjaERhdGEuc2ltcGxlU2VhcmNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFN0cmluZyA9IHNlYXJjaERhdGEuc2ltcGxlU2VhcmNoO1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hTdHJpbmdMZW4gPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBsYXN0TWF0Y2hJbmRleCA9IC1zZWFyY2hTdHJpbmdMZW47XHJcbiAgICAgICAgICAgIHdoaWxlICgobGFzdE1hdGNoSW5kZXggPSB0ZXh0LmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBsYXN0TWF0Y2hJbmRleCArIHNlYXJjaFN0cmluZ0xlbikpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkU2VwYXJhdG9ycyB8fCBpc1ZhbGlkTWF0Y2god29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIGxhc3RNYXRjaEluZGV4LCBzZWFyY2hTdHJpbmdMZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIGxhc3RNYXRjaEluZGV4ICsgMSArIGRlbHRhT2Zmc2V0LCBsaW5lTnVtYmVyLCBsYXN0TWF0Y2hJbmRleCArIDEgKyBzZWFyY2hTdHJpbmdMZW4gKyBkZWx0YU9mZnNldCksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihzZWFyY2hEYXRhLndvcmRTZXBhcmF0b3JzLCBzZWFyY2hEYXRhLnJlZ2V4KTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICAvLyBSZXNldCByZWdleCB0byBzZWFyY2ggZnJvbSB0aGUgYmVnaW5uaW5nXHJcbiAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBtID0gc2VhcmNoZXIubmV4dCh0ZXh0KTtcclxuICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBjcmVhdGVGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgZGVsdGFPZmZzZXQsIGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgbVswXS5sZW5ndGggKyBkZWx0YU9mZnNldCksIG0sIGNhcHR1cmVNYXRjaGVzKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChtKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmROZXh0TWF0Y2gobW9kZWwsIHNlYXJjaFBhcmFtcywgc2VhcmNoU3RhcnQsIGNhcHR1cmVNYXRjaGVzKSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IHNlYXJjaFBhcmFtcy5wYXJzZVNlYXJjaFJlcXVlc3QoKTtcclxuICAgICAgICBpZiAoIXNlYXJjaERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpO1xyXG4gICAgICAgIGlmIChzZWFyY2hEYXRhLnJlZ2V4Lm11bHRpbGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kTmV4dE1hdGNoTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE5leHRNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9kb0ZpbmROZXh0TWF0Y2hNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpIHtcclxuICAgICAgICBjb25zdCBzZWFyY2hUZXh0U3RhcnQgPSBuZXcgUG9zaXRpb24oc2VhcmNoU3RhcnQubGluZU51bWJlciwgMSk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChzZWFyY2hUZXh0U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpO1xyXG4gICAgICAgIC8vIFdlIGFsd2F5cyBleGVjdXRlIG11bHRpbGluZSBzZWFyY2ggb3ZlciB0aGUgbGluZXMgam9pbmVkIHdpdGggXFxuXHJcbiAgICAgICAgLy8gVGhpcyBtYWtlcyBpdCB0aGF0IFxcbiB3aWxsIG1hdGNoIHRoZSBFT0wgZm9yIGJvdGggQ1JMRiBhbmQgTEYgbW9kZWxzXHJcbiAgICAgICAgLy8gV2UgY29tcGVuc2F0ZSBmb3Igb2Zmc2V0IGVycm9ycyBpbiBgX2dldE11bHRpbGluZU1hdGNoUmFuZ2VgXHJcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShuZXcgUmFuZ2Uoc2VhcmNoVGV4dFN0YXJ0LmxpbmVOdW1iZXIsIHNlYXJjaFRleHRTdGFydC5jb2x1bW4sIGxpbmVDb3VudCwgbW9kZWwuZ2V0TGluZU1heENvbHVtbihsaW5lQ291bnQpKSwgMSAvKiBFbmRPZkxpbmVQcmVmZXJlbmNlLkxGICovKTtcclxuICAgICAgICBjb25zdCBsZkNvdW50ZXIgPSAobW9kZWwuZ2V0RU9MKCkgPT09ICdcXHJcXG4nID8gbmV3IExpbmVGZWVkQ291bnRlcih0ZXh0KSA6IG51bGwpO1xyXG4gICAgICAgIHNlYXJjaGVyLnJlc2V0KHNlYXJjaFN0YXJ0LmNvbHVtbiAtIDEpO1xyXG4gICAgICAgIGNvbnN0IG0gPSBzZWFyY2hlci5uZXh0KHRleHQpO1xyXG4gICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaW5kTWF0Y2godGhpcy5fZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZShtb2RlbCwgZGVsdGFPZmZzZXQsIHRleHQsIGxmQ291bnRlciwgbS5pbmRleCwgbVswXSksIG0sIGNhcHR1cmVNYXRjaGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIgIT09IDEgfHwgc2VhcmNoU3RhcnQuY29sdW1uICE9PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIFRyeSBhZ2FpbiBmcm9tIHRoZSB0b3BcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE5leHRNYXRjaE11bHRpbGluZShtb2RlbCwgbmV3IFBvc2l0aW9uKDEsIDEpLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZG9GaW5kTmV4dE1hdGNoTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcykge1xyXG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZU51bWJlciA9IHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXI7XHJcbiAgICAgICAgLy8gTG9vayBpbiBmaXJzdCBsaW5lXHJcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHN0YXJ0TGluZU51bWJlcik7XHJcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX2ZpbmRGaXJzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBzdGFydExpbmVOdW1iZXIsIHNlYXJjaFN0YXJ0LmNvbHVtbiwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgICAgIGlmIChyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsaW5lQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lSW5kZXggPSAoc3RhcnRMaW5lTnVtYmVyICsgaSAtIDEpICUgbGluZUNvdW50O1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZUluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9maW5kRmlyc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgbGluZUluZGV4ICsgMSwgMSwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2ZpbmRGaXJzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBsaW5lTnVtYmVyLCBmcm9tQ29sdW1uLCBjYXB0dXJlTWF0Y2hlcykge1xyXG4gICAgICAgIC8vIFNldCByZWdleCB0byBzZWFyY2ggZnJvbSBjb2x1bW5cclxuICAgICAgICBzZWFyY2hlci5yZXNldChmcm9tQ29sdW1uIC0gMSk7XHJcbiAgICAgICAgY29uc3QgbSA9IHNlYXJjaGVyLm5leHQodGV4dCk7XHJcbiAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbS5pbmRleCArIDEsIGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgbVswXS5sZW5ndGgpLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRQcmV2aW91c01hdGNoKG1vZGVsLCBzZWFyY2hQYXJhbXMsIHNlYXJjaFN0YXJ0LCBjYXB0dXJlTWF0Y2hlcykge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XHJcbiAgICAgICAgaWYgKCFzZWFyY2hEYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihzZWFyY2hEYXRhLndvcmRTZXBhcmF0b3JzLCBzZWFyY2hEYXRhLnJlZ2V4KTtcclxuICAgICAgICBpZiAoc2VhcmNoRGF0YS5yZWdleC5tdWx0aWxpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZFByZXZpb3VzTWF0Y2hNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kUHJldmlvdXNNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9kb0ZpbmRQcmV2aW91c01hdGNoTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2RvRmluZE1hdGNoZXNNdWx0aWxpbmUobW9kZWwsIG5ldyBSYW5nZSgxLCAxLCBzZWFyY2hTdGFydC5saW5lTnVtYmVyLCBzZWFyY2hTdGFydC5jb2x1bW4pLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMsIDEwICogTElNSVRfRklORF9DT1VOVCk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcclxuICAgICAgICBpZiAoc2VhcmNoU3RhcnQubGluZU51bWJlciAhPT0gbGluZUNvdW50IHx8IHNlYXJjaFN0YXJ0LmNvbHVtbiAhPT0gbW9kZWwuZ2V0TGluZU1heENvbHVtbihsaW5lQ291bnQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRyeSBhZ2FpbiB3aXRoIGFsbCBjb250ZW50XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRQcmV2aW91c01hdGNoTXVsdGlsaW5lKG1vZGVsLCBuZXcgUG9zaXRpb24obGluZUNvdW50LCBtb2RlbC5nZXRMaW5lTWF4Q29sdW1uKGxpbmVDb3VudCkpLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZG9GaW5kUHJldmlvdXNNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpIHtcclxuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcclxuICAgICAgICBjb25zdCBzdGFydExpbmVOdW1iZXIgPSBzZWFyY2hTdGFydC5saW5lTnVtYmVyO1xyXG4gICAgICAgIC8vIExvb2sgaW4gZmlyc3QgbGluZVxyXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChzdGFydExpbmVOdW1iZXIpLnN1YnN0cmluZygwLCBzZWFyY2hTdGFydC5jb2x1bW4gLSAxKTtcclxuICAgICAgICBjb25zdCByID0gdGhpcy5fZmluZExhc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgc3RhcnRMaW5lTnVtYmVyLCBjYXB0dXJlTWF0Y2hlcyk7XHJcbiAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxpbmVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVJbmRleCA9IChsaW5lQ291bnQgKyBzdGFydExpbmVOdW1iZXIgLSBpIC0gMSkgJSBsaW5lQ291bnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lSW5kZXggKyAxKTtcclxuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX2ZpbmRMYXN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVJbmRleCArIDEsIGNhcHR1cmVNYXRjaGVzKTtcclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9maW5kTGFzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBsaW5lTnVtYmVyLCBjYXB0dXJlTWF0Y2hlcykge1xyXG4gICAgICAgIGxldCBiZXN0UmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICBzZWFyY2hlci5yZXNldCgwKTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBzZWFyY2hlci5uZXh0KHRleHQpKSkge1xyXG4gICAgICAgICAgICBiZXN0UmVzdWx0ID0gY3JlYXRlRmluZE1hdGNoKG5ldyBSYW5nZShsaW5lTnVtYmVyLCBtLmluZGV4ICsgMSwgbGluZU51bWJlciwgbS5pbmRleCArIDEgKyBtWzBdLmxlbmd0aCksIG0sIGNhcHR1cmVNYXRjaGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlc3RSZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGVmdElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcclxuICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggPT09IDApIHtcclxuICAgICAgICAvLyBNYXRjaCBzdGFydHMgYXQgc3RhcnQgb2Ygc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGFyQmVmb3JlID0gdGV4dC5jaGFyQ29kZUF0KG1hdGNoU3RhcnRJbmRleCAtIDEpO1xyXG4gICAgaWYgKHdvcmRTZXBhcmF0b3JzLmdldChjaGFyQmVmb3JlKSAhPT0gMCAvKiBXb3JkQ2hhcmFjdGVyQ2xhc3MuUmVndWxhciAqLykge1xyXG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBtYXRjaCBpcyBhIHdvcmQgc2VwYXJhdG9yXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hhckJlZm9yZSA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2hhckJlZm9yZSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcclxuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgbWF0Y2ggaXMgbGluZSBicmVhayBvciBjYXJyaWFnZSByZXR1cm4uXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAobWF0Y2hMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RDaGFySW5NYXRjaCA9IHRleHQuY2hhckNvZGVBdChtYXRjaFN0YXJ0SW5kZXgpO1xyXG4gICAgICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQoZmlyc3RDaGFySW5NYXRjaCkgIT09IDAgLyogV29yZENoYXJhY3RlckNsYXNzLlJlZ3VsYXIgKi8pIHtcclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGNoYXJhY3RlciBpbnNpZGUgdGhlIG1hdGNoIGlzIGEgd29yZCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHJpZ2h0SXNXb3JkQm91bmRheSh3b3JkU2VwYXJhdG9ycywgdGV4dCwgdGV4dExlbmd0aCwgbWF0Y2hTdGFydEluZGV4LCBtYXRjaExlbmd0aCkge1xyXG4gICAgaWYgKG1hdGNoU3RhcnRJbmRleCArIG1hdGNoTGVuZ3RoID09PSB0ZXh0TGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gTWF0Y2ggZW5kcyBhdCBlbmQgb2Ygc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGFyQWZ0ZXIgPSB0ZXh0LmNoYXJDb2RlQXQobWF0Y2hTdGFydEluZGV4ICsgbWF0Y2hMZW5ndGgpO1xyXG4gICAgaWYgKHdvcmRTZXBhcmF0b3JzLmdldChjaGFyQWZ0ZXIpICE9PSAwIC8qIFdvcmRDaGFyYWN0ZXJDbGFzcy5SZWd1bGFyICovKSB7XHJcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBhZnRlciB0aGUgbWF0Y2ggaXMgYSB3b3JkIHNlcGFyYXRvclxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoYXJBZnRlciA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2hhckFmdGVyID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xyXG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIG1hdGNoIGlzIGxpbmUgYnJlYWsgb3IgY2FycmlhZ2UgcmV0dXJuLlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG1hdGNoTGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGxhc3RDaGFySW5NYXRjaCA9IHRleHQuY2hhckNvZGVBdChtYXRjaFN0YXJ0SW5kZXggKyBtYXRjaExlbmd0aCAtIDEpO1xyXG4gICAgICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQobGFzdENoYXJJbk1hdGNoKSAhPT0gMCAvKiBXb3JkQ2hhcmFjdGVyQ2xhc3MuUmVndWxhciAqLykge1xyXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBjaGFyYWN0ZXIgaW4gdGhlIG1hdGNoIGlzIGEgd29yZCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWF0Y2god29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcclxuICAgIHJldHVybiAobGVmdElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpXHJcbiAgICAgICAgJiYgcmlnaHRJc1dvcmRCb3VuZGF5KHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKSk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIFNlYXJjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdvcmRTZXBhcmF0b3JzLCBzZWFyY2hSZWdleCkge1xyXG4gICAgICAgIHRoaXMuX3dvcmRTZXBhcmF0b3JzID0gd29yZFNlcGFyYXRvcnM7XHJcbiAgICAgICAgdGhpcy5fc2VhcmNoUmVnZXggPSBzZWFyY2hSZWdleDtcclxuICAgICAgICB0aGlzLl9wcmV2TWF0Y2hTdGFydEluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIHJlc2V0KGxhc3RJbmRleCkge1xyXG4gICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4Lmxhc3RJbmRleCA9IGxhc3RJbmRleDtcclxuICAgICAgICB0aGlzLl9wcmV2TWF0Y2hTdGFydEluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIG5leHQodGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2TWF0Y2hTdGFydEluZGV4ICsgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID09PSB0ZXh0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGxpbmVcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG0gPSB0aGlzLl9zZWFyY2hSZWdleC5leGVjKHRleHQpO1xyXG4gICAgICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RhcnRJbmRleCA9IG0uaW5kZXg7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gbVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggPT09IHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggJiYgbWF0Y2hMZW5ndGggPT09IHRoaXMuX3ByZXZNYXRjaExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlYXJjaCByZXN1bHQgaXMgYW4gZW1wdHkgc3RyaW5nIGFuZCB3b24ndCBhZHZhbmNlIGByZWdleC5sYXN0SW5kZXhgLCBzbyBgcmVnZXguZXhlY2Agd2lsbCBzdHVjayBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gdGhhdCBieSBhZHZhbmNpbmcgYnkgdHdvIGlmIHN1cnJvZ2F0ZSBwYWlyIGZvdW5kIGFuZCBieSBvbmUgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuZ2V0TmV4dENvZGVQb2ludCh0ZXh0LCB0ZXh0TGVuZ3RoLCB0aGlzLl9zZWFyY2hSZWdleC5sYXN0SW5kZXgpID4gMHhGRkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4Lmxhc3RJbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoUmVnZXgubGFzdEluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgcmVnZXggbWF0Y2hlcyB0aGUgc2FtZSByYW5nZSB0d2ljZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcHJldk1hdGNoU3RhcnRJbmRleCA9IG1hdGNoU3RhcnRJbmRleDtcclxuICAgICAgICAgICAgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID0gbWF0Y2hMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fd29yZFNlcGFyYXRvcnMgfHwgaXNWYWxpZE1hdGNoKHRoaXMuX3dvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChtKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyMod: () => (/* binding */ KeyMod),\n/* harmony export */   createMonacoBaseAPI: () => (/* binding */ createMonacoBaseAPI)\n/* harmony export */ });\n/* harmony import */ var _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/cancellation.js */ \"./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\");\n/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/* harmony import */ var _base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/keyCodes.js */ \"./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\");\n/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/uri.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uri.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/selection.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\");\n/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/languages.js\");\n/* harmony import */ var _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../standalone/standaloneEnums.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KeyMod {\r\n    static chord(firstPart, secondPart) {\r\n        return (0,_base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__.KeyChord)(firstPart, secondPart);\r\n    }\r\n}\r\nKeyMod.CtrlCmd = 2048 /* ConstKeyMod.CtrlCmd */;\r\nKeyMod.Shift = 1024 /* ConstKeyMod.Shift */;\r\nKeyMod.Alt = 512 /* ConstKeyMod.Alt */;\r\nKeyMod.WinCtrl = 256 /* ConstKeyMod.WinCtrl */;\r\nfunction createMonacoBaseAPI() {\r\n    return {\r\n        editor: undefined, // undefined override expected here\r\n        languages: undefined, // undefined override expected here\r\n        CancellationTokenSource: _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource,\r\n        Emitter: _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter,\r\n        KeyCode: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.KeyCode,\r\n        KeyMod: KeyMod,\r\n        Position: _core_position_js__WEBPACK_IMPORTED_MODULE_4__.Position,\r\n        Range: _core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range,\r\n        Selection: _core_selection_js__WEBPACK_IMPORTED_MODULE_6__.Selection,\r\n        SelectionDirection: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.SelectionDirection,\r\n        MarkerSeverity: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerSeverity,\r\n        MarkerTag: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerTag,\r\n        Uri: _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI,\r\n        Token: _languages_js__WEBPACK_IMPORTED_MODULE_7__.Token\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JCYXNlQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDK0U7QUFDdkI7QUFDSTtBQUNWO0FBQ0g7QUFDTjtBQUNRO0FBQ1Q7QUFDNEI7QUFDN0Q7QUFDUDtBQUNBLGVBQWUsa0VBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUZBQXVCO0FBQ3hELGlCQUFpQiwwREFBTztBQUN4QixpQkFBaUIsbUVBQXVCO0FBQ3hDO0FBQ0Esa0JBQWtCLHVEQUFRO0FBQzFCLGVBQWUsaURBQUs7QUFDcEIsbUJBQW1CLHlEQUFTO0FBQzVCLDRCQUE0Qiw4RUFBa0M7QUFDOUQsd0JBQXdCLDBFQUE4QjtBQUN0RCxtQkFBbUIscUVBQXlCO0FBQzVDLGFBQWEsb0RBQUc7QUFDaEIsZUFBZSxnREFBSztBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yQmFzZUFwaS5qcz80MjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyc7XHJcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XHJcbmltcG9ydCB7IEtleUNob3JkIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24va2V5Q29kZXMuanMnO1xyXG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xyXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICcuLi9jb3JlL3NlbGVjdGlvbi5qcyc7XHJcbmltcG9ydCB7IFRva2VuIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzLmpzJztcclxuaW1wb3J0ICogYXMgc3RhbmRhbG9uZUVudW1zIGZyb20gJy4uL3N0YW5kYWxvbmUvc3RhbmRhbG9uZUVudW1zLmpzJztcclxuZXhwb3J0IGNsYXNzIEtleU1vZCB7XHJcbiAgICBzdGF0aWMgY2hvcmQoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XHJcbiAgICB9XHJcbn1cclxuS2V5TW9kLkN0cmxDbWQgPSAyMDQ4IC8qIENvbnN0S2V5TW9kLkN0cmxDbWQgKi87XHJcbktleU1vZC5TaGlmdCA9IDEwMjQgLyogQ29uc3RLZXlNb2QuU2hpZnQgKi87XHJcbktleU1vZC5BbHQgPSA1MTIgLyogQ29uc3RLZXlNb2QuQWx0ICovO1xyXG5LZXlNb2QuV2luQ3RybCA9IDI1NiAvKiBDb25zdEtleU1vZC5XaW5DdHJsICovO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9uYWNvQmFzZUFQSSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZWRpdG9yOiB1bmRlZmluZWQsIC8vIHVuZGVmaW5lZCBvdmVycmlkZSBleHBlY3RlZCBoZXJlXHJcbiAgICAgICAgbGFuZ3VhZ2VzOiB1bmRlZmluZWQsIC8vIHVuZGVmaW5lZCBvdmVycmlkZSBleHBlY3RlZCBoZXJlXHJcbiAgICAgICAgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U6IENhbmNlbGxhdGlvblRva2VuU291cmNlLFxyXG4gICAgICAgIEVtaXR0ZXI6IEVtaXR0ZXIsXHJcbiAgICAgICAgS2V5Q29kZTogc3RhbmRhbG9uZUVudW1zLktleUNvZGUsXHJcbiAgICAgICAgS2V5TW9kOiBLZXlNb2QsXHJcbiAgICAgICAgUG9zaXRpb246IFBvc2l0aW9uLFxyXG4gICAgICAgIFJhbmdlOiBSYW5nZSxcclxuICAgICAgICBTZWxlY3Rpb246IFNlbGVjdGlvbixcclxuICAgICAgICBTZWxlY3Rpb25EaXJlY3Rpb246IHN0YW5kYWxvbmVFbnVtcy5TZWxlY3Rpb25EaXJlY3Rpb24sXHJcbiAgICAgICAgTWFya2VyU2V2ZXJpdHk6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJTZXZlcml0eSxcclxuICAgICAgICBNYXJrZXJUYWc6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJUYWcsXHJcbiAgICAgICAgVXJpOiBVUkksXHJcbiAgICAgICAgVG9rZW46IFRva2VuXHJcbiAgICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorSimpleWorker: () => (/* binding */ EditorSimpleWorker),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ \"./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\");\n/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/uri.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uri.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/mirrorTextModel.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\");\n/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/wordHelper.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js\");\n/* harmony import */ var _languages_linkComputer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../languages/linkComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js\");\n/* harmony import */ var _languages_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages/supports/inplaceReplaceSupport.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js\");\n/* harmony import */ var _editorBaseApi_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editorBaseApi.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js\");\n/* harmony import */ var _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../base/common/stopwatch.js */ \"./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\");\n/* harmony import */ var _unicodeTextModelHighlighter_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./unicodeTextModelHighlighter.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js\");\n/* harmony import */ var _diff_linesDiffComputers_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../diff/linesDiffComputers.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js\");\n/* harmony import */ var _base_common_objects_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../base/common/objects.js */ \"./node_modules/monaco-editor/esm/vs/base/common/objects.js\");\n/* harmony import */ var _languages_defaultDocumentColorsComputer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../languages/defaultDocumentColorsComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js\");\n/* harmony import */ var _findSectionHeaders_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./findSectionHeaders.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @internal\r\n */\r\nclass MirrorModel extends _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_4__.MirrorTextModel {\r\n    get uri() {\r\n        return this._uri;\r\n    }\r\n    get eol() {\r\n        return this._eol;\r\n    }\r\n    getValue() {\r\n        return this.getText();\r\n    }\r\n    findMatches(regex) {\r\n        const matches = [];\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n            const offsetToAdd = this.offsetAt(new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(i + 1, 1));\r\n            const iteratorOverMatches = line.matchAll(regex);\r\n            for (const match of iteratorOverMatches) {\r\n                if (match.index || match.index === 0) {\r\n                    match.index = match.index + offsetToAdd;\r\n                }\r\n                matches.push(match);\r\n            }\r\n        }\r\n        return matches;\r\n    }\r\n    getLinesContent() {\r\n        return this._lines.slice(0);\r\n    }\r\n    getLineCount() {\r\n        return this._lines.length;\r\n    }\r\n    getLineContent(lineNumber) {\r\n        return this._lines[lineNumber - 1];\r\n    }\r\n    getWordAtPosition(position, wordDefinition) {\r\n        const wordAtText = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_5__.getWordAtText)(position.column, (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_5__.ensureValidWordDefinition)(wordDefinition), this._lines[position.lineNumber - 1], 0);\r\n        if (wordAtText) {\r\n            return new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\r\n        }\r\n        return null;\r\n    }\r\n    words(wordDefinition) {\r\n        const lines = this._lines;\r\n        const wordenize = this._wordenize.bind(this);\r\n        let lineNumber = 0;\r\n        let lineText = '';\r\n        let wordRangesIdx = 0;\r\n        let wordRanges = [];\r\n        return {\r\n            *[Symbol.iterator]() {\r\n                while (true) {\r\n                    if (wordRangesIdx < wordRanges.length) {\r\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\r\n                        wordRangesIdx += 1;\r\n                        yield value;\r\n                    }\r\n                    else {\r\n                        if (lineNumber < lines.length) {\r\n                            lineText = lines[lineNumber];\r\n                            wordRanges = wordenize(lineText, wordDefinition);\r\n                            wordRangesIdx = 0;\r\n                            lineNumber += 1;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    getLineWords(lineNumber, wordDefinition) {\r\n        const content = this._lines[lineNumber - 1];\r\n        const ranges = this._wordenize(content, wordDefinition);\r\n        const words = [];\r\n        for (const range of ranges) {\r\n            words.push({\r\n                word: content.substring(range.start, range.end),\r\n                startColumn: range.start + 1,\r\n                endColumn: range.end + 1\r\n            });\r\n        }\r\n        return words;\r\n    }\r\n    _wordenize(content, wordDefinition) {\r\n        const result = [];\r\n        let match;\r\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\r\n        while (match = wordDefinition.exec(content)) {\r\n            if (match[0].length === 0) {\r\n                // it did match the empty string\r\n                break;\r\n            }\r\n            result.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n        return result;\r\n    }\r\n    getValueInRange(range) {\r\n        range = this._validateRange(range);\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\r\n        }\r\n        const lineEnding = this._eol;\r\n        const startLineIndex = range.startLineNumber - 1;\r\n        const endLineIndex = range.endLineNumber - 1;\r\n        const resultLines = [];\r\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\r\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\r\n            resultLines.push(this._lines[i]);\r\n        }\r\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\r\n        return resultLines.join(lineEnding);\r\n    }\r\n    offsetAt(position) {\r\n        position = this._validatePosition(position);\r\n        this._ensureLineStarts();\r\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\r\n    }\r\n    positionAt(offset) {\r\n        offset = Math.floor(offset);\r\n        offset = Math.max(0, offset);\r\n        this._ensureLineStarts();\r\n        const out = this._lineStarts.getIndexOf(offset);\r\n        const lineLength = this._lines[out.index].length;\r\n        // Ensure we return a valid position\r\n        return {\r\n            lineNumber: 1 + out.index,\r\n            column: 1 + Math.min(out.remainder, lineLength)\r\n        };\r\n    }\r\n    _validateRange(range) {\r\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\r\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\r\n        if (start.lineNumber !== range.startLineNumber\r\n            || start.column !== range.startColumn\r\n            || end.lineNumber !== range.endLineNumber\r\n            || end.column !== range.endColumn) {\r\n            return {\r\n                startLineNumber: start.lineNumber,\r\n                startColumn: start.column,\r\n                endLineNumber: end.lineNumber,\r\n                endColumn: end.column\r\n            };\r\n        }\r\n        return range;\r\n    }\r\n    _validatePosition(position) {\r\n        if (!_core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position.isIPosition(position)) {\r\n            throw new Error('bad position');\r\n        }\r\n        let { lineNumber, column } = position;\r\n        let hasChanged = false;\r\n        if (lineNumber < 1) {\r\n            lineNumber = 1;\r\n            column = 1;\r\n            hasChanged = true;\r\n        }\r\n        else if (lineNumber > this._lines.length) {\r\n            lineNumber = this._lines.length;\r\n            column = this._lines[lineNumber - 1].length + 1;\r\n            hasChanged = true;\r\n        }\r\n        else {\r\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\r\n            if (column < 1) {\r\n                column = 1;\r\n                hasChanged = true;\r\n            }\r\n            else if (column > maxCharacter) {\r\n                column = maxCharacter;\r\n                hasChanged = true;\r\n            }\r\n        }\r\n        if (!hasChanged) {\r\n            return position;\r\n        }\r\n        else {\r\n            return { lineNumber, column };\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass EditorSimpleWorker {\r\n    constructor(host, foreignModuleFactory) {\r\n        this._host = host;\r\n        this._models = Object.create(null);\r\n        this._foreignModuleFactory = foreignModuleFactory;\r\n        this._foreignModule = null;\r\n    }\r\n    dispose() {\r\n        this._models = Object.create(null);\r\n    }\r\n    _getModel(uri) {\r\n        return this._models[uri];\r\n    }\r\n    _getModels() {\r\n        const all = [];\r\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\r\n        return all;\r\n    }\r\n    acceptNewModel(data) {\r\n        this._models[data.url] = new MirrorModel(_base_common_uri_js__WEBPACK_IMPORTED_MODULE_1__.URI.parse(data.url), data.lines, data.EOL, data.versionId);\r\n    }\r\n    acceptModelChanged(strURL, e) {\r\n        if (!this._models[strURL]) {\r\n            return;\r\n        }\r\n        const model = this._models[strURL];\r\n        model.onEvents(e);\r\n    }\r\n    acceptRemovedModel(strURL) {\r\n        if (!this._models[strURL]) {\r\n            return;\r\n        }\r\n        delete this._models[strURL];\r\n    }\r\n    async computeUnicodeHighlights(url, options, range) {\r\n        const model = this._getModel(url);\r\n        if (!model) {\r\n            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\r\n        }\r\n        return _unicodeTextModelHighlighter_js__WEBPACK_IMPORTED_MODULE_10__.UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\r\n    }\r\n    async findSectionHeaders(url, options) {\r\n        const model = this._getModel(url);\r\n        if (!model) {\r\n            return [];\r\n        }\r\n        return (0,_findSectionHeaders_js__WEBPACK_IMPORTED_MODULE_14__.findSectionHeaders)(model, options);\r\n    }\r\n    // ---- BEGIN diff --------------------------------------------------------------------------\r\n    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {\r\n        const original = this._getModel(originalUrl);\r\n        const modified = this._getModel(modifiedUrl);\r\n        if (!original || !modified) {\r\n            return null;\r\n        }\r\n        const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\r\n        return result;\r\n    }\r\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\r\n        const diffAlgorithm = algorithm === 'advanced' ? _diff_linesDiffComputers_js__WEBPACK_IMPORTED_MODULE_11__.linesDiffComputers.getDefault() : _diff_linesDiffComputers_js__WEBPACK_IMPORTED_MODULE_11__.linesDiffComputers.getLegacy();\r\n        const originalLines = originalTextModel.getLinesContent();\r\n        const modifiedLines = modifiedTextModel.getLinesContent();\r\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\r\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\r\n        function getLineChanges(changes) {\r\n            return changes.map(m => {\r\n                var _a;\r\n                return ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [\r\n                        m.originalRange.startLineNumber,\r\n                        m.originalRange.startColumn,\r\n                        m.originalRange.endLineNumber,\r\n                        m.originalRange.endColumn,\r\n                        m.modifiedRange.startLineNumber,\r\n                        m.modifiedRange.startColumn,\r\n                        m.modifiedRange.endLineNumber,\r\n                        m.modifiedRange.endColumn,\r\n                    ])]);\r\n            });\r\n        }\r\n        return {\r\n            identical,\r\n            quitEarly: result.hitTimeout,\r\n            changes: getLineChanges(result.changes),\r\n            moves: result.moves.map(m => ([\r\n                m.lineRangeMapping.original.startLineNumber,\r\n                m.lineRangeMapping.original.endLineNumberExclusive,\r\n                m.lineRangeMapping.modified.startLineNumber,\r\n                m.lineRangeMapping.modified.endLineNumberExclusive,\r\n                getLineChanges(m.changes)\r\n            ])),\r\n        };\r\n    }\r\n    static _modelsAreIdentical(original, modified) {\r\n        const originalLineCount = original.getLineCount();\r\n        const modifiedLineCount = modified.getLineCount();\r\n        if (originalLineCount !== modifiedLineCount) {\r\n            return false;\r\n        }\r\n        for (let line = 1; line <= originalLineCount; line++) {\r\n            const originalLine = original.getLineContent(line);\r\n            const modifiedLine = modified.getLineContent(line);\r\n            if (originalLine !== modifiedLine) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    async computeMoreMinimalEdits(modelUrl, edits, pretty) {\r\n        const model = this._getModel(modelUrl);\r\n        if (!model) {\r\n            return edits;\r\n        }\r\n        const result = [];\r\n        let lastEol = undefined;\r\n        edits = edits.slice(0).sort((a, b) => {\r\n            if (a.range && b.range) {\r\n                return _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.compareRangesUsingStarts(a.range, b.range);\r\n            }\r\n            // eol only changes should go to the end\r\n            const aRng = a.range ? 0 : 1;\r\n            const bRng = b.range ? 0 : 1;\r\n            return aRng - bRng;\r\n        });\r\n        // merge adjacent edits\r\n        let writeIndex = 0;\r\n        for (let readIndex = 1; readIndex < edits.length; readIndex++) {\r\n            if (_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.getEndPosition(edits[writeIndex].range).equals(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.getStartPosition(edits[readIndex].range))) {\r\n                edits[writeIndex].range = _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.fromPositions(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.getStartPosition(edits[writeIndex].range), _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.getEndPosition(edits[readIndex].range));\r\n                edits[writeIndex].text += edits[readIndex].text;\r\n            }\r\n            else {\r\n                writeIndex++;\r\n                edits[writeIndex] = edits[readIndex];\r\n            }\r\n        }\r\n        edits.length = writeIndex + 1;\r\n        for (let { range, text, eol } of edits) {\r\n            if (typeof eol === 'number') {\r\n                lastEol = eol;\r\n            }\r\n            if (_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.isEmpty(range) && !text) {\r\n                // empty change\r\n                continue;\r\n            }\r\n            const original = model.getValueInRange(range);\r\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\r\n            if (original === text) {\r\n                // noop\r\n                continue;\r\n            }\r\n            // make sure diff won't take too long\r\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\r\n                result.push({ range, text });\r\n                continue;\r\n            }\r\n            // compute diff between original and edit.text\r\n            const changes = (0,_base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.stringDiff)(original, text, pretty);\r\n            const editOffset = model.offsetAt(_core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range.lift(range).getStartPosition());\r\n            for (const change of changes) {\r\n                const start = model.positionAt(editOffset + change.originalStart);\r\n                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\r\n                const newEdit = {\r\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\r\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\r\n                };\r\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\r\n                    result.push(newEdit);\r\n                }\r\n            }\r\n        }\r\n        if (typeof lastEol === 'number') {\r\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\r\n        }\r\n        return result;\r\n    }\r\n    // ---- END minimal edits ---------------------------------------------------------------\r\n    async computeLinks(modelUrl) {\r\n        const model = this._getModel(modelUrl);\r\n        if (!model) {\r\n            return null;\r\n        }\r\n        return (0,_languages_linkComputer_js__WEBPACK_IMPORTED_MODULE_6__.computeLinks)(model);\r\n    }\r\n    // --- BEGIN default document colors -----------------------------------------------------------\r\n    async computeDefaultDocumentColors(modelUrl) {\r\n        const model = this._getModel(modelUrl);\r\n        if (!model) {\r\n            return null;\r\n        }\r\n        return (0,_languages_defaultDocumentColorsComputer_js__WEBPACK_IMPORTED_MODULE_13__.computeDefaultDocumentColors)(model);\r\n    }\r\n    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\r\n        const sw = new _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_9__.StopWatch();\r\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n        const seen = new Set();\r\n        outer: for (const url of modelUrls) {\r\n            const model = this._getModel(url);\r\n            if (!model) {\r\n                continue;\r\n            }\r\n            for (const word of model.words(wordDefRegExp)) {\r\n                if (word === leadingWord || !isNaN(Number(word))) {\r\n                    continue;\r\n                }\r\n                seen.add(word);\r\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\r\n                    break outer;\r\n                }\r\n            }\r\n        }\r\n        return { words: Array.from(seen), duration: sw.elapsed() };\r\n    }\r\n    // ---- END suggest --------------------------------------------------------------------------\r\n    //#region -- word ranges --\r\n    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\r\n        const model = this._getModel(modelUrl);\r\n        if (!model) {\r\n            return Object.create(null);\r\n        }\r\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n        const result = Object.create(null);\r\n        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\r\n            const words = model.getLineWords(line, wordDefRegExp);\r\n            for (const word of words) {\r\n                if (!isNaN(Number(word.word))) {\r\n                    continue;\r\n                }\r\n                let array = result[word.word];\r\n                if (!array) {\r\n                    array = [];\r\n                    result[word.word] = array;\r\n                }\r\n                array.push({\r\n                    startLineNumber: line,\r\n                    startColumn: word.startColumn,\r\n                    endLineNumber: line,\r\n                    endColumn: word.endColumn\r\n                });\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    //#endregion\r\n    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\r\n        const model = this._getModel(modelUrl);\r\n        if (!model) {\r\n            return null;\r\n        }\r\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n        if (range.startColumn === range.endColumn) {\r\n            range = {\r\n                startLineNumber: range.startLineNumber,\r\n                startColumn: range.startColumn,\r\n                endLineNumber: range.endLineNumber,\r\n                endColumn: range.endColumn + 1\r\n            };\r\n        }\r\n        const selectionText = model.getValueInRange(range);\r\n        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\r\n        if (!wordRange) {\r\n            return null;\r\n        }\r\n        const word = model.getValueInRange(wordRange);\r\n        const result = _languages_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_7__.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\r\n        return result;\r\n    }\r\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\r\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._host.fhr(method, args);\r\n        };\r\n        const foreignHost = (0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_12__.createProxyObject)(foreignHostMethods, proxyMethodRequest);\r\n        const ctx = {\r\n            host: foreignHost,\r\n            getMirrorModels: () => {\r\n                return this._getModels();\r\n            }\r\n        };\r\n        if (this._foreignModuleFactory) {\r\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\r\n            // static foreing module\r\n            return Promise.resolve((0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_12__.getAllMethodNames)(this._foreignModule));\r\n        }\r\n        // ESM-comment-begin\r\n        // \t\treturn new Promise<any>((resolve, reject) => {\r\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\r\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\r\n        // \r\n        // \t\t\t\tresolve(getAllMethodNames(this._foreignModule));\r\n        // \r\n        // \t\t\t}, reject);\r\n        // \t\t});\r\n        // ESM-comment-end\r\n        // ESM-uncomment-begin\r\n        return Promise.reject(new Error(`Unexpected usage`));\r\n        // ESM-uncomment-end\r\n    }\r\n    // foreign method request\r\n    fmr(method, args) {\r\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\r\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\r\n        }\r\n        try {\r\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n}\r\n// ---- END diff --------------------------------------------------------------------------\r\n// ---- BEGIN minimal edits ---------------------------------------------------------------\r\nEditorSimpleWorker._diffLimit = 100000;\r\n// ---- BEGIN suggest --------------------------------------------------------------------------\r\nEditorSimpleWorker._suggestionsLimit = 10000;\r\n/**\r\n * Called on the worker side\r\n * @internal\r\n */\r\nfunction create(host) {\r\n    return new EditorSimpleWorker(host, null);\r\n}\r\nif (typeof importScripts === 'function') {\r\n    // Running in a web worker\r\n    globalThis.monaco = (0,_editorBaseApi_js__WEBPACK_IMPORTED_MODULE_8__.createMonacoBaseAPI)();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRDtBQUNiO0FBQ0g7QUFDTjtBQUN3QztBQUNBO0FBQ3JCO0FBQ3lCO0FBQzVCO0FBQ0s7QUFDaUI7QUFDWjtBQUNvQjtBQUNNO0FBQ2hDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLGtEQUFrRCx1REFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFhLGtCQUFrQiw4RUFBeUI7QUFDbkY7QUFDQSx1QkFBdUIsaURBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUF3RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw4REFBOEQ7QUFDN0csNkNBQTZDLDBEQUEwRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1REFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvREFBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsZUFBZSx5RkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRFQUFrQixnQkFBZ0IsNEVBQWtCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFELGdCQUFnQixpREFBSyxnREFBZ0QsaURBQUs7QUFDMUUsMENBQTBDLGlEQUFLLGVBQWUsaURBQUssNENBQTRDLGlEQUFLO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFFQUFVO0FBQ3RDLDhDQUE4QyxpREFBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQyxzRUFBc0U7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3RUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEdBQTRCO0FBQzNDO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOERBQThEO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZGQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyRUFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJFQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFtQjtBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvclNpbXBsZVdvcmtlci5qcz9jY2Y2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBzdHJpbmdEaWZmIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzJztcclxuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdXJpLmpzJztcclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcclxuaW1wb3J0IHsgTWlycm9yVGV4dE1vZGVsIGFzIEJhc2VNaXJyb3JNb2RlbCB9IGZyb20gJy4uL21vZGVsL21pcnJvclRleHRNb2RlbC5qcyc7XHJcbmltcG9ydCB7IGVuc3VyZVZhbGlkV29yZERlZmluaXRpb24sIGdldFdvcmRBdFRleHQgfSBmcm9tICcuLi9jb3JlL3dvcmRIZWxwZXIuanMnO1xyXG5pbXBvcnQgeyBjb21wdXRlTGlua3MgfSBmcm9tICcuLi9sYW5ndWFnZXMvbGlua0NvbXB1dGVyLmpzJztcclxuaW1wb3J0IHsgQmFzaWNJbnBsYWNlUmVwbGFjZSB9IGZyb20gJy4uL2xhbmd1YWdlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVNb25hY29CYXNlQVBJIH0gZnJvbSAnLi9lZGl0b3JCYXNlQXBpLmpzJztcclxuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzJztcclxuaW1wb3J0IHsgVW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyIH0gZnJvbSAnLi91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuanMnO1xyXG5pbXBvcnQgeyBsaW5lc0RpZmZDb21wdXRlcnMgfSBmcm9tICcuLi9kaWZmL2xpbmVzRGlmZkNvbXB1dGVycy5qcyc7XHJcbmltcG9ydCB7IGNyZWF0ZVByb3h5T2JqZWN0LCBnZXRBbGxNZXRob2ROYW1lcyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL29iamVjdHMuanMnO1xyXG5pbXBvcnQgeyBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2RlZmF1bHREb2N1bWVudENvbG9yc0NvbXB1dGVyLmpzJztcclxuaW1wb3J0IHsgZmluZFNlY3Rpb25IZWFkZXJzIH0gZnJvbSAnLi9maW5kU2VjdGlvbkhlYWRlcnMuanMnO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBNaXJyb3JNb2RlbCBleHRlbmRzIEJhc2VNaXJyb3JNb2RlbCB7XHJcbiAgICBnZXQgdXJpKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cmk7XHJcbiAgICB9XHJcbiAgICBnZXQgZW9sKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lb2w7XHJcbiAgICB9XHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCk7XHJcbiAgICB9XHJcbiAgICBmaW5kTWF0Y2hlcyhyZWdleCkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLl9saW5lc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0VG9BZGQgPSB0aGlzLm9mZnNldEF0KG5ldyBQb3NpdGlvbihpICsgMSwgMSkpO1xyXG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvck92ZXJNYXRjaGVzID0gbGluZS5tYXRjaEFsbChyZWdleCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgaXRlcmF0b3JPdmVyTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4IHx8IG1hdGNoLmluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guaW5kZXggPSBtYXRjaC5pbmRleCArIG9mZnNldFRvQWRkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcclxuICAgIH1cclxuICAgIGdldExpbmVzQ29udGVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCk7XHJcbiAgICB9XHJcbiAgICBnZXRMaW5lQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xyXG4gICAgfVxyXG4gICAgZ2V0V29yZEF0UG9zaXRpb24ocG9zaXRpb24sIHdvcmREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgd29yZEF0VGV4dCA9IGdldFdvcmRBdFRleHQocG9zaXRpb24uY29sdW1uLCBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLCAwKTtcclxuICAgICAgICBpZiAod29yZEF0VGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRBdFRleHQuc3RhcnRDb2x1bW4sIHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRBdFRleHQuZW5kQ29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB3b3Jkcyh3b3JkRGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fbGluZXM7XHJcbiAgICAgICAgY29uc3Qgd29yZGVuaXplID0gdGhpcy5fd29yZGVuaXplLmJpbmQodGhpcyk7XHJcbiAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBsaW5lVGV4dCA9ICcnO1xyXG4gICAgICAgIGxldCB3b3JkUmFuZ2VzSWR4ID0gMDtcclxuICAgICAgICBsZXQgd29yZFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmRSYW5nZXNJZHggPCB3b3JkUmFuZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGxpbmVUZXh0LnN1YnN0cmluZyh3b3JkUmFuZ2VzW3dvcmRSYW5nZXNJZHhdLnN0YXJ0LCB3b3JkUmFuZ2VzW3dvcmRSYW5nZXNJZHhdLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXNJZHggKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlciA8IGxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRleHQgPSBsaW5lc1tsaW5lTnVtYmVyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXMgPSB3b3JkZW5pemUobGluZVRleHQsIHdvcmREZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXNJZHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0TGluZVdvcmRzKGxpbmVOdW1iZXIsIHdvcmREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX2xpbmVzW2xpbmVOdW1iZXIgLSAxXTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSB0aGlzLl93b3JkZW5pemUoY29udGVudCwgd29yZERlZmluaXRpb24pO1xyXG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHtcclxuICAgICAgICAgICAgd29yZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB3b3JkOiBjb250ZW50LnN1YnN0cmluZyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiByYW5nZS5zdGFydCArIDEsXHJcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZCArIDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3b3JkcztcclxuICAgIH1cclxuICAgIF93b3JkZW5pemUoY29udGVudCwgd29yZERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgbWF0Y2g7XHJcbiAgICAgICAgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID0gMDsgLy8gcmVzZXQgbGFzdEluZGV4IGp1c3QgdG8gYmUgc3VyZVxyXG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWMoY29udGVudCkpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaXQgZGlkIG1hdGNoIHRoZSBlbXB0eSBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgc3RhcnQ6IG1hdGNoLmluZGV4LCBlbmQ6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZ2V0VmFsdWVJblJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl92YWxpZGF0ZVJhbmdlKHJhbmdlKTtcclxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByYW5nZS5lbmRDb2x1bW4gLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGluZUVuZGluZyA9IHRoaXMuX2VvbDtcclxuICAgICAgICBjb25zdCBzdGFydExpbmVJbmRleCA9IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDE7XHJcbiAgICAgICAgY29uc3QgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIDE7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0TGluZXMgPSBbXTtcclxuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW3N0YXJ0TGluZUluZGV4XS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZUluZGV4ICsgMTsgaSA8IGVuZExpbmVJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2godGhpcy5fbGluZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW2VuZExpbmVJbmRleF0uc3Vic3RyaW5nKDAsIHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0TGluZXMuam9pbihsaW5lRW5kaW5nKTtcclxuICAgIH1cclxuICAgIG9mZnNldEF0KHBvc2l0aW9uKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9lbnN1cmVMaW5lU3RhcnRzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVTdGFydHMuZ2V0UHJlZml4U3VtKHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAyKSArIChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uQXQob2Zmc2V0KSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KDAsIG9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlTGluZVN0YXJ0cygpO1xyXG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuX2xpbmVTdGFydHMuZ2V0SW5kZXhPZihvZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSB0aGlzLl9saW5lc1tvdXQuaW5kZXhdLmxlbmd0aDtcclxuICAgICAgICAvLyBFbnN1cmUgd2UgcmV0dXJuIGEgdmFsaWQgcG9zaXRpb25cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiAxICsgb3V0LmluZGV4LFxyXG4gICAgICAgICAgICBjb2x1bW46IDEgKyBNYXRoLm1pbihvdXQucmVtYWluZGVyLCBsaW5lTGVuZ3RoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfdmFsaWRhdGVSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9KTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uKHsgbGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlciwgY29sdW1uOiByYW5nZS5lbmRDb2x1bW4gfSk7XHJcbiAgICAgICAgaWYgKHN0YXJ0LmxpbmVOdW1iZXIgIT09IHJhbmdlLnN0YXJ0TGluZU51bWJlclxyXG4gICAgICAgICAgICB8fCBzdGFydC5jb2x1bW4gIT09IHJhbmdlLnN0YXJ0Q29sdW1uXHJcbiAgICAgICAgICAgIHx8IGVuZC5saW5lTnVtYmVyICE9PSByYW5nZS5lbmRMaW5lTnVtYmVyXHJcbiAgICAgICAgICAgIHx8IGVuZC5jb2x1bW4gIT09IHJhbmdlLmVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydC5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0LmNvbHVtbixcclxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBlbmQuY29sdW1uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZTtcclxuICAgIH1cclxuICAgIF92YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFQb3NpdGlvbi5pc0lQb3NpdGlvbihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9zaXRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgbGluZU51bWJlciwgY29sdW1uIH0gPSBwb3NpdGlvbjtcclxuICAgICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChsaW5lTnVtYmVyIDwgMSkge1xyXG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gMTtcclxuICAgICAgICAgICAgY29sdW1uID0gMTtcclxuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxpbmVOdW1iZXIgPiB0aGlzLl9saW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGluZU51bWJlciA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29sdW1uID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbWF4Q2hhcmFjdGVyID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSAxO1xyXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uID4gbWF4Q2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBtYXhDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbGluZU51bWJlciwgY29sdW1uIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFZGl0b3JTaW1wbGVXb3JrZXIge1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcclxuICAgICAgICB0aGlzLl9tb2RlbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5ID0gZm9yZWlnbk1vZHVsZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5fZm9yZWlnbk1vZHVsZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX21vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0TW9kZWwodXJpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsc1t1cmldO1xyXG4gICAgfVxyXG4gICAgX2dldE1vZGVscygpIHtcclxuICAgICAgICBjb25zdCBhbGwgPSBbXTtcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tb2RlbHMpLmZvckVhY2goKGtleSkgPT4gYWxsLnB1c2godGhpcy5fbW9kZWxzW2tleV0pKTtcclxuICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgfVxyXG4gICAgYWNjZXB0TmV3TW9kZWwoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX21vZGVsc1tkYXRhLnVybF0gPSBuZXcgTWlycm9yTW9kZWwoVVJJLnBhcnNlKGRhdGEudXJsKSwgZGF0YS5saW5lcywgZGF0YS5FT0wsIGRhdGEudmVyc2lvbklkKTtcclxuICAgIH1cclxuICAgIGFjY2VwdE1vZGVsQ2hhbmdlZChzdHJVUkwsIGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21vZGVsc1tzdHJVUkxdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9tb2RlbHNbc3RyVVJMXTtcclxuICAgICAgICBtb2RlbC5vbkV2ZW50cyhlKTtcclxuICAgIH1cclxuICAgIGFjY2VwdFJlbW92ZWRNb2RlbChzdHJVUkwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21vZGVsc1tzdHJVUkxdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVsc1tzdHJVUkxdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRzKHVybCwgb3B0aW9ucywgcmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKHVybCk7XHJcbiAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZXM6IFtdLCBoYXNNb3JlOiBmYWxzZSwgYW1iaWd1b3VzQ2hhcmFjdGVyQ291bnQ6IDAsIGludmlzaWJsZUNoYXJhY3RlckNvdW50OiAwLCBub25CYXNpY0FzY2lpQ2hhcmFjdGVyQ291bnQ6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlci5jb21wdXRlVW5pY29kZUhpZ2hsaWdodHMobW9kZWwsIG9wdGlvbnMsIHJhbmdlKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGZpbmRTZWN0aW9uSGVhZGVycyh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKHVybCk7XHJcbiAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaW5kU2VjdGlvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBCRUdJTiBkaWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBhc3luYyBjb21wdXRlRGlmZihvcmlnaW5hbFVybCwgbW9kaWZpZWRVcmwsIG9wdGlvbnMsIGFsZ29yaXRobSkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGhpcy5fZ2V0TW9kZWwob3JpZ2luYWxVcmwpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkID0gdGhpcy5fZ2V0TW9kZWwobW9kaWZpZWRVcmwpO1xyXG4gICAgICAgIGlmICghb3JpZ2luYWwgfHwgIW1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBFZGl0b3JTaW1wbGVXb3JrZXIuY29tcHV0ZURpZmYob3JpZ2luYWwsIG1vZGlmaWVkLCBvcHRpb25zLCBhbGdvcml0aG0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29tcHV0ZURpZmYob3JpZ2luYWxUZXh0TW9kZWwsIG1vZGlmaWVkVGV4dE1vZGVsLCBvcHRpb25zLCBhbGdvcml0aG0pIHtcclxuICAgICAgICBjb25zdCBkaWZmQWxnb3JpdGhtID0gYWxnb3JpdGhtID09PSAnYWR2YW5jZWQnID8gbGluZXNEaWZmQ29tcHV0ZXJzLmdldERlZmF1bHQoKSA6IGxpbmVzRGlmZkNvbXB1dGVycy5nZXRMZWdhY3koKTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVzID0gb3JpZ2luYWxUZXh0TW9kZWwuZ2V0TGluZXNDb250ZW50KCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkVGV4dE1vZGVsLmdldExpbmVzQ29udGVudCgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpZmZBbGdvcml0aG0uY29tcHV0ZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgaWRlbnRpY2FsID0gKHJlc3VsdC5jaGFuZ2VzLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRoaXMuX21vZGVsc0FyZUlkZW50aWNhbChvcmlnaW5hbFRleHRNb2RlbCwgbW9kaWZpZWRUZXh0TW9kZWwpKTtcclxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lQ2hhbmdlcyhjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzLm1hcChtID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoW20ub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyLCBtLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIG0ubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyLCBtLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIChfYSA9IG0uaW5uZXJDaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG0gPT4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2Uuc3RhcnRDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ub3JpZ2luYWxSYW5nZS5lbmRMaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2UuZW5kQ29sdW1uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2Uuc3RhcnRDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubW9kaWZpZWRSYW5nZS5lbmRMaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2UuZW5kQ29sdW1uLFxyXG4gICAgICAgICAgICAgICAgICAgIF0pXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZGVudGljYWwsXHJcbiAgICAgICAgICAgIHF1aXRFYXJseTogcmVzdWx0LmhpdFRpbWVvdXQsXHJcbiAgICAgICAgICAgIGNoYW5nZXM6IGdldExpbmVDaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSxcclxuICAgICAgICAgICAgbW92ZXM6IHJlc3VsdC5tb3Zlcy5tYXAobSA9PiAoW1xyXG4gICAgICAgICAgICAgICAgbS5saW5lUmFuZ2VNYXBwaW5nLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgIG0ubGluZVJhbmdlTWFwcGluZy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLFxyXG4gICAgICAgICAgICAgICAgbS5saW5lUmFuZ2VNYXBwaW5nLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgIG0ubGluZVJhbmdlTWFwcGluZy5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLFxyXG4gICAgICAgICAgICAgICAgZ2V0TGluZUNoYW5nZXMobS5jaGFuZ2VzKVxyXG4gICAgICAgICAgICBdKSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfbW9kZWxzQXJlSWRlbnRpY2FsKG9yaWdpbmFsLCBtb2RpZmllZCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZUNvdW50ID0gb3JpZ2luYWwuZ2V0TGluZUNvdW50KCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lQ291bnQgPSBtb2RpZmllZC5nZXRMaW5lQ291bnQoKTtcclxuICAgICAgICBpZiAob3JpZ2luYWxMaW5lQ291bnQgIT09IG1vZGlmaWVkTGluZUNvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgbGluZSA9IDE7IGxpbmUgPD0gb3JpZ2luYWxMaW5lQ291bnQ7IGxpbmUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5nZXRMaW5lQ29udGVudChsaW5lKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWQuZ2V0TGluZUNvbnRlbnQobGluZSk7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbExpbmUgIT09IG1vZGlmaWVkTGluZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY29tcHV0ZU1vcmVNaW5pbWFsRWRpdHMobW9kZWxVcmwsIGVkaXRzLCBwcmV0dHkpIHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICBpZiAoIW1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlZGl0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGxhc3RFb2wgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZWRpdHMgPSBlZGl0cy5zbGljZSgwKS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhLnJhbmdlICYmIGIucmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBSYW5nZS5jb21wYXJlUmFuZ2VzVXNpbmdTdGFydHMoYS5yYW5nZSwgYi5yYW5nZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZW9sIG9ubHkgY2hhbmdlcyBzaG91bGQgZ28gdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICBjb25zdCBhUm5nID0gYS5yYW5nZSA/IDAgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBiUm5nID0gYi5yYW5nZSA/IDAgOiAxO1xyXG4gICAgICAgICAgICByZXR1cm4gYVJuZyAtIGJSbmc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgZWRpdHNcclxuICAgICAgICBsZXQgd3JpdGVJbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgcmVhZEluZGV4ID0gMTsgcmVhZEluZGV4IDwgZWRpdHMubGVuZ3RoOyByZWFkSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoUmFuZ2UuZ2V0RW5kUG9zaXRpb24oZWRpdHNbd3JpdGVJbmRleF0ucmFuZ2UpLmVxdWFscyhSYW5nZS5nZXRTdGFydFBvc2l0aW9uKGVkaXRzW3JlYWRJbmRleF0ucmFuZ2UpKSkge1xyXG4gICAgICAgICAgICAgICAgZWRpdHNbd3JpdGVJbmRleF0ucmFuZ2UgPSBSYW5nZS5mcm9tUG9zaXRpb25zKFJhbmdlLmdldFN0YXJ0UG9zaXRpb24oZWRpdHNbd3JpdGVJbmRleF0ucmFuZ2UpLCBSYW5nZS5nZXRFbmRQb3NpdGlvbihlZGl0c1tyZWFkSW5kZXhdLnJhbmdlKSk7XHJcbiAgICAgICAgICAgICAgICBlZGl0c1t3cml0ZUluZGV4XS50ZXh0ICs9IGVkaXRzW3JlYWRJbmRleF0udGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIGVkaXRzW3dyaXRlSW5kZXhdID0gZWRpdHNbcmVhZEluZGV4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlZGl0cy5sZW5ndGggPSB3cml0ZUluZGV4ICsgMTtcclxuICAgICAgICBmb3IgKGxldCB7IHJhbmdlLCB0ZXh0LCBlb2wgfSBvZiBlZGl0cykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVvbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RFb2wgPSBlb2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFJhbmdlLmlzRW1wdHkocmFuZ2UpICYmICF0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHJhbmdlKTtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxufFxcbnxcXHIvZywgbW9kZWwuZW9sKTtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsID09PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub29wXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgZGlmZiB3b24ndCB0YWtlIHRvbyBsb25nXHJcbiAgICAgICAgICAgIGlmIChNYXRoLm1heCh0ZXh0Lmxlbmd0aCwgb3JpZ2luYWwubGVuZ3RoKSA+IEVkaXRvclNpbXBsZVdvcmtlci5fZGlmZkxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHJhbmdlLCB0ZXh0IH0pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIGJldHdlZW4gb3JpZ2luYWwgYW5kIGVkaXQudGV4dFxyXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gc3RyaW5nRGlmZihvcmlnaW5hbCwgdGV4dCwgcHJldHR5KTtcclxuICAgICAgICAgICAgY29uc3QgZWRpdE9mZnNldCA9IG1vZGVsLm9mZnNldEF0KFJhbmdlLmxpZnQocmFuZ2UpLmdldFN0YXJ0UG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWRpdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LnN1YnN0cihjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogeyBzdGFydExpbmVOdW1iZXI6IHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uOiBzdGFydC5jb2x1bW4sIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLCBlbmRDb2x1bW46IGVuZC5jb2x1bW4gfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5nZXRWYWx1ZUluUmFuZ2UobmV3RWRpdC5yYW5nZSkgIT09IG5ld0VkaXQudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld0VkaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGFzdEVvbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBlb2w6IGxhc3RFb2wsIHRleHQ6ICcnLCByYW5nZTogeyBzdGFydExpbmVOdW1iZXI6IDAsIHN0YXJ0Q29sdW1uOiAwLCBlbmRMaW5lTnVtYmVyOiAwLCBlbmRDb2x1bW46IDAgfSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gRU5EIG1pbmltYWwgZWRpdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBhc3luYyBjb21wdXRlTGlua3MobW9kZWxVcmwpIHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICBpZiAoIW1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcHV0ZUxpbmtzKG1vZGVsKTtcclxuICAgIH1cclxuICAgIC8vIC0tLSBCRUdJTiBkZWZhdWx0IGRvY3VtZW50IGNvbG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgYXN5bmMgY29tcHV0ZURlZmF1bHREb2N1bWVudENvbG9ycyhtb2RlbFVybCkge1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xyXG4gICAgICAgIGlmICghbW9kZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzKG1vZGVsKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHRleHR1YWxTdWdnZXN0KG1vZGVsVXJscywgbGVhZGluZ1dvcmQsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xyXG4gICAgICAgIGNvbnN0IHN3ID0gbmV3IFN0b3BXYXRjaCgpO1xyXG4gICAgICAgIGNvbnN0IHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XHJcbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgICAgICBvdXRlcjogZm9yIChjb25zdCB1cmwgb2YgbW9kZWxVcmxzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwodXJsKTtcclxuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIG1vZGVsLndvcmRzKHdvcmREZWZSZWdFeHApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod29yZCA9PT0gbGVhZGluZ1dvcmQgfHwgIWlzTmFOKE51bWJlcih3b3JkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZW4uYWRkKHdvcmQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uc2l6ZSA+IEVkaXRvclNpbXBsZVdvcmtlci5fc3VnZ2VzdGlvbnNMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHdvcmRzOiBBcnJheS5mcm9tKHNlZW4pLCBkdXJhdGlvbjogc3cuZWxhcHNlZCgpIH07XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tIEVORCBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyNyZWdpb24gLS0gd29yZCByYW5nZXMgLS1cclxuICAgIGFzeW5jIGNvbXB1dGVXb3JkUmFuZ2VzKG1vZGVsVXJsLCByYW5nZSwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XHJcbiAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIGZvciAobGV0IGxpbmUgPSByYW5nZS5zdGFydExpbmVOdW1iZXI7IGxpbmUgPCByYW5nZS5lbmRMaW5lTnVtYmVyOyBsaW5lKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBtb2RlbC5nZXRMaW5lV29yZHMobGluZSwgd29yZERlZlJlZ0V4cCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29yZCBvZiB3b3Jkcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIod29yZC53b3JkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBhcnJheSA9IHJlc3VsdFt3b3JkLndvcmRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3dvcmQud29yZF0gPSBhcnJheTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogbGluZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogd29yZC5zdGFydENvbHVtbixcclxuICAgICAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZENvbHVtbjogd29yZC5lbmRDb2x1bW5cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIGFzeW5jIG5hdmlnYXRlVmFsdWVTZXQobW9kZWxVcmwsIHJhbmdlLCB1cCwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XHJcbiAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcclxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uLFxyXG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogcmFuZ2UuZW5kQ29sdW1uICsgMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25UZXh0ID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHJhbmdlKTtcclxuICAgICAgICBjb25zdCB3b3JkUmFuZ2UgPSBtb2RlbC5nZXRXb3JkQXRQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9LCB3b3JkRGVmUmVnRXhwKTtcclxuICAgICAgICBpZiAoIXdvcmRSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd29yZCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZSh3b3JkUmFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEJhc2ljSW5wbGFjZVJlcGxhY2UuSU5TVEFOQ0UubmF2aWdhdGVWYWx1ZVNldChyYW5nZSwgc2VsZWN0aW9uVGV4dCwgd29yZFJhbmdlLCB3b3JkLCB1cCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gQkVHSU4gZm9yZWlnbiBtb2R1bGUgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbG9hZEZvcmVpZ25Nb2R1bGUobW9kdWxlSWQsIGNyZWF0ZURhdGEsIGZvcmVpZ25Ib3N0TWV0aG9kcykge1xyXG4gICAgICAgIGNvbnN0IHByb3h5TWV0aG9kUmVxdWVzdCA9IChtZXRob2QsIGFyZ3MpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3QuZmhyKG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmb3JlaWduSG9zdCA9IGNyZWF0ZVByb3h5T2JqZWN0KGZvcmVpZ25Ib3N0TWV0aG9kcywgcHJveHlNZXRob2RSZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBjdHggPSB7XHJcbiAgICAgICAgICAgIGhvc3Q6IGZvcmVpZ25Ib3N0LFxyXG4gICAgICAgICAgICBnZXRNaXJyb3JNb2RlbHM6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRNb2RlbHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeShjdHgsIGNyZWF0ZURhdGEpO1xyXG4gICAgICAgICAgICAvLyBzdGF0aWMgZm9yZWluZyBtb2R1bGVcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9mb3JlaWduTW9kdWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVTTS1jb21tZW50LWJlZ2luXHJcbiAgICAgICAgLy8gXHRcdHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvLyBcdFx0XHRyZXF1aXJlKFttb2R1bGVJZF0sIChmb3JlaWduTW9kdWxlOiB7IGNyZWF0ZTogSUZvcmVpZ25Nb2R1bGVGYWN0b3J5IH0pID0+IHtcclxuICAgICAgICAvLyBcdFx0XHRcdHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSBmb3JlaWduTW9kdWxlLmNyZWF0ZShjdHgsIGNyZWF0ZURhdGEpO1xyXG4gICAgICAgIC8vIFxyXG4gICAgICAgIC8vIFx0XHRcdFx0cmVzb2x2ZShnZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9mb3JlaWduTW9kdWxlKSk7XHJcbiAgICAgICAgLy8gXHJcbiAgICAgICAgLy8gXHRcdFx0fSwgcmVqZWN0KTtcclxuICAgICAgICAvLyBcdFx0fSk7XHJcbiAgICAgICAgLy8gRVNNLWNvbW1lbnQtZW5kXHJcbiAgICAgICAgLy8gRVNNLXVuY29tbWVudC1iZWdpblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdXNhZ2VgKSk7XHJcbiAgICAgICAgLy8gRVNNLXVuY29tbWVudC1lbmRcclxuICAgIH1cclxuICAgIC8vIGZvcmVpZ24gbWV0aG9kIHJlcXVlc3RcclxuICAgIGZtcihtZXRob2QsIGFyZ3MpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZvcmVpZ25Nb2R1bGUgfHwgdHlwZW9mIHRoaXMuX2ZvcmVpZ25Nb2R1bGVbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVlc3RIYW5kbGVyIG9yIG1ldGhvZDogJyArIG1ldGhvZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZvcmVpZ25Nb2R1bGVbbWV0aG9kXS5hcHBseSh0aGlzLl9mb3JlaWduTW9kdWxlLCBhcmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gLS0tLSBFTkQgZGlmZiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAtLS0tIEJFR0lOIG1pbmltYWwgZWRpdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbkVkaXRvclNpbXBsZVdvcmtlci5fZGlmZkxpbWl0ID0gMTAwMDAwO1xyXG4vLyAtLS0tIEJFR0lOIHN1Z2dlc3QgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuRWRpdG9yU2ltcGxlV29ya2VyLl9zdWdnZXN0aW9uc0xpbWl0ID0gMTAwMDA7XHJcbi8qKlxyXG4gKiBDYWxsZWQgb24gdGhlIHdvcmtlciBzaWRlXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShob3N0KSB7XHJcbiAgICByZXR1cm4gbmV3IEVkaXRvclNpbXBsZVdvcmtlcihob3N0LCBudWxsKTtcclxufVxyXG5pZiAodHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vIFJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyXHJcbiAgICBnbG9iYWxUaGlzLm1vbmFjbyA9IGNyZWF0ZU1vbmFjb0Jhc2VBUEkoKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findSectionHeaders: () => (/* binding */ findSectionHeaders)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst markRegex = new RegExp('\\\\bMARK:\\\\s*(.*)$', 'd');\r\nconst trimDashesRegex = /^-+|-+$/g;\r\n/**\r\n * Find section headers in the model.\r\n *\r\n * @param model the text model to search in\r\n * @param options options to search with\r\n * @returns an array of section headers\r\n */\r\nfunction findSectionHeaders(model, options) {\r\n    var _a;\r\n    let headers = [];\r\n    if (options.findRegionSectionHeaders && ((_a = options.foldingRules) === null || _a === void 0 ? void 0 : _a.markers)) {\r\n        const regionHeaders = collectRegionHeaders(model, options);\r\n        headers = headers.concat(regionHeaders);\r\n    }\r\n    if (options.findMarkSectionHeaders) {\r\n        const markHeaders = collectMarkHeaders(model);\r\n        headers = headers.concat(markHeaders);\r\n    }\r\n    return headers;\r\n}\r\nfunction collectRegionHeaders(model, options) {\r\n    const regionHeaders = [];\r\n    const endLineNumber = model.getLineCount();\r\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        const match = lineContent.match(options.foldingRules.markers.start);\r\n        if (match) {\r\n            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\r\n            if (range.endColumn > range.startColumn) {\r\n                const sectionHeader = {\r\n                    range,\r\n                    ...getHeaderText(lineContent.substring(match[0].length)),\r\n                    shouldBeInComments: false\r\n                };\r\n                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\r\n                    regionHeaders.push(sectionHeader);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return regionHeaders;\r\n}\r\nfunction collectMarkHeaders(model) {\r\n    const markHeaders = [];\r\n    const endLineNumber = model.getLineCount();\r\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\r\n    }\r\n    return markHeaders;\r\n}\r\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\r\n    markRegex.lastIndex = 0;\r\n    const match = markRegex.exec(lineContent);\r\n    if (match) {\r\n        const column = match.indices[1][0] + 1;\r\n        const endColumn = match.indices[1][1] + 1;\r\n        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };\r\n        if (range.endColumn > range.startColumn) {\r\n            const sectionHeader = {\r\n                range,\r\n                ...getHeaderText(match[1]),\r\n                shouldBeInComments: true\r\n            };\r\n            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\r\n                sectionHeaders.push(sectionHeader);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getHeaderText(text) {\r\n    text = text.trim();\r\n    const hasSeparatorLine = text.startsWith('-');\r\n    text = text.replace(trimDashesRegex, '');\r\n    return { text, hasSeparatorLine };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9maW5kU2VjdGlvbkhlYWRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZmluZFNlY3Rpb25IZWFkZXJzLmpzPzdjODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmNvbnN0IG1hcmtSZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxiTUFSSzpcXFxccyooLiopJCcsICdkJyk7XHJcbmNvbnN0IHRyaW1EYXNoZXNSZWdleCA9IC9eLSt8LSskL2c7XHJcbi8qKlxyXG4gKiBGaW5kIHNlY3Rpb24gaGVhZGVycyBpbiB0aGUgbW9kZWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2RlbCB0aGUgdGV4dCBtb2RlbCB0byBzZWFyY2ggaW5cclxuICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBzZWFyY2ggd2l0aFxyXG4gKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzZWN0aW9uIGhlYWRlcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kU2VjdGlvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGxldCBoZWFkZXJzID0gW107XHJcbiAgICBpZiAob3B0aW9ucy5maW5kUmVnaW9uU2VjdGlvbkhlYWRlcnMgJiYgKChfYSA9IG9wdGlvbnMuZm9sZGluZ1J1bGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykpIHtcclxuICAgICAgICBjb25zdCByZWdpb25IZWFkZXJzID0gY29sbGVjdFJlZ2lvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpO1xyXG4gICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzLmNvbmNhdChyZWdpb25IZWFkZXJzKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmZpbmRNYXJrU2VjdGlvbkhlYWRlcnMpIHtcclxuICAgICAgICBjb25zdCBtYXJrSGVhZGVycyA9IGNvbGxlY3RNYXJrSGVhZGVycyhtb2RlbCk7XHJcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMuY29uY2F0KG1hcmtIZWFkZXJzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZWFkZXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbGxlY3RSZWdpb25IZWFkZXJzKG1vZGVsLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCByZWdpb25IZWFkZXJzID0gW107XHJcbiAgICBjb25zdCBlbmRMaW5lTnVtYmVyID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7XHJcbiAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcclxuICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IG1vZGVsLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZUNvbnRlbnQubWF0Y2gob3B0aW9ucy5mb2xkaW5nUnVsZXMubWFya2Vycy5zdGFydCk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBzdGFydExpbmVOdW1iZXI6IGxpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uOiBtYXRjaFswXS5sZW5ndGggKyAxLCBlbmRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLCBlbmRDb2x1bW46IGxpbmVDb250ZW50Lmxlbmd0aCArIDEgfTtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZENvbHVtbiA+IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uSGVhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdldEhlYWRlclRleHQobGluZUNvbnRlbnQuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEJlSW5Db21tZW50czogZmFsc2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbkhlYWRlci50ZXh0IHx8IHNlY3Rpb25IZWFkZXIuaGFzU2VwYXJhdG9yTGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbkhlYWRlcnMucHVzaChzZWN0aW9uSGVhZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZWdpb25IZWFkZXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbGxlY3RNYXJrSGVhZGVycyhtb2RlbCkge1xyXG4gICAgY29uc3QgbWFya0hlYWRlcnMgPSBbXTtcclxuICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcclxuICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSAxOyBsaW5lTnVtYmVyIDw9IGVuZExpbmVOdW1iZXI7IGxpbmVOdW1iZXIrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XHJcbiAgICAgICAgYWRkTWFya0hlYWRlcklmRm91bmQobGluZUNvbnRlbnQsIGxpbmVOdW1iZXIsIG1hcmtIZWFkZXJzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXJrSGVhZGVycztcclxufVxyXG5mdW5jdGlvbiBhZGRNYXJrSGVhZGVySWZGb3VuZChsaW5lQ29udGVudCwgbGluZU51bWJlciwgc2VjdGlvbkhlYWRlcnMpIHtcclxuICAgIG1hcmtSZWdleC5sYXN0SW5kZXggPSAwO1xyXG4gICAgY29uc3QgbWF0Y2ggPSBtYXJrUmVnZXguZXhlYyhsaW5lQ29udGVudCk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBjb2x1bW4gPSBtYXRjaC5pbmRpY2VzWzFdWzBdICsgMTtcclxuICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSBtYXRjaC5pbmRpY2VzWzFdWzFdICsgMTtcclxuICAgICAgICBjb25zdCByYW5nZSA9IHsgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLCBzdGFydENvbHVtbjogY29sdW1uLCBlbmRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLCBlbmRDb2x1bW46IGVuZENvbHVtbiB9O1xyXG4gICAgICAgIGlmIChyYW5nZS5lbmRDb2x1bW4gPiByYW5nZS5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uSGVhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAuLi5nZXRIZWFkZXJUZXh0KG1hdGNoWzFdKSxcclxuICAgICAgICAgICAgICAgIHNob3VsZEJlSW5Db21tZW50czogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoc2VjdGlvbkhlYWRlci50ZXh0IHx8IHNlY3Rpb25IZWFkZXIuaGFzU2VwYXJhdG9yTGluZSkge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbkhlYWRlcnMucHVzaChzZWN0aW9uSGVhZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRIZWFkZXJUZXh0KHRleHQpIHtcclxuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcclxuICAgIGNvbnN0IGhhc1NlcGFyYXRvckxpbmUgPSB0ZXh0LnN0YXJ0c1dpdGgoJy0nKTtcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UodHJpbURhc2hlc1JlZ2V4LCAnJyk7XHJcbiAgICByZXR1cm4geyB0ZXh0LCBoYXNTZXBhcmF0b3JMaW5lIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicodeTextModelHighlighter: () => (/* binding */ UnicodeTextModelHighlighter)\n/* harmony export */ });\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _model_textModelSearch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/textModelSearch.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js\");\n/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/* harmony import */ var _base_common_assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/assert.js */ \"./node_modules/monaco-editor/esm/vs/base/common/assert.js\");\n/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/wordHelper.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\nclass UnicodeTextModelHighlighter {\r\n    static computeUnicodeHighlights(model, options, range) {\r\n        const startLine = range ? range.startLineNumber : 1;\r\n        const endLine = range ? range.endLineNumber : model.getLineCount();\r\n        const codePointHighlighter = new CodePointHighlighter(options);\r\n        const candidates = codePointHighlighter.getCandidateCodePoints();\r\n        let regex;\r\n        if (candidates === 'allNonBasicAscii') {\r\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\r\n        }\r\n        else {\r\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\r\n        }\r\n        const searcher = new _model_textModelSearch_js__WEBPACK_IMPORTED_MODULE_1__.Searcher(null, regex);\r\n        const ranges = [];\r\n        let hasMore = false;\r\n        let m;\r\n        let ambiguousCharacterCount = 0;\r\n        let invisibleCharacterCount = 0;\r\n        let nonBasicAsciiCharacterCount = 0;\r\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\r\n            const lineContent = model.getLineContent(lineNumber);\r\n            const lineLength = lineContent.length;\r\n            // Reset regex to search from the beginning\r\n            searcher.reset(0);\r\n            do {\r\n                m = searcher.next(lineContent);\r\n                if (m) {\r\n                    let startIndex = m.index;\r\n                    let endIndex = m.index + m[0].length;\r\n                    // Extend range to entire code point\r\n                    if (startIndex > 0) {\r\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\r\n                        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isHighSurrogate(charCodeBefore)) {\r\n                            startIndex--;\r\n                        }\r\n                    }\r\n                    if (endIndex + 1 < lineLength) {\r\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\r\n                        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isHighSurrogate(charCodeBefore)) {\r\n                            endIndex++;\r\n                        }\r\n                    }\r\n                    const str = lineContent.substring(startIndex, endIndex);\r\n                    let word = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__.getWordAtText)(startIndex + 1, _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WORD_REGEXP, lineContent, 0);\r\n                    if (word && word.endColumn <= startIndex + 1) {\r\n                        // The word does not include the problematic character, ignore the word\r\n                        word = null;\r\n                    }\r\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\r\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\r\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\r\n                            ambiguousCharacterCount++;\r\n                        }\r\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\r\n                            invisibleCharacterCount++;\r\n                        }\r\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\r\n                            nonBasicAsciiCharacterCount++;\r\n                        }\r\n                        else {\r\n                            (0,_base_common_assert_js__WEBPACK_IMPORTED_MODULE_3__.assertNever)(highlightReason);\r\n                        }\r\n                        const MAX_RESULT_LENGTH = 1000;\r\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\r\n                            hasMore = true;\r\n                            break forLoop;\r\n                        }\r\n                        ranges.push(new _core_range_js__WEBPACK_IMPORTED_MODULE_0__.Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\r\n                    }\r\n                }\r\n            } while (m);\r\n        }\r\n        return {\r\n            ranges,\r\n            hasMore,\r\n            ambiguousCharacterCount,\r\n            invisibleCharacterCount,\r\n            nonBasicAsciiCharacterCount\r\n        };\r\n    }\r\n    static computeUnicodeHighlightReason(char, options) {\r\n        const codePointHighlighter = new CodePointHighlighter(options);\r\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\r\n        switch (reason) {\r\n            case 0 /* SimpleHighlightReason.None */:\r\n                return null;\r\n            case 2 /* SimpleHighlightReason.Invisible */:\r\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\r\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\r\n                const codePoint = char.codePointAt(0);\r\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\r\n                const notAmbiguousInLocales = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getLocales().filter((l) => !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\r\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\r\n            }\r\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\r\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\r\n        }\r\n    }\r\n}\r\nfunction buildRegExpCharClassExpr(codePoints, flags) {\r\n    const src = `[${_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\r\n    return src;\r\n}\r\nclass CodePointHighlighter {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\r\n        this.ambiguousCharacters = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\r\n    }\r\n    getCandidateCodePoints() {\r\n        if (this.options.nonBasicASCII) {\r\n            return 'allNonBasicAscii';\r\n        }\r\n        const set = new Set();\r\n        if (this.options.invisibleCharacters) {\r\n            for (const cp of _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.codePoints) {\r\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\r\n                    set.add(cp);\r\n                }\r\n            }\r\n        }\r\n        if (this.options.ambiguousCharacters) {\r\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\r\n                set.add(cp);\r\n            }\r\n        }\r\n        for (const cp of this.allowedCodePoints) {\r\n            set.delete(cp);\r\n        }\r\n        return set;\r\n    }\r\n    shouldHighlightNonBasicASCII(character, wordContext) {\r\n        const codePoint = character.codePointAt(0);\r\n        if (this.allowedCodePoints.has(codePoint)) {\r\n            return 0 /* SimpleHighlightReason.None */;\r\n        }\r\n        if (this.options.nonBasicASCII) {\r\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\r\n        }\r\n        let hasBasicASCIICharacters = false;\r\n        let hasNonConfusableNonBasicAsciiCharacter = false;\r\n        if (wordContext) {\r\n            for (const char of wordContext) {\r\n                const codePoint = char.codePointAt(0);\r\n                const isBasicASCII = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isBasicASCII(char);\r\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\r\n                if (!isBasicASCII &&\r\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\r\n                    !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\r\n                    hasNonConfusableNonBasicAsciiCharacter = true;\r\n                }\r\n            }\r\n        }\r\n        if (\r\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\r\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\r\n            return 0 /* SimpleHighlightReason.None */;\r\n        }\r\n        if (this.options.invisibleCharacters) {\r\n            // TODO check for emojis\r\n            if (!isAllowedInvisibleCharacter(character) && _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\r\n                return 2 /* SimpleHighlightReason.Invisible */;\r\n            }\r\n        }\r\n        if (this.options.ambiguousCharacters) {\r\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\r\n                return 3 /* SimpleHighlightReason.Ambiguous */;\r\n            }\r\n        }\r\n        return 0 /* SimpleHighlightReason.None */;\r\n    }\r\n}\r\nfunction isAllowedInvisibleCharacter(character) {\r\n    return character === ' ' || character === '\\n' || character === '\\t';\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDYztBQUNJO0FBQ0U7QUFDYztBQUNwRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlEQUFpRDtBQUNuRjtBQUNBLDZCQUE2QiwrREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvRUFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvRUFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0VBQWEsaUJBQWlCLG9FQUFtQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaURBQUs7QUFDN0M7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0VBQTJCLDZCQUE2Qix3RUFBMkI7QUFDakkseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkVBQThCLDBEQUEwRDtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0VBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdFQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpRUFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdFQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdFQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyLmpzPzg1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IFNlYXJjaGVyIH0gZnJvbSAnLi4vbW9kZWwvdGV4dE1vZGVsU2VhcmNoLmpzJztcclxuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcclxuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBERUZBVUxUX1dPUkRfUkVHRVhQLCBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vY29yZS93b3JkSGVscGVyLmpzJztcclxuZXhwb3J0IGNsYXNzIFVuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlciB7XHJcbiAgICBzdGF0aWMgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRzKG1vZGVsLCBvcHRpb25zLCByYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IHJhbmdlID8gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDogMTtcclxuICAgICAgICBjb25zdCBlbmRMaW5lID0gcmFuZ2UgPyByYW5nZS5lbmRMaW5lTnVtYmVyIDogbW9kZWwuZ2V0TGluZUNvdW50KCk7XHJcbiAgICAgICAgY29uc3QgY29kZVBvaW50SGlnaGxpZ2h0ZXIgPSBuZXcgQ29kZVBvaW50SGlnaGxpZ2h0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IGNvZGVQb2ludEhpZ2hsaWdodGVyLmdldENhbmRpZGF0ZUNvZGVQb2ludHMoKTtcclxuICAgICAgICBsZXQgcmVnZXg7XHJcbiAgICAgICAgaWYgKGNhbmRpZGF0ZXMgPT09ICdhbGxOb25CYXNpY0FzY2lpJykge1xyXG4gICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoJ1teXFxcXHRcXFxcblxcXFxyXFxcXHgyMC1cXFxceDdFXScsICdnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYCR7YnVpbGRSZWdFeHBDaGFyQ2xhc3NFeHByKEFycmF5LmZyb20oY2FuZGlkYXRlcykpfWAsICdnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gbmV3IFNlYXJjaGVyKG51bGwsIHJlZ2V4KTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgaGFzTW9yZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBtO1xyXG4gICAgICAgIGxldCBhbWJpZ3VvdXNDaGFyYWN0ZXJDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGludmlzaWJsZUNoYXJhY3RlckNvdW50ID0gMDtcclxuICAgICAgICBsZXQgbm9uQmFzaWNBc2NpaUNoYXJhY3RlckNvdW50ID0gMDtcclxuICAgICAgICBmb3JMb29wOiBmb3IgKGxldCBsaW5lTnVtYmVyID0gc3RhcnRMaW5lLCBsaW5lQ291bnQgPSBlbmRMaW5lOyBsaW5lTnVtYmVyIDw9IGxpbmVDb3VudDsgbGluZU51bWJlcisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lQ29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHJlZ2V4IHRvIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIG0gPSBzZWFyY2hlci5uZXh0KGxpbmVDb250ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBtLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgcmFuZ2UgdG8gZW50aXJlIGNvZGUgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KHN0YXJ0SW5kZXggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlQmVmb3JlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCArIDEgPCBsaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlID0gbGluZUNvbnRlbnQuY2hhckNvZGVBdChlbmRJbmRleCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGVCZWZvcmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ciA9IGxpbmVDb250ZW50LnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBnZXRXb3JkQXRUZXh0KHN0YXJ0SW5kZXggKyAxLCBERUZBVUxUX1dPUkRfUkVHRVhQLCBsaW5lQ29udGVudCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQgJiYgd29yZC5lbmRDb2x1bW4gPD0gc3RhcnRJbmRleCArIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdvcmQgZG9lcyBub3QgaW5jbHVkZSB0aGUgcHJvYmxlbWF0aWMgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodFJlYXNvbiA9IGNvZGVQb2ludEhpZ2hsaWdodGVyLnNob3VsZEhpZ2hsaWdodE5vbkJhc2ljQVNDSUkoc3RyLCB3b3JkID8gd29yZC53b3JkIDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodFJlYXNvbiAhPT0gMCAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uZSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAzIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5BbWJpZ3VvdXMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0NoYXJhY3RlckNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAyIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5JbnZpc2libGUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmlzaWJsZUNoYXJhY3RlckNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25CYXNpY0FzY2lpQ2hhcmFjdGVyQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKGhpZ2hsaWdodFJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTUFYX1JFU1VMVF9MRU5HVEggPSAxMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBNQVhfUkVTVUxUX0xFTkdUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzTW9yZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBmb3JMb29wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShsaW5lTnVtYmVyLCBzdGFydEluZGV4ICsgMSwgbGluZU51bWJlciwgZW5kSW5kZXggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmFuZ2VzLFxyXG4gICAgICAgICAgICBoYXNNb3JlLFxyXG4gICAgICAgICAgICBhbWJpZ3VvdXNDaGFyYWN0ZXJDb3VudCxcclxuICAgICAgICAgICAgaW52aXNpYmxlQ2hhcmFjdGVyQ291bnQsXHJcbiAgICAgICAgICAgIG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRSZWFzb24oY2hhciwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGNvZGVQb2ludEhpZ2hsaWdodGVyID0gbmV3IENvZGVQb2ludEhpZ2hsaWdodGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IGNvZGVQb2ludEhpZ2hsaWdodGVyLnNob3VsZEhpZ2hsaWdodE5vbkJhc2ljQVNDSUkoY2hhciwgbnVsbCk7XHJcbiAgICAgICAgc3dpdGNoIChyZWFzb24pIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25lICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uSW52aXNpYmxlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsga2luZDogMSAvKiBVbmljb2RlSGlnaGxpZ2h0ZXJSZWFzb25LaW5kLkludmlzaWJsZSAqLyB9O1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLkFtYmlndW91cyAqLzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByaW1hcnlDb25mdXNhYmxlID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuYW1iaWd1b3VzQ2hhcmFjdGVycy5nZXRQcmltYXJ5Q29uZnVzYWJsZShjb2RlUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm90QW1iaWd1b3VzSW5Mb2NhbGVzID0gc3RyaW5ncy5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldExvY2FsZXMoKS5maWx0ZXIoKGwpID0+ICFzdHJpbmdzLkFtYmlndW91c0NoYXJhY3RlcnMuZ2V0SW5zdGFuY2UobmV3IFNldChbLi4ub3B0aW9ucy5hbGxvd2VkTG9jYWxlcywgbF0pKS5pc0FtYmlndW91cyhjb2RlUG9pbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDAgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5BbWJpZ3VvdXMgKi8sIGNvbmZ1c2FibGVXaXRoOiBTdHJpbmcuZnJvbUNvZGVQb2ludChwcmltYXJ5Q29uZnVzYWJsZSksIG5vdEFtYmlndW91c0luTG9jYWxlcyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uQmFzaWNBU0NJSSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDIgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5Ob25CYXNpY0FzY2lpICovIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkUmVnRXhwQ2hhckNsYXNzRXhwcihjb2RlUG9pbnRzLCBmbGFncykge1xyXG4gICAgY29uc3Qgc3JjID0gYFske3N0cmluZ3MuZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhjb2RlUG9pbnRzLm1hcCgoaSkgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoaSkpLmpvaW4oJycpKX1dYDtcclxuICAgIHJldHVybiBzcmM7XHJcbn1cclxuY2xhc3MgQ29kZVBvaW50SGlnaGxpZ2h0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5hbGxvd2VkQ29kZVBvaW50cyA9IG5ldyBTZXQob3B0aW9ucy5hbGxvd2VkQ29kZVBvaW50cyk7XHJcbiAgICAgICAgdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzID0gc3RyaW5ncy5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldEluc3RhbmNlKG5ldyBTZXQob3B0aW9ucy5hbGxvd2VkTG9jYWxlcykpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FuZGlkYXRlQ29kZVBvaW50cygpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vbkJhc2ljQVNDSUkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbGxOb25CYXNpY0FzY2lpJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aXNpYmxlQ2hhcmFjdGVycykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNwIG9mIHN0cmluZ3MuSW52aXNpYmxlQ2hhcmFjdGVycy5jb2RlUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihTdHJpbmcuZnJvbUNvZGVQb2ludChjcCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChjcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbWJpZ3VvdXNDaGFyYWN0ZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3Agb2YgdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldENvbmZ1c2FibGVDb2RlUG9pbnRzKCkpIHtcclxuICAgICAgICAgICAgICAgIHNldC5hZGQoY3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY3Agb2YgdGhpcy5hbGxvd2VkQ29kZVBvaW50cykge1xyXG4gICAgICAgICAgICBzZXQuZGVsZXRlKGNwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNldDtcclxuICAgIH1cclxuICAgIHNob3VsZEhpZ2hsaWdodE5vbkJhc2ljQVNDSUkoY2hhcmFjdGVyLCB3b3JkQ29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXJhY3Rlci5jb2RlUG9pbnRBdCgwKTtcclxuICAgICAgICBpZiAodGhpcy5hbGxvd2VkQ29kZVBvaW50cy5oYXMoY29kZVBvaW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uZSAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub25CYXNpY0FTQ0lJKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaGFzQmFzaWNBU0NJSUNoYXJhY3RlcnMgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSBmYWxzZTtcclxuICAgICAgICBpZiAod29yZENvbnRleHQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFyIG9mIHdvcmRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNCYXNpY0FTQ0lJID0gc3RyaW5ncy5pc0Jhc2ljQVNDSUkoY2hhcik7XHJcbiAgICAgICAgICAgICAgICBoYXNCYXNpY0FTQ0lJQ2hhcmFjdGVycyA9IGhhc0Jhc2ljQVNDSUlDaGFyYWN0ZXJzIHx8IGlzQmFzaWNBU0NJSTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNCYXNpY0FTQ0lJICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuYW1iaWd1b3VzQ2hhcmFjdGVycy5pc0FtYmlndW91cyhjb2RlUG9pbnQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXN0cmluZ3MuSW52aXNpYmxlQ2hhcmFjdGVycy5pc0ludmlzaWJsZUNoYXJhY3Rlcihjb2RlUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvKiBEb24ndCBhbGxvdyBtaXhpbmcgd2VpcmQgbG9va2luZyBjaGFyYWN0ZXJzIHdpdGggQVNDSUkgKi8gIWhhc0Jhc2ljQVNDSUlDaGFyYWN0ZXJzICYmXHJcbiAgICAgICAgICAgIC8qIElzIHRoZXJlIGFuIG9idmlvdXNseSB3ZWlyZCBsb29raW5nIGNoYXJhY3Rlcj8gKi8gaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLk5vbmUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aXNpYmxlQ2hhcmFjdGVycykge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIGZvciBlbW9qaXNcclxuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWRJbnZpc2libGVDaGFyYWN0ZXIoY2hhcmFjdGVyKSAmJiBzdHJpbmdzLkludmlzaWJsZUNoYXJhY3RlcnMuaXNJbnZpc2libGVDaGFyYWN0ZXIoY29kZVBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLkludmlzaWJsZSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFtYmlndW91c0NoYXJhY3RlcnMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYW1iaWd1b3VzQ2hhcmFjdGVycy5pc0FtYmlndW91cyhjb2RlUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uQW1iaWd1b3VzICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25lICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihjaGFyYWN0ZXIpIHtcclxuICAgIHJldHVybiBjaGFyYWN0ZXIgPT09ICcgJyB8fCBjaGFyYWN0ZXIgPT09ICdcXG4nIHx8IGNoYXJhY3RlciA9PT0gJ1xcdCc7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessibilitySupport: () => (/* binding */ AccessibilitySupport),\n/* harmony export */   CodeActionTriggerType: () => (/* binding */ CodeActionTriggerType),\n/* harmony export */   CompletionItemInsertTextRule: () => (/* binding */ CompletionItemInsertTextRule),\n/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),\n/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),\n/* harmony export */   CompletionTriggerKind: () => (/* binding */ CompletionTriggerKind),\n/* harmony export */   ContentWidgetPositionPreference: () => (/* binding */ ContentWidgetPositionPreference),\n/* harmony export */   CursorChangeReason: () => (/* binding */ CursorChangeReason),\n/* harmony export */   DefaultEndOfLine: () => (/* binding */ DefaultEndOfLine),\n/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),\n/* harmony export */   EditorAutoIndentStrategy: () => (/* binding */ EditorAutoIndentStrategy),\n/* harmony export */   EditorOption: () => (/* binding */ EditorOption),\n/* harmony export */   EndOfLinePreference: () => (/* binding */ EndOfLinePreference),\n/* harmony export */   EndOfLineSequence: () => (/* binding */ EndOfLineSequence),\n/* harmony export */   GlyphMarginLane: () => (/* binding */ GlyphMarginLane),\n/* harmony export */   HoverVerbosityAction: () => (/* binding */ HoverVerbosityAction),\n/* harmony export */   IndentAction: () => (/* binding */ IndentAction),\n/* harmony export */   InjectedTextCursorStops: () => (/* binding */ InjectedTextCursorStops),\n/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),\n/* harmony export */   InlineCompletionTriggerKind: () => (/* binding */ InlineCompletionTriggerKind),\n/* harmony export */   InlineEditTriggerKind: () => (/* binding */ InlineEditTriggerKind),\n/* harmony export */   KeyCode: () => (/* binding */ KeyCode),\n/* harmony export */   MarkerSeverity: () => (/* binding */ MarkerSeverity),\n/* harmony export */   MarkerTag: () => (/* binding */ MarkerTag),\n/* harmony export */   MinimapPosition: () => (/* binding */ MinimapPosition),\n/* harmony export */   MinimapSectionHeaderStyle: () => (/* binding */ MinimapSectionHeaderStyle),\n/* harmony export */   MouseTargetType: () => (/* binding */ MouseTargetType),\n/* harmony export */   NewSymbolNameTag: () => (/* binding */ NewSymbolNameTag),\n/* harmony export */   NewSymbolNameTriggerKind: () => (/* binding */ NewSymbolNameTriggerKind),\n/* harmony export */   OverlayWidgetPositionPreference: () => (/* binding */ OverlayWidgetPositionPreference),\n/* harmony export */   OverviewRulerLane: () => (/* binding */ OverviewRulerLane),\n/* harmony export */   PartialAcceptTriggerKind: () => (/* binding */ PartialAcceptTriggerKind),\n/* harmony export */   PositionAffinity: () => (/* binding */ PositionAffinity),\n/* harmony export */   RenderLineNumbersType: () => (/* binding */ RenderLineNumbersType),\n/* harmony export */   RenderMinimap: () => (/* binding */ RenderMinimap),\n/* harmony export */   ScrollType: () => (/* binding */ ScrollType),\n/* harmony export */   ScrollbarVisibility: () => (/* binding */ ScrollbarVisibility),\n/* harmony export */   SelectionDirection: () => (/* binding */ SelectionDirection),\n/* harmony export */   ShowLightbulbIconMode: () => (/* binding */ ShowLightbulbIconMode),\n/* harmony export */   SignatureHelpTriggerKind: () => (/* binding */ SignatureHelpTriggerKind),\n/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),\n/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),\n/* harmony export */   TextEditorCursorBlinkingStyle: () => (/* binding */ TextEditorCursorBlinkingStyle),\n/* harmony export */   TextEditorCursorStyle: () => (/* binding */ TextEditorCursorStyle),\n/* harmony export */   TrackedRangeStickiness: () => (/* binding */ TrackedRangeStickiness),\n/* harmony export */   WrappingIndent: () => (/* binding */ WrappingIndent)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.\r\nvar AccessibilitySupport;\r\n(function (AccessibilitySupport) {\r\n    /**\r\n     * This should be the browser case where it is not known if a screen reader is attached or no.\r\n     */\r\n    AccessibilitySupport[AccessibilitySupport[\"Unknown\"] = 0] = \"Unknown\";\r\n    AccessibilitySupport[AccessibilitySupport[\"Disabled\"] = 1] = \"Disabled\";\r\n    AccessibilitySupport[AccessibilitySupport[\"Enabled\"] = 2] = \"Enabled\";\r\n})(AccessibilitySupport || (AccessibilitySupport = {}));\r\nvar CodeActionTriggerType;\r\n(function (CodeActionTriggerType) {\r\n    CodeActionTriggerType[CodeActionTriggerType[\"Invoke\"] = 1] = \"Invoke\";\r\n    CodeActionTriggerType[CodeActionTriggerType[\"Auto\"] = 2] = \"Auto\";\r\n})(CodeActionTriggerType || (CodeActionTriggerType = {}));\r\nvar CompletionItemInsertTextRule;\r\n(function (CompletionItemInsertTextRule) {\r\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Adjust whitespace/indentation of multiline insert texts to\r\n     * match the current line indentation.\r\n     */\r\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\r\n    /**\r\n     * `insertText` is a snippet.\r\n     */\r\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\r\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));\r\nvar CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind[CompletionItemKind[\"Method\"] = 0] = \"Method\";\r\n    CompletionItemKind[CompletionItemKind[\"Function\"] = 1] = \"Function\";\r\n    CompletionItemKind[CompletionItemKind[\"Constructor\"] = 2] = \"Constructor\";\r\n    CompletionItemKind[CompletionItemKind[\"Field\"] = 3] = \"Field\";\r\n    CompletionItemKind[CompletionItemKind[\"Variable\"] = 4] = \"Variable\";\r\n    CompletionItemKind[CompletionItemKind[\"Class\"] = 5] = \"Class\";\r\n    CompletionItemKind[CompletionItemKind[\"Struct\"] = 6] = \"Struct\";\r\n    CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\r\n    CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\r\n    CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\r\n    CompletionItemKind[CompletionItemKind[\"Event\"] = 10] = \"Event\";\r\n    CompletionItemKind[CompletionItemKind[\"Operator\"] = 11] = \"Operator\";\r\n    CompletionItemKind[CompletionItemKind[\"Unit\"] = 12] = \"Unit\";\r\n    CompletionItemKind[CompletionItemKind[\"Value\"] = 13] = \"Value\";\r\n    CompletionItemKind[CompletionItemKind[\"Constant\"] = 14] = \"Constant\";\r\n    CompletionItemKind[CompletionItemKind[\"Enum\"] = 15] = \"Enum\";\r\n    CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 16] = \"EnumMember\";\r\n    CompletionItemKind[CompletionItemKind[\"Keyword\"] = 17] = \"Keyword\";\r\n    CompletionItemKind[CompletionItemKind[\"Text\"] = 18] = \"Text\";\r\n    CompletionItemKind[CompletionItemKind[\"Color\"] = 19] = \"Color\";\r\n    CompletionItemKind[CompletionItemKind[\"File\"] = 20] = \"File\";\r\n    CompletionItemKind[CompletionItemKind[\"Reference\"] = 21] = \"Reference\";\r\n    CompletionItemKind[CompletionItemKind[\"Customcolor\"] = 22] = \"Customcolor\";\r\n    CompletionItemKind[CompletionItemKind[\"Folder\"] = 23] = \"Folder\";\r\n    CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\r\n    CompletionItemKind[CompletionItemKind[\"User\"] = 25] = \"User\";\r\n    CompletionItemKind[CompletionItemKind[\"Issue\"] = 26] = \"Issue\";\r\n    CompletionItemKind[CompletionItemKind[\"Snippet\"] = 27] = \"Snippet\";\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\nvar CompletionItemTag;\r\n(function (CompletionItemTag) {\r\n    CompletionItemTag[CompletionItemTag[\"Deprecated\"] = 1] = \"Deprecated\";\r\n})(CompletionItemTag || (CompletionItemTag = {}));\r\n/**\r\n * How a suggest provider was triggered.\r\n */\r\nvar CompletionTriggerKind;\r\n(function (CompletionTriggerKind) {\r\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\r\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\r\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\r\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\r\n/**\r\n * A positioning preference for rendering content widgets.\r\n */\r\nvar ContentWidgetPositionPreference;\r\n(function (ContentWidgetPositionPreference) {\r\n    /**\r\n     * Place the content widget exactly at a position\r\n     */\r\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"EXACT\"] = 0] = \"EXACT\";\r\n    /**\r\n     * Place the content widget above a position\r\n     */\r\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"ABOVE\"] = 1] = \"ABOVE\";\r\n    /**\r\n     * Place the content widget below a position\r\n     */\r\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"BELOW\"] = 2] = \"BELOW\";\r\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));\r\n/**\r\n * Describes the reason the cursor has changed its position.\r\n */\r\nvar CursorChangeReason;\r\n(function (CursorChangeReason) {\r\n    /**\r\n     * Unknown or not set.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"NotSet\"] = 0] = \"NotSet\";\r\n    /**\r\n     * A `model.setValue()` was called.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"ContentFlush\"] = 1] = \"ContentFlush\";\r\n    /**\r\n     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\r\n    /**\r\n     * There was an explicit user gesture.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Explicit\"] = 3] = \"Explicit\";\r\n    /**\r\n     * There was a Paste.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Paste\"] = 4] = \"Paste\";\r\n    /**\r\n     * There was an Undo.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Undo\"] = 5] = \"Undo\";\r\n    /**\r\n     * There was a Redo.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Redo\"] = 6] = \"Redo\";\r\n})(CursorChangeReason || (CursorChangeReason = {}));\r\n/**\r\n * The default end of line to use when instantiating models.\r\n */\r\nvar DefaultEndOfLine;\r\n(function (DefaultEndOfLine) {\r\n    /**\r\n     * Use line feed (\\n) as the end of line character.\r\n     */\r\n    DefaultEndOfLine[DefaultEndOfLine[\"LF\"] = 1] = \"LF\";\r\n    /**\r\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\r\n     */\r\n    DefaultEndOfLine[DefaultEndOfLine[\"CRLF\"] = 2] = \"CRLF\";\r\n})(DefaultEndOfLine || (DefaultEndOfLine = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nvar DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * Configuration options for auto indentation in the editor\r\n */\r\nvar EditorAutoIndentStrategy;\r\n(function (EditorAutoIndentStrategy) {\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"None\"] = 0] = \"None\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Keep\"] = 1] = \"Keep\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Brackets\"] = 2] = \"Brackets\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Advanced\"] = 3] = \"Advanced\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Full\"] = 4] = \"Full\";\r\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));\r\nvar EditorOption;\r\n(function (EditorOption) {\r\n    EditorOption[EditorOption[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\r\n    EditorOption[EditorOption[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\r\n    EditorOption[EditorOption[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\r\n    EditorOption[EditorOption[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\r\n    EditorOption[EditorOption[\"ariaLabel\"] = 4] = \"ariaLabel\";\r\n    EditorOption[EditorOption[\"ariaRequired\"] = 5] = \"ariaRequired\";\r\n    EditorOption[EditorOption[\"autoClosingBrackets\"] = 6] = \"autoClosingBrackets\";\r\n    EditorOption[EditorOption[\"autoClosingComments\"] = 7] = \"autoClosingComments\";\r\n    EditorOption[EditorOption[\"screenReaderAnnounceInlineSuggestion\"] = 8] = \"screenReaderAnnounceInlineSuggestion\";\r\n    EditorOption[EditorOption[\"autoClosingDelete\"] = 9] = \"autoClosingDelete\";\r\n    EditorOption[EditorOption[\"autoClosingOvertype\"] = 10] = \"autoClosingOvertype\";\r\n    EditorOption[EditorOption[\"autoClosingQuotes\"] = 11] = \"autoClosingQuotes\";\r\n    EditorOption[EditorOption[\"autoIndent\"] = 12] = \"autoIndent\";\r\n    EditorOption[EditorOption[\"automaticLayout\"] = 13] = \"automaticLayout\";\r\n    EditorOption[EditorOption[\"autoSurround\"] = 14] = \"autoSurround\";\r\n    EditorOption[EditorOption[\"bracketPairColorization\"] = 15] = \"bracketPairColorization\";\r\n    EditorOption[EditorOption[\"guides\"] = 16] = \"guides\";\r\n    EditorOption[EditorOption[\"codeLens\"] = 17] = \"codeLens\";\r\n    EditorOption[EditorOption[\"codeLensFontFamily\"] = 18] = \"codeLensFontFamily\";\r\n    EditorOption[EditorOption[\"codeLensFontSize\"] = 19] = \"codeLensFontSize\";\r\n    EditorOption[EditorOption[\"colorDecorators\"] = 20] = \"colorDecorators\";\r\n    EditorOption[EditorOption[\"colorDecoratorsLimit\"] = 21] = \"colorDecoratorsLimit\";\r\n    EditorOption[EditorOption[\"columnSelection\"] = 22] = \"columnSelection\";\r\n    EditorOption[EditorOption[\"comments\"] = 23] = \"comments\";\r\n    EditorOption[EditorOption[\"contextmenu\"] = 24] = \"contextmenu\";\r\n    EditorOption[EditorOption[\"copyWithSyntaxHighlighting\"] = 25] = \"copyWithSyntaxHighlighting\";\r\n    EditorOption[EditorOption[\"cursorBlinking\"] = 26] = \"cursorBlinking\";\r\n    EditorOption[EditorOption[\"cursorSmoothCaretAnimation\"] = 27] = \"cursorSmoothCaretAnimation\";\r\n    EditorOption[EditorOption[\"cursorStyle\"] = 28] = \"cursorStyle\";\r\n    EditorOption[EditorOption[\"cursorSurroundingLines\"] = 29] = \"cursorSurroundingLines\";\r\n    EditorOption[EditorOption[\"cursorSurroundingLinesStyle\"] = 30] = \"cursorSurroundingLinesStyle\";\r\n    EditorOption[EditorOption[\"cursorWidth\"] = 31] = \"cursorWidth\";\r\n    EditorOption[EditorOption[\"disableLayerHinting\"] = 32] = \"disableLayerHinting\";\r\n    EditorOption[EditorOption[\"disableMonospaceOptimizations\"] = 33] = \"disableMonospaceOptimizations\";\r\n    EditorOption[EditorOption[\"domReadOnly\"] = 34] = \"domReadOnly\";\r\n    EditorOption[EditorOption[\"dragAndDrop\"] = 35] = \"dragAndDrop\";\r\n    EditorOption[EditorOption[\"dropIntoEditor\"] = 36] = \"dropIntoEditor\";\r\n    EditorOption[EditorOption[\"emptySelectionClipboard\"] = 37] = \"emptySelectionClipboard\";\r\n    EditorOption[EditorOption[\"experimentalWhitespaceRendering\"] = 38] = \"experimentalWhitespaceRendering\";\r\n    EditorOption[EditorOption[\"extraEditorClassName\"] = 39] = \"extraEditorClassName\";\r\n    EditorOption[EditorOption[\"fastScrollSensitivity\"] = 40] = \"fastScrollSensitivity\";\r\n    EditorOption[EditorOption[\"find\"] = 41] = \"find\";\r\n    EditorOption[EditorOption[\"fixedOverflowWidgets\"] = 42] = \"fixedOverflowWidgets\";\r\n    EditorOption[EditorOption[\"folding\"] = 43] = \"folding\";\r\n    EditorOption[EditorOption[\"foldingStrategy\"] = 44] = \"foldingStrategy\";\r\n    EditorOption[EditorOption[\"foldingHighlight\"] = 45] = \"foldingHighlight\";\r\n    EditorOption[EditorOption[\"foldingImportsByDefault\"] = 46] = \"foldingImportsByDefault\";\r\n    EditorOption[EditorOption[\"foldingMaximumRegions\"] = 47] = \"foldingMaximumRegions\";\r\n    EditorOption[EditorOption[\"unfoldOnClickAfterEndOfLine\"] = 48] = \"unfoldOnClickAfterEndOfLine\";\r\n    EditorOption[EditorOption[\"fontFamily\"] = 49] = \"fontFamily\";\r\n    EditorOption[EditorOption[\"fontInfo\"] = 50] = \"fontInfo\";\r\n    EditorOption[EditorOption[\"fontLigatures\"] = 51] = \"fontLigatures\";\r\n    EditorOption[EditorOption[\"fontSize\"] = 52] = \"fontSize\";\r\n    EditorOption[EditorOption[\"fontWeight\"] = 53] = \"fontWeight\";\r\n    EditorOption[EditorOption[\"fontVariations\"] = 54] = \"fontVariations\";\r\n    EditorOption[EditorOption[\"formatOnPaste\"] = 55] = \"formatOnPaste\";\r\n    EditorOption[EditorOption[\"formatOnType\"] = 56] = \"formatOnType\";\r\n    EditorOption[EditorOption[\"glyphMargin\"] = 57] = \"glyphMargin\";\r\n    EditorOption[EditorOption[\"gotoLocation\"] = 58] = \"gotoLocation\";\r\n    EditorOption[EditorOption[\"hideCursorInOverviewRuler\"] = 59] = \"hideCursorInOverviewRuler\";\r\n    EditorOption[EditorOption[\"hover\"] = 60] = \"hover\";\r\n    EditorOption[EditorOption[\"inDiffEditor\"] = 61] = \"inDiffEditor\";\r\n    EditorOption[EditorOption[\"inlineSuggest\"] = 62] = \"inlineSuggest\";\r\n    EditorOption[EditorOption[\"inlineEdit\"] = 63] = \"inlineEdit\";\r\n    EditorOption[EditorOption[\"letterSpacing\"] = 64] = \"letterSpacing\";\r\n    EditorOption[EditorOption[\"lightbulb\"] = 65] = \"lightbulb\";\r\n    EditorOption[EditorOption[\"lineDecorationsWidth\"] = 66] = \"lineDecorationsWidth\";\r\n    EditorOption[EditorOption[\"lineHeight\"] = 67] = \"lineHeight\";\r\n    EditorOption[EditorOption[\"lineNumbers\"] = 68] = \"lineNumbers\";\r\n    EditorOption[EditorOption[\"lineNumbersMinChars\"] = 69] = \"lineNumbersMinChars\";\r\n    EditorOption[EditorOption[\"linkedEditing\"] = 70] = \"linkedEditing\";\r\n    EditorOption[EditorOption[\"links\"] = 71] = \"links\";\r\n    EditorOption[EditorOption[\"matchBrackets\"] = 72] = \"matchBrackets\";\r\n    EditorOption[EditorOption[\"minimap\"] = 73] = \"minimap\";\r\n    EditorOption[EditorOption[\"mouseStyle\"] = 74] = \"mouseStyle\";\r\n    EditorOption[EditorOption[\"mouseWheelScrollSensitivity\"] = 75] = \"mouseWheelScrollSensitivity\";\r\n    EditorOption[EditorOption[\"mouseWheelZoom\"] = 76] = \"mouseWheelZoom\";\r\n    EditorOption[EditorOption[\"multiCursorMergeOverlapping\"] = 77] = \"multiCursorMergeOverlapping\";\r\n    EditorOption[EditorOption[\"multiCursorModifier\"] = 78] = \"multiCursorModifier\";\r\n    EditorOption[EditorOption[\"multiCursorPaste\"] = 79] = \"multiCursorPaste\";\r\n    EditorOption[EditorOption[\"multiCursorLimit\"] = 80] = \"multiCursorLimit\";\r\n    EditorOption[EditorOption[\"occurrencesHighlight\"] = 81] = \"occurrencesHighlight\";\r\n    EditorOption[EditorOption[\"overviewRulerBorder\"] = 82] = \"overviewRulerBorder\";\r\n    EditorOption[EditorOption[\"overviewRulerLanes\"] = 83] = \"overviewRulerLanes\";\r\n    EditorOption[EditorOption[\"padding\"] = 84] = \"padding\";\r\n    EditorOption[EditorOption[\"pasteAs\"] = 85] = \"pasteAs\";\r\n    EditorOption[EditorOption[\"parameterHints\"] = 86] = \"parameterHints\";\r\n    EditorOption[EditorOption[\"peekWidgetDefaultFocus\"] = 87] = \"peekWidgetDefaultFocus\";\r\n    EditorOption[EditorOption[\"definitionLinkOpensInPeek\"] = 88] = \"definitionLinkOpensInPeek\";\r\n    EditorOption[EditorOption[\"quickSuggestions\"] = 89] = \"quickSuggestions\";\r\n    EditorOption[EditorOption[\"quickSuggestionsDelay\"] = 90] = \"quickSuggestionsDelay\";\r\n    EditorOption[EditorOption[\"readOnly\"] = 91] = \"readOnly\";\r\n    EditorOption[EditorOption[\"readOnlyMessage\"] = 92] = \"readOnlyMessage\";\r\n    EditorOption[EditorOption[\"renameOnType\"] = 93] = \"renameOnType\";\r\n    EditorOption[EditorOption[\"renderControlCharacters\"] = 94] = \"renderControlCharacters\";\r\n    EditorOption[EditorOption[\"renderFinalNewline\"] = 95] = \"renderFinalNewline\";\r\n    EditorOption[EditorOption[\"renderLineHighlight\"] = 96] = \"renderLineHighlight\";\r\n    EditorOption[EditorOption[\"renderLineHighlightOnlyWhenFocus\"] = 97] = \"renderLineHighlightOnlyWhenFocus\";\r\n    EditorOption[EditorOption[\"renderValidationDecorations\"] = 98] = \"renderValidationDecorations\";\r\n    EditorOption[EditorOption[\"renderWhitespace\"] = 99] = \"renderWhitespace\";\r\n    EditorOption[EditorOption[\"revealHorizontalRightPadding\"] = 100] = \"revealHorizontalRightPadding\";\r\n    EditorOption[EditorOption[\"roundedSelection\"] = 101] = \"roundedSelection\";\r\n    EditorOption[EditorOption[\"rulers\"] = 102] = \"rulers\";\r\n    EditorOption[EditorOption[\"scrollbar\"] = 103] = \"scrollbar\";\r\n    EditorOption[EditorOption[\"scrollBeyondLastColumn\"] = 104] = \"scrollBeyondLastColumn\";\r\n    EditorOption[EditorOption[\"scrollBeyondLastLine\"] = 105] = \"scrollBeyondLastLine\";\r\n    EditorOption[EditorOption[\"scrollPredominantAxis\"] = 106] = \"scrollPredominantAxis\";\r\n    EditorOption[EditorOption[\"selectionClipboard\"] = 107] = \"selectionClipboard\";\r\n    EditorOption[EditorOption[\"selectionHighlight\"] = 108] = \"selectionHighlight\";\r\n    EditorOption[EditorOption[\"selectOnLineNumbers\"] = 109] = \"selectOnLineNumbers\";\r\n    EditorOption[EditorOption[\"showFoldingControls\"] = 110] = \"showFoldingControls\";\r\n    EditorOption[EditorOption[\"showUnused\"] = 111] = \"showUnused\";\r\n    EditorOption[EditorOption[\"snippetSuggestions\"] = 112] = \"snippetSuggestions\";\r\n    EditorOption[EditorOption[\"smartSelect\"] = 113] = \"smartSelect\";\r\n    EditorOption[EditorOption[\"smoothScrolling\"] = 114] = \"smoothScrolling\";\r\n    EditorOption[EditorOption[\"stickyScroll\"] = 115] = \"stickyScroll\";\r\n    EditorOption[EditorOption[\"stickyTabStops\"] = 116] = \"stickyTabStops\";\r\n    EditorOption[EditorOption[\"stopRenderingLineAfter\"] = 117] = \"stopRenderingLineAfter\";\r\n    EditorOption[EditorOption[\"suggest\"] = 118] = \"suggest\";\r\n    EditorOption[EditorOption[\"suggestFontSize\"] = 119] = \"suggestFontSize\";\r\n    EditorOption[EditorOption[\"suggestLineHeight\"] = 120] = \"suggestLineHeight\";\r\n    EditorOption[EditorOption[\"suggestOnTriggerCharacters\"] = 121] = \"suggestOnTriggerCharacters\";\r\n    EditorOption[EditorOption[\"suggestSelection\"] = 122] = \"suggestSelection\";\r\n    EditorOption[EditorOption[\"tabCompletion\"] = 123] = \"tabCompletion\";\r\n    EditorOption[EditorOption[\"tabIndex\"] = 124] = \"tabIndex\";\r\n    EditorOption[EditorOption[\"unicodeHighlighting\"] = 125] = \"unicodeHighlighting\";\r\n    EditorOption[EditorOption[\"unusualLineTerminators\"] = 126] = \"unusualLineTerminators\";\r\n    EditorOption[EditorOption[\"useShadowDOM\"] = 127] = \"useShadowDOM\";\r\n    EditorOption[EditorOption[\"useTabStops\"] = 128] = \"useTabStops\";\r\n    EditorOption[EditorOption[\"wordBreak\"] = 129] = \"wordBreak\";\r\n    EditorOption[EditorOption[\"wordSegmenterLocales\"] = 130] = \"wordSegmenterLocales\";\r\n    EditorOption[EditorOption[\"wordSeparators\"] = 131] = \"wordSeparators\";\r\n    EditorOption[EditorOption[\"wordWrap\"] = 132] = \"wordWrap\";\r\n    EditorOption[EditorOption[\"wordWrapBreakAfterCharacters\"] = 133] = \"wordWrapBreakAfterCharacters\";\r\n    EditorOption[EditorOption[\"wordWrapBreakBeforeCharacters\"] = 134] = \"wordWrapBreakBeforeCharacters\";\r\n    EditorOption[EditorOption[\"wordWrapColumn\"] = 135] = \"wordWrapColumn\";\r\n    EditorOption[EditorOption[\"wordWrapOverride1\"] = 136] = \"wordWrapOverride1\";\r\n    EditorOption[EditorOption[\"wordWrapOverride2\"] = 137] = \"wordWrapOverride2\";\r\n    EditorOption[EditorOption[\"wrappingIndent\"] = 138] = \"wrappingIndent\";\r\n    EditorOption[EditorOption[\"wrappingStrategy\"] = 139] = \"wrappingStrategy\";\r\n    EditorOption[EditorOption[\"showDeprecated\"] = 140] = \"showDeprecated\";\r\n    EditorOption[EditorOption[\"inlayHints\"] = 141] = \"inlayHints\";\r\n    EditorOption[EditorOption[\"editorClassName\"] = 142] = \"editorClassName\";\r\n    EditorOption[EditorOption[\"pixelRatio\"] = 143] = \"pixelRatio\";\r\n    EditorOption[EditorOption[\"tabFocusMode\"] = 144] = \"tabFocusMode\";\r\n    EditorOption[EditorOption[\"layoutInfo\"] = 145] = \"layoutInfo\";\r\n    EditorOption[EditorOption[\"wrappingInfo\"] = 146] = \"wrappingInfo\";\r\n    EditorOption[EditorOption[\"defaultColorDecorators\"] = 147] = \"defaultColorDecorators\";\r\n    EditorOption[EditorOption[\"colorDecoratorsActivatedOn\"] = 148] = \"colorDecoratorsActivatedOn\";\r\n    EditorOption[EditorOption[\"inlineCompletionsAccessibilityVerbose\"] = 149] = \"inlineCompletionsAccessibilityVerbose\";\r\n})(EditorOption || (EditorOption = {}));\r\n/**\r\n * End of line character preference.\r\n */\r\nvar EndOfLinePreference;\r\n(function (EndOfLinePreference) {\r\n    /**\r\n     * Use the end of line character identified in the text buffer.\r\n     */\r\n    EndOfLinePreference[EndOfLinePreference[\"TextDefined\"] = 0] = \"TextDefined\";\r\n    /**\r\n     * Use line feed (\\n) as the end of line character.\r\n     */\r\n    EndOfLinePreference[EndOfLinePreference[\"LF\"] = 1] = \"LF\";\r\n    /**\r\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\r\n     */\r\n    EndOfLinePreference[EndOfLinePreference[\"CRLF\"] = 2] = \"CRLF\";\r\n})(EndOfLinePreference || (EndOfLinePreference = {}));\r\n/**\r\n * End of line character preference.\r\n */\r\nvar EndOfLineSequence;\r\n(function (EndOfLineSequence) {\r\n    /**\r\n     * Use line feed (\\n) as the end of line character.\r\n     */\r\n    EndOfLineSequence[EndOfLineSequence[\"LF\"] = 0] = \"LF\";\r\n    /**\r\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\r\n     */\r\n    EndOfLineSequence[EndOfLineSequence[\"CRLF\"] = 1] = \"CRLF\";\r\n})(EndOfLineSequence || (EndOfLineSequence = {}));\r\n/**\r\n * Vertical Lane in the glyph margin of the editor.\r\n */\r\nvar GlyphMarginLane;\r\n(function (GlyphMarginLane) {\r\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\r\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\r\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\r\n})(GlyphMarginLane || (GlyphMarginLane = {}));\r\nvar HoverVerbosityAction;\r\n(function (HoverVerbosityAction) {\r\n    /**\r\n     * Increase the verbosity of the hover\r\n     */\r\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\r\n    /**\r\n     * Decrease the verbosity of the hover\r\n     */\r\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\r\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\r\n/**\r\n * Describes what to do with the indentation when pressing Enter.\r\n */\r\nvar IndentAction;\r\n(function (IndentAction) {\r\n    /**\r\n     * Insert new line and copy the previous line's indentation.\r\n     */\r\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Insert new line and indent once (relative to the previous line's indentation).\r\n     */\r\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\r\n    /**\r\n     * Insert two new lines:\r\n     *  - the first one indented which will hold the cursor\r\n     *  - the second one at the same indentation level\r\n     */\r\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\r\n    /**\r\n     * Insert new line and outdent once (relative to the previous line's indentation).\r\n     */\r\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\r\n})(IndentAction || (IndentAction = {}));\r\nvar InjectedTextCursorStops;\r\n(function (InjectedTextCursorStops) {\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\r\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\r\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\r\nvar InlayHintKind;\r\n(function (InlayHintKind) {\r\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\r\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\r\n})(InlayHintKind || (InlayHintKind = {}));\r\n/**\r\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\r\n */\r\nvar InlineCompletionTriggerKind;\r\n(function (InlineCompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered automatically while editing.\r\n     * It is sufficient to return a single completion item in this case.\r\n     */\r\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\r\n    /**\r\n     * Completion was triggered explicitly by a user gesture.\r\n     * Return multiple completion items to enable cycling through them.\r\n     */\r\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\r\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\r\nvar InlineEditTriggerKind;\r\n(function (InlineEditTriggerKind) {\r\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\r\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\r\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\r\n/**\r\n * Virtual Key Codes, the value does not hold any inherent meaning.\r\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n * But these are \"more general\", as they should work across browsers & OS`s.\r\n */\r\nvar KeyCode;\r\n(function (KeyCode) {\r\n    KeyCode[KeyCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\r\n    /**\r\n     * Placed first to cover the 0 value of the enum.\r\n     */\r\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\r\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\r\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\r\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\r\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\r\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\r\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\r\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\r\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\r\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\r\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\r\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\r\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\r\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\r\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\r\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\r\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\r\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\r\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\r\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\r\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\r\n    KeyCode[KeyCode[\"Digit0\"] = 21] = \"Digit0\";\r\n    KeyCode[KeyCode[\"Digit1\"] = 22] = \"Digit1\";\r\n    KeyCode[KeyCode[\"Digit2\"] = 23] = \"Digit2\";\r\n    KeyCode[KeyCode[\"Digit3\"] = 24] = \"Digit3\";\r\n    KeyCode[KeyCode[\"Digit4\"] = 25] = \"Digit4\";\r\n    KeyCode[KeyCode[\"Digit5\"] = 26] = \"Digit5\";\r\n    KeyCode[KeyCode[\"Digit6\"] = 27] = \"Digit6\";\r\n    KeyCode[KeyCode[\"Digit7\"] = 28] = \"Digit7\";\r\n    KeyCode[KeyCode[\"Digit8\"] = 29] = \"Digit8\";\r\n    KeyCode[KeyCode[\"Digit9\"] = 30] = \"Digit9\";\r\n    KeyCode[KeyCode[\"KeyA\"] = 31] = \"KeyA\";\r\n    KeyCode[KeyCode[\"KeyB\"] = 32] = \"KeyB\";\r\n    KeyCode[KeyCode[\"KeyC\"] = 33] = \"KeyC\";\r\n    KeyCode[KeyCode[\"KeyD\"] = 34] = \"KeyD\";\r\n    KeyCode[KeyCode[\"KeyE\"] = 35] = \"KeyE\";\r\n    KeyCode[KeyCode[\"KeyF\"] = 36] = \"KeyF\";\r\n    KeyCode[KeyCode[\"KeyG\"] = 37] = \"KeyG\";\r\n    KeyCode[KeyCode[\"KeyH\"] = 38] = \"KeyH\";\r\n    KeyCode[KeyCode[\"KeyI\"] = 39] = \"KeyI\";\r\n    KeyCode[KeyCode[\"KeyJ\"] = 40] = \"KeyJ\";\r\n    KeyCode[KeyCode[\"KeyK\"] = 41] = \"KeyK\";\r\n    KeyCode[KeyCode[\"KeyL\"] = 42] = \"KeyL\";\r\n    KeyCode[KeyCode[\"KeyM\"] = 43] = \"KeyM\";\r\n    KeyCode[KeyCode[\"KeyN\"] = 44] = \"KeyN\";\r\n    KeyCode[KeyCode[\"KeyO\"] = 45] = \"KeyO\";\r\n    KeyCode[KeyCode[\"KeyP\"] = 46] = \"KeyP\";\r\n    KeyCode[KeyCode[\"KeyQ\"] = 47] = \"KeyQ\";\r\n    KeyCode[KeyCode[\"KeyR\"] = 48] = \"KeyR\";\r\n    KeyCode[KeyCode[\"KeyS\"] = 49] = \"KeyS\";\r\n    KeyCode[KeyCode[\"KeyT\"] = 50] = \"KeyT\";\r\n    KeyCode[KeyCode[\"KeyU\"] = 51] = \"KeyU\";\r\n    KeyCode[KeyCode[\"KeyV\"] = 52] = \"KeyV\";\r\n    KeyCode[KeyCode[\"KeyW\"] = 53] = \"KeyW\";\r\n    KeyCode[KeyCode[\"KeyX\"] = 54] = \"KeyX\";\r\n    KeyCode[KeyCode[\"KeyY\"] = 55] = \"KeyY\";\r\n    KeyCode[KeyCode[\"KeyZ\"] = 56] = \"KeyZ\";\r\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\r\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\r\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\r\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\r\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\r\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\r\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\r\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\r\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\r\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\r\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\r\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\r\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\r\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\r\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\r\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\r\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\r\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\r\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\r\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\r\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\r\n    KeyCode[KeyCode[\"F20\"] = 78] = \"F20\";\r\n    KeyCode[KeyCode[\"F21\"] = 79] = \"F21\";\r\n    KeyCode[KeyCode[\"F22\"] = 80] = \"F22\";\r\n    KeyCode[KeyCode[\"F23\"] = 81] = \"F23\";\r\n    KeyCode[KeyCode[\"F24\"] = 82] = \"F24\";\r\n    KeyCode[KeyCode[\"NumLock\"] = 83] = \"NumLock\";\r\n    KeyCode[KeyCode[\"ScrollLock\"] = 84] = \"ScrollLock\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the ';:' key\r\n     */\r\n    KeyCode[KeyCode[\"Semicolon\"] = 85] = \"Semicolon\";\r\n    /**\r\n     * For any country/region, the '+' key\r\n     * For the US standard keyboard, the '=+' key\r\n     */\r\n    KeyCode[KeyCode[\"Equal\"] = 86] = \"Equal\";\r\n    /**\r\n     * For any country/region, the ',' key\r\n     * For the US standard keyboard, the ',<' key\r\n     */\r\n    KeyCode[KeyCode[\"Comma\"] = 87] = \"Comma\";\r\n    /**\r\n     * For any country/region, the '-' key\r\n     * For the US standard keyboard, the '-_' key\r\n     */\r\n    KeyCode[KeyCode[\"Minus\"] = 88] = \"Minus\";\r\n    /**\r\n     * For any country/region, the '.' key\r\n     * For the US standard keyboard, the '.>' key\r\n     */\r\n    KeyCode[KeyCode[\"Period\"] = 89] = \"Period\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '/?' key\r\n     */\r\n    KeyCode[KeyCode[\"Slash\"] = 90] = \"Slash\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '`~' key\r\n     */\r\n    KeyCode[KeyCode[\"Backquote\"] = 91] = \"Backquote\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '[{' key\r\n     */\r\n    KeyCode[KeyCode[\"BracketLeft\"] = 92] = \"BracketLeft\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '\\|' key\r\n     */\r\n    KeyCode[KeyCode[\"Backslash\"] = 93] = \"Backslash\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the ']}' key\r\n     */\r\n    KeyCode[KeyCode[\"BracketRight\"] = 94] = \"BracketRight\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the ''\"' key\r\n     */\r\n    KeyCode[KeyCode[\"Quote\"] = 95] = \"Quote\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     */\r\n    KeyCode[KeyCode[\"OEM_8\"] = 96] = \"OEM_8\";\r\n    /**\r\n     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\r\n     */\r\n    KeyCode[KeyCode[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\r\n    KeyCode[KeyCode[\"Numpad0\"] = 98] = \"Numpad0\";\r\n    KeyCode[KeyCode[\"Numpad1\"] = 99] = \"Numpad1\";\r\n    KeyCode[KeyCode[\"Numpad2\"] = 100] = \"Numpad2\";\r\n    KeyCode[KeyCode[\"Numpad3\"] = 101] = \"Numpad3\";\r\n    KeyCode[KeyCode[\"Numpad4\"] = 102] = \"Numpad4\";\r\n    KeyCode[KeyCode[\"Numpad5\"] = 103] = \"Numpad5\";\r\n    KeyCode[KeyCode[\"Numpad6\"] = 104] = \"Numpad6\";\r\n    KeyCode[KeyCode[\"Numpad7\"] = 105] = \"Numpad7\";\r\n    KeyCode[KeyCode[\"Numpad8\"] = 106] = \"Numpad8\";\r\n    KeyCode[KeyCode[\"Numpad9\"] = 107] = \"Numpad9\";\r\n    KeyCode[KeyCode[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\r\n    KeyCode[KeyCode[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\r\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\r\n    KeyCode[KeyCode[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\r\n    KeyCode[KeyCode[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\r\n    KeyCode[KeyCode[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\r\n    /**\r\n     * Cover all key codes when IME is processing input.\r\n     */\r\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\r\n    KeyCode[KeyCode[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\r\n    KeyCode[KeyCode[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\r\n    KeyCode[KeyCode[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\r\n    KeyCode[KeyCode[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\r\n    KeyCode[KeyCode[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\r\n    KeyCode[KeyCode[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\r\n    KeyCode[KeyCode[\"BrowserHome\"] = 121] = \"BrowserHome\";\r\n    KeyCode[KeyCode[\"BrowserBack\"] = 122] = \"BrowserBack\";\r\n    KeyCode[KeyCode[\"BrowserForward\"] = 123] = \"BrowserForward\";\r\n    KeyCode[KeyCode[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\r\n    KeyCode[KeyCode[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\r\n    KeyCode[KeyCode[\"MediaStop\"] = 126] = \"MediaStop\";\r\n    KeyCode[KeyCode[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\r\n    KeyCode[KeyCode[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\r\n    KeyCode[KeyCode[\"LaunchMail\"] = 129] = \"LaunchMail\";\r\n    KeyCode[KeyCode[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\r\n    /**\r\n     * VK_CLEAR, 0x0C, CLEAR key\r\n     */\r\n    KeyCode[KeyCode[\"Clear\"] = 131] = \"Clear\";\r\n    /**\r\n     * Placed last to cover the length of the enum.\r\n     * Please do not depend on this value!\r\n     */\r\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\r\n})(KeyCode || (KeyCode = {}));\r\nvar MarkerSeverity;\r\n(function (MarkerSeverity) {\r\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\r\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\r\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\r\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\r\n})(MarkerSeverity || (MarkerSeverity = {}));\r\nvar MarkerTag;\r\n(function (MarkerTag) {\r\n    MarkerTag[MarkerTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\r\n    MarkerTag[MarkerTag[\"Deprecated\"] = 2] = \"Deprecated\";\r\n})(MarkerTag || (MarkerTag = {}));\r\n/**\r\n * Position in the minimap to render the decoration.\r\n */\r\nvar MinimapPosition;\r\n(function (MinimapPosition) {\r\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\r\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\r\n})(MinimapPosition || (MinimapPosition = {}));\r\n/**\r\n * Section header style.\r\n */\r\nvar MinimapSectionHeaderStyle;\r\n(function (MinimapSectionHeaderStyle) {\r\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Normal\"] = 1] = \"Normal\";\r\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Underlined\"] = 2] = \"Underlined\";\r\n})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));\r\n/**\r\n * Type of hit element with the mouse in the editor.\r\n */\r\nvar MouseTargetType;\r\n(function (MouseTargetType) {\r\n    /**\r\n     * Mouse is on top of an unknown element.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\r\n    /**\r\n     * Mouse is on top of the textarea used for input.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\r\n    /**\r\n     * Mouse is on top of the glyph margin\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\r\n    /**\r\n     * Mouse is on top of the line numbers\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\r\n    /**\r\n     * Mouse is on top of the line decorations\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\r\n    /**\r\n     * Mouse is on top of the whitespace left in the gutter by a view zone.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\r\n    /**\r\n     * Mouse is on top of text in the content.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\r\n    /**\r\n     * Mouse is on top of empty space in the content (e.g. after line text or below last line)\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\r\n    /**\r\n     * Mouse is on top of a view zone in the content.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\r\n    /**\r\n     * Mouse is on top of a content widget.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\r\n    /**\r\n     * Mouse is on top of the decorations overview ruler.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\r\n    /**\r\n     * Mouse is on top of a scrollbar.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\r\n    /**\r\n     * Mouse is on top of an overlay widget.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\r\n    /**\r\n     * Mouse is outside of the editor.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\r\n})(MouseTargetType || (MouseTargetType = {}));\r\nvar NewSymbolNameTag;\r\n(function (NewSymbolNameTag) {\r\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\r\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\r\nvar NewSymbolNameTriggerKind;\r\n(function (NewSymbolNameTriggerKind) {\r\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\r\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\r\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\r\n/**\r\n * A positioning preference for rendering overlay widgets.\r\n */\r\nvar OverlayWidgetPositionPreference;\r\n(function (OverlayWidgetPositionPreference) {\r\n    /**\r\n     * Position the overlay widget in the top right corner\r\n     */\r\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\r\n    /**\r\n     * Position the overlay widget in the bottom right corner\r\n     */\r\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\r\n    /**\r\n     * Position the overlay widget in the top center\r\n     */\r\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\r\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));\r\n/**\r\n * Vertical Lane in the overview ruler of the editor.\r\n */\r\nvar OverviewRulerLane;\r\n(function (OverviewRulerLane) {\r\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\r\n})(OverviewRulerLane || (OverviewRulerLane = {}));\r\n/**\r\n * How a partial acceptance was triggered.\r\n */\r\nvar PartialAcceptTriggerKind;\r\n(function (PartialAcceptTriggerKind) {\r\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Word\"] = 0] = \"Word\";\r\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Line\"] = 1] = \"Line\";\r\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Suggest\"] = 2] = \"Suggest\";\r\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));\r\nvar PositionAffinity;\r\n(function (PositionAffinity) {\r\n    /**\r\n     * Prefers the left most position.\r\n    */\r\n    PositionAffinity[PositionAffinity[\"Left\"] = 0] = \"Left\";\r\n    /**\r\n     * Prefers the right most position.\r\n    */\r\n    PositionAffinity[PositionAffinity[\"Right\"] = 1] = \"Right\";\r\n    /**\r\n     * No preference.\r\n    */\r\n    PositionAffinity[PositionAffinity[\"None\"] = 2] = \"None\";\r\n    /**\r\n     * If the given position is on injected text, prefers the position left of it.\r\n    */\r\n    PositionAffinity[PositionAffinity[\"LeftOfInjectedText\"] = 3] = \"LeftOfInjectedText\";\r\n    /**\r\n     * If the given position is on injected text, prefers the position right of it.\r\n    */\r\n    PositionAffinity[PositionAffinity[\"RightOfInjectedText\"] = 4] = \"RightOfInjectedText\";\r\n})(PositionAffinity || (PositionAffinity = {}));\r\nvar RenderLineNumbersType;\r\n(function (RenderLineNumbersType) {\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Off\"] = 0] = \"Off\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"On\"] = 1] = \"On\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Relative\"] = 2] = \"Relative\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Interval\"] = 3] = \"Interval\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Custom\"] = 4] = \"Custom\";\r\n})(RenderLineNumbersType || (RenderLineNumbersType = {}));\r\nvar RenderMinimap;\r\n(function (RenderMinimap) {\r\n    RenderMinimap[RenderMinimap[\"None\"] = 0] = \"None\";\r\n    RenderMinimap[RenderMinimap[\"Text\"] = 1] = \"Text\";\r\n    RenderMinimap[RenderMinimap[\"Blocks\"] = 2] = \"Blocks\";\r\n})(RenderMinimap || (RenderMinimap = {}));\r\nvar ScrollType;\r\n(function (ScrollType) {\r\n    ScrollType[ScrollType[\"Smooth\"] = 0] = \"Smooth\";\r\n    ScrollType[ScrollType[\"Immediate\"] = 1] = \"Immediate\";\r\n})(ScrollType || (ScrollType = {}));\r\nvar ScrollbarVisibility;\r\n(function (ScrollbarVisibility) {\r\n    ScrollbarVisibility[ScrollbarVisibility[\"Auto\"] = 1] = \"Auto\";\r\n    ScrollbarVisibility[ScrollbarVisibility[\"Hidden\"] = 2] = \"Hidden\";\r\n    ScrollbarVisibility[ScrollbarVisibility[\"Visible\"] = 3] = \"Visible\";\r\n})(ScrollbarVisibility || (ScrollbarVisibility = {}));\r\n/**\r\n * The direction of a selection.\r\n */\r\nvar SelectionDirection;\r\n(function (SelectionDirection) {\r\n    /**\r\n     * The selection starts above where it ends.\r\n     */\r\n    SelectionDirection[SelectionDirection[\"LTR\"] = 0] = \"LTR\";\r\n    /**\r\n     * The selection starts below where it ends.\r\n     */\r\n    SelectionDirection[SelectionDirection[\"RTL\"] = 1] = \"RTL\";\r\n})(SelectionDirection || (SelectionDirection = {}));\r\nvar ShowLightbulbIconMode;\r\n(function (ShowLightbulbIconMode) {\r\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\r\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\r\n    ShowLightbulbIconMode[\"On\"] = \"on\";\r\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));\r\nvar SignatureHelpTriggerKind;\r\n(function (SignatureHelpTriggerKind) {\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\r\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nvar SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\r\n    SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\r\n    SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\r\n    SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\r\n    SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\r\n    SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\r\n    SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\r\n    SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\r\n    SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\r\n    SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\r\n    SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\r\n    SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\r\n    SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\r\n    SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\r\n    SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\r\n    SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\r\n    SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\r\n    SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\r\n    SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\r\n    SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\r\n    SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\r\n    SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\r\n    SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\r\n    SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\r\n    SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\r\n    SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\r\n})(SymbolKind || (SymbolKind = {}));\r\nvar SymbolTag;\r\n(function (SymbolTag) {\r\n    SymbolTag[SymbolTag[\"Deprecated\"] = 1] = \"Deprecated\";\r\n})(SymbolTag || (SymbolTag = {}));\r\n/**\r\n * The kind of animation in which the editor's cursor should be rendered.\r\n */\r\nvar TextEditorCursorBlinkingStyle;\r\n(function (TextEditorCursorBlinkingStyle) {\r\n    /**\r\n     * Hidden\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Hidden\"] = 0] = \"Hidden\";\r\n    /**\r\n     * Blinking\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Blink\"] = 1] = \"Blink\";\r\n    /**\r\n     * Blinking with smooth fading\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Smooth\"] = 2] = \"Smooth\";\r\n    /**\r\n     * Blinking with prolonged filled state and smooth fading\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Phase\"] = 3] = \"Phase\";\r\n    /**\r\n     * Expand collapse animation on the y axis\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Expand\"] = 4] = \"Expand\";\r\n    /**\r\n     * No-Blinking\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Solid\"] = 5] = \"Solid\";\r\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));\r\n/**\r\n * The style in which the editor's cursor should be rendered.\r\n */\r\nvar TextEditorCursorStyle;\r\n(function (TextEditorCursorStyle) {\r\n    /**\r\n     * As a vertical line (sitting between two characters).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\r\n    /**\r\n     * As a block (sitting on top of a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\r\n    /**\r\n     * As a horizontal line (sitting under a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\r\n    /**\r\n     * As a thin vertical line (sitting between two characters).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\r\n    /**\r\n     * As an outlined block (sitting on top of a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\r\n    /**\r\n     * As a thin horizontal line (sitting under a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\r\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\r\n/**\r\n * Describes the behavior of decorations when typing/editing near their edges.\r\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\r\n */\r\nvar TrackedRangeStickiness;\r\n(function (TrackedRangeStickiness) {\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\r\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));\r\n/**\r\n * Describes how to indent wrapped lines.\r\n */\r\nvar WrappingIndent;\r\n(function (WrappingIndent) {\r\n    /**\r\n     * No indentation => wrapped lines begin at column 1.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Same => wrapped lines get the same indentation as the parent.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"Same\"] = 1] = \"Same\";\r\n    /**\r\n     * Indent => wrapped lines get +1 indentation toward the parent.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"Indent\"] = 2] = \"Indent\";\r\n    /**\r\n     * DeepIndent => wrapped lines get +2 indentation toward the parent.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"DeepIndent\"] = 3] = \"DeepIndent\";\r\n})(WrappingIndent || (WrappingIndent = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zdGFuZGFsb25lL3N0YW5kYWxvbmVFbnVtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0VBQW9FO0FBQzlEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQzFDO0FBQ1A7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwRUFBMEU7QUFDM0U7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQ3BDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBEO0FBQ3BEO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQSxXQUFXLDREQUE0RDtBQUN2RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0VBQWtFO0FBQzVEO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQ3BCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsOERBQThEO0FBQy9EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDcEM7QUFDUDtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwRUFBMEU7QUFDM0U7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3REO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUNoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDaEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQzdEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDMUI7QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0VBQXNFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc3RhbmRhbG9uZS9zdGFuZGFsb25lRW51bXMuanM/Njg4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gVEhJUyBJUyBBIEdFTkVSQVRFRCBGSUxFLiBETyBOT1QgRURJVCBESVJFQ1RMWS5cclxuZXhwb3J0IHZhciBBY2Nlc3NpYmlsaXR5U3VwcG9ydDtcclxuKGZ1bmN0aW9uIChBY2Nlc3NpYmlsaXR5U3VwcG9ydCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB0aGUgYnJvd3NlciBjYXNlIHdoZXJlIGl0IGlzIG5vdCBrbm93biBpZiBhIHNjcmVlbiByZWFkZXIgaXMgYXR0YWNoZWQgb3Igbm8uXHJcbiAgICAgKi9cclxuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiVW5rbm93blwiXSA9IDBdID0gXCJVbmtub3duXCI7XHJcbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIkRpc2FibGVkXCJdID0gMV0gPSBcIkRpc2FibGVkXCI7XHJcbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIkVuYWJsZWRcIl0gPSAyXSA9IFwiRW5hYmxlZFwiO1xyXG59KShBY2Nlc3NpYmlsaXR5U3VwcG9ydCB8fCAoQWNjZXNzaWJpbGl0eVN1cHBvcnQgPSB7fSkpO1xyXG5leHBvcnQgdmFyIENvZGVBY3Rpb25UcmlnZ2VyVHlwZTtcclxuKGZ1bmN0aW9uIChDb2RlQWN0aW9uVHJpZ2dlclR5cGUpIHtcclxuICAgIENvZGVBY3Rpb25UcmlnZ2VyVHlwZVtDb2RlQWN0aW9uVHJpZ2dlclR5cGVbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XHJcbiAgICBDb2RlQWN0aW9uVHJpZ2dlclR5cGVbQ29kZUFjdGlvblRyaWdnZXJUeXBlW1wiQXV0b1wiXSA9IDJdID0gXCJBdXRvXCI7XHJcbn0pKENvZGVBY3Rpb25UcmlnZ2VyVHlwZSB8fCAoQ29kZUFjdGlvblRyaWdnZXJUeXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGUpIHtcclxuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3Qgd2hpdGVzcGFjZS9pbmRlbnRhdGlvbiBvZiBtdWx0aWxpbmUgaW5zZXJ0IHRleHRzIHRvXHJcbiAgICAgKiBtYXRjaCB0aGUgY3VycmVudCBsaW5lIGluZGVudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW0NvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbXCJLZWVwV2hpdGVzcGFjZVwiXSA9IDFdID0gXCJLZWVwV2hpdGVzcGFjZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgaW5zZXJ0VGV4dGAgaXMgYSBzbmlwcGV0LlxyXG4gICAgICovXHJcbiAgICBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW0NvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbXCJJbnNlcnRBc1NuaXBwZXRcIl0gPSA0XSA9IFwiSW5zZXJ0QXNTbmlwcGV0XCI7XHJcbn0pKENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGUgfHwgKENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtS2luZDtcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJNZXRob2RcIl0gPSAwXSA9IFwiTWV0aG9kXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRnVuY3Rpb25cIl0gPSAxXSA9IFwiRnVuY3Rpb25cIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDb25zdHJ1Y3RvclwiXSA9IDJdID0gXCJDb25zdHJ1Y3RvclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkZpZWxkXCJdID0gM10gPSBcIkZpZWxkXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVmFyaWFibGVcIl0gPSA0XSA9IFwiVmFyaWFibGVcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDbGFzc1wiXSA9IDVdID0gXCJDbGFzc1wiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlN0cnVjdFwiXSA9IDZdID0gXCJTdHJ1Y3RcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJJbnRlcmZhY2VcIl0gPSA3XSA9IFwiSW50ZXJmYWNlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiTW9kdWxlXCJdID0gOF0gPSBcIk1vZHVsZVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlByb3BlcnR5XCJdID0gOV0gPSBcIlByb3BlcnR5XCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRXZlbnRcIl0gPSAxMF0gPSBcIkV2ZW50XCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiT3BlcmF0b3JcIl0gPSAxMV0gPSBcIk9wZXJhdG9yXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVW5pdFwiXSA9IDEyXSA9IFwiVW5pdFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlZhbHVlXCJdID0gMTNdID0gXCJWYWx1ZVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbnN0YW50XCJdID0gMTRdID0gXCJDb25zdGFudFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkVudW1cIl0gPSAxNV0gPSBcIkVudW1cIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFbnVtTWVtYmVyXCJdID0gMTZdID0gXCJFbnVtTWVtYmVyXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiS2V5d29yZFwiXSA9IDE3XSA9IFwiS2V5d29yZFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlRleHRcIl0gPSAxOF0gPSBcIlRleHRcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDb2xvclwiXSA9IDE5XSA9IFwiQ29sb3JcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGaWxlXCJdID0gMjBdID0gXCJGaWxlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiUmVmZXJlbmNlXCJdID0gMjFdID0gXCJSZWZlcmVuY2VcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDdXN0b21jb2xvclwiXSA9IDIyXSA9IFwiQ3VzdG9tY29sb3JcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGb2xkZXJcIl0gPSAyM10gPSBcIkZvbGRlclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlR5cGVQYXJhbWV0ZXJcIl0gPSAyNF0gPSBcIlR5cGVQYXJhbWV0ZXJcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJVc2VyXCJdID0gMjVdID0gXCJVc2VyXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiSXNzdWVcIl0gPSAyNl0gPSBcIklzc3VlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiU25pcHBldFwiXSA9IDI3XSA9IFwiU25pcHBldFwiO1xyXG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1UYWc7XHJcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcclxuICAgIENvbXBsZXRpb25JdGVtVGFnW0NvbXBsZXRpb25JdGVtVGFnW1wiRGVwcmVjYXRlZFwiXSA9IDFdID0gXCJEZXByZWNhdGVkXCI7XHJcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBIb3cgYSBzdWdnZXN0IHByb3ZpZGVyIHdhcyB0cmlnZ2VyZWQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcclxuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAwXSA9IFwiSW52b2tlXCI7XHJcbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmRbQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiVHJpZ2dlckNoYXJhY3RlclwiXSA9IDFdID0gXCJUcmlnZ2VyQ2hhcmFjdGVyXCI7XHJcbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmRbQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9uc1wiXSA9IDJdID0gXCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zXCI7XHJcbn0pKENvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIEEgcG9zaXRpb25pbmcgcHJlZmVyZW5jZSBmb3IgcmVuZGVyaW5nIGNvbnRlbnQgd2lkZ2V0cy5cclxuICovXHJcbmV4cG9ydCB2YXIgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZTtcclxuKGZ1bmN0aW9uIChDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFBsYWNlIHRoZSBjb250ZW50IHdpZGdldCBleGFjdGx5IGF0IGEgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiRVhBQ1RcIl0gPSAwXSA9IFwiRVhBQ1RcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGFib3ZlIGEgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiQUJPVkVcIl0gPSAxXSA9IFwiQUJPVkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGJlbG93IGEgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiQkVMT1dcIl0gPSAyXSA9IFwiQkVMT1dcIjtcclxufSkoQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSB8fCAoQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgdGhlIHJlYXNvbiB0aGUgY3Vyc29yIGhhcyBjaGFuZ2VkIGl0cyBwb3NpdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgQ3Vyc29yQ2hhbmdlUmVhc29uO1xyXG4oZnVuY3Rpb24gKEN1cnNvckNoYW5nZVJlYXNvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmtub3duIG9yIG5vdCBzZXQuXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJOb3RTZXRcIl0gPSAwXSA9IFwiTm90U2V0XCI7XHJcbiAgICAvKipcclxuICAgICAqIEEgYG1vZGVsLnNldFZhbHVlKClgIHdhcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJDb250ZW50Rmx1c2hcIl0gPSAxXSA9IFwiQ29udGVudEZsdXNoXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgbW9kZWxgIGhhcyBiZWVuIGNoYW5nZWQgb3V0c2lkZSBvZiB0aGlzIGN1cnNvciBhbmQgdGhlIGN1cnNvciByZWNvdmVycyBpdHMgcG9zaXRpb24gZnJvbSBhc3NvY2lhdGVkIG1hcmtlcnMuXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJSZWNvdmVyRnJvbU1hcmtlcnNcIl0gPSAyXSA9IFwiUmVjb3ZlckZyb21NYXJrZXJzXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIHdhcyBhbiBleHBsaWNpdCB1c2VyIGdlc3R1cmUuXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJFeHBsaWNpdFwiXSA9IDNdID0gXCJFeHBsaWNpdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGVyZSB3YXMgYSBQYXN0ZS5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlBhc3RlXCJdID0gNF0gPSBcIlBhc3RlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIHdhcyBhbiBVbmRvLlxyXG4gICAgICovXHJcbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiVW5kb1wiXSA9IDVdID0gXCJVbmRvXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIHdhcyBhIFJlZG8uXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJSZWRvXCJdID0gNl0gPSBcIlJlZG9cIjtcclxufSkoQ3Vyc29yQ2hhbmdlUmVhc29uIHx8IChDdXJzb3JDaGFuZ2VSZWFzb24gPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgZW5kIG9mIGxpbmUgdG8gdXNlIHdoZW4gaW5zdGFudGlhdGluZyBtb2RlbHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIERlZmF1bHRFbmRPZkxpbmU7XHJcbihmdW5jdGlvbiAoRGVmYXVsdEVuZE9mTGluZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgbGluZSBmZWVkIChcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRFbmRPZkxpbmVbRGVmYXVsdEVuZE9mTGluZVtcIkxGXCJdID0gMV0gPSBcIkxGXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0RW5kT2ZMaW5lW0RlZmF1bHRFbmRPZkxpbmVbXCJDUkxGXCJdID0gMl0gPSBcIkNSTEZcIjtcclxufSkoRGVmYXVsdEVuZE9mTGluZSB8fCAoRGVmYXVsdEVuZE9mTGluZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxyXG4gKi9cclxuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XHJcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIEEgdGV4dHVhbCBvY2N1cnJlbmNlLlxyXG4gICAgICovXHJcbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cclxuICAgICAqL1xyXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIlJlYWRcIl0gPSAxXSA9IFwiUmVhZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxyXG4gICAgICovXHJcbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiV3JpdGVcIl0gPSAyXSA9IFwiV3JpdGVcIjtcclxufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xyXG4vKipcclxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhdXRvIGluZGVudGF0aW9uIGluIHRoZSBlZGl0b3JcclxuICovXHJcbmV4cG9ydCB2YXIgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5O1xyXG4oZnVuY3Rpb24gKEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneSkge1xyXG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIktlZXBcIl0gPSAxXSA9IFwiS2VlcFwiO1xyXG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIkJyYWNrZXRzXCJdID0gMl0gPSBcIkJyYWNrZXRzXCI7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQWR2YW5jZWRcIl0gPSAzXSA9IFwiQWR2YW5jZWRcIjtcclxuICAgIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbXCJGdWxsXCJdID0gNF0gPSBcIkZ1bGxcIjtcclxufSkoRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5IHx8IChFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kgPSB7fSkpO1xyXG5leHBvcnQgdmFyIEVkaXRvck9wdGlvbjtcclxuKGZ1bmN0aW9uIChFZGl0b3JPcHRpb24pIHtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhY2NlcHRTdWdnZXN0aW9uT25Db21taXRDaGFyYWN0ZXJcIl0gPSAwXSA9IFwiYWNjZXB0U3VnZ2VzdGlvbk9uQ29tbWl0Q2hhcmFjdGVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXB0U3VnZ2VzdGlvbk9uRW50ZXJcIl0gPSAxXSA9IFwiYWNjZXB0U3VnZ2VzdGlvbk9uRW50ZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhY2Nlc3NpYmlsaXR5U3VwcG9ydFwiXSA9IDJdID0gXCJhY2Nlc3NpYmlsaXR5U3VwcG9ydFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2Vzc2liaWxpdHlQYWdlU2l6ZVwiXSA9IDNdID0gXCJhY2Nlc3NpYmlsaXR5UGFnZVNpemVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhcmlhTGFiZWxcIl0gPSA0XSA9IFwiYXJpYUxhYmVsXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXJpYVJlcXVpcmVkXCJdID0gNV0gPSBcImFyaWFSZXF1aXJlZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nQnJhY2tldHNcIl0gPSA2XSA9IFwiYXV0b0Nsb3NpbmdCcmFja2V0c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nQ29tbWVudHNcIl0gPSA3XSA9IFwiYXV0b0Nsb3NpbmdDb21tZW50c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcmVlblJlYWRlckFubm91bmNlSW5saW5lU3VnZ2VzdGlvblwiXSA9IDhdID0gXCJzY3JlZW5SZWFkZXJBbm5vdW5jZUlubGluZVN1Z2dlc3Rpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiXSA9IDldID0gXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIl0gPSAxMF0gPSBcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ1F1b3Rlc1wiXSA9IDExXSA9IFwiYXV0b0Nsb3NpbmdRdW90ZXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvSW5kZW50XCJdID0gMTJdID0gXCJhdXRvSW5kZW50XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b21hdGljTGF5b3V0XCJdID0gMTNdID0gXCJhdXRvbWF0aWNMYXlvdXRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvU3Vycm91bmRcIl0gPSAxNF0gPSBcImF1dG9TdXJyb3VuZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImJyYWNrZXRQYWlyQ29sb3JpemF0aW9uXCJdID0gMTVdID0gXCJicmFja2V0UGFpckNvbG9yaXphdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImd1aWRlc1wiXSA9IDE2XSA9IFwiZ3VpZGVzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNcIl0gPSAxN10gPSBcImNvZGVMZW5zXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNGb250RmFtaWx5XCJdID0gMThdID0gXCJjb2RlTGVuc0ZvbnRGYW1pbHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2RlTGVuc0ZvbnRTaXplXCJdID0gMTldID0gXCJjb2RlTGVuc0ZvbnRTaXplXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29sb3JEZWNvcmF0b3JzXCJdID0gMjBdID0gXCJjb2xvckRlY29yYXRvcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2xvckRlY29yYXRvcnNMaW1pdFwiXSA9IDIxXSA9IFwiY29sb3JEZWNvcmF0b3JzTGltaXRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2x1bW5TZWxlY3Rpb25cIl0gPSAyMl0gPSBcImNvbHVtblNlbGVjdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbW1lbnRzXCJdID0gMjNdID0gXCJjb21tZW50c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbnRleHRtZW51XCJdID0gMjRdID0gXCJjb250ZXh0bWVudVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvcHlXaXRoU3ludGF4SGlnaGxpZ2h0aW5nXCJdID0gMjVdID0gXCJjb3B5V2l0aFN5bnRheEhpZ2hsaWdodGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvckJsaW5raW5nXCJdID0gMjZdID0gXCJjdXJzb3JCbGlua2luZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclNtb290aENhcmV0QW5pbWF0aW9uXCJdID0gMjddID0gXCJjdXJzb3JTbW9vdGhDYXJldEFuaW1hdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclN0eWxlXCJdID0gMjhdID0gXCJjdXJzb3JTdHlsZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclN1cnJvdW5kaW5nTGluZXNcIl0gPSAyOV0gPSBcImN1cnNvclN1cnJvdW5kaW5nTGluZXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzU3R5bGVcIl0gPSAzMF0gPSBcImN1cnNvclN1cnJvdW5kaW5nTGluZXNTdHlsZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvcldpZHRoXCJdID0gMzFdID0gXCJjdXJzb3JXaWR0aFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImRpc2FibGVMYXllckhpbnRpbmdcIl0gPSAzMl0gPSBcImRpc2FibGVMYXllckhpbnRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkaXNhYmxlTW9ub3NwYWNlT3B0aW1pemF0aW9uc1wiXSA9IDMzXSA9IFwiZGlzYWJsZU1vbm9zcGFjZU9wdGltaXphdGlvbnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkb21SZWFkT25seVwiXSA9IDM0XSA9IFwiZG9tUmVhZE9ubHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkcmFnQW5kRHJvcFwiXSA9IDM1XSA9IFwiZHJhZ0FuZERyb3BcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkcm9wSW50b0VkaXRvclwiXSA9IDM2XSA9IFwiZHJvcEludG9FZGl0b3JcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJlbXB0eVNlbGVjdGlvbkNsaXBib2FyZFwiXSA9IDM3XSA9IFwiZW1wdHlTZWxlY3Rpb25DbGlwYm9hcmRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJleHBlcmltZW50YWxXaGl0ZXNwYWNlUmVuZGVyaW5nXCJdID0gMzhdID0gXCJleHBlcmltZW50YWxXaGl0ZXNwYWNlUmVuZGVyaW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZXh0cmFFZGl0b3JDbGFzc05hbWVcIl0gPSAzOV0gPSBcImV4dHJhRWRpdG9yQ2xhc3NOYW1lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmFzdFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gNDBdID0gXCJmYXN0U2Nyb2xsU2Vuc2l0aXZpdHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmaW5kXCJdID0gNDFdID0gXCJmaW5kXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZml4ZWRPdmVyZmxvd1dpZGdldHNcIl0gPSA0Ml0gPSBcImZpeGVkT3ZlcmZsb3dXaWRnZXRzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ1wiXSA9IDQzXSA9IFwiZm9sZGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdTdHJhdGVneVwiXSA9IDQ0XSA9IFwiZm9sZGluZ1N0cmF0ZWd5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ0hpZ2hsaWdodFwiXSA9IDQ1XSA9IFwiZm9sZGluZ0hpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdJbXBvcnRzQnlEZWZhdWx0XCJdID0gNDZdID0gXCJmb2xkaW5nSW1wb3J0c0J5RGVmYXVsdFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdNYXhpbXVtUmVnaW9uc1wiXSA9IDQ3XSA9IFwiZm9sZGluZ01heGltdW1SZWdpb25zXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widW5mb2xkT25DbGlja0FmdGVyRW5kT2ZMaW5lXCJdID0gNDhdID0gXCJ1bmZvbGRPbkNsaWNrQWZ0ZXJFbmRPZkxpbmVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250RmFtaWx5XCJdID0gNDldID0gXCJmb250RmFtaWx5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udEluZm9cIl0gPSA1MF0gPSBcImZvbnRJbmZvXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udExpZ2F0dXJlc1wiXSA9IDUxXSA9IFwiZm9udExpZ2F0dXJlc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRTaXplXCJdID0gNTJdID0gXCJmb250U2l6ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRXZWlnaHRcIl0gPSA1M10gPSBcImZvbnRXZWlnaHRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250VmFyaWF0aW9uc1wiXSA9IDU0XSA9IFwiZm9udFZhcmlhdGlvbnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb3JtYXRPblBhc3RlXCJdID0gNTVdID0gXCJmb3JtYXRPblBhc3RlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9ybWF0T25UeXBlXCJdID0gNTZdID0gXCJmb3JtYXRPblR5cGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJnbHlwaE1hcmdpblwiXSA9IDU3XSA9IFwiZ2x5cGhNYXJnaW5cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJnb3RvTG9jYXRpb25cIl0gPSA1OF0gPSBcImdvdG9Mb2NhdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImhpZGVDdXJzb3JJbk92ZXJ2aWV3UnVsZXJcIl0gPSA1OV0gPSBcImhpZGVDdXJzb3JJbk92ZXJ2aWV3UnVsZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJob3ZlclwiXSA9IDYwXSA9IFwiaG92ZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbkRpZmZFZGl0b3JcIl0gPSA2MV0gPSBcImluRGlmZkVkaXRvclwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImlubGluZVN1Z2dlc3RcIl0gPSA2Ml0gPSBcImlubGluZVN1Z2dlc3RcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxpbmVFZGl0XCJdID0gNjNdID0gXCJpbmxpbmVFZGl0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGV0dGVyU3BhY2luZ1wiXSA9IDY0XSA9IFwibGV0dGVyU3BhY2luZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpZ2h0YnVsYlwiXSA9IDY1XSA9IFwibGlnaHRidWxiXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZURlY29yYXRpb25zV2lkdGhcIl0gPSA2Nl0gPSBcImxpbmVEZWNvcmF0aW9uc1dpZHRoXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZUhlaWdodFwiXSA9IDY3XSA9IFwibGluZUhlaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmVOdW1iZXJzXCJdID0gNjhdID0gXCJsaW5lTnVtYmVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmVOdW1iZXJzTWluQ2hhcnNcIl0gPSA2OV0gPSBcImxpbmVOdW1iZXJzTWluQ2hhcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5rZWRFZGl0aW5nXCJdID0gNzBdID0gXCJsaW5rZWRFZGl0aW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGlua3NcIl0gPSA3MV0gPSBcImxpbmtzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibWF0Y2hCcmFja2V0c1wiXSA9IDcyXSA9IFwibWF0Y2hCcmFja2V0c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1pbmltYXBcIl0gPSA3M10gPSBcIm1pbmltYXBcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVN0eWxlXCJdID0gNzRdID0gXCJtb3VzZVN0eWxlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VXaGVlbFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gNzVdID0gXCJtb3VzZVdoZWVsU2Nyb2xsU2Vuc2l0aXZpdHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVdoZWVsWm9vbVwiXSA9IDc2XSA9IFwibW91c2VXaGVlbFpvb21cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvck1lcmdlT3ZlcmxhcHBpbmdcIl0gPSA3N10gPSBcIm11bHRpQ3Vyc29yTWVyZ2VPdmVybGFwcGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm11bHRpQ3Vyc29yTW9kaWZpZXJcIl0gPSA3OF0gPSBcIm11bHRpQ3Vyc29yTW9kaWZpZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvclBhc3RlXCJdID0gNzldID0gXCJtdWx0aUN1cnNvclBhc3RlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JMaW1pdFwiXSA9IDgwXSA9IFwibXVsdGlDdXJzb3JMaW1pdFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm9jY3VycmVuY2VzSGlnaGxpZ2h0XCJdID0gODFdID0gXCJvY2N1cnJlbmNlc0hpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm92ZXJ2aWV3UnVsZXJCb3JkZXJcIl0gPSA4Ml0gPSBcIm92ZXJ2aWV3UnVsZXJCb3JkZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJvdmVydmlld1J1bGVyTGFuZXNcIl0gPSA4M10gPSBcIm92ZXJ2aWV3UnVsZXJMYW5lc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBhZGRpbmdcIl0gPSA4NF0gPSBcInBhZGRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwYXN0ZUFzXCJdID0gODVdID0gXCJwYXN0ZUFzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGFyYW1ldGVySGludHNcIl0gPSA4Nl0gPSBcInBhcmFtZXRlckhpbnRzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGVla1dpZGdldERlZmF1bHRGb2N1c1wiXSA9IDg3XSA9IFwicGVla1dpZGdldERlZmF1bHRGb2N1c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImRlZmluaXRpb25MaW5rT3BlbnNJblBlZWtcIl0gPSA4OF0gPSBcImRlZmluaXRpb25MaW5rT3BlbnNJblBlZWtcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJxdWlja1N1Z2dlc3Rpb25zXCJdID0gODldID0gXCJxdWlja1N1Z2dlc3Rpb25zXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicXVpY2tTdWdnZXN0aW9uc0RlbGF5XCJdID0gOTBdID0gXCJxdWlja1N1Z2dlc3Rpb25zRGVsYXlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZWFkT25seVwiXSA9IDkxXSA9IFwicmVhZE9ubHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZWFkT25seU1lc3NhZ2VcIl0gPSA5Ml0gPSBcInJlYWRPbmx5TWVzc2FnZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmFtZU9uVHlwZVwiXSA9IDkzXSA9IFwicmVuYW1lT25UeXBlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyQ29udHJvbENoYXJhY3RlcnNcIl0gPSA5NF0gPSBcInJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyRmluYWxOZXdsaW5lXCJdID0gOTVdID0gXCJyZW5kZXJGaW5hbE5ld2xpbmVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJMaW5lSGlnaGxpZ2h0XCJdID0gOTZdID0gXCJyZW5kZXJMaW5lSGlnaGxpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyTGluZUhpZ2hsaWdodE9ubHlXaGVuRm9jdXNcIl0gPSA5N10gPSBcInJlbmRlckxpbmVIaWdobGlnaHRPbmx5V2hlbkZvY3VzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyVmFsaWRhdGlvbkRlY29yYXRpb25zXCJdID0gOThdID0gXCJyZW5kZXJWYWxpZGF0aW9uRGVjb3JhdGlvbnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJXaGl0ZXNwYWNlXCJdID0gOTldID0gXCJyZW5kZXJXaGl0ZXNwYWNlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmV2ZWFsSG9yaXpvbnRhbFJpZ2h0UGFkZGluZ1wiXSA9IDEwMF0gPSBcInJldmVhbEhvcml6b250YWxSaWdodFBhZGRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyb3VuZGVkU2VsZWN0aW9uXCJdID0gMTAxXSA9IFwicm91bmRlZFNlbGVjdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJ1bGVyc1wiXSA9IDEwMl0gPSBcInJ1bGVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcm9sbGJhclwiXSA9IDEwM10gPSBcInNjcm9sbGJhclwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcm9sbEJleW9uZExhc3RDb2x1bW5cIl0gPSAxMDRdID0gXCJzY3JvbGxCZXlvbmRMYXN0Q29sdW1uXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsQmV5b25kTGFzdExpbmVcIl0gPSAxMDVdID0gXCJzY3JvbGxCZXlvbmRMYXN0TGluZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcm9sbFByZWRvbWluYW50QXhpc1wiXSA9IDEwNl0gPSBcInNjcm9sbFByZWRvbWluYW50QXhpc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdGlvbkNsaXBib2FyZFwiXSA9IDEwN10gPSBcInNlbGVjdGlvbkNsaXBib2FyZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdGlvbkhpZ2hsaWdodFwiXSA9IDEwOF0gPSBcInNlbGVjdGlvbkhpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdE9uTGluZU51bWJlcnNcIl0gPSAxMDldID0gXCJzZWxlY3RPbkxpbmVOdW1iZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2hvd0ZvbGRpbmdDb250cm9sc1wiXSA9IDExMF0gPSBcInNob3dGb2xkaW5nQ29udHJvbHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzaG93VW51c2VkXCJdID0gMTExXSA9IFwic2hvd1VudXNlZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNuaXBwZXRTdWdnZXN0aW9uc1wiXSA9IDExMl0gPSBcInNuaXBwZXRTdWdnZXN0aW9uc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNtYXJ0U2VsZWN0XCJdID0gMTEzXSA9IFwic21hcnRTZWxlY3RcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbW9vdGhTY3JvbGxpbmdcIl0gPSAxMTRdID0gXCJzbW9vdGhTY3JvbGxpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdGlja3lTY3JvbGxcIl0gPSAxMTVdID0gXCJzdGlja3lTY3JvbGxcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdGlja3lUYWJTdG9wc1wiXSA9IDExNl0gPSBcInN0aWNreVRhYlN0b3BzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3RvcFJlbmRlcmluZ0xpbmVBZnRlclwiXSA9IDExN10gPSBcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0XCJdID0gMTE4XSA9IFwic3VnZ2VzdFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RGb250U2l6ZVwiXSA9IDExOV0gPSBcInN1Z2dlc3RGb250U2l6ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RMaW5lSGVpZ2h0XCJdID0gMTIwXSA9IFwic3VnZ2VzdExpbmVIZWlnaHRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0T25UcmlnZ2VyQ2hhcmFjdGVyc1wiXSA9IDEyMV0gPSBcInN1Z2dlc3RPblRyaWdnZXJDaGFyYWN0ZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdFNlbGVjdGlvblwiXSA9IDEyMl0gPSBcInN1Z2dlc3RTZWxlY3Rpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ0YWJDb21wbGV0aW9uXCJdID0gMTIzXSA9IFwidGFiQ29tcGxldGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInRhYkluZGV4XCJdID0gMTI0XSA9IFwidGFiSW5kZXhcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bmljb2RlSGlnaGxpZ2h0aW5nXCJdID0gMTI1XSA9IFwidW5pY29kZUhpZ2hsaWdodGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVudXN1YWxMaW5lVGVybWluYXRvcnNcIl0gPSAxMjZdID0gXCJ1bnVzdWFsTGluZVRlcm1pbmF0b3JzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widXNlU2hhZG93RE9NXCJdID0gMTI3XSA9IFwidXNlU2hhZG93RE9NXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widXNlVGFiU3RvcHNcIl0gPSAxMjhdID0gXCJ1c2VUYWJTdG9wc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRCcmVha1wiXSA9IDEyOV0gPSBcIndvcmRCcmVha1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRTZWdtZW50ZXJMb2NhbGVzXCJdID0gMTMwXSA9IFwid29yZFNlZ21lbnRlckxvY2FsZXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkU2VwYXJhdG9yc1wiXSA9IDEzMV0gPSBcIndvcmRTZXBhcmF0b3JzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBcIl0gPSAxMzJdID0gXCJ3b3JkV3JhcFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwQnJlYWtBZnRlckNoYXJhY3RlcnNcIl0gPSAxMzNdID0gXCJ3b3JkV3JhcEJyZWFrQWZ0ZXJDaGFyYWN0ZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBCcmVha0JlZm9yZUNoYXJhY3RlcnNcIl0gPSAxMzRdID0gXCJ3b3JkV3JhcEJyZWFrQmVmb3JlQ2hhcmFjdGVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwQ29sdW1uXCJdID0gMTM1XSA9IFwid29yZFdyYXBDb2x1bW5cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcE92ZXJyaWRlMVwiXSA9IDEzNl0gPSBcIndvcmRXcmFwT3ZlcnJpZGUxXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBPdmVycmlkZTJcIl0gPSAxMzddID0gXCJ3b3JkV3JhcE92ZXJyaWRlMlwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndyYXBwaW5nSW5kZW50XCJdID0gMTM4XSA9IFwid3JhcHBpbmdJbmRlbnRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ1N0cmF0ZWd5XCJdID0gMTM5XSA9IFwid3JhcHBpbmdTdHJhdGVneVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNob3dEZXByZWNhdGVkXCJdID0gMTQwXSA9IFwic2hvd0RlcHJlY2F0ZWRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxheUhpbnRzXCJdID0gMTQxXSA9IFwiaW5sYXlIaW50c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImVkaXRvckNsYXNzTmFtZVwiXSA9IDE0Ml0gPSBcImVkaXRvckNsYXNzTmFtZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBpeGVsUmF0aW9cIl0gPSAxNDNdID0gXCJwaXhlbFJhdGlvXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiRm9jdXNNb2RlXCJdID0gMTQ0XSA9IFwidGFiRm9jdXNNb2RlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGF5b3V0SW5mb1wiXSA9IDE0NV0gPSBcImxheW91dEluZm9cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZm9cIl0gPSAxNDZdID0gXCJ3cmFwcGluZ0luZm9cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkZWZhdWx0Q29sb3JEZWNvcmF0b3JzXCJdID0gMTQ3XSA9IFwiZGVmYXVsdENvbG9yRGVjb3JhdG9yc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbG9yRGVjb3JhdG9yc0FjdGl2YXRlZE9uXCJdID0gMTQ4XSA9IFwiY29sb3JEZWNvcmF0b3JzQWN0aXZhdGVkT25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxpbmVDb21wbGV0aW9uc0FjY2Vzc2liaWxpdHlWZXJib3NlXCJdID0gMTQ5XSA9IFwiaW5saW5lQ29tcGxldGlvbnNBY2Nlc3NpYmlsaXR5VmVyYm9zZVwiO1xyXG59KShFZGl0b3JPcHRpb24gfHwgKEVkaXRvck9wdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbmQgb2YgbGluZSBjaGFyYWN0ZXIgcHJlZmVyZW5jZS5cclxuICovXHJcbmV4cG9ydCB2YXIgRW5kT2ZMaW5lUHJlZmVyZW5jZTtcclxuKGZ1bmN0aW9uIChFbmRPZkxpbmVQcmVmZXJlbmNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyIGlkZW50aWZpZWQgaW4gdGhlIHRleHQgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBFbmRPZkxpbmVQcmVmZXJlbmNlW0VuZE9mTGluZVByZWZlcmVuY2VbXCJUZXh0RGVmaW5lZFwiXSA9IDBdID0gXCJUZXh0RGVmaW5lZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgbGluZSBmZWVkIChcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIEVuZE9mTGluZVByZWZlcmVuY2VbRW5kT2ZMaW5lUHJlZmVyZW5jZVtcIkxGXCJdID0gMV0gPSBcIkxGXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBFbmRPZkxpbmVQcmVmZXJlbmNlW0VuZE9mTGluZVByZWZlcmVuY2VbXCJDUkxGXCJdID0gMl0gPSBcIkNSTEZcIjtcclxufSkoRW5kT2ZMaW5lUHJlZmVyZW5jZSB8fCAoRW5kT2ZMaW5lUHJlZmVyZW5jZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbmQgb2YgbGluZSBjaGFyYWN0ZXIgcHJlZmVyZW5jZS5cclxuICovXHJcbmV4cG9ydCB2YXIgRW5kT2ZMaW5lU2VxdWVuY2U7XHJcbihmdW5jdGlvbiAoRW5kT2ZMaW5lU2VxdWVuY2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIGxpbmUgZmVlZCAoXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBFbmRPZkxpbmVTZXF1ZW5jZVtFbmRPZkxpbmVTZXF1ZW5jZVtcIkxGXCJdID0gMF0gPSBcIkxGXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBFbmRPZkxpbmVTZXF1ZW5jZVtFbmRPZkxpbmVTZXF1ZW5jZVtcIkNSTEZcIl0gPSAxXSA9IFwiQ1JMRlwiO1xyXG59KShFbmRPZkxpbmVTZXF1ZW5jZSB8fCAoRW5kT2ZMaW5lU2VxdWVuY2UgPSB7fSkpO1xyXG4vKipcclxuICogVmVydGljYWwgTGFuZSBpbiB0aGUgZ2x5cGggbWFyZ2luIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEdseXBoTWFyZ2luTGFuZTtcclxuKGZ1bmN0aW9uIChHbHlwaE1hcmdpbkxhbmUpIHtcclxuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcclxuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBHbHlwaE1hcmdpbkxhbmVbR2x5cGhNYXJnaW5MYW5lW1wiUmlnaHRcIl0gPSAzXSA9IFwiUmlnaHRcIjtcclxufSkoR2x5cGhNYXJnaW5MYW5lIHx8IChHbHlwaE1hcmdpbkxhbmUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIEhvdmVyVmVyYm9zaXR5QWN0aW9uO1xyXG4oZnVuY3Rpb24gKEhvdmVyVmVyYm9zaXR5QWN0aW9uKSB7XHJcbiAgICAvKipcclxuICAgICAqIEluY3JlYXNlIHRoZSB2ZXJib3NpdHkgb2YgdGhlIGhvdmVyXHJcbiAgICAgKi9cclxuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiSW5jcmVhc2VcIl0gPSAwXSA9IFwiSW5jcmVhc2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGVjcmVhc2UgdGhlIHZlcmJvc2l0eSBvZiB0aGUgaG92ZXJcclxuICAgICAqL1xyXG4gICAgSG92ZXJWZXJib3NpdHlBY3Rpb25bSG92ZXJWZXJib3NpdHlBY3Rpb25bXCJEZWNyZWFzZVwiXSA9IDFdID0gXCJEZWNyZWFzZVwiO1xyXG59KShIb3ZlclZlcmJvc2l0eUFjdGlvbiB8fCAoSG92ZXJWZXJib3NpdHlBY3Rpb24gPSB7fSkpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIHdoYXQgdG8gZG8gd2l0aCB0aGUgaW5kZW50YXRpb24gd2hlbiBwcmVzc2luZyBFbnRlci5cclxuICovXHJcbmV4cG9ydCB2YXIgSW5kZW50QWN0aW9uO1xyXG4oZnVuY3Rpb24gKEluZGVudEFjdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIGNvcHkgdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIGluZGVudCBvbmNlIChyZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uKS5cclxuICAgICAqL1xyXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIkluZGVudFwiXSA9IDFdID0gXCJJbmRlbnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IHR3byBuZXcgbGluZXM6XHJcbiAgICAgKiAgLSB0aGUgZmlyc3Qgb25lIGluZGVudGVkIHdoaWNoIHdpbGwgaG9sZCB0aGUgY3Vyc29yXHJcbiAgICAgKiAgLSB0aGUgc2Vjb25kIG9uZSBhdCB0aGUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbFxyXG4gICAgICovXHJcbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiSW5kZW50T3V0ZGVudFwiXSA9IDJdID0gXCJJbmRlbnRPdXRkZW50XCI7XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBuZXcgbGluZSBhbmQgb3V0ZGVudCBvbmNlIChyZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uKS5cclxuICAgICAqL1xyXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIk91dGRlbnRcIl0gPSAzXSA9IFwiT3V0ZGVudFwiO1xyXG59KShJbmRlbnRBY3Rpb24gfHwgKEluZGVudEFjdGlvbiA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHM7XHJcbihmdW5jdGlvbiAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMpIHtcclxuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiQm90aFwiXSA9IDBdID0gXCJCb3RoXCI7XHJcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XHJcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkxlZnRcIl0gPSAyXSA9IFwiTGVmdFwiO1xyXG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJOb25lXCJdID0gM10gPSBcIk5vbmVcIjtcclxufSkoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgfHwgKEluamVjdGVkVGV4dEN1cnNvclN0b3BzID0ge30pKTtcclxuZXhwb3J0IHZhciBJbmxheUhpbnRLaW5kO1xyXG4oZnVuY3Rpb24gKElubGF5SGludEtpbmQpIHtcclxuICAgIElubGF5SGludEtpbmRbSW5sYXlIaW50S2luZFtcIlR5cGVcIl0gPSAxXSA9IFwiVHlwZVwiO1xyXG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiUGFyYW1ldGVyXCJdID0gMl0gPSBcIlBhcmFtZXRlclwiO1xyXG59KShJbmxheUhpbnRLaW5kIHx8IChJbmxheUhpbnRLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIEhvdyBhbiB7QGxpbmsgSW5saW5lQ29tcGxldGlvbnNQcm92aWRlciBpbmxpbmUgY29tcGxldGlvbiBwcm92aWRlcn0gd2FzIHRyaWdnZXJlZC5cclxuICovXHJcbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxyXG4gICAgICogSXQgaXMgc3VmZmljaWVudCB0byByZXR1cm4gYSBzaW5nbGUgY29tcGxldGlvbiBpdGVtIGluIHRoaXMgY2FzZS5cclxuICAgICAqL1xyXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDBdID0gXCJBdXRvbWF0aWNcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGV4cGxpY2l0bHkgYnkgYSB1c2VyIGdlc3R1cmUuXHJcbiAgICAgKiBSZXR1cm4gbXVsdGlwbGUgY29tcGxldGlvbiBpdGVtcyB0byBlbmFibGUgY3ljbGluZyB0aHJvdWdoIHRoZW0uXHJcbiAgICAgKi9cclxuICAgIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJFeHBsaWNpdFwiXSA9IDFdID0gXCJFeHBsaWNpdFwiO1xyXG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgSW5saW5lRWRpdFRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKElubGluZUVkaXRUcmlnZ2VyS2luZCkge1xyXG4gICAgSW5saW5lRWRpdFRyaWdnZXJLaW5kW0lubGluZUVkaXRUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcclxuICAgIElubGluZUVkaXRUcmlnZ2VyS2luZFtJbmxpbmVFZGl0VHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAxXSA9IFwiQXV0b21hdGljXCI7XHJcbn0pKElubGluZUVkaXRUcmlnZ2VyS2luZCB8fCAoSW5saW5lRWRpdFRyaWdnZXJLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIFZpcnR1YWwgS2V5IENvZGVzLCB0aGUgdmFsdWUgZG9lcyBub3QgaG9sZCBhbnkgaW5oZXJlbnQgbWVhbmluZy5cclxuICogSW5zcGlyZWQgc29tZXdoYXQgZnJvbSBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9kZDM3NTczMSh2PXZzLjg1KS5hc3B4XHJcbiAqIEJ1dCB0aGVzZSBhcmUgXCJtb3JlIGdlbmVyYWxcIiwgYXMgdGhleSBzaG91bGQgd29yayBhY3Jvc3MgYnJvd3NlcnMgJiBPU2BzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBLZXlDb2RlO1xyXG4oZnVuY3Rpb24gKEtleUNvZGUpIHtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRlcGVuZHNPbktiTGF5b3V0XCJdID0gLTFdID0gXCJEZXBlbmRzT25LYkxheW91dFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZWQgZmlyc3QgdG8gY292ZXIgdGhlIDAgdmFsdWUgb2YgdGhlIGVudW0uXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQmFja3NwYWNlXCJdID0gMV0gPSBcIkJhY2tzcGFjZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVGFiXCJdID0gMl0gPSBcIlRhYlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRW50ZXJcIl0gPSAzXSA9IFwiRW50ZXJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNoaWZ0XCJdID0gNF0gPSBcIlNoaWZ0XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDdHJsXCJdID0gNV0gPSBcIkN0cmxcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFsdFwiXSA9IDZdID0gXCJBbHRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhdXNlQnJlYWtcIl0gPSA3XSA9IFwiUGF1c2VCcmVha1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ2Fwc0xvY2tcIl0gPSA4XSA9IFwiQ2Fwc0xvY2tcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVzY2FwZVwiXSA9IDldID0gXCJFc2NhcGVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNwYWNlXCJdID0gMTBdID0gXCJTcGFjZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGFnZVVwXCJdID0gMTFdID0gXCJQYWdlVXBcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhZ2VEb3duXCJdID0gMTJdID0gXCJQYWdlRG93blwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRW5kXCJdID0gMTNdID0gXCJFbmRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkhvbWVcIl0gPSAxNF0gPSBcIkhvbWVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxlZnRBcnJvd1wiXSA9IDE1XSA9IFwiTGVmdEFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVcEFycm93XCJdID0gMTZdID0gXCJVcEFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJSaWdodEFycm93XCJdID0gMTddID0gXCJSaWdodEFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEb3duQXJyb3dcIl0gPSAxOF0gPSBcIkRvd25BcnJvd1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiSW5zZXJ0XCJdID0gMTldID0gXCJJbnNlcnRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRlbGV0ZVwiXSA9IDIwXSA9IFwiRGVsZXRlXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDBcIl0gPSAyMV0gPSBcIkRpZ2l0MFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQxXCJdID0gMjJdID0gXCJEaWdpdDFcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0MlwiXSA9IDIzXSA9IFwiRGlnaXQyXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDNcIl0gPSAyNF0gPSBcIkRpZ2l0M1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ0XCJdID0gMjVdID0gXCJEaWdpdDRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0NVwiXSA9IDI2XSA9IFwiRGlnaXQ1XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDZcIl0gPSAyN10gPSBcIkRpZ2l0NlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ3XCJdID0gMjhdID0gXCJEaWdpdDdcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0OFwiXSA9IDI5XSA9IFwiRGlnaXQ4XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDlcIl0gPSAzMF0gPSBcIkRpZ2l0OVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5QVwiXSA9IDMxXSA9IFwiS2V5QVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5QlwiXSA9IDMyXSA9IFwiS2V5QlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5Q1wiXSA9IDMzXSA9IFwiS2V5Q1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5RFwiXSA9IDM0XSA9IFwiS2V5RFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5RVwiXSA9IDM1XSA9IFwiS2V5RVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5RlwiXSA9IDM2XSA9IFwiS2V5RlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5R1wiXSA9IDM3XSA9IFwiS2V5R1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5SFwiXSA9IDM4XSA9IFwiS2V5SFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5SVwiXSA9IDM5XSA9IFwiS2V5SVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5SlwiXSA9IDQwXSA9IFwiS2V5SlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5S1wiXSA9IDQxXSA9IFwiS2V5S1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5TFwiXSA9IDQyXSA9IFwiS2V5TFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5TVwiXSA9IDQzXSA9IFwiS2V5TVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5TlwiXSA9IDQ0XSA9IFwiS2V5TlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5T1wiXSA9IDQ1XSA9IFwiS2V5T1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5UFwiXSA9IDQ2XSA9IFwiS2V5UFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5UVwiXSA9IDQ3XSA9IFwiS2V5UVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5UlwiXSA9IDQ4XSA9IFwiS2V5UlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5U1wiXSA9IDQ5XSA9IFwiS2V5U1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5VFwiXSA9IDUwXSA9IFwiS2V5VFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5VVwiXSA9IDUxXSA9IFwiS2V5VVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5VlwiXSA9IDUyXSA9IFwiS2V5VlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5V1wiXSA9IDUzXSA9IFwiS2V5V1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5WFwiXSA9IDU0XSA9IFwiS2V5WFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5WVwiXSA9IDU1XSA9IFwiS2V5WVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5WlwiXSA9IDU2XSA9IFwiS2V5WlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWV0YVwiXSA9IDU3XSA9IFwiTWV0YVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ29udGV4dE1lbnVcIl0gPSA1OF0gPSBcIkNvbnRleHRNZW51XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMVwiXSA9IDU5XSA9IFwiRjFcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyXCJdID0gNjBdID0gXCJGMlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjNcIl0gPSA2MV0gPSBcIkYzXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGNFwiXSA9IDYyXSA9IFwiRjRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY1XCJdID0gNjNdID0gXCJGNVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjZcIl0gPSA2NF0gPSBcIkY2XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGN1wiXSA9IDY1XSA9IFwiRjdcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY4XCJdID0gNjZdID0gXCJGOFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjlcIl0gPSA2N10gPSBcIkY5XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTBcIl0gPSA2OF0gPSBcIkYxMFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjExXCJdID0gNjldID0gXCJGMTFcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMlwiXSA9IDcwXSA9IFwiRjEyXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTNcIl0gPSA3MV0gPSBcIkYxM1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE0XCJdID0gNzJdID0gXCJGMTRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNVwiXSA9IDczXSA9IFwiRjE1XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTZcIl0gPSA3NF0gPSBcIkYxNlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE3XCJdID0gNzVdID0gXCJGMTdcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxOFwiXSA9IDc2XSA9IFwiRjE4XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTlcIl0gPSA3N10gPSBcIkYxOVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjIwXCJdID0gNzhdID0gXCJGMjBcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyMVwiXSA9IDc5XSA9IFwiRjIxXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMjJcIl0gPSA4MF0gPSBcIkYyMlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjIzXCJdID0gODFdID0gXCJGMjNcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyNFwiXSA9IDgyXSA9IFwiRjI0XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1Mb2NrXCJdID0gODNdID0gXCJOdW1Mb2NrXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJTY3JvbGxMb2NrXCJdID0gODRdID0gXCJTY3JvbGxMb2NrXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJzs6JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2VtaWNvbG9uXCJdID0gODVdID0gXCJTZW1pY29sb25cIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcrJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnPSsnIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFcXVhbFwiXSA9IDg2XSA9IFwiRXF1YWxcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcsJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLDwnIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDb21tYVwiXSA9IDg3XSA9IFwiQ29tbWFcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICctJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLV8nIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNaW51c1wiXSA9IDg4XSA9IFwiTWludXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcuJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLj4nIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQZXJpb2RcIl0gPSA4OV0gPSBcIlBlcmlvZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcvPycga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNsYXNoXCJdID0gOTBdID0gXCJTbGFzaFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICdgficga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJhY2txdW90ZVwiXSA9IDkxXSA9IFwiQmFja3F1b3RlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ1t7JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJhY2tldExlZnRcIl0gPSA5Ml0gPSBcIkJyYWNrZXRMZWZ0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ1xcfCcga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJhY2tzbGFzaFwiXSA9IDkzXSA9IFwiQmFja3NsYXNoXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ119JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJhY2tldFJpZ2h0XCJdID0gOTRdID0gXCJCcmFja2V0UmlnaHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnJ1wiJyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUXVvdGVcIl0gPSA5NV0gPSBcIlF1b3RlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk9FTV84XCJdID0gOTZdID0gXCJPRU1fOFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFaXRoZXIgdGhlIGFuZ2xlIGJyYWNrZXQga2V5IG9yIHRoZSBiYWNrc2xhc2gga2V5IG9uIHRoZSBSVCAxMDIta2V5IGtleWJvYXJkLlxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJJbnRsQmFja3NsYXNoXCJdID0gOTddID0gXCJJbnRsQmFja3NsYXNoXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQwXCJdID0gOThdID0gXCJOdW1wYWQwXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQxXCJdID0gOTldID0gXCJOdW1wYWQxXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQyXCJdID0gMTAwXSA9IFwiTnVtcGFkMlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkM1wiXSA9IDEwMV0gPSBcIk51bXBhZDNcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDRcIl0gPSAxMDJdID0gXCJOdW1wYWQ0XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ1XCJdID0gMTAzXSA9IFwiTnVtcGFkNVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkNlwiXSA9IDEwNF0gPSBcIk51bXBhZDZcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDdcIl0gPSAxMDVdID0gXCJOdW1wYWQ3XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ4XCJdID0gMTA2XSA9IFwiTnVtcGFkOFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkOVwiXSA9IDEwN10gPSBcIk51bXBhZDlcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZE11bHRpcGx5XCJdID0gMTA4XSA9IFwiTnVtcGFkTXVsdGlwbHlcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZEFkZFwiXSA9IDEwOV0gPSBcIk51bXBhZEFkZFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX1NFUEFSQVRPUlwiXSA9IDExMF0gPSBcIk5VTVBBRF9TRVBBUkFUT1JcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZFN1YnRyYWN0XCJdID0gMTExXSA9IFwiTnVtcGFkU3VidHJhY3RcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZERlY2ltYWxcIl0gPSAxMTJdID0gXCJOdW1wYWREZWNpbWFsXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWREaXZpZGVcIl0gPSAxMTNdID0gXCJOdW1wYWREaXZpZGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ292ZXIgYWxsIGtleSBjb2RlcyB3aGVuIElNRSBpcyBwcm9jZXNzaW5nIGlucHV0LlxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfSU5fQ09NUE9TSVRJT05cIl0gPSAxMTRdID0gXCJLRVlfSU5fQ09NUE9TSVRJT05cIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFCTlRfQzFcIl0gPSAxMTVdID0gXCJBQk5UX0MxXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBQk5UX0MyXCJdID0gMTE2XSA9IFwiQUJOVF9DMlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQXVkaW9Wb2x1bWVNdXRlXCJdID0gMTE3XSA9IFwiQXVkaW9Wb2x1bWVNdXRlXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBdWRpb1ZvbHVtZVVwXCJdID0gMTE4XSA9IFwiQXVkaW9Wb2x1bWVVcFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQXVkaW9Wb2x1bWVEb3duXCJdID0gMTE5XSA9IFwiQXVkaW9Wb2x1bWVEb3duXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCcm93c2VyU2VhcmNoXCJdID0gMTIwXSA9IFwiQnJvd3NlclNlYXJjaFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlckhvbWVcIl0gPSAxMjFdID0gXCJCcm93c2VySG9tZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlckJhY2tcIl0gPSAxMjJdID0gXCJCcm93c2VyQmFja1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlckZvcndhcmRcIl0gPSAxMjNdID0gXCJCcm93c2VyRm9yd2FyZFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWVkaWFUcmFja05leHRcIl0gPSAxMjRdID0gXCJNZWRpYVRyYWNrTmV4dFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWVkaWFUcmFja1ByZXZpb3VzXCJdID0gMTI1XSA9IFwiTWVkaWFUcmFja1ByZXZpb3VzXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZWRpYVN0b3BcIl0gPSAxMjZdID0gXCJNZWRpYVN0b3BcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1lZGlhUGxheVBhdXNlXCJdID0gMTI3XSA9IFwiTWVkaWFQbGF5UGF1c2VcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxhdW5jaE1lZGlhUGxheWVyXCJdID0gMTI4XSA9IFwiTGF1bmNoTWVkaWFQbGF5ZXJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxhdW5jaE1haWxcIl0gPSAxMjldID0gXCJMYXVuY2hNYWlsXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJMYXVuY2hBcHAyXCJdID0gMTMwXSA9IFwiTGF1bmNoQXBwMlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWS19DTEVBUiwgMHgwQywgQ0xFQVIga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNsZWFyXCJdID0gMTMxXSA9IFwiQ2xlYXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGxhY2VkIGxhc3QgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZW51bS5cclxuICAgICAqIFBsZWFzZSBkbyBub3QgZGVwZW5kIG9uIHRoaXMgdmFsdWUhXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1BWF9WQUxVRVwiXSA9IDEzMl0gPSBcIk1BWF9WQUxVRVwiO1xyXG59KShLZXlDb2RlIHx8IChLZXlDb2RlID0ge30pKTtcclxuZXhwb3J0IHZhciBNYXJrZXJTZXZlcml0eTtcclxuKGZ1bmN0aW9uIChNYXJrZXJTZXZlcml0eSkge1xyXG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJIaW50XCJdID0gMV0gPSBcIkhpbnRcIjtcclxuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiSW5mb1wiXSA9IDJdID0gXCJJbmZvXCI7XHJcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIldhcm5pbmdcIl0gPSA0XSA9IFwiV2FybmluZ1wiO1xyXG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJFcnJvclwiXSA9IDhdID0gXCJFcnJvclwiO1xyXG59KShNYXJrZXJTZXZlcml0eSB8fCAoTWFya2VyU2V2ZXJpdHkgPSB7fSkpO1xyXG5leHBvcnQgdmFyIE1hcmtlclRhZztcclxuKGZ1bmN0aW9uIChNYXJrZXJUYWcpIHtcclxuICAgIE1hcmtlclRhZ1tNYXJrZXJUYWdbXCJVbm5lY2Vzc2FyeVwiXSA9IDFdID0gXCJVbm5lY2Vzc2FyeVwiO1xyXG4gICAgTWFya2VyVGFnW01hcmtlclRhZ1tcIkRlcHJlY2F0ZWRcIl0gPSAyXSA9IFwiRGVwcmVjYXRlZFwiO1xyXG59KShNYXJrZXJUYWcgfHwgKE1hcmtlclRhZyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBQb3NpdGlvbiBpbiB0aGUgbWluaW1hcCB0byByZW5kZXIgdGhlIGRlY29yYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIE1pbmltYXBQb3NpdGlvbjtcclxuKGZ1bmN0aW9uIChNaW5pbWFwUG9zaXRpb24pIHtcclxuICAgIE1pbmltYXBQb3NpdGlvbltNaW5pbWFwUG9zaXRpb25bXCJJbmxpbmVcIl0gPSAxXSA9IFwiSW5saW5lXCI7XHJcbiAgICBNaW5pbWFwUG9zaXRpb25bTWluaW1hcFBvc2l0aW9uW1wiR3V0dGVyXCJdID0gMl0gPSBcIkd1dHRlclwiO1xyXG59KShNaW5pbWFwUG9zaXRpb24gfHwgKE1pbmltYXBQb3NpdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBTZWN0aW9uIGhlYWRlciBzdHlsZS5cclxuICovXHJcbmV4cG9ydCB2YXIgTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZTtcclxuKGZ1bmN0aW9uIChNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlKSB7XHJcbiAgICBNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlW01pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGVbXCJOb3JtYWxcIl0gPSAxXSA9IFwiTm9ybWFsXCI7XHJcbiAgICBNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlW01pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGVbXCJVbmRlcmxpbmVkXCJdID0gMl0gPSBcIlVuZGVybGluZWRcIjtcclxufSkoTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZSB8fCAoTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIGhpdCBlbGVtZW50IHdpdGggdGhlIG1vdXNlIGluIHRoZSBlZGl0b3IuXHJcbiAqL1xyXG5leHBvcnQgdmFyIE1vdXNlVGFyZ2V0VHlwZTtcclxuKGZ1bmN0aW9uIChNb3VzZVRhcmdldFR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGFuIHVua25vd24gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIHRleHRhcmVhIHVzZWQgZm9yIGlucHV0LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiVEVYVEFSRUFcIl0gPSAxXSA9IFwiVEVYVEFSRUFcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBnbHlwaCBtYXJnaW5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9HTFlQSF9NQVJHSU5cIl0gPSAyXSA9IFwiR1VUVEVSX0dMWVBIX01BUkdJTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIGxpbmUgbnVtYmVyc1xyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0xJTkVfTlVNQkVSU1wiXSA9IDNdID0gXCJHVVRURVJfTElORV9OVU1CRVJTXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgbGluZSBkZWNvcmF0aW9uc1xyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0xJTkVfREVDT1JBVElPTlNcIl0gPSA0XSA9IFwiR1VUVEVSX0xJTkVfREVDT1JBVElPTlNcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSB3aGl0ZXNwYWNlIGxlZnQgaW4gdGhlIGd1dHRlciBieSBhIHZpZXcgem9uZS5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9WSUVXX1pPTkVcIl0gPSA1XSA9IFwiR1VUVEVSX1ZJRVdfWk9ORVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGV4dCBpbiB0aGUgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfVEVYVFwiXSA9IDZdID0gXCJDT05URU5UX1RFWFRcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGVtcHR5IHNwYWNlIGluIHRoZSBjb250ZW50IChlLmcuIGFmdGVyIGxpbmUgdGV4dCBvciBiZWxvdyBsYXN0IGxpbmUpXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX0VNUFRZXCJdID0gN10gPSBcIkNPTlRFTlRfRU1QVFlcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgdmlldyB6b25lIGluIHRoZSBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9WSUVXX1pPTkVcIl0gPSA4XSA9IFwiQ09OVEVOVF9WSUVXX1pPTkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgY29udGVudCB3aWRnZXQuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1dJREdFVFwiXSA9IDldID0gXCJDT05URU5UX1dJREdFVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIGRlY29yYXRpb25zIG92ZXJ2aWV3IHJ1bGVyLlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiT1ZFUlZJRVdfUlVMRVJcIl0gPSAxMF0gPSBcIk9WRVJWSUVXX1JVTEVSXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIHNjcm9sbGJhci5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlNDUk9MTEJBUlwiXSA9IDExXSA9IFwiU0NST0xMQkFSXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhbiBvdmVybGF5IHdpZGdldC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9WRVJMQVlfV0lER0VUXCJdID0gMTJdID0gXCJPVkVSTEFZX1dJREdFVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJPVVRTSURFX0VESVRPUlwiXSA9IDEzXSA9IFwiT1VUU0lERV9FRElUT1JcIjtcclxufSkoTW91c2VUYXJnZXRUeXBlIHx8IChNb3VzZVRhcmdldFR5cGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIE5ld1N5bWJvbE5hbWVUYWc7XHJcbihmdW5jdGlvbiAoTmV3U3ltYm9sTmFtZVRhZykge1xyXG4gICAgTmV3U3ltYm9sTmFtZVRhZ1tOZXdTeW1ib2xOYW1lVGFnW1wiQUlHZW5lcmF0ZWRcIl0gPSAxXSA9IFwiQUlHZW5lcmF0ZWRcIjtcclxufSkoTmV3U3ltYm9sTmFtZVRhZyB8fCAoTmV3U3ltYm9sTmFtZVRhZyA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCkge1xyXG4gICAgTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW05ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcclxuICAgIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAxXSA9IFwiQXV0b21hdGljXCI7XHJcbn0pKE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZCB8fCAoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIEEgcG9zaXRpb25pbmcgcHJlZmVyZW5jZSBmb3IgcmVuZGVyaW5nIG92ZXJsYXkgd2lkZ2V0cy5cclxuICovXHJcbmV4cG9ydCB2YXIgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZTtcclxuKGZ1bmN0aW9uIChPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIHRoZSBvdmVybGF5IHdpZGdldCBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lclxyXG4gICAgICovXHJcbiAgICBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW092ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJUT1BfUklHSFRfQ09STkVSXCJdID0gMF0gPSBcIlRPUF9SSUdIVF9DT1JORVJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gdGhlIG92ZXJsYXkgd2lkZ2V0IGluIHRoZSBib3R0b20gcmlnaHQgY29ybmVyXHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIkJPVFRPTV9SSUdIVF9DT1JORVJcIl0gPSAxXSA9IFwiQk9UVE9NX1JJR0hUX0NPUk5FUlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiB0aGUgb3ZlcmxheSB3aWRnZXQgaW4gdGhlIHRvcCBjZW50ZXJcclxuICAgICAqL1xyXG4gICAgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiVE9QX0NFTlRFUlwiXSA9IDJdID0gXCJUT1BfQ0VOVEVSXCI7XHJcbn0pKE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UgfHwgKE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UgPSB7fSkpO1xyXG4vKipcclxuICogVmVydGljYWwgTGFuZSBpbiB0aGUgb3ZlcnZpZXcgcnVsZXIgb2YgdGhlIGVkaXRvci5cclxuICovXHJcbmV4cG9ydCB2YXIgT3ZlcnZpZXdSdWxlckxhbmU7XHJcbihmdW5jdGlvbiAoT3ZlcnZpZXdSdWxlckxhbmUpIHtcclxuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiTGVmdFwiXSA9IDFdID0gXCJMZWZ0XCI7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkNlbnRlclwiXSA9IDJdID0gXCJDZW50ZXJcIjtcclxuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiUmlnaHRcIl0gPSA0XSA9IFwiUmlnaHRcIjtcclxuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiRnVsbFwiXSA9IDddID0gXCJGdWxsXCI7XHJcbn0pKE92ZXJ2aWV3UnVsZXJMYW5lIHx8IChPdmVydmlld1J1bGVyTGFuZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBIb3cgYSBwYXJ0aWFsIGFjY2VwdGFuY2Ugd2FzIHRyaWdnZXJlZC5cclxuICovXHJcbmV4cG9ydCB2YXIgUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZCkge1xyXG4gICAgUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1BhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xyXG4gICAgUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1BhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xyXG4gICAgUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1BhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtcIlN1Z2dlc3RcIl0gPSAyXSA9IFwiU3VnZ2VzdFwiO1xyXG59KShQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmQgfHwgKFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgUG9zaXRpb25BZmZpbml0eTtcclxuKGZ1bmN0aW9uIChQb3NpdGlvbkFmZmluaXR5KSB7XHJcbiAgICAvKipcclxuICAgICAqIFByZWZlcnMgdGhlIGxlZnQgbW9zdCBwb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogUHJlZmVycyB0aGUgcmlnaHQgbW9zdCBwb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBObyBwcmVmZXJlbmNlLlxyXG4gICAgKi9cclxuICAgIFBvc2l0aW9uQWZmaW5pdHlbUG9zaXRpb25BZmZpbml0eVtcIk5vbmVcIl0gPSAyXSA9IFwiTm9uZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb24gaW5qZWN0ZWQgdGV4dCwgcHJlZmVycyB0aGUgcG9zaXRpb24gbGVmdCBvZiBpdC5cclxuICAgICovXHJcbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJMZWZ0T2ZJbmplY3RlZFRleHRcIl0gPSAzXSA9IFwiTGVmdE9mSW5qZWN0ZWRUZXh0XCI7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvbiBpbmplY3RlZCB0ZXh0LCBwcmVmZXJzIHRoZSBwb3NpdGlvbiByaWdodCBvZiBpdC5cclxuICAgICovXHJcbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJSaWdodE9mSW5qZWN0ZWRUZXh0XCJdID0gNF0gPSBcIlJpZ2h0T2ZJbmplY3RlZFRleHRcIjtcclxufSkoUG9zaXRpb25BZmZpbml0eSB8fCAoUG9zaXRpb25BZmZpbml0eSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgUmVuZGVyTGluZU51bWJlcnNUeXBlO1xyXG4oZnVuY3Rpb24gKFJlbmRlckxpbmVOdW1iZXJzVHlwZSkge1xyXG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIk9mZlwiXSA9IDBdID0gXCJPZmZcIjtcclxuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJPblwiXSA9IDFdID0gXCJPblwiO1xyXG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIlJlbGF0aXZlXCJdID0gMl0gPSBcIlJlbGF0aXZlXCI7XHJcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiSW50ZXJ2YWxcIl0gPSAzXSA9IFwiSW50ZXJ2YWxcIjtcclxuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJDdXN0b21cIl0gPSA0XSA9IFwiQ3VzdG9tXCI7XHJcbn0pKFJlbmRlckxpbmVOdW1iZXJzVHlwZSB8fCAoUmVuZGVyTGluZU51bWJlcnNUeXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBSZW5kZXJNaW5pbWFwO1xyXG4oZnVuY3Rpb24gKFJlbmRlck1pbmltYXApIHtcclxuICAgIFJlbmRlck1pbmltYXBbUmVuZGVyTWluaW1hcFtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgUmVuZGVyTWluaW1hcFtSZW5kZXJNaW5pbWFwW1wiVGV4dFwiXSA9IDFdID0gXCJUZXh0XCI7XHJcbiAgICBSZW5kZXJNaW5pbWFwW1JlbmRlck1pbmltYXBbXCJCbG9ja3NcIl0gPSAyXSA9IFwiQmxvY2tzXCI7XHJcbn0pKFJlbmRlck1pbmltYXAgfHwgKFJlbmRlck1pbmltYXAgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFNjcm9sbFR5cGU7XHJcbihmdW5jdGlvbiAoU2Nyb2xsVHlwZSkge1xyXG4gICAgU2Nyb2xsVHlwZVtTY3JvbGxUeXBlW1wiU21vb3RoXCJdID0gMF0gPSBcIlNtb290aFwiO1xyXG4gICAgU2Nyb2xsVHlwZVtTY3JvbGxUeXBlW1wiSW1tZWRpYXRlXCJdID0gMV0gPSBcIkltbWVkaWF0ZVwiO1xyXG59KShTY3JvbGxUeXBlIHx8IChTY3JvbGxUeXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBTY3JvbGxiYXJWaXNpYmlsaXR5O1xyXG4oZnVuY3Rpb24gKFNjcm9sbGJhclZpc2liaWxpdHkpIHtcclxuICAgIFNjcm9sbGJhclZpc2liaWxpdHlbU2Nyb2xsYmFyVmlzaWJpbGl0eVtcIkF1dG9cIl0gPSAxXSA9IFwiQXV0b1wiO1xyXG4gICAgU2Nyb2xsYmFyVmlzaWJpbGl0eVtTY3JvbGxiYXJWaXNpYmlsaXR5W1wiSGlkZGVuXCJdID0gMl0gPSBcIkhpZGRlblwiO1xyXG4gICAgU2Nyb2xsYmFyVmlzaWJpbGl0eVtTY3JvbGxiYXJWaXNpYmlsaXR5W1wiVmlzaWJsZVwiXSA9IDNdID0gXCJWaXNpYmxlXCI7XHJcbn0pKFNjcm9sbGJhclZpc2liaWxpdHkgfHwgKFNjcm9sbGJhclZpc2liaWxpdHkgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGRpcmVjdGlvbiBvZiBhIHNlbGVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgU2VsZWN0aW9uRGlyZWN0aW9uO1xyXG4oZnVuY3Rpb24gKFNlbGVjdGlvbkRpcmVjdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VsZWN0aW9uIHN0YXJ0cyBhYm92ZSB3aGVyZSBpdCBlbmRzLlxyXG4gICAgICovXHJcbiAgICBTZWxlY3Rpb25EaXJlY3Rpb25bU2VsZWN0aW9uRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VsZWN0aW9uIHN0YXJ0cyBiZWxvdyB3aGVyZSBpdCBlbmRzLlxyXG4gICAgICovXHJcbiAgICBTZWxlY3Rpb25EaXJlY3Rpb25bU2VsZWN0aW9uRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xyXG59KShTZWxlY3Rpb25EaXJlY3Rpb24gfHwgKFNlbGVjdGlvbkRpcmVjdGlvbiA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgU2hvd0xpZ2h0YnVsYkljb25Nb2RlO1xyXG4oZnVuY3Rpb24gKFNob3dMaWdodGJ1bGJJY29uTW9kZSkge1xyXG4gICAgU2hvd0xpZ2h0YnVsYkljb25Nb2RlW1wiT2ZmXCJdID0gXCJvZmZcIjtcclxuICAgIFNob3dMaWdodGJ1bGJJY29uTW9kZVtcIk9uQ29kZVwiXSA9IFwib25Db2RlXCI7XHJcbiAgICBTaG93TGlnaHRidWxiSWNvbk1vZGVbXCJPblwiXSA9IFwib25cIjtcclxufSkoU2hvd0xpZ2h0YnVsYkljb25Nb2RlIHx8IChTaG93TGlnaHRidWxiSWNvbk1vZGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQpIHtcclxuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiVHJpZ2dlckNoYXJhY3RlclwiXSA9IDJdID0gXCJUcmlnZ2VyQ2hhcmFjdGVyXCI7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiQ29udGVudENoYW5nZVwiXSA9IDNdID0gXCJDb250ZW50Q2hhbmdlXCI7XHJcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIEEgc3ltYm9sIGtpbmQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFN5bWJvbEtpbmQ7XHJcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmlsZVwiXSA9IDBdID0gXCJGaWxlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJNb2R1bGVcIl0gPSAxXSA9IFwiTW9kdWxlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJOYW1lc3BhY2VcIl0gPSAyXSA9IFwiTmFtZXNwYWNlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQYWNrYWdlXCJdID0gM10gPSBcIlBhY2thZ2VcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNsYXNzXCJdID0gNF0gPSBcIkNsYXNzXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJNZXRob2RcIl0gPSA1XSA9IFwiTWV0aG9kXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQcm9wZXJ0eVwiXSA9IDZdID0gXCJQcm9wZXJ0eVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmllbGRcIl0gPSA3XSA9IFwiRmllbGRcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNvbnN0cnVjdG9yXCJdID0gOF0gPSBcIkNvbnN0cnVjdG9yXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtXCJdID0gOV0gPSBcIkVudW1cIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkludGVyZmFjZVwiXSA9IDEwXSA9IFwiSW50ZXJmYWNlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJGdW5jdGlvblwiXSA9IDExXSA9IFwiRnVuY3Rpb25cIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlZhcmlhYmxlXCJdID0gMTJdID0gXCJWYXJpYWJsZVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQ29uc3RhbnRcIl0gPSAxM10gPSBcIkNvbnN0YW50XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJTdHJpbmdcIl0gPSAxNF0gPSBcIlN0cmluZ1wiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTnVtYmVyXCJdID0gMTVdID0gXCJOdW1iZXJcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkJvb2xlYW5cIl0gPSAxNl0gPSBcIkJvb2xlYW5cIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkFycmF5XCJdID0gMTddID0gXCJBcnJheVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiT2JqZWN0XCJdID0gMThdID0gXCJPYmplY3RcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIktleVwiXSA9IDE5XSA9IFwiS2V5XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJOdWxsXCJdID0gMjBdID0gXCJOdWxsXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtTWVtYmVyXCJdID0gMjFdID0gXCJFbnVtTWVtYmVyXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJTdHJ1Y3RcIl0gPSAyMl0gPSBcIlN0cnVjdFwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRXZlbnRcIl0gPSAyM10gPSBcIkV2ZW50XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJPcGVyYXRvclwiXSA9IDI0XSA9IFwiT3BlcmF0b3JcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlR5cGVQYXJhbWV0ZXJcIl0gPSAyNV0gPSBcIlR5cGVQYXJhbWV0ZXJcIjtcclxufSkoU3ltYm9sS2luZCB8fCAoU3ltYm9sS2luZCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgU3ltYm9sVGFnO1xyXG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xyXG4gICAgU3ltYm9sVGFnW1N5bWJvbFRhZ1tcIkRlcHJlY2F0ZWRcIl0gPSAxXSA9IFwiRGVwcmVjYXRlZFwiO1xyXG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUga2luZCBvZiBhbmltYXRpb24gaW4gd2hpY2ggdGhlIGVkaXRvcidzIGN1cnNvciBzaG91bGQgYmUgcmVuZGVyZWQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlO1xyXG4oZnVuY3Rpb24gKFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEhpZGRlblxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkhpZGRlblwiXSA9IDBdID0gXCJIaWRkZW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogQmxpbmtpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJCbGlua1wiXSA9IDFdID0gXCJCbGlua1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCbGlua2luZyB3aXRoIHNtb290aCBmYWRpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJTbW9vdGhcIl0gPSAyXSA9IFwiU21vb3RoXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJsaW5raW5nIHdpdGggcHJvbG9uZ2VkIGZpbGxlZCBzdGF0ZSBhbmQgc21vb3RoIGZhZGluZ1xyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlBoYXNlXCJdID0gM10gPSBcIlBoYXNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEV4cGFuZCBjb2xsYXBzZSBhbmltYXRpb24gb24gdGhlIHkgYXhpc1xyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkV4cGFuZFwiXSA9IDRdID0gXCJFeHBhbmRcIjtcclxuICAgIC8qKlxyXG4gICAgICogTm8tQmxpbmtpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJTb2xpZFwiXSA9IDVdID0gXCJTb2xpZFwiO1xyXG59KShUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSB8fCAoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIHN0eWxlIGluIHdoaWNoIHRoZSBlZGl0b3IncyBjdXJzb3Igc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gKi9cclxuZXhwb3J0IHZhciBUZXh0RWRpdG9yQ3Vyc29yU3R5bGU7XHJcbihmdW5jdGlvbiAoVGV4dEVkaXRvckN1cnNvclN0eWxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFzIGEgdmVydGljYWwgbGluZSAoc2l0dGluZyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzKS5cclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcyBhIGJsb2NrIChzaXR0aW5nIG9uIHRvcCBvZiBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJCbG9ja1wiXSA9IDJdID0gXCJCbG9ja1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcyBhIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJVbmRlcmxpbmVcIl0gPSAzXSA9IFwiVW5kZXJsaW5lXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFzIGEgdGhpbiB2ZXJ0aWNhbCBsaW5lIChzaXR0aW5nIGJldHdlZW4gdHdvIGNoYXJhY3RlcnMpLlxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiTGluZVRoaW5cIl0gPSA0XSA9IFwiTGluZVRoaW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogQXMgYW4gb3V0bGluZWQgYmxvY2sgKHNpdHRpbmcgb24gdG9wIG9mIGEgY2hhcmFjdGVyKS5cclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkJsb2NrT3V0bGluZVwiXSA9IDVdID0gXCJCbG9ja091dGxpbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXMgYSB0aGluIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJVbmRlcmxpbmVUaGluXCJdID0gNl0gPSBcIlVuZGVybGluZVRoaW5cIjtcclxufSkoVGV4dEVkaXRvckN1cnNvclN0eWxlIHx8IChUZXh0RWRpdG9yQ3Vyc29yU3R5bGUgPSB7fSkpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIHRoZSBiZWhhdmlvciBvZiBkZWNvcmF0aW9ucyB3aGVuIHR5cGluZy9lZGl0aW5nIG5lYXIgdGhlaXIgZWRnZXMuXHJcbiAqIE5vdGU6IFBsZWFzZSBkbyBub3QgZWRpdCB0aGUgdmFsdWVzLCBhcyB0aGV5IHZlcnkgY2FyZWZ1bGx5IG1hdGNoIGBEZWNvcmF0aW9uUmFuZ2VCZWhhdmlvcmBcclxuICovXHJcbmV4cG9ydCB2YXIgVHJhY2tlZFJhbmdlU3RpY2tpbmVzcztcclxuKGZ1bmN0aW9uIChUcmFja2VkUmFuZ2VTdGlja2luZXNzKSB7XHJcbiAgICBUcmFja2VkUmFuZ2VTdGlja2luZXNzW1RyYWNrZWRSYW5nZVN0aWNraW5lc3NbXCJBbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCJdID0gMF0gPSBcIkFsd2F5c0dyb3dzV2hlblR5cGluZ0F0RWRnZXNcIjtcclxuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIk5ldmVyR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiXSA9IDFdID0gXCJOZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXNcIjtcclxuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdCZWZvcmVcIl0gPSAyXSA9IFwiR3Jvd3NPbmx5V2hlblR5cGluZ0JlZm9yZVwiO1xyXG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiR3Jvd3NPbmx5V2hlblR5cGluZ0FmdGVyXCJdID0gM10gPSBcIkdyb3dzT25seVdoZW5UeXBpbmdBZnRlclwiO1xyXG59KShUcmFja2VkUmFuZ2VTdGlja2luZXNzIHx8IChUcmFja2VkUmFuZ2VTdGlja2luZXNzID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBob3cgdG8gaW5kZW50IHdyYXBwZWQgbGluZXMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFdyYXBwaW5nSW5kZW50O1xyXG4oZnVuY3Rpb24gKFdyYXBwaW5nSW5kZW50KSB7XHJcbiAgICAvKipcclxuICAgICAqIE5vIGluZGVudGF0aW9uID0+IHdyYXBwZWQgbGluZXMgYmVnaW4gYXQgY29sdW1uIDEuXHJcbiAgICAgKi9cclxuICAgIFdyYXBwaW5nSW5kZW50W1dyYXBwaW5nSW5kZW50W1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNhbWUgPT4gd3JhcHBlZCBsaW5lcyBnZXQgdGhlIHNhbWUgaW5kZW50YXRpb24gYXMgdGhlIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJTYW1lXCJdID0gMV0gPSBcIlNhbWVcIjtcclxuICAgIC8qKlxyXG4gICAgICogSW5kZW50ID0+IHdyYXBwZWQgbGluZXMgZ2V0ICsxIGluZGVudGF0aW9uIHRvd2FyZCB0aGUgcGFyZW50LlxyXG4gICAgICovXHJcbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIkluZGVudFwiXSA9IDJdID0gXCJJbmRlbnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGVlcEluZGVudCA9PiB3cmFwcGVkIGxpbmVzIGdldCArMiBpbmRlbnRhdGlvbiB0b3dhcmQgdGhlIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJEZWVwSW5kZW50XCJdID0gM10gPSBcIkRlZXBJbmRlbnRcIjtcclxufSkoV3JhcHBpbmdJbmRlbnQgfHwgKFdyYXBwaW5nSW5kZW50ID0ge30pKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenizationRegistry: () => (/* binding */ TokenizationRegistry)\n/* harmony export */ });\n/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base/common/lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass TokenizationRegistry {\r\n    constructor() {\r\n        this._tokenizationSupports = new Map();\r\n        this._factories = new Map();\r\n        this._onDidChange = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();\r\n        this.onDidChange = this._onDidChange.event;\r\n        this._colorMap = null;\r\n    }\r\n    handleChange(languageIds) {\r\n        this._onDidChange.fire({\r\n            changedLanguages: languageIds,\r\n            changedColorMap: false\r\n        });\r\n    }\r\n    register(languageId, support) {\r\n        this._tokenizationSupports.set(languageId, support);\r\n        this.handleChange([languageId]);\r\n        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {\r\n            if (this._tokenizationSupports.get(languageId) !== support) {\r\n                return;\r\n            }\r\n            this._tokenizationSupports.delete(languageId);\r\n            this.handleChange([languageId]);\r\n        });\r\n    }\r\n    get(languageId) {\r\n        return this._tokenizationSupports.get(languageId) || null;\r\n    }\r\n    registerFactory(languageId, factory) {\r\n        var _a;\r\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\r\n        this._factories.set(languageId, myData);\r\n        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {\r\n            const v = this._factories.get(languageId);\r\n            if (!v || v !== myData) {\r\n                return;\r\n            }\r\n            this._factories.delete(languageId);\r\n            v.dispose();\r\n        });\r\n    }\r\n    async getOrCreate(languageId) {\r\n        // check first if the support is already set\r\n        const tokenizationSupport = this.get(languageId);\r\n        if (tokenizationSupport) {\r\n            return tokenizationSupport;\r\n        }\r\n        const factory = this._factories.get(languageId);\r\n        if (!factory || factory.isResolved) {\r\n            // no factory or factory.resolve already finished\r\n            return null;\r\n        }\r\n        await factory.resolve();\r\n        return this.get(languageId);\r\n    }\r\n    isResolved(languageId) {\r\n        const tokenizationSupport = this.get(languageId);\r\n        if (tokenizationSupport) {\r\n            return true;\r\n        }\r\n        const factory = this._factories.get(languageId);\r\n        if (!factory || factory.isResolved) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setColorMap(colorMap) {\r\n        this._colorMap = colorMap;\r\n        this._onDidChange.fire({\r\n            changedLanguages: Array.from(this._tokenizationSupports.keys()),\r\n            changedColorMap: true\r\n        });\r\n    }\r\n    getColorMap() {\r\n        return this._colorMap;\r\n    }\r\n    getDefaultBackground() {\r\n        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {\r\n            return this._colorMap[2 /* ColorId.DefaultBackground */];\r\n        }\r\n        return null;\r\n    }\r\n}\r\nclass TokenizationSupportFactoryData extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {\r\n    get isResolved() {\r\n        return this._isResolved;\r\n    }\r\n    constructor(_registry, _languageId, _factory) {\r\n        super();\r\n        this._registry = _registry;\r\n        this._languageId = _languageId;\r\n        this._factory = _factory;\r\n        this._isDisposed = false;\r\n        this._resolvePromise = null;\r\n        this._isResolved = false;\r\n    }\r\n    dispose() {\r\n        this._isDisposed = true;\r\n        super.dispose();\r\n    }\r\n    async resolve() {\r\n        if (!this._resolvePromise) {\r\n            this._resolvePromise = this._create();\r\n        }\r\n        return this._resolvePromise;\r\n    }\r\n    async _create() {\r\n        const value = await this._factory.tokenizationSupport;\r\n        this._isResolved = true;\r\n        if (value && !this._isDisposed) {\r\n            this._register(this._registry.register(this._languageId, value));\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbml6YXRpb25SZWdpc3RyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRDtBQUNxQjtBQUNuRTtBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUVBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVFQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlFQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3Rva2VuaXphdGlvblJlZ2lzdHJ5LmpzPzRhNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XHJcbmltcG9ydCB7IERpc3Bvc2FibGUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4uLy4uL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcyc7XHJcbmV4cG9ydCBjbGFzcyBUb2tlbml6YXRpb25SZWdpc3RyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9mYWN0b3JpZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2UgPSB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcclxuICAgICAgICB0aGlzLl9jb2xvck1hcCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDaGFuZ2UobGFuZ3VhZ2VJZHMpIHtcclxuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZS5maXJlKHtcclxuICAgICAgICAgICAgY2hhbmdlZExhbmd1YWdlczogbGFuZ3VhZ2VJZHMsXHJcbiAgICAgICAgICAgIGNoYW5nZWRDb2xvck1hcDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyKGxhbmd1YWdlSWQsIHN1cHBvcnQpIHtcclxuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cy5zZXQobGFuZ3VhZ2VJZCwgc3VwcG9ydCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoW2xhbmd1YWdlSWRdKTtcclxuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnRzLmdldChsYW5ndWFnZUlkKSAhPT0gc3VwcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnRzLmRlbGV0ZShsYW5ndWFnZUlkKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoW2xhbmd1YWdlSWRdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldChsYW5ndWFnZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnRzLmdldChsYW5ndWFnZUlkKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJGYWN0b3J5KGxhbmd1YWdlSWQsIGZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5fZmFjdG9yaWVzLmdldChsYW5ndWFnZUlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcclxuICAgICAgICBjb25zdCBteURhdGEgPSBuZXcgVG9rZW5pemF0aW9uU3VwcG9ydEZhY3RvcnlEYXRhKHRoaXMsIGxhbmd1YWdlSWQsIGZhY3RvcnkpO1xyXG4gICAgICAgIHRoaXMuX2ZhY3Rvcmllcy5zZXQobGFuZ3VhZ2VJZCwgbXlEYXRhKTtcclxuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuX2ZhY3Rvcmllcy5nZXQobGFuZ3VhZ2VJZCk7XHJcbiAgICAgICAgICAgIGlmICghdiB8fCB2ICE9PSBteURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMuZGVsZXRlKGxhbmd1YWdlSWQpO1xyXG4gICAgICAgICAgICB2LmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldE9yQ3JlYXRlKGxhbmd1YWdlSWQpIHtcclxuICAgICAgICAvLyBjaGVjayBmaXJzdCBpZiB0aGUgc3VwcG9ydCBpcyBhbHJlYWR5IHNldFxyXG4gICAgICAgIGNvbnN0IHRva2VuaXphdGlvblN1cHBvcnQgPSB0aGlzLmdldChsYW5ndWFnZUlkKTtcclxuICAgICAgICBpZiAodG9rZW5pemF0aW9uU3VwcG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5pemF0aW9uU3VwcG9ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuX2ZhY3Rvcmllcy5nZXQobGFuZ3VhZ2VJZCk7XHJcbiAgICAgICAgaWYgKCFmYWN0b3J5IHx8IGZhY3RvcnkuaXNSZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAvLyBubyBmYWN0b3J5IG9yIGZhY3RvcnkucmVzb2x2ZSBhbHJlYWR5IGZpbmlzaGVkXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBmYWN0b3J5LnJlc29sdmUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQobGFuZ3VhZ2VJZCk7XHJcbiAgICB9XHJcbiAgICBpc1Jlc29sdmVkKGxhbmd1YWdlSWQpIHtcclxuICAgICAgICBjb25zdCB0b2tlbml6YXRpb25TdXBwb3J0ID0gdGhpcy5nZXQobGFuZ3VhZ2VJZCk7XHJcbiAgICAgICAgaWYgKHRva2VuaXphdGlvblN1cHBvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGxhbmd1YWdlSWQpO1xyXG4gICAgICAgIGlmICghZmFjdG9yeSB8fCBmYWN0b3J5LmlzUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHNldENvbG9yTWFwKGNvbG9yTWFwKSB7XHJcbiAgICAgICAgdGhpcy5fY29sb3JNYXAgPSBjb2xvck1hcDtcclxuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZS5maXJlKHtcclxuICAgICAgICAgICAgY2hhbmdlZExhbmd1YWdlczogQXJyYXkuZnJvbSh0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cy5rZXlzKCkpLFxyXG4gICAgICAgICAgICBjaGFuZ2VkQ29sb3JNYXA6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENvbG9yTWFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvck1hcDtcclxuICAgIH1cclxuICAgIGdldERlZmF1bHRCYWNrZ3JvdW5kKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xvck1hcCAmJiB0aGlzLl9jb2xvck1hcC5sZW5ndGggPiAyIC8qIENvbG9ySWQuRGVmYXVsdEJhY2tncm91bmQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yTWFwWzIgLyogQ29sb3JJZC5EZWZhdWx0QmFja2dyb3VuZCAqL107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFRva2VuaXphdGlvblN1cHBvcnRGYWN0b3J5RGF0YSBleHRlbmRzIERpc3Bvc2FibGUge1xyXG4gICAgZ2V0IGlzUmVzb2x2ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmVzb2x2ZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihfcmVnaXN0cnksIF9sYW5ndWFnZUlkLCBfZmFjdG9yeSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSBfcmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IF9sYW5ndWFnZUlkO1xyXG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBfZmFjdG9yeTtcclxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2lzUmVzb2x2ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVzb2x2ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Jlc29sdmVQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9taXNlID0gdGhpcy5fY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUHJvbWlzZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9jcmVhdGUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLl9mYWN0b3J5LnRva2VuaXphdGlvblN1cHBvcnQ7XHJcbiAgICAgICAgdGhpcy5faXNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyKHRoaXMuX3JlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMuX2xhbmd1YWdlSWQsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/editor.worker.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/editor.worker.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initialize: () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/common/worker/simpleWorker.js */ \"./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\");\n/* harmony import */ var _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/services/editorSimpleWorker.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nlet initialized = false;\r\nfunction initialize(foreignModule) {\r\n    if (initialized) {\r\n        return;\r\n    }\r\n    initialized = true;\r\n    const simpleWorker = new _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__.SimpleWorkerServer((msg) => {\r\n        globalThis.postMessage(msg);\r\n    }, (host) => new _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__.EditorSimpleWorker(host, foreignModule));\r\n    globalThis.onmessage = (e) => {\r\n        simpleWorker.onmessage(e.data);\r\n    };\r\n}\r\nglobalThis.onmessage = (e) => {\r\n    // Ignore first message in this case and initialize if not yet initialized\r\n    if (!initialized) {\r\n        initialize(null);\r\n    }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2VkaXRvci53b3JrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMkU7QUFDRTtBQUM3RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQWtCO0FBQy9DO0FBQ0EsS0FBSyxnQkFBZ0Isc0ZBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9lZGl0b3Iud29ya2VyLmpzP2U1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IFNpbXBsZVdvcmtlclNlcnZlciB9IGZyb20gJy4uL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanMnO1xyXG5pbXBvcnQgeyBFZGl0b3JTaW1wbGVXb3JrZXIgfSBmcm9tICcuL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMnO1xyXG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUoZm9yZWlnbk1vZHVsZSkge1xyXG4gICAgaWYgKGluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgY29uc3Qgc2ltcGxlV29ya2VyID0gbmV3IFNpbXBsZVdvcmtlclNlcnZlcigobXNnKSA9PiB7XHJcbiAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZShtc2cpO1xyXG4gICAgfSwgKGhvc3QpID0+IG5ldyBFZGl0b3JTaW1wbGVXb3JrZXIoaG9zdCwgZm9yZWlnbk1vZHVsZSkpO1xyXG4gICAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgIHNpbXBsZVdvcmtlci5vbm1lc3NhZ2UoZS5kYXRhKTtcclxuICAgIH07XHJcbn1cclxuZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgLy8gSWdub3JlIGZpcnN0IG1lc3NhZ2UgaW4gdGhpcyBjYXNlIGFuZCBpbml0aWFsaXplIGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcclxuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICBpbml0aWFsaXplKG51bGwpO1xyXG4gICAgfVxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/editor.worker.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/language/json/json.worker.js":
/*!************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/language/json/json.worker.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _editor_editor_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../editor/editor.worker.js */ \"./node_modules/monaco-editor/esm/vs/editor/editor.worker.js\");\n/*!-----------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)\r\n * Released under the MIT license\r\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\r\n *-----------------------------------------------------------------------------*/\r\n\r\n\r\n// src/language/json/json.worker.ts\r\n\r\n\r\n// node_modules/jsonc-parser/lib/esm/impl/scanner.js\r\nfunction createScanner(text, ignoreTrivia = false) {\r\n  const len = text.length;\r\n  let pos = 0, value = \"\", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;\r\n  function scanHexDigits(count, exact) {\r\n    let digits = 0;\r\n    let value2 = 0;\r\n    while (digits < count || !exact) {\r\n      let ch = text.charCodeAt(pos);\r\n      if (ch >= 48 && ch <= 57) {\r\n        value2 = value2 * 16 + ch - 48;\r\n      } else if (ch >= 65 && ch <= 70) {\r\n        value2 = value2 * 16 + ch - 65 + 10;\r\n      } else if (ch >= 97 && ch <= 102) {\r\n        value2 = value2 * 16 + ch - 97 + 10;\r\n      } else {\r\n        break;\r\n      }\r\n      pos++;\r\n      digits++;\r\n    }\r\n    if (digits < count) {\r\n      value2 = -1;\r\n    }\r\n    return value2;\r\n  }\r\n  function setPosition(newPosition) {\r\n    pos = newPosition;\r\n    value = \"\";\r\n    tokenOffset = 0;\r\n    token = 16;\r\n    scanError = 0;\r\n  }\r\n  function scanNumber() {\r\n    let start = pos;\r\n    if (text.charCodeAt(pos) === 48) {\r\n      pos++;\r\n    } else {\r\n      pos++;\r\n      while (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n        pos++;\r\n      }\r\n    }\r\n    if (pos < text.length && text.charCodeAt(pos) === 46) {\r\n      pos++;\r\n      if (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n        pos++;\r\n        while (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n          pos++;\r\n        }\r\n      } else {\r\n        scanError = 3;\r\n        return text.substring(start, pos);\r\n      }\r\n    }\r\n    let end = pos;\r\n    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {\r\n      pos++;\r\n      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {\r\n        pos++;\r\n      }\r\n      if (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n        pos++;\r\n        while (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n          pos++;\r\n        }\r\n        end = pos;\r\n      } else {\r\n        scanError = 3;\r\n      }\r\n    }\r\n    return text.substring(start, end);\r\n  }\r\n  function scanString() {\r\n    let result = \"\", start = pos;\r\n    while (true) {\r\n      if (pos >= len) {\r\n        result += text.substring(start, pos);\r\n        scanError = 2;\r\n        break;\r\n      }\r\n      const ch = text.charCodeAt(pos);\r\n      if (ch === 34) {\r\n        result += text.substring(start, pos);\r\n        pos++;\r\n        break;\r\n      }\r\n      if (ch === 92) {\r\n        result += text.substring(start, pos);\r\n        pos++;\r\n        if (pos >= len) {\r\n          scanError = 2;\r\n          break;\r\n        }\r\n        const ch2 = text.charCodeAt(pos++);\r\n        switch (ch2) {\r\n          case 34:\r\n            result += '\"';\r\n            break;\r\n          case 92:\r\n            result += \"\\\\\";\r\n            break;\r\n          case 47:\r\n            result += \"/\";\r\n            break;\r\n          case 98:\r\n            result += \"\\b\";\r\n            break;\r\n          case 102:\r\n            result += \"\\f\";\r\n            break;\r\n          case 110:\r\n            result += \"\\n\";\r\n            break;\r\n          case 114:\r\n            result += \"\\r\";\r\n            break;\r\n          case 116:\r\n            result += \"\t\";\r\n            break;\r\n          case 117:\r\n            const ch3 = scanHexDigits(4, true);\r\n            if (ch3 >= 0) {\r\n              result += String.fromCharCode(ch3);\r\n            } else {\r\n              scanError = 4;\r\n            }\r\n            break;\r\n          default:\r\n            scanError = 5;\r\n        }\r\n        start = pos;\r\n        continue;\r\n      }\r\n      if (ch >= 0 && ch <= 31) {\r\n        if (isLineBreak(ch)) {\r\n          result += text.substring(start, pos);\r\n          scanError = 2;\r\n          break;\r\n        } else {\r\n          scanError = 6;\r\n        }\r\n      }\r\n      pos++;\r\n    }\r\n    return result;\r\n  }\r\n  function scanNext() {\r\n    value = \"\";\r\n    scanError = 0;\r\n    tokenOffset = pos;\r\n    lineStartOffset = lineNumber;\r\n    prevTokenLineStartOffset = tokenLineStartOffset;\r\n    if (pos >= len) {\r\n      tokenOffset = len;\r\n      return token = 17;\r\n    }\r\n    let code = text.charCodeAt(pos);\r\n    if (isWhiteSpace(code)) {\r\n      do {\r\n        pos++;\r\n        value += String.fromCharCode(code);\r\n        code = text.charCodeAt(pos);\r\n      } while (isWhiteSpace(code));\r\n      return token = 15;\r\n    }\r\n    if (isLineBreak(code)) {\r\n      pos++;\r\n      value += String.fromCharCode(code);\r\n      if (code === 13 && text.charCodeAt(pos) === 10) {\r\n        pos++;\r\n        value += \"\\n\";\r\n      }\r\n      lineNumber++;\r\n      tokenLineStartOffset = pos;\r\n      return token = 14;\r\n    }\r\n    switch (code) {\r\n      case 123:\r\n        pos++;\r\n        return token = 1;\r\n      case 125:\r\n        pos++;\r\n        return token = 2;\r\n      case 91:\r\n        pos++;\r\n        return token = 3;\r\n      case 93:\r\n        pos++;\r\n        return token = 4;\r\n      case 58:\r\n        pos++;\r\n        return token = 6;\r\n      case 44:\r\n        pos++;\r\n        return token = 5;\r\n      case 34:\r\n        pos++;\r\n        value = scanString();\r\n        return token = 10;\r\n      case 47:\r\n        const start = pos - 1;\r\n        if (text.charCodeAt(pos + 1) === 47) {\r\n          pos += 2;\r\n          while (pos < len) {\r\n            if (isLineBreak(text.charCodeAt(pos))) {\r\n              break;\r\n            }\r\n            pos++;\r\n          }\r\n          value = text.substring(start, pos);\r\n          return token = 12;\r\n        }\r\n        if (text.charCodeAt(pos + 1) === 42) {\r\n          pos += 2;\r\n          const safeLength = len - 1;\r\n          let commentClosed = false;\r\n          while (pos < safeLength) {\r\n            const ch = text.charCodeAt(pos);\r\n            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {\r\n              pos += 2;\r\n              commentClosed = true;\r\n              break;\r\n            }\r\n            pos++;\r\n            if (isLineBreak(ch)) {\r\n              if (ch === 13 && text.charCodeAt(pos) === 10) {\r\n                pos++;\r\n              }\r\n              lineNumber++;\r\n              tokenLineStartOffset = pos;\r\n            }\r\n          }\r\n          if (!commentClosed) {\r\n            pos++;\r\n            scanError = 1;\r\n          }\r\n          value = text.substring(start, pos);\r\n          return token = 13;\r\n        }\r\n        value += String.fromCharCode(code);\r\n        pos++;\r\n        return token = 16;\r\n      case 45:\r\n        value += String.fromCharCode(code);\r\n        pos++;\r\n        if (pos === len || !isDigit(text.charCodeAt(pos))) {\r\n          return token = 16;\r\n        }\r\n      case 48:\r\n      case 49:\r\n      case 50:\r\n      case 51:\r\n      case 52:\r\n      case 53:\r\n      case 54:\r\n      case 55:\r\n      case 56:\r\n      case 57:\r\n        value += scanNumber();\r\n        return token = 11;\r\n      default:\r\n        while (pos < len && isUnknownContentCharacter(code)) {\r\n          pos++;\r\n          code = text.charCodeAt(pos);\r\n        }\r\n        if (tokenOffset !== pos) {\r\n          value = text.substring(tokenOffset, pos);\r\n          switch (value) {\r\n            case \"true\":\r\n              return token = 8;\r\n            case \"false\":\r\n              return token = 9;\r\n            case \"null\":\r\n              return token = 7;\r\n          }\r\n          return token = 16;\r\n        }\r\n        value += String.fromCharCode(code);\r\n        pos++;\r\n        return token = 16;\r\n    }\r\n  }\r\n  function isUnknownContentCharacter(code) {\r\n    if (isWhiteSpace(code) || isLineBreak(code)) {\r\n      return false;\r\n    }\r\n    switch (code) {\r\n      case 125:\r\n      case 93:\r\n      case 123:\r\n      case 91:\r\n      case 34:\r\n      case 58:\r\n      case 44:\r\n      case 47:\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  function scanNextNonTrivia() {\r\n    let result;\r\n    do {\r\n      result = scanNext();\r\n    } while (result >= 12 && result <= 15);\r\n    return result;\r\n  }\r\n  return {\r\n    setPosition,\r\n    getPosition: () => pos,\r\n    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\r\n    getToken: () => token,\r\n    getTokenValue: () => value,\r\n    getTokenOffset: () => tokenOffset,\r\n    getTokenLength: () => pos - tokenOffset,\r\n    getTokenStartLine: () => lineStartOffset,\r\n    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,\r\n    getTokenError: () => scanError\r\n  };\r\n}\r\nfunction isWhiteSpace(ch) {\r\n  return ch === 32 || ch === 9;\r\n}\r\nfunction isLineBreak(ch) {\r\n  return ch === 10 || ch === 13;\r\n}\r\nfunction isDigit(ch) {\r\n  return ch >= 48 && ch <= 57;\r\n}\r\nvar CharacterCodes;\r\n(function(CharacterCodes2) {\r\n  CharacterCodes2[CharacterCodes2[\"lineFeed\"] = 10] = \"lineFeed\";\r\n  CharacterCodes2[CharacterCodes2[\"carriageReturn\"] = 13] = \"carriageReturn\";\r\n  CharacterCodes2[CharacterCodes2[\"space\"] = 32] = \"space\";\r\n  CharacterCodes2[CharacterCodes2[\"_0\"] = 48] = \"_0\";\r\n  CharacterCodes2[CharacterCodes2[\"_1\"] = 49] = \"_1\";\r\n  CharacterCodes2[CharacterCodes2[\"_2\"] = 50] = \"_2\";\r\n  CharacterCodes2[CharacterCodes2[\"_3\"] = 51] = \"_3\";\r\n  CharacterCodes2[CharacterCodes2[\"_4\"] = 52] = \"_4\";\r\n  CharacterCodes2[CharacterCodes2[\"_5\"] = 53] = \"_5\";\r\n  CharacterCodes2[CharacterCodes2[\"_6\"] = 54] = \"_6\";\r\n  CharacterCodes2[CharacterCodes2[\"_7\"] = 55] = \"_7\";\r\n  CharacterCodes2[CharacterCodes2[\"_8\"] = 56] = \"_8\";\r\n  CharacterCodes2[CharacterCodes2[\"_9\"] = 57] = \"_9\";\r\n  CharacterCodes2[CharacterCodes2[\"a\"] = 97] = \"a\";\r\n  CharacterCodes2[CharacterCodes2[\"b\"] = 98] = \"b\";\r\n  CharacterCodes2[CharacterCodes2[\"c\"] = 99] = \"c\";\r\n  CharacterCodes2[CharacterCodes2[\"d\"] = 100] = \"d\";\r\n  CharacterCodes2[CharacterCodes2[\"e\"] = 101] = \"e\";\r\n  CharacterCodes2[CharacterCodes2[\"f\"] = 102] = \"f\";\r\n  CharacterCodes2[CharacterCodes2[\"g\"] = 103] = \"g\";\r\n  CharacterCodes2[CharacterCodes2[\"h\"] = 104] = \"h\";\r\n  CharacterCodes2[CharacterCodes2[\"i\"] = 105] = \"i\";\r\n  CharacterCodes2[CharacterCodes2[\"j\"] = 106] = \"j\";\r\n  CharacterCodes2[CharacterCodes2[\"k\"] = 107] = \"k\";\r\n  CharacterCodes2[CharacterCodes2[\"l\"] = 108] = \"l\";\r\n  CharacterCodes2[CharacterCodes2[\"m\"] = 109] = \"m\";\r\n  CharacterCodes2[CharacterCodes2[\"n\"] = 110] = \"n\";\r\n  CharacterCodes2[CharacterCodes2[\"o\"] = 111] = \"o\";\r\n  CharacterCodes2[CharacterCodes2[\"p\"] = 112] = \"p\";\r\n  CharacterCodes2[CharacterCodes2[\"q\"] = 113] = \"q\";\r\n  CharacterCodes2[CharacterCodes2[\"r\"] = 114] = \"r\";\r\n  CharacterCodes2[CharacterCodes2[\"s\"] = 115] = \"s\";\r\n  CharacterCodes2[CharacterCodes2[\"t\"] = 116] = \"t\";\r\n  CharacterCodes2[CharacterCodes2[\"u\"] = 117] = \"u\";\r\n  CharacterCodes2[CharacterCodes2[\"v\"] = 118] = \"v\";\r\n  CharacterCodes2[CharacterCodes2[\"w\"] = 119] = \"w\";\r\n  CharacterCodes2[CharacterCodes2[\"x\"] = 120] = \"x\";\r\n  CharacterCodes2[CharacterCodes2[\"y\"] = 121] = \"y\";\r\n  CharacterCodes2[CharacterCodes2[\"z\"] = 122] = \"z\";\r\n  CharacterCodes2[CharacterCodes2[\"A\"] = 65] = \"A\";\r\n  CharacterCodes2[CharacterCodes2[\"B\"] = 66] = \"B\";\r\n  CharacterCodes2[CharacterCodes2[\"C\"] = 67] = \"C\";\r\n  CharacterCodes2[CharacterCodes2[\"D\"] = 68] = \"D\";\r\n  CharacterCodes2[CharacterCodes2[\"E\"] = 69] = \"E\";\r\n  CharacterCodes2[CharacterCodes2[\"F\"] = 70] = \"F\";\r\n  CharacterCodes2[CharacterCodes2[\"G\"] = 71] = \"G\";\r\n  CharacterCodes2[CharacterCodes2[\"H\"] = 72] = \"H\";\r\n  CharacterCodes2[CharacterCodes2[\"I\"] = 73] = \"I\";\r\n  CharacterCodes2[CharacterCodes2[\"J\"] = 74] = \"J\";\r\n  CharacterCodes2[CharacterCodes2[\"K\"] = 75] = \"K\";\r\n  CharacterCodes2[CharacterCodes2[\"L\"] = 76] = \"L\";\r\n  CharacterCodes2[CharacterCodes2[\"M\"] = 77] = \"M\";\r\n  CharacterCodes2[CharacterCodes2[\"N\"] = 78] = \"N\";\r\n  CharacterCodes2[CharacterCodes2[\"O\"] = 79] = \"O\";\r\n  CharacterCodes2[CharacterCodes2[\"P\"] = 80] = \"P\";\r\n  CharacterCodes2[CharacterCodes2[\"Q\"] = 81] = \"Q\";\r\n  CharacterCodes2[CharacterCodes2[\"R\"] = 82] = \"R\";\r\n  CharacterCodes2[CharacterCodes2[\"S\"] = 83] = \"S\";\r\n  CharacterCodes2[CharacterCodes2[\"T\"] = 84] = \"T\";\r\n  CharacterCodes2[CharacterCodes2[\"U\"] = 85] = \"U\";\r\n  CharacterCodes2[CharacterCodes2[\"V\"] = 86] = \"V\";\r\n  CharacterCodes2[CharacterCodes2[\"W\"] = 87] = \"W\";\r\n  CharacterCodes2[CharacterCodes2[\"X\"] = 88] = \"X\";\r\n  CharacterCodes2[CharacterCodes2[\"Y\"] = 89] = \"Y\";\r\n  CharacterCodes2[CharacterCodes2[\"Z\"] = 90] = \"Z\";\r\n  CharacterCodes2[CharacterCodes2[\"asterisk\"] = 42] = \"asterisk\";\r\n  CharacterCodes2[CharacterCodes2[\"backslash\"] = 92] = \"backslash\";\r\n  CharacterCodes2[CharacterCodes2[\"closeBrace\"] = 125] = \"closeBrace\";\r\n  CharacterCodes2[CharacterCodes2[\"closeBracket\"] = 93] = \"closeBracket\";\r\n  CharacterCodes2[CharacterCodes2[\"colon\"] = 58] = \"colon\";\r\n  CharacterCodes2[CharacterCodes2[\"comma\"] = 44] = \"comma\";\r\n  CharacterCodes2[CharacterCodes2[\"dot\"] = 46] = \"dot\";\r\n  CharacterCodes2[CharacterCodes2[\"doubleQuote\"] = 34] = \"doubleQuote\";\r\n  CharacterCodes2[CharacterCodes2[\"minus\"] = 45] = \"minus\";\r\n  CharacterCodes2[CharacterCodes2[\"openBrace\"] = 123] = \"openBrace\";\r\n  CharacterCodes2[CharacterCodes2[\"openBracket\"] = 91] = \"openBracket\";\r\n  CharacterCodes2[CharacterCodes2[\"plus\"] = 43] = \"plus\";\r\n  CharacterCodes2[CharacterCodes2[\"slash\"] = 47] = \"slash\";\r\n  CharacterCodes2[CharacterCodes2[\"formFeed\"] = 12] = \"formFeed\";\r\n  CharacterCodes2[CharacterCodes2[\"tab\"] = 9] = \"tab\";\r\n})(CharacterCodes || (CharacterCodes = {}));\r\n\r\n// node_modules/jsonc-parser/lib/esm/impl/string-intern.js\r\nvar cachedSpaces = new Array(20).fill(0).map((_, index) => {\r\n  return \" \".repeat(index);\r\n});\r\nvar maxCachedValues = 200;\r\nvar cachedBreakLinesWithSpaces = {\r\n  \" \": {\r\n    \"\\n\": new Array(maxCachedValues).fill(0).map((_, index) => {\r\n      return \"\\n\" + \" \".repeat(index);\r\n    }),\r\n    \"\\r\": new Array(maxCachedValues).fill(0).map((_, index) => {\r\n      return \"\\r\" + \" \".repeat(index);\r\n    }),\r\n    \"\\r\\n\": new Array(maxCachedValues).fill(0).map((_, index) => {\r\n      return \"\\r\\n\" + \" \".repeat(index);\r\n    })\r\n  },\r\n  \"\t\": {\r\n    \"\\n\": new Array(maxCachedValues).fill(0).map((_, index) => {\r\n      return \"\\n\" + \"\t\".repeat(index);\r\n    }),\r\n    \"\\r\": new Array(maxCachedValues).fill(0).map((_, index) => {\r\n      return \"\\r\" + \"\t\".repeat(index);\r\n    }),\r\n    \"\\r\\n\": new Array(maxCachedValues).fill(0).map((_, index) => {\r\n      return \"\\r\\n\" + \"\t\".repeat(index);\r\n    })\r\n  }\r\n};\r\nvar supportedEols = [\"\\n\", \"\\r\", \"\\r\\n\"];\r\n\r\n// node_modules/jsonc-parser/lib/esm/impl/format.js\r\nfunction format(documentText, range, options) {\r\n  let initialIndentLevel;\r\n  let formatText;\r\n  let formatTextStart;\r\n  let rangeStart;\r\n  let rangeEnd;\r\n  if (range) {\r\n    rangeStart = range.offset;\r\n    rangeEnd = rangeStart + range.length;\r\n    formatTextStart = rangeStart;\r\n    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\r\n      formatTextStart--;\r\n    }\r\n    let endOffset = rangeEnd;\r\n    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\r\n      endOffset++;\r\n    }\r\n    formatText = documentText.substring(formatTextStart, endOffset);\r\n    initialIndentLevel = computeIndentLevel(formatText, options);\r\n  } else {\r\n    formatText = documentText;\r\n    initialIndentLevel = 0;\r\n    formatTextStart = 0;\r\n    rangeStart = 0;\r\n    rangeEnd = documentText.length;\r\n  }\r\n  const eol = getEOL(options, documentText);\r\n  const eolFastPathSupported = supportedEols.includes(eol);\r\n  let numberLineBreaks = 0;\r\n  let indentLevel = 0;\r\n  let indentValue;\r\n  if (options.insertSpaces) {\r\n    indentValue = cachedSpaces[options.tabSize || 4] ?? repeat(cachedSpaces[1], options.tabSize || 4);\r\n  } else {\r\n    indentValue = \"\t\";\r\n  }\r\n  const indentType = indentValue === \"\t\" ? \"\t\" : \" \";\r\n  let scanner = createScanner(formatText, false);\r\n  let hasError = false;\r\n  function newLinesAndIndent() {\r\n    if (numberLineBreaks > 1) {\r\n      return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);\r\n    }\r\n    const amountOfSpaces = indentValue.length * (initialIndentLevel + indentLevel);\r\n    if (!eolFastPathSupported || amountOfSpaces > cachedBreakLinesWithSpaces[indentType][eol].length) {\r\n      return eol + repeat(indentValue, initialIndentLevel + indentLevel);\r\n    }\r\n    if (amountOfSpaces <= 0) {\r\n      return eol;\r\n    }\r\n    return cachedBreakLinesWithSpaces[indentType][eol][amountOfSpaces];\r\n  }\r\n  function scanNext() {\r\n    let token = scanner.scan();\r\n    numberLineBreaks = 0;\r\n    while (token === 15 || token === 14) {\r\n      if (token === 14 && options.keepLines) {\r\n        numberLineBreaks += 1;\r\n      } else if (token === 14) {\r\n        numberLineBreaks = 1;\r\n      }\r\n      token = scanner.scan();\r\n    }\r\n    hasError = token === 16 || scanner.getTokenError() !== 0;\r\n    return token;\r\n  }\r\n  const editOperations = [];\r\n  function addEdit(text, startOffset, endOffset) {\r\n    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {\r\n      editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\r\n    }\r\n  }\r\n  let firstToken = scanNext();\r\n  if (options.keepLines && numberLineBreaks > 0) {\r\n    addEdit(repeat(eol, numberLineBreaks), 0, 0);\r\n  }\r\n  if (firstToken !== 17) {\r\n    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;\r\n    let initialIndent = indentValue.length * initialIndentLevel < 20 && options.insertSpaces ? cachedSpaces[indentValue.length * initialIndentLevel] : repeat(indentValue, initialIndentLevel);\r\n    addEdit(initialIndent, formatTextStart, firstTokenStart);\r\n  }\r\n  while (firstToken !== 17) {\r\n    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\r\n    let secondToken = scanNext();\r\n    let replaceContent = \"\";\r\n    let needsLineBreak = false;\r\n    while (numberLineBreaks === 0 && (secondToken === 12 || secondToken === 13)) {\r\n      let commentTokenStart = scanner.getTokenOffset() + formatTextStart;\r\n      addEdit(cachedSpaces[1], firstTokenEnd, commentTokenStart);\r\n      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\r\n      needsLineBreak = secondToken === 12;\r\n      replaceContent = needsLineBreak ? newLinesAndIndent() : \"\";\r\n      secondToken = scanNext();\r\n    }\r\n    if (secondToken === 2) {\r\n      if (firstToken !== 1) {\r\n        indentLevel--;\r\n      }\r\n      ;\r\n      if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1) {\r\n        replaceContent = newLinesAndIndent();\r\n      } else if (options.keepLines) {\r\n        replaceContent = cachedSpaces[1];\r\n      }\r\n    } else if (secondToken === 4) {\r\n      if (firstToken !== 3) {\r\n        indentLevel--;\r\n      }\r\n      ;\r\n      if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3) {\r\n        replaceContent = newLinesAndIndent();\r\n      } else if (options.keepLines) {\r\n        replaceContent = cachedSpaces[1];\r\n      }\r\n    } else {\r\n      switch (firstToken) {\r\n        case 3:\r\n        case 1:\r\n          indentLevel++;\r\n          if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {\r\n            replaceContent = newLinesAndIndent();\r\n          } else {\r\n            replaceContent = cachedSpaces[1];\r\n          }\r\n          break;\r\n        case 5:\r\n          if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {\r\n            replaceContent = newLinesAndIndent();\r\n          } else {\r\n            replaceContent = cachedSpaces[1];\r\n          }\r\n          break;\r\n        case 12:\r\n          replaceContent = newLinesAndIndent();\r\n          break;\r\n        case 13:\r\n          if (numberLineBreaks > 0) {\r\n            replaceContent = newLinesAndIndent();\r\n          } else if (!needsLineBreak) {\r\n            replaceContent = cachedSpaces[1];\r\n          }\r\n          break;\r\n        case 6:\r\n          if (options.keepLines && numberLineBreaks > 0) {\r\n            replaceContent = newLinesAndIndent();\r\n          } else if (!needsLineBreak) {\r\n            replaceContent = cachedSpaces[1];\r\n          }\r\n          break;\r\n        case 10:\r\n          if (options.keepLines && numberLineBreaks > 0) {\r\n            replaceContent = newLinesAndIndent();\r\n          } else if (secondToken === 6 && !needsLineBreak) {\r\n            replaceContent = \"\";\r\n          }\r\n          break;\r\n        case 7:\r\n        case 8:\r\n        case 9:\r\n        case 11:\r\n        case 2:\r\n        case 4:\r\n          if (options.keepLines && numberLineBreaks > 0) {\r\n            replaceContent = newLinesAndIndent();\r\n          } else {\r\n            if ((secondToken === 12 || secondToken === 13) && !needsLineBreak) {\r\n              replaceContent = cachedSpaces[1];\r\n            } else if (secondToken !== 5 && secondToken !== 17) {\r\n              hasError = true;\r\n            }\r\n          }\r\n          break;\r\n        case 16:\r\n          hasError = true;\r\n          break;\r\n      }\r\n      if (numberLineBreaks > 0 && (secondToken === 12 || secondToken === 13)) {\r\n        replaceContent = newLinesAndIndent();\r\n      }\r\n    }\r\n    if (secondToken === 17) {\r\n      if (options.keepLines && numberLineBreaks > 0) {\r\n        replaceContent = newLinesAndIndent();\r\n      } else {\r\n        replaceContent = options.insertFinalNewline ? eol : \"\";\r\n      }\r\n    }\r\n    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;\r\n    addEdit(replaceContent, firstTokenEnd, secondTokenStart);\r\n    firstToken = secondToken;\r\n  }\r\n  return editOperations;\r\n}\r\nfunction repeat(s, count) {\r\n  let result = \"\";\r\n  for (let i = 0; i < count; i++) {\r\n    result += s;\r\n  }\r\n  return result;\r\n}\r\nfunction computeIndentLevel(content, options) {\r\n  let i = 0;\r\n  let nChars = 0;\r\n  const tabSize = options.tabSize || 4;\r\n  while (i < content.length) {\r\n    let ch = content.charAt(i);\r\n    if (ch === cachedSpaces[1]) {\r\n      nChars++;\r\n    } else if (ch === \"\t\") {\r\n      nChars += tabSize;\r\n    } else {\r\n      break;\r\n    }\r\n    i++;\r\n  }\r\n  return Math.floor(nChars / tabSize);\r\n}\r\nfunction getEOL(options, text) {\r\n  for (let i = 0; i < text.length; i++) {\r\n    const ch = text.charAt(i);\r\n    if (ch === \"\\r\") {\r\n      if (i + 1 < text.length && text.charAt(i + 1) === \"\\n\") {\r\n        return \"\\r\\n\";\r\n      }\r\n      return \"\\r\";\r\n    } else if (ch === \"\\n\") {\r\n      return \"\\n\";\r\n    }\r\n  }\r\n  return options && options.eol || \"\\n\";\r\n}\r\nfunction isEOL(text, offset) {\r\n  return \"\\r\\n\".indexOf(text.charAt(offset)) !== -1;\r\n}\r\n\r\n// node_modules/jsonc-parser/lib/esm/impl/parser.js\r\nvar ParseOptions;\r\n(function(ParseOptions2) {\r\n  ParseOptions2.DEFAULT = {\r\n    allowTrailingComma: false\r\n  };\r\n})(ParseOptions || (ParseOptions = {}));\r\nfunction parse(text, errors = [], options = ParseOptions.DEFAULT) {\r\n  let currentProperty = null;\r\n  let currentParent = [];\r\n  const previousParents = [];\r\n  function onValue(value) {\r\n    if (Array.isArray(currentParent)) {\r\n      currentParent.push(value);\r\n    } else if (currentProperty !== null) {\r\n      currentParent[currentProperty] = value;\r\n    }\r\n  }\r\n  const visitor = {\r\n    onObjectBegin: () => {\r\n      const object = {};\r\n      onValue(object);\r\n      previousParents.push(currentParent);\r\n      currentParent = object;\r\n      currentProperty = null;\r\n    },\r\n    onObjectProperty: (name) => {\r\n      currentProperty = name;\r\n    },\r\n    onObjectEnd: () => {\r\n      currentParent = previousParents.pop();\r\n    },\r\n    onArrayBegin: () => {\r\n      const array = [];\r\n      onValue(array);\r\n      previousParents.push(currentParent);\r\n      currentParent = array;\r\n      currentProperty = null;\r\n    },\r\n    onArrayEnd: () => {\r\n      currentParent = previousParents.pop();\r\n    },\r\n    onLiteralValue: onValue,\r\n    onError: (error, offset, length) => {\r\n      errors.push({ error, offset, length });\r\n    }\r\n  };\r\n  visit(text, visitor, options);\r\n  return currentParent[0];\r\n}\r\nfunction getNodePath(node) {\r\n  if (!node.parent || !node.parent.children) {\r\n    return [];\r\n  }\r\n  const path = getNodePath(node.parent);\r\n  if (node.parent.type === \"property\") {\r\n    const key = node.parent.children[0].value;\r\n    path.push(key);\r\n  } else if (node.parent.type === \"array\") {\r\n    const index = node.parent.children.indexOf(node);\r\n    if (index !== -1) {\r\n      path.push(index);\r\n    }\r\n  }\r\n  return path;\r\n}\r\nfunction getNodeValue(node) {\r\n  switch (node.type) {\r\n    case \"array\":\r\n      return node.children.map(getNodeValue);\r\n    case \"object\":\r\n      const obj = /* @__PURE__ */ Object.create(null);\r\n      for (let prop of node.children) {\r\n        const valueNode = prop.children[1];\r\n        if (valueNode) {\r\n          obj[prop.children[0].value] = getNodeValue(valueNode);\r\n        }\r\n      }\r\n      return obj;\r\n    case \"null\":\r\n    case \"string\":\r\n    case \"number\":\r\n    case \"boolean\":\r\n      return node.value;\r\n    default:\r\n      return void 0;\r\n  }\r\n}\r\nfunction contains(node, offset, includeRightBound = false) {\r\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\r\n}\r\nfunction findNodeAtOffset(node, offset, includeRightBound = false) {\r\n  if (contains(node, offset, includeRightBound)) {\r\n    const children = node.children;\r\n    if (Array.isArray(children)) {\r\n      for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\r\n        const item = findNodeAtOffset(children[i], offset, includeRightBound);\r\n        if (item) {\r\n          return item;\r\n        }\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n  return void 0;\r\n}\r\nfunction visit(text, visitor, options = ParseOptions.DEFAULT) {\r\n  const _scanner = createScanner(text, false);\r\n  const _jsonPath = [];\r\n  function toNoArgVisit(visitFunction) {\r\n    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\r\n  }\r\n  function toNoArgVisitWithPath(visitFunction) {\r\n    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\r\n  }\r\n  function toOneArgVisit(visitFunction) {\r\n    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\r\n  }\r\n  function toOneArgVisitWithPath(visitFunction) {\r\n    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\r\n  }\r\n  const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\r\n  const disallowComments = options && options.disallowComments;\r\n  const allowTrailingComma = options && options.allowTrailingComma;\r\n  function scanNext() {\r\n    while (true) {\r\n      const token = _scanner.scan();\r\n      switch (_scanner.getTokenError()) {\r\n        case 4:\r\n          handleError(\r\n            14\r\n            /* ParseErrorCode.InvalidUnicode */\r\n          );\r\n          break;\r\n        case 5:\r\n          handleError(\r\n            15\r\n            /* ParseErrorCode.InvalidEscapeCharacter */\r\n          );\r\n          break;\r\n        case 3:\r\n          handleError(\r\n            13\r\n            /* ParseErrorCode.UnexpectedEndOfNumber */\r\n          );\r\n          break;\r\n        case 1:\r\n          if (!disallowComments) {\r\n            handleError(\r\n              11\r\n              /* ParseErrorCode.UnexpectedEndOfComment */\r\n            );\r\n          }\r\n          break;\r\n        case 2:\r\n          handleError(\r\n            12\r\n            /* ParseErrorCode.UnexpectedEndOfString */\r\n          );\r\n          break;\r\n        case 6:\r\n          handleError(\r\n            16\r\n            /* ParseErrorCode.InvalidCharacter */\r\n          );\r\n          break;\r\n      }\r\n      switch (token) {\r\n        case 12:\r\n        case 13:\r\n          if (disallowComments) {\r\n            handleError(\r\n              10\r\n              /* ParseErrorCode.InvalidCommentToken */\r\n            );\r\n          } else {\r\n            onComment();\r\n          }\r\n          break;\r\n        case 16:\r\n          handleError(\r\n            1\r\n            /* ParseErrorCode.InvalidSymbol */\r\n          );\r\n          break;\r\n        case 15:\r\n        case 14:\r\n          break;\r\n        default:\r\n          return token;\r\n      }\r\n    }\r\n  }\r\n  function handleError(error, skipUntilAfter = [], skipUntil = []) {\r\n    onError(error);\r\n    if (skipUntilAfter.length + skipUntil.length > 0) {\r\n      let token = _scanner.getToken();\r\n      while (token !== 17) {\r\n        if (skipUntilAfter.indexOf(token) !== -1) {\r\n          scanNext();\r\n          break;\r\n        } else if (skipUntil.indexOf(token) !== -1) {\r\n          break;\r\n        }\r\n        token = scanNext();\r\n      }\r\n    }\r\n  }\r\n  function parseString(isValue) {\r\n    const value = _scanner.getTokenValue();\r\n    if (isValue) {\r\n      onLiteralValue(value);\r\n    } else {\r\n      onObjectProperty(value);\r\n      _jsonPath.push(value);\r\n    }\r\n    scanNext();\r\n    return true;\r\n  }\r\n  function parseLiteral() {\r\n    switch (_scanner.getToken()) {\r\n      case 11:\r\n        const tokenValue = _scanner.getTokenValue();\r\n        let value = Number(tokenValue);\r\n        if (isNaN(value)) {\r\n          handleError(\r\n            2\r\n            /* ParseErrorCode.InvalidNumberFormat */\r\n          );\r\n          value = 0;\r\n        }\r\n        onLiteralValue(value);\r\n        break;\r\n      case 7:\r\n        onLiteralValue(null);\r\n        break;\r\n      case 8:\r\n        onLiteralValue(true);\r\n        break;\r\n      case 9:\r\n        onLiteralValue(false);\r\n        break;\r\n      default:\r\n        return false;\r\n    }\r\n    scanNext();\r\n    return true;\r\n  }\r\n  function parseProperty() {\r\n    if (_scanner.getToken() !== 10) {\r\n      handleError(3, [], [\r\n        2,\r\n        5\r\n        /* SyntaxKind.CommaToken */\r\n      ]);\r\n      return false;\r\n    }\r\n    parseString(false);\r\n    if (_scanner.getToken() === 6) {\r\n      onSeparator(\":\");\r\n      scanNext();\r\n      if (!parseValue()) {\r\n        handleError(4, [], [\r\n          2,\r\n          5\r\n          /* SyntaxKind.CommaToken */\r\n        ]);\r\n      }\r\n    } else {\r\n      handleError(5, [], [\r\n        2,\r\n        5\r\n        /* SyntaxKind.CommaToken */\r\n      ]);\r\n    }\r\n    _jsonPath.pop();\r\n    return true;\r\n  }\r\n  function parseObject() {\r\n    onObjectBegin();\r\n    scanNext();\r\n    let needsComma = false;\r\n    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {\r\n      if (_scanner.getToken() === 5) {\r\n        if (!needsComma) {\r\n          handleError(4, [], []);\r\n        }\r\n        onSeparator(\",\");\r\n        scanNext();\r\n        if (_scanner.getToken() === 2 && allowTrailingComma) {\r\n          break;\r\n        }\r\n      } else if (needsComma) {\r\n        handleError(6, [], []);\r\n      }\r\n      if (!parseProperty()) {\r\n        handleError(4, [], [\r\n          2,\r\n          5\r\n          /* SyntaxKind.CommaToken */\r\n        ]);\r\n      }\r\n      needsComma = true;\r\n    }\r\n    onObjectEnd();\r\n    if (_scanner.getToken() !== 2) {\r\n      handleError(7, [\r\n        2\r\n        /* SyntaxKind.CloseBraceToken */\r\n      ], []);\r\n    } else {\r\n      scanNext();\r\n    }\r\n    return true;\r\n  }\r\n  function parseArray() {\r\n    onArrayBegin();\r\n    scanNext();\r\n    let isFirstElement = true;\r\n    let needsComma = false;\r\n    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {\r\n      if (_scanner.getToken() === 5) {\r\n        if (!needsComma) {\r\n          handleError(4, [], []);\r\n        }\r\n        onSeparator(\",\");\r\n        scanNext();\r\n        if (_scanner.getToken() === 4 && allowTrailingComma) {\r\n          break;\r\n        }\r\n      } else if (needsComma) {\r\n        handleError(6, [], []);\r\n      }\r\n      if (isFirstElement) {\r\n        _jsonPath.push(0);\r\n        isFirstElement = false;\r\n      } else {\r\n        _jsonPath[_jsonPath.length - 1]++;\r\n      }\r\n      if (!parseValue()) {\r\n        handleError(4, [], [\r\n          4,\r\n          5\r\n          /* SyntaxKind.CommaToken */\r\n        ]);\r\n      }\r\n      needsComma = true;\r\n    }\r\n    onArrayEnd();\r\n    if (!isFirstElement) {\r\n      _jsonPath.pop();\r\n    }\r\n    if (_scanner.getToken() !== 4) {\r\n      handleError(8, [\r\n        4\r\n        /* SyntaxKind.CloseBracketToken */\r\n      ], []);\r\n    } else {\r\n      scanNext();\r\n    }\r\n    return true;\r\n  }\r\n  function parseValue() {\r\n    switch (_scanner.getToken()) {\r\n      case 3:\r\n        return parseArray();\r\n      case 1:\r\n        return parseObject();\r\n      case 10:\r\n        return parseString(true);\r\n      default:\r\n        return parseLiteral();\r\n    }\r\n  }\r\n  scanNext();\r\n  if (_scanner.getToken() === 17) {\r\n    if (options.allowEmptyContent) {\r\n      return true;\r\n    }\r\n    handleError(4, [], []);\r\n    return false;\r\n  }\r\n  if (!parseValue()) {\r\n    handleError(4, [], []);\r\n    return false;\r\n  }\r\n  if (_scanner.getToken() !== 17) {\r\n    handleError(9, [], []);\r\n  }\r\n  return true;\r\n}\r\n\r\n// node_modules/jsonc-parser/lib/esm/main.js\r\nvar createScanner2 = createScanner;\r\nvar ScanError;\r\n(function(ScanError2) {\r\n  ScanError2[ScanError2[\"None\"] = 0] = \"None\";\r\n  ScanError2[ScanError2[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\r\n  ScanError2[ScanError2[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\r\n  ScanError2[ScanError2[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\r\n  ScanError2[ScanError2[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\r\n  ScanError2[ScanError2[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\r\n  ScanError2[ScanError2[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\r\n})(ScanError || (ScanError = {}));\r\nvar SyntaxKind;\r\n(function(SyntaxKind2) {\r\n  SyntaxKind2[SyntaxKind2[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\r\n  SyntaxKind2[SyntaxKind2[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\r\n  SyntaxKind2[SyntaxKind2[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\r\n  SyntaxKind2[SyntaxKind2[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\r\n  SyntaxKind2[SyntaxKind2[\"CommaToken\"] = 5] = \"CommaToken\";\r\n  SyntaxKind2[SyntaxKind2[\"ColonToken\"] = 6] = \"ColonToken\";\r\n  SyntaxKind2[SyntaxKind2[\"NullKeyword\"] = 7] = \"NullKeyword\";\r\n  SyntaxKind2[SyntaxKind2[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\r\n  SyntaxKind2[SyntaxKind2[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\r\n  SyntaxKind2[SyntaxKind2[\"StringLiteral\"] = 10] = \"StringLiteral\";\r\n  SyntaxKind2[SyntaxKind2[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\r\n  SyntaxKind2[SyntaxKind2[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\r\n  SyntaxKind2[SyntaxKind2[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\r\n  SyntaxKind2[SyntaxKind2[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\r\n  SyntaxKind2[SyntaxKind2[\"Trivia\"] = 15] = \"Trivia\";\r\n  SyntaxKind2[SyntaxKind2[\"Unknown\"] = 16] = \"Unknown\";\r\n  SyntaxKind2[SyntaxKind2[\"EOF\"] = 17] = \"EOF\";\r\n})(SyntaxKind || (SyntaxKind = {}));\r\nvar parse2 = parse;\r\nvar findNodeAtOffset2 = findNodeAtOffset;\r\nvar getNodePath2 = getNodePath;\r\nvar getNodeValue2 = getNodeValue;\r\nvar ParseErrorCode;\r\n(function(ParseErrorCode2) {\r\n  ParseErrorCode2[ParseErrorCode2[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\r\n  ParseErrorCode2[ParseErrorCode2[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\r\n  ParseErrorCode2[ParseErrorCode2[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"ValueExpected\"] = 4] = \"ValueExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"ColonExpected\"] = 5] = \"ColonExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"CommaExpected\"] = 6] = \"CommaExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\r\n  ParseErrorCode2[ParseErrorCode2[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\r\n  ParseErrorCode2[ParseErrorCode2[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\r\n  ParseErrorCode2[ParseErrorCode2[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\r\n  ParseErrorCode2[ParseErrorCode2[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\r\n  ParseErrorCode2[ParseErrorCode2[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\r\n  ParseErrorCode2[ParseErrorCode2[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\r\n  ParseErrorCode2[ParseErrorCode2[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\r\n})(ParseErrorCode || (ParseErrorCode = {}));\r\nfunction format2(documentText, range, options) {\r\n  return format(documentText, range, options);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/objects.js\r\nfunction equals(one, other) {\r\n  if (one === other) {\r\n    return true;\r\n  }\r\n  if (one === null || one === void 0 || other === null || other === void 0) {\r\n    return false;\r\n  }\r\n  if (typeof one !== typeof other) {\r\n    return false;\r\n  }\r\n  if (typeof one !== \"object\") {\r\n    return false;\r\n  }\r\n  if (Array.isArray(one) !== Array.isArray(other)) {\r\n    return false;\r\n  }\r\n  let i, key;\r\n  if (Array.isArray(one)) {\r\n    if (one.length !== other.length) {\r\n      return false;\r\n    }\r\n    for (i = 0; i < one.length; i++) {\r\n      if (!equals(one[i], other[i])) {\r\n        return false;\r\n      }\r\n    }\r\n  } else {\r\n    const oneKeys = [];\r\n    for (key in one) {\r\n      oneKeys.push(key);\r\n    }\r\n    oneKeys.sort();\r\n    const otherKeys = [];\r\n    for (key in other) {\r\n      otherKeys.push(key);\r\n    }\r\n    otherKeys.sort();\r\n    if (!equals(oneKeys, otherKeys)) {\r\n      return false;\r\n    }\r\n    for (i = 0; i < oneKeys.length; i++) {\r\n      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction isNumber(val) {\r\n  return typeof val === \"number\";\r\n}\r\nfunction isDefined(val) {\r\n  return typeof val !== \"undefined\";\r\n}\r\nfunction isBoolean(val) {\r\n  return typeof val === \"boolean\";\r\n}\r\nfunction isString(val) {\r\n  return typeof val === \"string\";\r\n}\r\nfunction isObject(val) {\r\n  return typeof val === \"object\" && val !== null && !Array.isArray(val);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/strings.js\r\nfunction startsWith(haystack, needle) {\r\n  if (haystack.length < needle.length) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < needle.length; i++) {\r\n    if (haystack[i] !== needle[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction endsWith(haystack, needle) {\r\n  const diff = haystack.length - needle.length;\r\n  if (diff > 0) {\r\n    return haystack.lastIndexOf(needle) === diff;\r\n  } else if (diff === 0) {\r\n    return haystack === needle;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\nfunction extendedRegExp(pattern) {\r\n  let flags = \"\";\r\n  if (startsWith(pattern, \"(?i)\")) {\r\n    pattern = pattern.substring(4);\r\n    flags = \"i\";\r\n  }\r\n  try {\r\n    return new RegExp(pattern, flags + \"u\");\r\n  } catch (e) {\r\n    try {\r\n      return new RegExp(pattern, flags);\r\n    } catch (e2) {\r\n      return void 0;\r\n    }\r\n  }\r\n}\r\nfunction stringLength(str) {\r\n  let count = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    count++;\r\n    const code = str.charCodeAt(i);\r\n    if (55296 <= code && code <= 56319) {\r\n      i++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n// node_modules/vscode-languageserver-types/lib/esm/main.js\r\nvar DocumentUri;\r\n(function(DocumentUri2) {\r\n  function is(value) {\r\n    return typeof value === \"string\";\r\n  }\r\n  DocumentUri2.is = is;\r\n})(DocumentUri || (DocumentUri = {}));\r\nvar URI;\r\n(function(URI3) {\r\n  function is(value) {\r\n    return typeof value === \"string\";\r\n  }\r\n  URI3.is = is;\r\n})(URI || (URI = {}));\r\nvar integer;\r\n(function(integer2) {\r\n  integer2.MIN_VALUE = -2147483648;\r\n  integer2.MAX_VALUE = 2147483647;\r\n  function is(value) {\r\n    return typeof value === \"number\" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;\r\n  }\r\n  integer2.is = is;\r\n})(integer || (integer = {}));\r\nvar uinteger;\r\n(function(uinteger2) {\r\n  uinteger2.MIN_VALUE = 0;\r\n  uinteger2.MAX_VALUE = 2147483647;\r\n  function is(value) {\r\n    return typeof value === \"number\" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;\r\n  }\r\n  uinteger2.is = is;\r\n})(uinteger || (uinteger = {}));\r\nvar Position;\r\n(function(Position2) {\r\n  function create(line, character) {\r\n    if (line === Number.MAX_VALUE) {\r\n      line = uinteger.MAX_VALUE;\r\n    }\r\n    if (character === Number.MAX_VALUE) {\r\n      character = uinteger.MAX_VALUE;\r\n    }\r\n    return { line, character };\r\n  }\r\n  Position2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\r\n  }\r\n  Position2.is = is;\r\n})(Position || (Position = {}));\r\nvar Range;\r\n(function(Range2) {\r\n  function create(one, two, three, four) {\r\n    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\r\n      return { start: Position.create(one, two), end: Position.create(three, four) };\r\n    } else if (Position.is(one) && Position.is(two)) {\r\n      return { start: one, end: two };\r\n    } else {\r\n      throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\r\n    }\r\n  }\r\n  Range2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n  }\r\n  Range2.is = is;\r\n})(Range || (Range = {}));\r\nvar Location;\r\n(function(Location2) {\r\n  function create(uri, range) {\r\n    return { uri, range };\r\n  }\r\n  Location2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n  }\r\n  Location2.is = is;\r\n})(Location || (Location = {}));\r\nvar LocationLink;\r\n(function(LocationLink2) {\r\n  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\r\n    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\r\n  }\r\n  LocationLink2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\r\n  }\r\n  LocationLink2.is = is;\r\n})(LocationLink || (LocationLink = {}));\r\nvar Color;\r\n(function(Color2) {\r\n  function create(red, green, blue, alpha) {\r\n    return {\r\n      red,\r\n      green,\r\n      blue,\r\n      alpha\r\n    };\r\n  }\r\n  Color2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\r\n  }\r\n  Color2.is = is;\r\n})(Color || (Color = {}));\r\nvar ColorInformation;\r\n(function(ColorInformation2) {\r\n  function create(range, color) {\r\n    return {\r\n      range,\r\n      color\r\n    };\r\n  }\r\n  ColorInformation2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\r\n  }\r\n  ColorInformation2.is = is;\r\n})(ColorInformation || (ColorInformation = {}));\r\nvar ColorPresentation;\r\n(function(ColorPresentation2) {\r\n  function create(label, textEdit, additionalTextEdits) {\r\n    return {\r\n      label,\r\n      textEdit,\r\n      additionalTextEdits\r\n    };\r\n  }\r\n  ColorPresentation2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n  }\r\n  ColorPresentation2.is = is;\r\n})(ColorPresentation || (ColorPresentation = {}));\r\nvar FoldingRangeKind;\r\n(function(FoldingRangeKind2) {\r\n  FoldingRangeKind2.Comment = \"comment\";\r\n  FoldingRangeKind2.Imports = \"imports\";\r\n  FoldingRangeKind2.Region = \"region\";\r\n})(FoldingRangeKind || (FoldingRangeKind = {}));\r\nvar FoldingRange;\r\n(function(FoldingRange2) {\r\n  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\r\n    const result = {\r\n      startLine,\r\n      endLine\r\n    };\r\n    if (Is.defined(startCharacter)) {\r\n      result.startCharacter = startCharacter;\r\n    }\r\n    if (Is.defined(endCharacter)) {\r\n      result.endCharacter = endCharacter;\r\n    }\r\n    if (Is.defined(kind)) {\r\n      result.kind = kind;\r\n    }\r\n    if (Is.defined(collapsedText)) {\r\n      result.collapsedText = collapsedText;\r\n    }\r\n    return result;\r\n  }\r\n  FoldingRange2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n  }\r\n  FoldingRange2.is = is;\r\n})(FoldingRange || (FoldingRange = {}));\r\nvar DiagnosticRelatedInformation;\r\n(function(DiagnosticRelatedInformation2) {\r\n  function create(location, message) {\r\n    return {\r\n      location,\r\n      message\r\n    };\r\n  }\r\n  DiagnosticRelatedInformation2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n  }\r\n  DiagnosticRelatedInformation2.is = is;\r\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\r\nvar DiagnosticSeverity;\r\n(function(DiagnosticSeverity2) {\r\n  DiagnosticSeverity2.Error = 1;\r\n  DiagnosticSeverity2.Warning = 2;\r\n  DiagnosticSeverity2.Information = 3;\r\n  DiagnosticSeverity2.Hint = 4;\r\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\r\nvar DiagnosticTag;\r\n(function(DiagnosticTag2) {\r\n  DiagnosticTag2.Unnecessary = 1;\r\n  DiagnosticTag2.Deprecated = 2;\r\n})(DiagnosticTag || (DiagnosticTag = {}));\r\nvar CodeDescription;\r\n(function(CodeDescription2) {\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.string(candidate.href);\r\n  }\r\n  CodeDescription2.is = is;\r\n})(CodeDescription || (CodeDescription = {}));\r\nvar Diagnostic;\r\n(function(Diagnostic2) {\r\n  function create(range, message, severity, code, source, relatedInformation) {\r\n    let result = { range, message };\r\n    if (Is.defined(severity)) {\r\n      result.severity = severity;\r\n    }\r\n    if (Is.defined(code)) {\r\n      result.code = code;\r\n    }\r\n    if (Is.defined(source)) {\r\n      result.source = source;\r\n    }\r\n    if (Is.defined(relatedInformation)) {\r\n      result.relatedInformation = relatedInformation;\r\n    }\r\n    return result;\r\n  }\r\n  Diagnostic2.create = create;\r\n  function is(value) {\r\n    var _a;\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n  }\r\n  Diagnostic2.is = is;\r\n})(Diagnostic || (Diagnostic = {}));\r\nvar Command;\r\n(function(Command2) {\r\n  function create(title, command, ...args) {\r\n    let result = { title, command };\r\n    if (Is.defined(args) && args.length > 0) {\r\n      result.arguments = args;\r\n    }\r\n    return result;\r\n  }\r\n  Command2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n  }\r\n  Command2.is = is;\r\n})(Command || (Command = {}));\r\nvar TextEdit;\r\n(function(TextEdit2) {\r\n  function replace(range, newText) {\r\n    return { range, newText };\r\n  }\r\n  TextEdit2.replace = replace;\r\n  function insert(position, newText) {\r\n    return { range: { start: position, end: position }, newText };\r\n  }\r\n  TextEdit2.insert = insert;\r\n  function del(range) {\r\n    return { range, newText: \"\" };\r\n  }\r\n  TextEdit2.del = del;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\r\n  }\r\n  TextEdit2.is = is;\r\n})(TextEdit || (TextEdit = {}));\r\nvar ChangeAnnotation;\r\n(function(ChangeAnnotation2) {\r\n  function create(label, needsConfirmation, description) {\r\n    const result = { label };\r\n    if (needsConfirmation !== void 0) {\r\n      result.needsConfirmation = needsConfirmation;\r\n    }\r\n    if (description !== void 0) {\r\n      result.description = description;\r\n    }\r\n    return result;\r\n  }\r\n  ChangeAnnotation2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\r\n  }\r\n  ChangeAnnotation2.is = is;\r\n})(ChangeAnnotation || (ChangeAnnotation = {}));\r\nvar ChangeAnnotationIdentifier;\r\n(function(ChangeAnnotationIdentifier2) {\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.string(candidate);\r\n  }\r\n  ChangeAnnotationIdentifier2.is = is;\r\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\r\nvar AnnotatedTextEdit;\r\n(function(AnnotatedTextEdit2) {\r\n  function replace(range, newText, annotation) {\r\n    return { range, newText, annotationId: annotation };\r\n  }\r\n  AnnotatedTextEdit2.replace = replace;\r\n  function insert(position, newText, annotation) {\r\n    return { range: { start: position, end: position }, newText, annotationId: annotation };\r\n  }\r\n  AnnotatedTextEdit2.insert = insert;\r\n  function del(range, annotation) {\r\n    return { range, newText: \"\", annotationId: annotation };\r\n  }\r\n  AnnotatedTextEdit2.del = del;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n  }\r\n  AnnotatedTextEdit2.is = is;\r\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\r\nvar TextDocumentEdit;\r\n(function(TextDocumentEdit2) {\r\n  function create(textDocument, edits) {\r\n    return { textDocument, edits };\r\n  }\r\n  TextDocumentEdit2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\r\n  }\r\n  TextDocumentEdit2.is = is;\r\n})(TextDocumentEdit || (TextDocumentEdit = {}));\r\nvar CreateFile;\r\n(function(CreateFile2) {\r\n  function create(uri, options, annotation) {\r\n    let result = {\r\n      kind: \"create\",\r\n      uri\r\n    };\r\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n      result.options = options;\r\n    }\r\n    if (annotation !== void 0) {\r\n      result.annotationId = annotation;\r\n    }\r\n    return result;\r\n  }\r\n  CreateFile2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return candidate && candidate.kind === \"create\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n  }\r\n  CreateFile2.is = is;\r\n})(CreateFile || (CreateFile = {}));\r\nvar RenameFile;\r\n(function(RenameFile2) {\r\n  function create(oldUri, newUri, options, annotation) {\r\n    let result = {\r\n      kind: \"rename\",\r\n      oldUri,\r\n      newUri\r\n    };\r\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n      result.options = options;\r\n    }\r\n    if (annotation !== void 0) {\r\n      result.annotationId = annotation;\r\n    }\r\n    return result;\r\n  }\r\n  RenameFile2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return candidate && candidate.kind === \"rename\" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n  }\r\n  RenameFile2.is = is;\r\n})(RenameFile || (RenameFile = {}));\r\nvar DeleteFile;\r\n(function(DeleteFile2) {\r\n  function create(uri, options, annotation) {\r\n    let result = {\r\n      kind: \"delete\",\r\n      uri\r\n    };\r\n    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\r\n      result.options = options;\r\n    }\r\n    if (annotation !== void 0) {\r\n      result.annotationId = annotation;\r\n    }\r\n    return result;\r\n  }\r\n  DeleteFile2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return candidate && candidate.kind === \"delete\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n  }\r\n  DeleteFile2.is = is;\r\n})(DeleteFile || (DeleteFile = {}));\r\nvar WorkspaceEdit;\r\n(function(WorkspaceEdit2) {\r\n  function is(value) {\r\n    let candidate = value;\r\n    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {\r\n      if (Is.string(change.kind)) {\r\n        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n      } else {\r\n        return TextDocumentEdit.is(change);\r\n      }\r\n    }));\r\n  }\r\n  WorkspaceEdit2.is = is;\r\n})(WorkspaceEdit || (WorkspaceEdit = {}));\r\nvar TextDocumentIdentifier;\r\n(function(TextDocumentIdentifier2) {\r\n  function create(uri) {\r\n    return { uri };\r\n  }\r\n  TextDocumentIdentifier2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.string(candidate.uri);\r\n  }\r\n  TextDocumentIdentifier2.is = is;\r\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\r\nvar VersionedTextDocumentIdentifier;\r\n(function(VersionedTextDocumentIdentifier2) {\r\n  function create(uri, version) {\r\n    return { uri, version };\r\n  }\r\n  VersionedTextDocumentIdentifier2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\r\n  }\r\n  VersionedTextDocumentIdentifier2.is = is;\r\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\r\nvar OptionalVersionedTextDocumentIdentifier;\r\n(function(OptionalVersionedTextDocumentIdentifier2) {\r\n  function create(uri, version) {\r\n    return { uri, version };\r\n  }\r\n  OptionalVersionedTextDocumentIdentifier2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\r\n  }\r\n  OptionalVersionedTextDocumentIdentifier2.is = is;\r\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\r\nvar TextDocumentItem;\r\n(function(TextDocumentItem2) {\r\n  function create(uri, languageId, version, text) {\r\n    return { uri, languageId, version, text };\r\n  }\r\n  TextDocumentItem2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\r\n  }\r\n  TextDocumentItem2.is = is;\r\n})(TextDocumentItem || (TextDocumentItem = {}));\r\nvar MarkupKind;\r\n(function(MarkupKind2) {\r\n  MarkupKind2.PlainText = \"plaintext\";\r\n  MarkupKind2.Markdown = \"markdown\";\r\n  function is(value) {\r\n    const candidate = value;\r\n    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;\r\n  }\r\n  MarkupKind2.is = is;\r\n})(MarkupKind || (MarkupKind = {}));\r\nvar MarkupContent;\r\n(function(MarkupContent2) {\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n  }\r\n  MarkupContent2.is = is;\r\n})(MarkupContent || (MarkupContent = {}));\r\nvar CompletionItemKind;\r\n(function(CompletionItemKind2) {\r\n  CompletionItemKind2.Text = 1;\r\n  CompletionItemKind2.Method = 2;\r\n  CompletionItemKind2.Function = 3;\r\n  CompletionItemKind2.Constructor = 4;\r\n  CompletionItemKind2.Field = 5;\r\n  CompletionItemKind2.Variable = 6;\r\n  CompletionItemKind2.Class = 7;\r\n  CompletionItemKind2.Interface = 8;\r\n  CompletionItemKind2.Module = 9;\r\n  CompletionItemKind2.Property = 10;\r\n  CompletionItemKind2.Unit = 11;\r\n  CompletionItemKind2.Value = 12;\r\n  CompletionItemKind2.Enum = 13;\r\n  CompletionItemKind2.Keyword = 14;\r\n  CompletionItemKind2.Snippet = 15;\r\n  CompletionItemKind2.Color = 16;\r\n  CompletionItemKind2.File = 17;\r\n  CompletionItemKind2.Reference = 18;\r\n  CompletionItemKind2.Folder = 19;\r\n  CompletionItemKind2.EnumMember = 20;\r\n  CompletionItemKind2.Constant = 21;\r\n  CompletionItemKind2.Struct = 22;\r\n  CompletionItemKind2.Event = 23;\r\n  CompletionItemKind2.Operator = 24;\r\n  CompletionItemKind2.TypeParameter = 25;\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\nvar InsertTextFormat;\r\n(function(InsertTextFormat2) {\r\n  InsertTextFormat2.PlainText = 1;\r\n  InsertTextFormat2.Snippet = 2;\r\n})(InsertTextFormat || (InsertTextFormat = {}));\r\nvar CompletionItemTag;\r\n(function(CompletionItemTag2) {\r\n  CompletionItemTag2.Deprecated = 1;\r\n})(CompletionItemTag || (CompletionItemTag = {}));\r\nvar InsertReplaceEdit;\r\n(function(InsertReplaceEdit2) {\r\n  function create(newText, insert, replace) {\r\n    return { newText, insert, replace };\r\n  }\r\n  InsertReplaceEdit2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\r\n  }\r\n  InsertReplaceEdit2.is = is;\r\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\r\nvar InsertTextMode;\r\n(function(InsertTextMode2) {\r\n  InsertTextMode2.asIs = 1;\r\n  InsertTextMode2.adjustIndentation = 2;\r\n})(InsertTextMode || (InsertTextMode = {}));\r\nvar CompletionItemLabelDetails;\r\n(function(CompletionItemLabelDetails2) {\r\n  function is(value) {\r\n    const candidate = value;\r\n    return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\r\n  }\r\n  CompletionItemLabelDetails2.is = is;\r\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\r\nvar CompletionItem;\r\n(function(CompletionItem2) {\r\n  function create(label) {\r\n    return { label };\r\n  }\r\n  CompletionItem2.create = create;\r\n})(CompletionItem || (CompletionItem = {}));\r\nvar CompletionList;\r\n(function(CompletionList2) {\r\n  function create(items, isIncomplete) {\r\n    return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n  }\r\n  CompletionList2.create = create;\r\n})(CompletionList || (CompletionList = {}));\r\nvar MarkedString;\r\n(function(MarkedString2) {\r\n  function fromPlainText(plainText) {\r\n    return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\");\r\n  }\r\n  MarkedString2.fromPlainText = fromPlainText;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\r\n  }\r\n  MarkedString2.is = is;\r\n})(MarkedString || (MarkedString = {}));\r\nvar Hover;\r\n(function(Hover2) {\r\n  function is(value) {\r\n    let candidate = value;\r\n    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\r\n  }\r\n  Hover2.is = is;\r\n})(Hover || (Hover = {}));\r\nvar ParameterInformation;\r\n(function(ParameterInformation2) {\r\n  function create(label, documentation) {\r\n    return documentation ? { label, documentation } : { label };\r\n  }\r\n  ParameterInformation2.create = create;\r\n})(ParameterInformation || (ParameterInformation = {}));\r\nvar SignatureInformation;\r\n(function(SignatureInformation2) {\r\n  function create(label, documentation, ...parameters) {\r\n    let result = { label };\r\n    if (Is.defined(documentation)) {\r\n      result.documentation = documentation;\r\n    }\r\n    if (Is.defined(parameters)) {\r\n      result.parameters = parameters;\r\n    } else {\r\n      result.parameters = [];\r\n    }\r\n    return result;\r\n  }\r\n  SignatureInformation2.create = create;\r\n})(SignatureInformation || (SignatureInformation = {}));\r\nvar DocumentHighlightKind;\r\n(function(DocumentHighlightKind2) {\r\n  DocumentHighlightKind2.Text = 1;\r\n  DocumentHighlightKind2.Read = 2;\r\n  DocumentHighlightKind2.Write = 3;\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\nvar DocumentHighlight;\r\n(function(DocumentHighlight2) {\r\n  function create(range, kind) {\r\n    let result = { range };\r\n    if (Is.number(kind)) {\r\n      result.kind = kind;\r\n    }\r\n    return result;\r\n  }\r\n  DocumentHighlight2.create = create;\r\n})(DocumentHighlight || (DocumentHighlight = {}));\r\nvar SymbolKind;\r\n(function(SymbolKind2) {\r\n  SymbolKind2.File = 1;\r\n  SymbolKind2.Module = 2;\r\n  SymbolKind2.Namespace = 3;\r\n  SymbolKind2.Package = 4;\r\n  SymbolKind2.Class = 5;\r\n  SymbolKind2.Method = 6;\r\n  SymbolKind2.Property = 7;\r\n  SymbolKind2.Field = 8;\r\n  SymbolKind2.Constructor = 9;\r\n  SymbolKind2.Enum = 10;\r\n  SymbolKind2.Interface = 11;\r\n  SymbolKind2.Function = 12;\r\n  SymbolKind2.Variable = 13;\r\n  SymbolKind2.Constant = 14;\r\n  SymbolKind2.String = 15;\r\n  SymbolKind2.Number = 16;\r\n  SymbolKind2.Boolean = 17;\r\n  SymbolKind2.Array = 18;\r\n  SymbolKind2.Object = 19;\r\n  SymbolKind2.Key = 20;\r\n  SymbolKind2.Null = 21;\r\n  SymbolKind2.EnumMember = 22;\r\n  SymbolKind2.Struct = 23;\r\n  SymbolKind2.Event = 24;\r\n  SymbolKind2.Operator = 25;\r\n  SymbolKind2.TypeParameter = 26;\r\n})(SymbolKind || (SymbolKind = {}));\r\nvar SymbolTag;\r\n(function(SymbolTag2) {\r\n  SymbolTag2.Deprecated = 1;\r\n})(SymbolTag || (SymbolTag = {}));\r\nvar SymbolInformation;\r\n(function(SymbolInformation2) {\r\n  function create(name, kind, range, uri, containerName) {\r\n    let result = {\r\n      name,\r\n      kind,\r\n      location: { uri, range }\r\n    };\r\n    if (containerName) {\r\n      result.containerName = containerName;\r\n    }\r\n    return result;\r\n  }\r\n  SymbolInformation2.create = create;\r\n})(SymbolInformation || (SymbolInformation = {}));\r\nvar WorkspaceSymbol;\r\n(function(WorkspaceSymbol2) {\r\n  function create(name, kind, uri, range) {\r\n    return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };\r\n  }\r\n  WorkspaceSymbol2.create = create;\r\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\r\nvar DocumentSymbol;\r\n(function(DocumentSymbol2) {\r\n  function create(name, detail, kind, range, selectionRange, children) {\r\n    let result = {\r\n      name,\r\n      detail,\r\n      kind,\r\n      range,\r\n      selectionRange\r\n    };\r\n    if (children !== void 0) {\r\n      result.children = children;\r\n    }\r\n    return result;\r\n  }\r\n  DocumentSymbol2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));\r\n  }\r\n  DocumentSymbol2.is = is;\r\n})(DocumentSymbol || (DocumentSymbol = {}));\r\nvar CodeActionKind;\r\n(function(CodeActionKind2) {\r\n  CodeActionKind2.Empty = \"\";\r\n  CodeActionKind2.QuickFix = \"quickfix\";\r\n  CodeActionKind2.Refactor = \"refactor\";\r\n  CodeActionKind2.RefactorExtract = \"refactor.extract\";\r\n  CodeActionKind2.RefactorInline = \"refactor.inline\";\r\n  CodeActionKind2.RefactorRewrite = \"refactor.rewrite\";\r\n  CodeActionKind2.Source = \"source\";\r\n  CodeActionKind2.SourceOrganizeImports = \"source.organizeImports\";\r\n  CodeActionKind2.SourceFixAll = \"source.fixAll\";\r\n})(CodeActionKind || (CodeActionKind = {}));\r\nvar CodeActionTriggerKind;\r\n(function(CodeActionTriggerKind2) {\r\n  CodeActionTriggerKind2.Invoked = 1;\r\n  CodeActionTriggerKind2.Automatic = 2;\r\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\r\nvar CodeActionContext;\r\n(function(CodeActionContext2) {\r\n  function create(diagnostics, only, triggerKind) {\r\n    let result = { diagnostics };\r\n    if (only !== void 0 && only !== null) {\r\n      result.only = only;\r\n    }\r\n    if (triggerKind !== void 0 && triggerKind !== null) {\r\n      result.triggerKind = triggerKind;\r\n    }\r\n    return result;\r\n  }\r\n  CodeActionContext2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\r\n  }\r\n  CodeActionContext2.is = is;\r\n})(CodeActionContext || (CodeActionContext = {}));\r\nvar CodeAction;\r\n(function(CodeAction2) {\r\n  function create(title, kindOrCommandOrEdit, kind) {\r\n    let result = { title };\r\n    let checkKind = true;\r\n    if (typeof kindOrCommandOrEdit === \"string\") {\r\n      checkKind = false;\r\n      result.kind = kindOrCommandOrEdit;\r\n    } else if (Command.is(kindOrCommandOrEdit)) {\r\n      result.command = kindOrCommandOrEdit;\r\n    } else {\r\n      result.edit = kindOrCommandOrEdit;\r\n    }\r\n    if (checkKind && kind !== void 0) {\r\n      result.kind = kind;\r\n    }\r\n    return result;\r\n  }\r\n  CodeAction2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\r\n  }\r\n  CodeAction2.is = is;\r\n})(CodeAction || (CodeAction = {}));\r\nvar CodeLens;\r\n(function(CodeLens2) {\r\n  function create(range, data) {\r\n    let result = { range };\r\n    if (Is.defined(data)) {\r\n      result.data = data;\r\n    }\r\n    return result;\r\n  }\r\n  CodeLens2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n  }\r\n  CodeLens2.is = is;\r\n})(CodeLens || (CodeLens = {}));\r\nvar FormattingOptions;\r\n(function(FormattingOptions2) {\r\n  function create(tabSize, insertSpaces) {\r\n    return { tabSize, insertSpaces };\r\n  }\r\n  FormattingOptions2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n  }\r\n  FormattingOptions2.is = is;\r\n})(FormattingOptions || (FormattingOptions = {}));\r\nvar DocumentLink;\r\n(function(DocumentLink2) {\r\n  function create(range, target, data) {\r\n    return { range, target, data };\r\n  }\r\n  DocumentLink2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n  }\r\n  DocumentLink2.is = is;\r\n})(DocumentLink || (DocumentLink = {}));\r\nvar SelectionRange;\r\n(function(SelectionRange2) {\r\n  function create(range, parent) {\r\n    return { range, parent };\r\n  }\r\n  SelectionRange2.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));\r\n  }\r\n  SelectionRange2.is = is;\r\n})(SelectionRange || (SelectionRange = {}));\r\nvar SemanticTokenTypes;\r\n(function(SemanticTokenTypes2) {\r\n  SemanticTokenTypes2[\"namespace\"] = \"namespace\";\r\n  SemanticTokenTypes2[\"type\"] = \"type\";\r\n  SemanticTokenTypes2[\"class\"] = \"class\";\r\n  SemanticTokenTypes2[\"enum\"] = \"enum\";\r\n  SemanticTokenTypes2[\"interface\"] = \"interface\";\r\n  SemanticTokenTypes2[\"struct\"] = \"struct\";\r\n  SemanticTokenTypes2[\"typeParameter\"] = \"typeParameter\";\r\n  SemanticTokenTypes2[\"parameter\"] = \"parameter\";\r\n  SemanticTokenTypes2[\"variable\"] = \"variable\";\r\n  SemanticTokenTypes2[\"property\"] = \"property\";\r\n  SemanticTokenTypes2[\"enumMember\"] = \"enumMember\";\r\n  SemanticTokenTypes2[\"event\"] = \"event\";\r\n  SemanticTokenTypes2[\"function\"] = \"function\";\r\n  SemanticTokenTypes2[\"method\"] = \"method\";\r\n  SemanticTokenTypes2[\"macro\"] = \"macro\";\r\n  SemanticTokenTypes2[\"keyword\"] = \"keyword\";\r\n  SemanticTokenTypes2[\"modifier\"] = \"modifier\";\r\n  SemanticTokenTypes2[\"comment\"] = \"comment\";\r\n  SemanticTokenTypes2[\"string\"] = \"string\";\r\n  SemanticTokenTypes2[\"number\"] = \"number\";\r\n  SemanticTokenTypes2[\"regexp\"] = \"regexp\";\r\n  SemanticTokenTypes2[\"operator\"] = \"operator\";\r\n  SemanticTokenTypes2[\"decorator\"] = \"decorator\";\r\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\r\nvar SemanticTokenModifiers;\r\n(function(SemanticTokenModifiers2) {\r\n  SemanticTokenModifiers2[\"declaration\"] = \"declaration\";\r\n  SemanticTokenModifiers2[\"definition\"] = \"definition\";\r\n  SemanticTokenModifiers2[\"readonly\"] = \"readonly\";\r\n  SemanticTokenModifiers2[\"static\"] = \"static\";\r\n  SemanticTokenModifiers2[\"deprecated\"] = \"deprecated\";\r\n  SemanticTokenModifiers2[\"abstract\"] = \"abstract\";\r\n  SemanticTokenModifiers2[\"async\"] = \"async\";\r\n  SemanticTokenModifiers2[\"modification\"] = \"modification\";\r\n  SemanticTokenModifiers2[\"documentation\"] = \"documentation\";\r\n  SemanticTokenModifiers2[\"defaultLibrary\"] = \"defaultLibrary\";\r\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\r\nvar SemanticTokens;\r\n(function(SemanticTokens2) {\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === \"string\") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \"number\");\r\n  }\r\n  SemanticTokens2.is = is;\r\n})(SemanticTokens || (SemanticTokens = {}));\r\nvar InlineValueText;\r\n(function(InlineValueText2) {\r\n  function create(range, text) {\r\n    return { range, text };\r\n  }\r\n  InlineValueText2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\r\n  }\r\n  InlineValueText2.is = is;\r\n})(InlineValueText || (InlineValueText = {}));\r\nvar InlineValueVariableLookup;\r\n(function(InlineValueVariableLookup2) {\r\n  function create(range, variableName, caseSensitiveLookup) {\r\n    return { range, variableName, caseSensitiveLookup };\r\n  }\r\n  InlineValueVariableLookup2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);\r\n  }\r\n  InlineValueVariableLookup2.is = is;\r\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\r\nvar InlineValueEvaluatableExpression;\r\n(function(InlineValueEvaluatableExpression2) {\r\n  function create(range, expression) {\r\n    return { range, expression };\r\n  }\r\n  InlineValueEvaluatableExpression2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);\r\n  }\r\n  InlineValueEvaluatableExpression2.is = is;\r\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\r\nvar InlineValueContext;\r\n(function(InlineValueContext2) {\r\n  function create(frameId, stoppedLocation) {\r\n    return { frameId, stoppedLocation };\r\n  }\r\n  InlineValueContext2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.defined(candidate) && Range.is(value.stoppedLocation);\r\n  }\r\n  InlineValueContext2.is = is;\r\n})(InlineValueContext || (InlineValueContext = {}));\r\nvar InlayHintKind;\r\n(function(InlayHintKind2) {\r\n  InlayHintKind2.Type = 1;\r\n  InlayHintKind2.Parameter = 2;\r\n  function is(value) {\r\n    return value === 1 || value === 2;\r\n  }\r\n  InlayHintKind2.is = is;\r\n})(InlayHintKind || (InlayHintKind = {}));\r\nvar InlayHintLabelPart;\r\n(function(InlayHintLabelPart2) {\r\n  function create(value) {\r\n    return { value };\r\n  }\r\n  InlayHintLabelPart2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));\r\n  }\r\n  InlayHintLabelPart2.is = is;\r\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\r\nvar InlayHint;\r\n(function(InlayHint2) {\r\n  function create(position, label, kind) {\r\n    const result = { position, label };\r\n    if (kind !== void 0) {\r\n      result.kind = kind;\r\n    }\r\n    return result;\r\n  }\r\n  InlayHint2.create = create;\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));\r\n  }\r\n  InlayHint2.is = is;\r\n})(InlayHint || (InlayHint = {}));\r\nvar StringValue;\r\n(function(StringValue2) {\r\n  function createSnippet(value) {\r\n    return { kind: \"snippet\", value };\r\n  }\r\n  StringValue2.createSnippet = createSnippet;\r\n})(StringValue || (StringValue = {}));\r\nvar InlineCompletionItem;\r\n(function(InlineCompletionItem2) {\r\n  function create(insertText, filterText, range, command) {\r\n    return { insertText, filterText, range, command };\r\n  }\r\n  InlineCompletionItem2.create = create;\r\n})(InlineCompletionItem || (InlineCompletionItem = {}));\r\nvar InlineCompletionList;\r\n(function(InlineCompletionList2) {\r\n  function create(items) {\r\n    return { items };\r\n  }\r\n  InlineCompletionList2.create = create;\r\n})(InlineCompletionList || (InlineCompletionList = {}));\r\nvar InlineCompletionTriggerKind;\r\n(function(InlineCompletionTriggerKind2) {\r\n  InlineCompletionTriggerKind2.Invoked = 0;\r\n  InlineCompletionTriggerKind2.Automatic = 1;\r\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\r\nvar SelectedCompletionInfo;\r\n(function(SelectedCompletionInfo2) {\r\n  function create(range, text) {\r\n    return { range, text };\r\n  }\r\n  SelectedCompletionInfo2.create = create;\r\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\r\nvar InlineCompletionContext;\r\n(function(InlineCompletionContext2) {\r\n  function create(triggerKind, selectedCompletionInfo) {\r\n    return { triggerKind, selectedCompletionInfo };\r\n  }\r\n  InlineCompletionContext2.create = create;\r\n})(InlineCompletionContext || (InlineCompletionContext = {}));\r\nvar WorkspaceFolder;\r\n(function(WorkspaceFolder2) {\r\n  function is(value) {\r\n    const candidate = value;\r\n    return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\r\n  }\r\n  WorkspaceFolder2.is = is;\r\n})(WorkspaceFolder || (WorkspaceFolder = {}));\r\nvar TextDocument;\r\n(function(TextDocument3) {\r\n  function create(uri, languageId, version, content) {\r\n    return new FullTextDocument(uri, languageId, version, content);\r\n  }\r\n  TextDocument3.create = create;\r\n  function is(value) {\r\n    let candidate = value;\r\n    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n  }\r\n  TextDocument3.is = is;\r\n  function applyEdits(document, edits) {\r\n    let text = document.getText();\r\n    let sortedEdits = mergeSort2(edits, (a2, b) => {\r\n      let diff = a2.range.start.line - b.range.start.line;\r\n      if (diff === 0) {\r\n        return a2.range.start.character - b.range.start.character;\r\n      }\r\n      return diff;\r\n    });\r\n    let lastModifiedOffset = text.length;\r\n    for (let i = sortedEdits.length - 1; i >= 0; i--) {\r\n      let e = sortedEdits[i];\r\n      let startOffset = document.offsetAt(e.range.start);\r\n      let endOffset = document.offsetAt(e.range.end);\r\n      if (endOffset <= lastModifiedOffset) {\r\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n      } else {\r\n        throw new Error(\"Overlapping edit\");\r\n      }\r\n      lastModifiedOffset = startOffset;\r\n    }\r\n    return text;\r\n  }\r\n  TextDocument3.applyEdits = applyEdits;\r\n  function mergeSort2(data, compare) {\r\n    if (data.length <= 1) {\r\n      return data;\r\n    }\r\n    const p = data.length / 2 | 0;\r\n    const left = data.slice(0, p);\r\n    const right = data.slice(p);\r\n    mergeSort2(left, compare);\r\n    mergeSort2(right, compare);\r\n    let leftIdx = 0;\r\n    let rightIdx = 0;\r\n    let i = 0;\r\n    while (leftIdx < left.length && rightIdx < right.length) {\r\n      let ret = compare(left[leftIdx], right[rightIdx]);\r\n      if (ret <= 0) {\r\n        data[i++] = left[leftIdx++];\r\n      } else {\r\n        data[i++] = right[rightIdx++];\r\n      }\r\n    }\r\n    while (leftIdx < left.length) {\r\n      data[i++] = left[leftIdx++];\r\n    }\r\n    while (rightIdx < right.length) {\r\n      data[i++] = right[rightIdx++];\r\n    }\r\n    return data;\r\n  }\r\n})(TextDocument || (TextDocument = {}));\r\nvar FullTextDocument = class {\r\n  constructor(uri, languageId, version, content) {\r\n    this._uri = uri;\r\n    this._languageId = languageId;\r\n    this._version = version;\r\n    this._content = content;\r\n    this._lineOffsets = void 0;\r\n  }\r\n  get uri() {\r\n    return this._uri;\r\n  }\r\n  get languageId() {\r\n    return this._languageId;\r\n  }\r\n  get version() {\r\n    return this._version;\r\n  }\r\n  getText(range) {\r\n    if (range) {\r\n      let start = this.offsetAt(range.start);\r\n      let end = this.offsetAt(range.end);\r\n      return this._content.substring(start, end);\r\n    }\r\n    return this._content;\r\n  }\r\n  update(event, version) {\r\n    this._content = event.text;\r\n    this._version = version;\r\n    this._lineOffsets = void 0;\r\n  }\r\n  getLineOffsets() {\r\n    if (this._lineOffsets === void 0) {\r\n      let lineOffsets = [];\r\n      let text = this._content;\r\n      let isLineStart = true;\r\n      for (let i = 0; i < text.length; i++) {\r\n        if (isLineStart) {\r\n          lineOffsets.push(i);\r\n          isLineStart = false;\r\n        }\r\n        let ch = text.charAt(i);\r\n        isLineStart = ch === \"\\r\" || ch === \"\\n\";\r\n        if (ch === \"\\r\" && i + 1 < text.length && text.charAt(i + 1) === \"\\n\") {\r\n          i++;\r\n        }\r\n      }\r\n      if (isLineStart && text.length > 0) {\r\n        lineOffsets.push(text.length);\r\n      }\r\n      this._lineOffsets = lineOffsets;\r\n    }\r\n    return this._lineOffsets;\r\n  }\r\n  positionAt(offset) {\r\n    offset = Math.max(Math.min(offset, this._content.length), 0);\r\n    let lineOffsets = this.getLineOffsets();\r\n    let low = 0, high = lineOffsets.length;\r\n    if (high === 0) {\r\n      return Position.create(0, offset);\r\n    }\r\n    while (low < high) {\r\n      let mid = Math.floor((low + high) / 2);\r\n      if (lineOffsets[mid] > offset) {\r\n        high = mid;\r\n      } else {\r\n        low = mid + 1;\r\n      }\r\n    }\r\n    let line = low - 1;\r\n    return Position.create(line, offset - lineOffsets[line]);\r\n  }\r\n  offsetAt(position) {\r\n    let lineOffsets = this.getLineOffsets();\r\n    if (position.line >= lineOffsets.length) {\r\n      return this._content.length;\r\n    } else if (position.line < 0) {\r\n      return 0;\r\n    }\r\n    let lineOffset = lineOffsets[position.line];\r\n    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\r\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n  }\r\n  get lineCount() {\r\n    return this.getLineOffsets().length;\r\n  }\r\n};\r\nvar Is;\r\n(function(Is2) {\r\n  const toString = Object.prototype.toString;\r\n  function defined(value) {\r\n    return typeof value !== \"undefined\";\r\n  }\r\n  Is2.defined = defined;\r\n  function undefined2(value) {\r\n    return typeof value === \"undefined\";\r\n  }\r\n  Is2.undefined = undefined2;\r\n  function boolean(value) {\r\n    return value === true || value === false;\r\n  }\r\n  Is2.boolean = boolean;\r\n  function string(value) {\r\n    return toString.call(value) === \"[object String]\";\r\n  }\r\n  Is2.string = string;\r\n  function number(value) {\r\n    return toString.call(value) === \"[object Number]\";\r\n  }\r\n  Is2.number = number;\r\n  function numberRange(value, min, max) {\r\n    return toString.call(value) === \"[object Number]\" && min <= value && value <= max;\r\n  }\r\n  Is2.numberRange = numberRange;\r\n  function integer2(value) {\r\n    return toString.call(value) === \"[object Number]\" && -2147483648 <= value && value <= 2147483647;\r\n  }\r\n  Is2.integer = integer2;\r\n  function uinteger2(value) {\r\n    return toString.call(value) === \"[object Number]\" && 0 <= value && value <= 2147483647;\r\n  }\r\n  Is2.uinteger = uinteger2;\r\n  function func(value) {\r\n    return toString.call(value) === \"[object Function]\";\r\n  }\r\n  Is2.func = func;\r\n  function objectLiteral(value) {\r\n    return value !== null && typeof value === \"object\";\r\n  }\r\n  Is2.objectLiteral = objectLiteral;\r\n  function typedArray(value, check) {\r\n    return Array.isArray(value) && value.every(check);\r\n  }\r\n  Is2.typedArray = typedArray;\r\n})(Is || (Is = {}));\r\n\r\n// node_modules/vscode-languageserver-textdocument/lib/esm/main.js\r\nvar FullTextDocument2 = class _FullTextDocument {\r\n  constructor(uri, languageId, version, content) {\r\n    this._uri = uri;\r\n    this._languageId = languageId;\r\n    this._version = version;\r\n    this._content = content;\r\n    this._lineOffsets = void 0;\r\n  }\r\n  get uri() {\r\n    return this._uri;\r\n  }\r\n  get languageId() {\r\n    return this._languageId;\r\n  }\r\n  get version() {\r\n    return this._version;\r\n  }\r\n  getText(range) {\r\n    if (range) {\r\n      const start = this.offsetAt(range.start);\r\n      const end = this.offsetAt(range.end);\r\n      return this._content.substring(start, end);\r\n    }\r\n    return this._content;\r\n  }\r\n  update(changes, version) {\r\n    for (let change of changes) {\r\n      if (_FullTextDocument.isIncremental(change)) {\r\n        const range = getWellformedRange(change.range);\r\n        const startOffset = this.offsetAt(range.start);\r\n        const endOffset = this.offsetAt(range.end);\r\n        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\r\n        const startLine = Math.max(range.start.line, 0);\r\n        const endLine = Math.max(range.end.line, 0);\r\n        let lineOffsets = this._lineOffsets;\r\n        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\r\n        if (endLine - startLine === addedLineOffsets.length) {\r\n          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\r\n            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\r\n          }\r\n        } else {\r\n          if (addedLineOffsets.length < 1e4) {\r\n            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\r\n          } else {\r\n            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\r\n          }\r\n        }\r\n        const diff = change.text.length - (endOffset - startOffset);\r\n        if (diff !== 0) {\r\n          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\r\n            lineOffsets[i] = lineOffsets[i] + diff;\r\n          }\r\n        }\r\n      } else if (_FullTextDocument.isFull(change)) {\r\n        this._content = change.text;\r\n        this._lineOffsets = void 0;\r\n      } else {\r\n        throw new Error(\"Unknown change event received\");\r\n      }\r\n    }\r\n    this._version = version;\r\n  }\r\n  getLineOffsets() {\r\n    if (this._lineOffsets === void 0) {\r\n      this._lineOffsets = computeLineOffsets(this._content, true);\r\n    }\r\n    return this._lineOffsets;\r\n  }\r\n  positionAt(offset) {\r\n    offset = Math.max(Math.min(offset, this._content.length), 0);\r\n    let lineOffsets = this.getLineOffsets();\r\n    let low = 0, high = lineOffsets.length;\r\n    if (high === 0) {\r\n      return { line: 0, character: offset };\r\n    }\r\n    while (low < high) {\r\n      let mid = Math.floor((low + high) / 2);\r\n      if (lineOffsets[mid] > offset) {\r\n        high = mid;\r\n      } else {\r\n        low = mid + 1;\r\n      }\r\n    }\r\n    let line = low - 1;\r\n    return { line, character: offset - lineOffsets[line] };\r\n  }\r\n  offsetAt(position) {\r\n    let lineOffsets = this.getLineOffsets();\r\n    if (position.line >= lineOffsets.length) {\r\n      return this._content.length;\r\n    } else if (position.line < 0) {\r\n      return 0;\r\n    }\r\n    let lineOffset = lineOffsets[position.line];\r\n    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\r\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n  }\r\n  get lineCount() {\r\n    return this.getLineOffsets().length;\r\n  }\r\n  static isIncremental(event) {\r\n    let candidate = event;\r\n    return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === \"number\");\r\n  }\r\n  static isFull(event) {\r\n    let candidate = event;\r\n    return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range === void 0 && candidate.rangeLength === void 0;\r\n  }\r\n};\r\nvar TextDocument2;\r\n(function(TextDocument3) {\r\n  function create(uri, languageId, version, content) {\r\n    return new FullTextDocument2(uri, languageId, version, content);\r\n  }\r\n  TextDocument3.create = create;\r\n  function update(document, changes, version) {\r\n    if (document instanceof FullTextDocument2) {\r\n      document.update(changes, version);\r\n      return document;\r\n    } else {\r\n      throw new Error(\"TextDocument.update: document must be created by TextDocument.create\");\r\n    }\r\n  }\r\n  TextDocument3.update = update;\r\n  function applyEdits(document, edits) {\r\n    let text = document.getText();\r\n    let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a2, b) => {\r\n      let diff = a2.range.start.line - b.range.start.line;\r\n      if (diff === 0) {\r\n        return a2.range.start.character - b.range.start.character;\r\n      }\r\n      return diff;\r\n    });\r\n    let lastModifiedOffset = 0;\r\n    const spans = [];\r\n    for (const e of sortedEdits) {\r\n      let startOffset = document.offsetAt(e.range.start);\r\n      if (startOffset < lastModifiedOffset) {\r\n        throw new Error(\"Overlapping edit\");\r\n      } else if (startOffset > lastModifiedOffset) {\r\n        spans.push(text.substring(lastModifiedOffset, startOffset));\r\n      }\r\n      if (e.newText.length) {\r\n        spans.push(e.newText);\r\n      }\r\n      lastModifiedOffset = document.offsetAt(e.range.end);\r\n    }\r\n    spans.push(text.substr(lastModifiedOffset));\r\n    return spans.join(\"\");\r\n  }\r\n  TextDocument3.applyEdits = applyEdits;\r\n})(TextDocument2 || (TextDocument2 = {}));\r\nfunction mergeSort(data, compare) {\r\n  if (data.length <= 1) {\r\n    return data;\r\n  }\r\n  const p = data.length / 2 | 0;\r\n  const left = data.slice(0, p);\r\n  const right = data.slice(p);\r\n  mergeSort(left, compare);\r\n  mergeSort(right, compare);\r\n  let leftIdx = 0;\r\n  let rightIdx = 0;\r\n  let i = 0;\r\n  while (leftIdx < left.length && rightIdx < right.length) {\r\n    let ret = compare(left[leftIdx], right[rightIdx]);\r\n    if (ret <= 0) {\r\n      data[i++] = left[leftIdx++];\r\n    } else {\r\n      data[i++] = right[rightIdx++];\r\n    }\r\n  }\r\n  while (leftIdx < left.length) {\r\n    data[i++] = left[leftIdx++];\r\n  }\r\n  while (rightIdx < right.length) {\r\n    data[i++] = right[rightIdx++];\r\n  }\r\n  return data;\r\n}\r\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\r\n  const result = isAtLineStart ? [textOffset] : [];\r\n  for (let i = 0; i < text.length; i++) {\r\n    let ch = text.charCodeAt(i);\r\n    if (ch === 13 || ch === 10) {\r\n      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {\r\n        i++;\r\n      }\r\n      result.push(textOffset + i + 1);\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction getWellformedRange(range) {\r\n  const start = range.start;\r\n  const end = range.end;\r\n  if (start.line > end.line || start.line === end.line && start.character > end.character) {\r\n    return { start: end, end: start };\r\n  }\r\n  return range;\r\n}\r\nfunction getWellformedEdit(textEdit) {\r\n  const range = getWellformedRange(textEdit.range);\r\n  if (range !== textEdit.range) {\r\n    return { newText: textEdit.newText, range };\r\n  }\r\n  return textEdit;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/jsonLanguageTypes.js\r\nvar ErrorCode;\r\n(function(ErrorCode2) {\r\n  ErrorCode2[ErrorCode2[\"Undefined\"] = 0] = \"Undefined\";\r\n  ErrorCode2[ErrorCode2[\"EnumValueMismatch\"] = 1] = \"EnumValueMismatch\";\r\n  ErrorCode2[ErrorCode2[\"Deprecated\"] = 2] = \"Deprecated\";\r\n  ErrorCode2[ErrorCode2[\"UnexpectedEndOfComment\"] = 257] = \"UnexpectedEndOfComment\";\r\n  ErrorCode2[ErrorCode2[\"UnexpectedEndOfString\"] = 258] = \"UnexpectedEndOfString\";\r\n  ErrorCode2[ErrorCode2[\"UnexpectedEndOfNumber\"] = 259] = \"UnexpectedEndOfNumber\";\r\n  ErrorCode2[ErrorCode2[\"InvalidUnicode\"] = 260] = \"InvalidUnicode\";\r\n  ErrorCode2[ErrorCode2[\"InvalidEscapeCharacter\"] = 261] = \"InvalidEscapeCharacter\";\r\n  ErrorCode2[ErrorCode2[\"InvalidCharacter\"] = 262] = \"InvalidCharacter\";\r\n  ErrorCode2[ErrorCode2[\"PropertyExpected\"] = 513] = \"PropertyExpected\";\r\n  ErrorCode2[ErrorCode2[\"CommaExpected\"] = 514] = \"CommaExpected\";\r\n  ErrorCode2[ErrorCode2[\"ColonExpected\"] = 515] = \"ColonExpected\";\r\n  ErrorCode2[ErrorCode2[\"ValueExpected\"] = 516] = \"ValueExpected\";\r\n  ErrorCode2[ErrorCode2[\"CommaOrCloseBacketExpected\"] = 517] = \"CommaOrCloseBacketExpected\";\r\n  ErrorCode2[ErrorCode2[\"CommaOrCloseBraceExpected\"] = 518] = \"CommaOrCloseBraceExpected\";\r\n  ErrorCode2[ErrorCode2[\"TrailingComma\"] = 519] = \"TrailingComma\";\r\n  ErrorCode2[ErrorCode2[\"DuplicateKey\"] = 520] = \"DuplicateKey\";\r\n  ErrorCode2[ErrorCode2[\"CommentNotPermitted\"] = 521] = \"CommentNotPermitted\";\r\n  ErrorCode2[ErrorCode2[\"PropertyKeysMustBeDoublequoted\"] = 528] = \"PropertyKeysMustBeDoublequoted\";\r\n  ErrorCode2[ErrorCode2[\"SchemaResolveError\"] = 768] = \"SchemaResolveError\";\r\n  ErrorCode2[ErrorCode2[\"SchemaUnsupportedFeature\"] = 769] = \"SchemaUnsupportedFeature\";\r\n})(ErrorCode || (ErrorCode = {}));\r\nvar SchemaDraft;\r\n(function(SchemaDraft2) {\r\n  SchemaDraft2[SchemaDraft2[\"v3\"] = 3] = \"v3\";\r\n  SchemaDraft2[SchemaDraft2[\"v4\"] = 4] = \"v4\";\r\n  SchemaDraft2[SchemaDraft2[\"v6\"] = 6] = \"v6\";\r\n  SchemaDraft2[SchemaDraft2[\"v7\"] = 7] = \"v7\";\r\n  SchemaDraft2[SchemaDraft2[\"v2019_09\"] = 19] = \"v2019_09\";\r\n  SchemaDraft2[SchemaDraft2[\"v2020_12\"] = 20] = \"v2020_12\";\r\n})(SchemaDraft || (SchemaDraft = {}));\r\nvar ClientCapabilities;\r\n(function(ClientCapabilities2) {\r\n  ClientCapabilities2.LATEST = {\r\n    textDocument: {\r\n      completion: {\r\n        completionItem: {\r\n          documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],\r\n          commitCharactersSupport: true,\r\n          labelDetailsSupport: true\r\n        }\r\n      }\r\n    }\r\n  };\r\n})(ClientCapabilities || (ClientCapabilities = {}));\r\n\r\n// node_modules/@vscode/l10n/dist/browser.js\r\nvar bundle;\r\nfunction t(...args) {\r\n  const firstArg = args[0];\r\n  let key;\r\n  let message;\r\n  let formatArgs;\r\n  if (typeof firstArg === \"string\") {\r\n    key = firstArg;\r\n    message = firstArg;\r\n    args.splice(0, 1);\r\n    formatArgs = !args || typeof args[0] !== \"object\" ? args : args[0];\r\n  } else if (firstArg instanceof Array) {\r\n    const replacements = args.slice(1);\r\n    if (firstArg.length !== replacements.length + 1) {\r\n      throw new Error(\"expected a string as the first argument to l10n.t\");\r\n    }\r\n    let str = firstArg[0];\r\n    for (let i = 1; i < firstArg.length; i++) {\r\n      str += `{${i - 1}}` + firstArg[i];\r\n    }\r\n    return t(str, ...replacements);\r\n  } else {\r\n    message = firstArg.message;\r\n    key = message;\r\n    if (firstArg.comment && firstArg.comment.length > 0) {\r\n      key += `/${Array.isArray(firstArg.comment) ? firstArg.comment.join(\"\") : firstArg.comment}`;\r\n    }\r\n    formatArgs = firstArg.args ?? {};\r\n  }\r\n  const messageFromBundle = bundle?.[key];\r\n  if (!messageFromBundle) {\r\n    return format3(message, formatArgs);\r\n  }\r\n  if (typeof messageFromBundle === \"string\") {\r\n    return format3(messageFromBundle, formatArgs);\r\n  }\r\n  if (messageFromBundle.comment) {\r\n    return format3(messageFromBundle.message, formatArgs);\r\n  }\r\n  return format3(message, formatArgs);\r\n}\r\nvar _format2Regexp = /{([^}]+)}/g;\r\nfunction format3(template, values) {\r\n  if (Object.keys(values).length === 0) {\r\n    return template;\r\n  }\r\n  return template.replace(_format2Regexp, (match, group) => values[group] ?? match);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/parser/jsonParser.js\r\nvar formats = {\r\n  \"color-hex\": { errorMessage: t(\"Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.\"), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },\r\n  \"date-time\": { errorMessage: t(\"String is not a RFC3339 date-time.\"), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\r\n  \"date\": { errorMessage: t(\"String is not a RFC3339 date.\"), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },\r\n  \"time\": { errorMessage: t(\"String is not a RFC3339 time.\"), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\r\n  \"email\": { errorMessage: t(\"String is not an e-mail address.\"), pattern: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}))$/ },\r\n  \"hostname\": { errorMessage: t(\"String is not a hostname.\"), pattern: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i },\r\n  \"ipv4\": { errorMessage: t(\"String is not an IPv4 address.\"), pattern: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/ },\r\n  \"ipv6\": { errorMessage: t(\"String is not an IPv6 address.\"), pattern: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i }\r\n};\r\nvar ASTNodeImpl = class {\r\n  constructor(parent, offset, length = 0) {\r\n    this.offset = offset;\r\n    this.length = length;\r\n    this.parent = parent;\r\n  }\r\n  get children() {\r\n    return [];\r\n  }\r\n  toString() {\r\n    return \"type: \" + this.type + \" (\" + this.offset + \"/\" + this.length + \")\" + (this.parent ? \" parent: {\" + this.parent.toString() + \"}\" : \"\");\r\n  }\r\n};\r\nvar NullASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, offset) {\r\n    super(parent, offset);\r\n    this.type = \"null\";\r\n    this.value = null;\r\n  }\r\n};\r\nvar BooleanASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, boolValue, offset) {\r\n    super(parent, offset);\r\n    this.type = \"boolean\";\r\n    this.value = boolValue;\r\n  }\r\n};\r\nvar ArrayASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, offset) {\r\n    super(parent, offset);\r\n    this.type = \"array\";\r\n    this.items = [];\r\n  }\r\n  get children() {\r\n    return this.items;\r\n  }\r\n};\r\nvar NumberASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, offset) {\r\n    super(parent, offset);\r\n    this.type = \"number\";\r\n    this.isInteger = true;\r\n    this.value = Number.NaN;\r\n  }\r\n};\r\nvar StringASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, offset, length) {\r\n    super(parent, offset, length);\r\n    this.type = \"string\";\r\n    this.value = \"\";\r\n  }\r\n};\r\nvar PropertyASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, offset, keyNode) {\r\n    super(parent, offset);\r\n    this.type = \"property\";\r\n    this.colonOffset = -1;\r\n    this.keyNode = keyNode;\r\n  }\r\n  get children() {\r\n    return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\r\n  }\r\n};\r\nvar ObjectASTNodeImpl = class extends ASTNodeImpl {\r\n  constructor(parent, offset) {\r\n    super(parent, offset);\r\n    this.type = \"object\";\r\n    this.properties = [];\r\n  }\r\n  get children() {\r\n    return this.properties;\r\n  }\r\n};\r\nfunction asSchema(schema) {\r\n  if (isBoolean(schema)) {\r\n    return schema ? {} : { \"not\": {} };\r\n  }\r\n  return schema;\r\n}\r\nvar EnumMatch;\r\n(function(EnumMatch2) {\r\n  EnumMatch2[EnumMatch2[\"Key\"] = 0] = \"Key\";\r\n  EnumMatch2[EnumMatch2[\"Enum\"] = 1] = \"Enum\";\r\n})(EnumMatch || (EnumMatch = {}));\r\nvar schemaDraftFromId = {\r\n  \"http://json-schema.org/draft-03/schema#\": SchemaDraft.v3,\r\n  \"http://json-schema.org/draft-04/schema#\": SchemaDraft.v4,\r\n  \"http://json-schema.org/draft-06/schema#\": SchemaDraft.v6,\r\n  \"http://json-schema.org/draft-07/schema#\": SchemaDraft.v7,\r\n  \"https://json-schema.org/draft/2019-09/schema\": SchemaDraft.v2019_09,\r\n  \"https://json-schema.org/draft/2020-12/schema\": SchemaDraft.v2020_12\r\n};\r\nvar EvaluationContext = class {\r\n  constructor(schemaDraft) {\r\n    this.schemaDraft = schemaDraft;\r\n  }\r\n};\r\nvar SchemaCollector = class _SchemaCollector {\r\n  constructor(focusOffset = -1, exclude) {\r\n    this.focusOffset = focusOffset;\r\n    this.exclude = exclude;\r\n    this.schemas = [];\r\n  }\r\n  add(schema) {\r\n    this.schemas.push(schema);\r\n  }\r\n  merge(other) {\r\n    Array.prototype.push.apply(this.schemas, other.schemas);\r\n  }\r\n  include(node) {\r\n    return (this.focusOffset === -1 || contains2(node, this.focusOffset)) && node !== this.exclude;\r\n  }\r\n  newSub() {\r\n    return new _SchemaCollector(-1, this.exclude);\r\n  }\r\n};\r\nvar NoOpSchemaCollector = class {\r\n  constructor() {\r\n  }\r\n  get schemas() {\r\n    return [];\r\n  }\r\n  add(_schema) {\r\n  }\r\n  merge(_other) {\r\n  }\r\n  include(_node) {\r\n    return true;\r\n  }\r\n  newSub() {\r\n    return this;\r\n  }\r\n};\r\nNoOpSchemaCollector.instance = new NoOpSchemaCollector();\r\nvar ValidationResult = class {\r\n  constructor() {\r\n    this.problems = [];\r\n    this.propertiesMatches = 0;\r\n    this.processedProperties = /* @__PURE__ */ new Set();\r\n    this.propertiesValueMatches = 0;\r\n    this.primaryValueMatches = 0;\r\n    this.enumValueMatch = false;\r\n    this.enumValues = void 0;\r\n  }\r\n  hasProblems() {\r\n    return !!this.problems.length;\r\n  }\r\n  merge(validationResult) {\r\n    this.problems = this.problems.concat(validationResult.problems);\r\n    this.propertiesMatches += validationResult.propertiesMatches;\r\n    this.propertiesValueMatches += validationResult.propertiesValueMatches;\r\n    this.mergeProcessedProperties(validationResult);\r\n  }\r\n  mergeEnumValues(validationResult) {\r\n    if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {\r\n      this.enumValues = this.enumValues.concat(validationResult.enumValues);\r\n      for (const error of this.problems) {\r\n        if (error.code === ErrorCode.EnumValueMismatch) {\r\n          error.message = t(\"Value is not accepted. Valid values: {0}.\", this.enumValues.map((v) => JSON.stringify(v)).join(\", \"));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  mergePropertyMatch(propertyValidationResult) {\r\n    this.problems = this.problems.concat(propertyValidationResult.problems);\r\n    this.propertiesMatches++;\r\n    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {\r\n      this.propertiesValueMatches++;\r\n    }\r\n    if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {\r\n      this.primaryValueMatches++;\r\n    }\r\n  }\r\n  mergeProcessedProperties(validationResult) {\r\n    validationResult.processedProperties.forEach((p) => this.processedProperties.add(p));\r\n  }\r\n  compare(other) {\r\n    const hasProblems = this.hasProblems();\r\n    if (hasProblems !== other.hasProblems()) {\r\n      return hasProblems ? -1 : 1;\r\n    }\r\n    if (this.enumValueMatch !== other.enumValueMatch) {\r\n      return other.enumValueMatch ? -1 : 1;\r\n    }\r\n    if (this.primaryValueMatches !== other.primaryValueMatches) {\r\n      return this.primaryValueMatches - other.primaryValueMatches;\r\n    }\r\n    if (this.propertiesValueMatches !== other.propertiesValueMatches) {\r\n      return this.propertiesValueMatches - other.propertiesValueMatches;\r\n    }\r\n    return this.propertiesMatches - other.propertiesMatches;\r\n  }\r\n};\r\nfunction newJSONDocument(root, diagnostics = []) {\r\n  return new JSONDocument(root, diagnostics, []);\r\n}\r\nfunction getNodeValue3(node) {\r\n  return getNodeValue2(node);\r\n}\r\nfunction getNodePath3(node) {\r\n  return getNodePath2(node);\r\n}\r\nfunction contains2(node, offset, includeRightBound = false) {\r\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\r\n}\r\nvar JSONDocument = class {\r\n  constructor(root, syntaxErrors = [], comments = []) {\r\n    this.root = root;\r\n    this.syntaxErrors = syntaxErrors;\r\n    this.comments = comments;\r\n  }\r\n  getNodeFromOffset(offset, includeRightBound = false) {\r\n    if (this.root) {\r\n      return findNodeAtOffset2(this.root, offset, includeRightBound);\r\n    }\r\n    return void 0;\r\n  }\r\n  visit(visitor) {\r\n    if (this.root) {\r\n      const doVisit = (node) => {\r\n        let ctn = visitor(node);\r\n        const children = node.children;\r\n        if (Array.isArray(children)) {\r\n          for (let i = 0; i < children.length && ctn; i++) {\r\n            ctn = doVisit(children[i]);\r\n          }\r\n        }\r\n        return ctn;\r\n      };\r\n      doVisit(this.root);\r\n    }\r\n  }\r\n  validate(textDocument, schema, severity = DiagnosticSeverity.Warning, schemaDraft) {\r\n    if (this.root && schema) {\r\n      const validationResult = new ValidationResult();\r\n      validate(this.root, schema, validationResult, NoOpSchemaCollector.instance, new EvaluationContext(schemaDraft ?? getSchemaDraft(schema)));\r\n      return validationResult.problems.map((p) => {\r\n        const range = Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\r\n        return Diagnostic.create(range, p.message, p.severity ?? severity, p.code);\r\n      });\r\n    }\r\n    return void 0;\r\n  }\r\n  getMatchingSchemas(schema, focusOffset = -1, exclude) {\r\n    if (this.root && schema) {\r\n      const matchingSchemas = new SchemaCollector(focusOffset, exclude);\r\n      const schemaDraft = getSchemaDraft(schema);\r\n      const context = new EvaluationContext(schemaDraft);\r\n      validate(this.root, schema, new ValidationResult(), matchingSchemas, context);\r\n      return matchingSchemas.schemas;\r\n    }\r\n    return [];\r\n  }\r\n};\r\nfunction getSchemaDraft(schema, fallBack = SchemaDraft.v2020_12) {\r\n  let schemaId = schema.$schema;\r\n  if (schemaId) {\r\n    return schemaDraftFromId[schemaId] ?? fallBack;\r\n  }\r\n  return fallBack;\r\n}\r\nfunction validate(n, schema, validationResult, matchingSchemas, context) {\r\n  if (!n || !matchingSchemas.include(n)) {\r\n    return;\r\n  }\r\n  if (n.type === \"property\") {\r\n    return validate(n.valueNode, schema, validationResult, matchingSchemas, context);\r\n  }\r\n  const node = n;\r\n  _validateNode();\r\n  switch (node.type) {\r\n    case \"object\":\r\n      _validateObjectNode(node);\r\n      break;\r\n    case \"array\":\r\n      _validateArrayNode(node);\r\n      break;\r\n    case \"string\":\r\n      _validateStringNode(node);\r\n      break;\r\n    case \"number\":\r\n      _validateNumberNode(node);\r\n      break;\r\n  }\r\n  matchingSchemas.add({ node, schema });\r\n  function _validateNode() {\r\n    function matchesType(type) {\r\n      return node.type === type || type === \"integer\" && node.type === \"number\" && node.isInteger;\r\n    }\r\n    if (Array.isArray(schema.type)) {\r\n      if (!schema.type.some(matchesType)) {\r\n        validationResult.problems.push({\r\n          location: { offset: node.offset, length: node.length },\r\n          message: schema.errorMessage || t(\"Incorrect type. Expected one of {0}.\", schema.type.join(\", \"))\r\n        });\r\n      }\r\n    } else if (schema.type) {\r\n      if (!matchesType(schema.type)) {\r\n        validationResult.problems.push({\r\n          location: { offset: node.offset, length: node.length },\r\n          message: schema.errorMessage || t('Incorrect type. Expected \"{0}\".', schema.type)\r\n        });\r\n      }\r\n    }\r\n    if (Array.isArray(schema.allOf)) {\r\n      for (const subSchemaRef of schema.allOf) {\r\n        const subValidationResult = new ValidationResult();\r\n        const subMatchingSchemas = matchingSchemas.newSub();\r\n        validate(node, asSchema(subSchemaRef), subValidationResult, subMatchingSchemas, context);\r\n        validationResult.merge(subValidationResult);\r\n        matchingSchemas.merge(subMatchingSchemas);\r\n      }\r\n    }\r\n    const notSchema = asSchema(schema.not);\r\n    if (notSchema) {\r\n      const subValidationResult = new ValidationResult();\r\n      const subMatchingSchemas = matchingSchemas.newSub();\r\n      validate(node, notSchema, subValidationResult, subMatchingSchemas, context);\r\n      if (!subValidationResult.hasProblems()) {\r\n        validationResult.problems.push({\r\n          location: { offset: node.offset, length: node.length },\r\n          message: schema.errorMessage || t(\"Matches a schema that is not allowed.\")\r\n        });\r\n      }\r\n      for (const ms of subMatchingSchemas.schemas) {\r\n        ms.inverted = !ms.inverted;\r\n        matchingSchemas.add(ms);\r\n      }\r\n    }\r\n    const testAlternatives = (alternatives, maxOneMatch) => {\r\n      const matches = [];\r\n      let bestMatch = void 0;\r\n      for (const subSchemaRef of alternatives) {\r\n        const subSchema = asSchema(subSchemaRef);\r\n        const subValidationResult = new ValidationResult();\r\n        const subMatchingSchemas = matchingSchemas.newSub();\r\n        validate(node, subSchema, subValidationResult, subMatchingSchemas, context);\r\n        if (!subValidationResult.hasProblems()) {\r\n          matches.push(subSchema);\r\n        }\r\n        if (!bestMatch) {\r\n          bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\r\n        } else {\r\n          if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {\r\n            bestMatch.matchingSchemas.merge(subMatchingSchemas);\r\n            bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;\r\n            bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\r\n            bestMatch.validationResult.mergeProcessedProperties(subValidationResult);\r\n          } else {\r\n            const compareResult = subValidationResult.compare(bestMatch.validationResult);\r\n            if (compareResult > 0) {\r\n              bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\r\n            } else if (compareResult === 0) {\r\n              bestMatch.matchingSchemas.merge(subMatchingSchemas);\r\n              bestMatch.validationResult.mergeEnumValues(subValidationResult);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (matches.length > 1 && maxOneMatch) {\r\n        validationResult.problems.push({\r\n          location: { offset: node.offset, length: 1 },\r\n          message: t(\"Matches multiple schemas when only one must validate.\")\r\n        });\r\n      }\r\n      if (bestMatch) {\r\n        validationResult.merge(bestMatch.validationResult);\r\n        matchingSchemas.merge(bestMatch.matchingSchemas);\r\n      }\r\n      return matches.length;\r\n    };\r\n    if (Array.isArray(schema.anyOf)) {\r\n      testAlternatives(schema.anyOf, false);\r\n    }\r\n    if (Array.isArray(schema.oneOf)) {\r\n      testAlternatives(schema.oneOf, true);\r\n    }\r\n    const testBranch = (schema2) => {\r\n      const subValidationResult = new ValidationResult();\r\n      const subMatchingSchemas = matchingSchemas.newSub();\r\n      validate(node, asSchema(schema2), subValidationResult, subMatchingSchemas, context);\r\n      validationResult.merge(subValidationResult);\r\n      matchingSchemas.merge(subMatchingSchemas);\r\n    };\r\n    const testCondition = (ifSchema2, thenSchema, elseSchema) => {\r\n      const subSchema = asSchema(ifSchema2);\r\n      const subValidationResult = new ValidationResult();\r\n      const subMatchingSchemas = matchingSchemas.newSub();\r\n      validate(node, subSchema, subValidationResult, subMatchingSchemas, context);\r\n      matchingSchemas.merge(subMatchingSchemas);\r\n      validationResult.mergeProcessedProperties(subValidationResult);\r\n      if (!subValidationResult.hasProblems()) {\r\n        if (thenSchema) {\r\n          testBranch(thenSchema);\r\n        }\r\n      } else if (elseSchema) {\r\n        testBranch(elseSchema);\r\n      }\r\n    };\r\n    const ifSchema = asSchema(schema.if);\r\n    if (ifSchema) {\r\n      testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));\r\n    }\r\n    if (Array.isArray(schema.enum)) {\r\n      const val = getNodeValue3(node);\r\n      let enumValueMatch = false;\r\n      for (const e of schema.enum) {\r\n        if (equals(val, e)) {\r\n          enumValueMatch = true;\r\n          break;\r\n        }\r\n      }\r\n      validationResult.enumValues = schema.enum;\r\n      validationResult.enumValueMatch = enumValueMatch;\r\n      if (!enumValueMatch) {\r\n        validationResult.problems.push({\r\n          location: { offset: node.offset, length: node.length },\r\n          code: ErrorCode.EnumValueMismatch,\r\n          message: schema.errorMessage || t(\"Value is not accepted. Valid values: {0}.\", schema.enum.map((v) => JSON.stringify(v)).join(\", \"))\r\n        });\r\n      }\r\n    }\r\n    if (isDefined(schema.const)) {\r\n      const val = getNodeValue3(node);\r\n      if (!equals(val, schema.const)) {\r\n        validationResult.problems.push({\r\n          location: { offset: node.offset, length: node.length },\r\n          code: ErrorCode.EnumValueMismatch,\r\n          message: schema.errorMessage || t(\"Value must be {0}.\", JSON.stringify(schema.const))\r\n        });\r\n        validationResult.enumValueMatch = false;\r\n      } else {\r\n        validationResult.enumValueMatch = true;\r\n      }\r\n      validationResult.enumValues = [schema.const];\r\n    }\r\n    let deprecationMessage = schema.deprecationMessage;\r\n    if (deprecationMessage || schema.deprecated) {\r\n      deprecationMessage = deprecationMessage || t(\"Value is deprecated\");\r\n      let targetNode = node.parent?.type === \"property\" ? node.parent : node;\r\n      validationResult.problems.push({\r\n        location: { offset: targetNode.offset, length: targetNode.length },\r\n        severity: DiagnosticSeverity.Warning,\r\n        message: deprecationMessage,\r\n        code: ErrorCode.Deprecated\r\n      });\r\n    }\r\n  }\r\n  function _validateNumberNode(node2) {\r\n    const val = node2.value;\r\n    function normalizeFloats(float) {\r\n      const parts = /^(-?\\d+)(?:\\.(\\d+))?(?:e([-+]\\d+))?$/.exec(float.toString());\r\n      return parts && {\r\n        value: Number(parts[1] + (parts[2] || \"\")),\r\n        multiplier: (parts[2]?.length || 0) - (parseInt(parts[3]) || 0)\r\n      };\r\n    }\r\n    ;\r\n    if (isNumber(schema.multipleOf)) {\r\n      let remainder = -1;\r\n      if (Number.isInteger(schema.multipleOf)) {\r\n        remainder = val % schema.multipleOf;\r\n      } else {\r\n        let normMultipleOf = normalizeFloats(schema.multipleOf);\r\n        let normValue = normalizeFloats(val);\r\n        if (normMultipleOf && normValue) {\r\n          const multiplier = 10 ** Math.abs(normValue.multiplier - normMultipleOf.multiplier);\r\n          if (normValue.multiplier < normMultipleOf.multiplier) {\r\n            normValue.value *= multiplier;\r\n          } else {\r\n            normMultipleOf.value *= multiplier;\r\n          }\r\n          remainder = normValue.value % normMultipleOf.value;\r\n        }\r\n      }\r\n      if (remainder !== 0) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: t(\"Value is not divisible by {0}.\", schema.multipleOf)\r\n        });\r\n      }\r\n    }\r\n    function getExclusiveLimit(limit, exclusive) {\r\n      if (isNumber(exclusive)) {\r\n        return exclusive;\r\n      }\r\n      if (isBoolean(exclusive) && exclusive) {\r\n        return limit;\r\n      }\r\n      return void 0;\r\n    }\r\n    function getLimit(limit, exclusive) {\r\n      if (!isBoolean(exclusive) || !exclusive) {\r\n        return limit;\r\n      }\r\n      return void 0;\r\n    }\r\n    const exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);\r\n    if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"Value is below the exclusive minimum of {0}.\", exclusiveMinimum)\r\n      });\r\n    }\r\n    const exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);\r\n    if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"Value is above the exclusive maximum of {0}.\", exclusiveMaximum)\r\n      });\r\n    }\r\n    const minimum = getLimit(schema.minimum, schema.exclusiveMinimum);\r\n    if (isNumber(minimum) && val < minimum) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"Value is below the minimum of {0}.\", minimum)\r\n      });\r\n    }\r\n    const maximum = getLimit(schema.maximum, schema.exclusiveMaximum);\r\n    if (isNumber(maximum) && val > maximum) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"Value is above the maximum of {0}.\", maximum)\r\n      });\r\n    }\r\n  }\r\n  function _validateStringNode(node2) {\r\n    if (isNumber(schema.minLength) && stringLength(node2.value) < schema.minLength) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"String is shorter than the minimum length of {0}.\", schema.minLength)\r\n      });\r\n    }\r\n    if (isNumber(schema.maxLength) && stringLength(node2.value) > schema.maxLength) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"String is longer than the maximum length of {0}.\", schema.maxLength)\r\n      });\r\n    }\r\n    if (isString(schema.pattern)) {\r\n      const regex = extendedRegExp(schema.pattern);\r\n      if (!regex?.test(node2.value)) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: schema.patternErrorMessage || schema.errorMessage || t('String does not match the pattern of \"{0}\".', schema.pattern)\r\n        });\r\n      }\r\n    }\r\n    if (schema.format) {\r\n      switch (schema.format) {\r\n        case \"uri\":\r\n        case \"uri-reference\":\r\n          {\r\n            let errorMessage;\r\n            if (!node2.value) {\r\n              errorMessage = t(\"URI expected.\");\r\n            } else {\r\n              const match = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(node2.value);\r\n              if (!match) {\r\n                errorMessage = t(\"URI is expected.\");\r\n              } else if (!match[2] && schema.format === \"uri\") {\r\n                errorMessage = t(\"URI with a scheme is expected.\");\r\n              }\r\n            }\r\n            if (errorMessage) {\r\n              validationResult.problems.push({\r\n                location: { offset: node2.offset, length: node2.length },\r\n                message: schema.patternErrorMessage || schema.errorMessage || t(\"String is not a URI: {0}\", errorMessage)\r\n              });\r\n            }\r\n          }\r\n          break;\r\n        case \"color-hex\":\r\n        case \"date-time\":\r\n        case \"date\":\r\n        case \"time\":\r\n        case \"email\":\r\n        case \"hostname\":\r\n        case \"ipv4\":\r\n        case \"ipv6\":\r\n          const format5 = formats[schema.format];\r\n          if (!node2.value || !format5.pattern.exec(node2.value)) {\r\n            validationResult.problems.push({\r\n              location: { offset: node2.offset, length: node2.length },\r\n              message: schema.patternErrorMessage || schema.errorMessage || format5.errorMessage\r\n            });\r\n          }\r\n        default:\r\n      }\r\n    }\r\n  }\r\n  function _validateArrayNode(node2) {\r\n    let prefixItemsSchemas;\r\n    let additionalItemSchema;\r\n    if (context.schemaDraft >= SchemaDraft.v2020_12) {\r\n      prefixItemsSchemas = schema.prefixItems;\r\n      additionalItemSchema = !Array.isArray(schema.items) ? schema.items : void 0;\r\n    } else {\r\n      prefixItemsSchemas = Array.isArray(schema.items) ? schema.items : void 0;\r\n      additionalItemSchema = !Array.isArray(schema.items) ? schema.items : schema.additionalItems;\r\n    }\r\n    let index = 0;\r\n    if (prefixItemsSchemas !== void 0) {\r\n      const max = Math.min(prefixItemsSchemas.length, node2.items.length);\r\n      for (; index < max; index++) {\r\n        const subSchemaRef = prefixItemsSchemas[index];\r\n        const subSchema = asSchema(subSchemaRef);\r\n        const itemValidationResult = new ValidationResult();\r\n        const item = node2.items[index];\r\n        if (item) {\r\n          validate(item, subSchema, itemValidationResult, matchingSchemas, context);\r\n          validationResult.mergePropertyMatch(itemValidationResult);\r\n        }\r\n        validationResult.processedProperties.add(String(index));\r\n      }\r\n    }\r\n    if (additionalItemSchema !== void 0 && index < node2.items.length) {\r\n      if (typeof additionalItemSchema === \"boolean\") {\r\n        if (additionalItemSchema === false) {\r\n          validationResult.problems.push({\r\n            location: { offset: node2.offset, length: node2.length },\r\n            message: t(\"Array has too many items according to schema. Expected {0} or fewer.\", index)\r\n          });\r\n        }\r\n        for (; index < node2.items.length; index++) {\r\n          validationResult.processedProperties.add(String(index));\r\n          validationResult.propertiesValueMatches++;\r\n        }\r\n      } else {\r\n        for (; index < node2.items.length; index++) {\r\n          const itemValidationResult = new ValidationResult();\r\n          validate(node2.items[index], additionalItemSchema, itemValidationResult, matchingSchemas, context);\r\n          validationResult.mergePropertyMatch(itemValidationResult);\r\n          validationResult.processedProperties.add(String(index));\r\n        }\r\n      }\r\n    }\r\n    const containsSchema = asSchema(schema.contains);\r\n    if (containsSchema) {\r\n      let containsCount = 0;\r\n      for (let index2 = 0; index2 < node2.items.length; index2++) {\r\n        const item = node2.items[index2];\r\n        const itemValidationResult = new ValidationResult();\r\n        validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance, context);\r\n        if (!itemValidationResult.hasProblems()) {\r\n          containsCount++;\r\n          if (context.schemaDraft >= SchemaDraft.v2020_12) {\r\n            validationResult.processedProperties.add(String(index2));\r\n          }\r\n        }\r\n      }\r\n      if (containsCount === 0 && !isNumber(schema.minContains)) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: schema.errorMessage || t(\"Array does not contain required item.\")\r\n        });\r\n      }\r\n      if (isNumber(schema.minContains) && containsCount < schema.minContains) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: schema.errorMessage || t(\"Array has too few items that match the contains contraint. Expected {0} or more.\", schema.minContains)\r\n        });\r\n      }\r\n      if (isNumber(schema.maxContains) && containsCount > schema.maxContains) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: schema.errorMessage || t(\"Array has too many items that match the contains contraint. Expected {0} or less.\", schema.maxContains)\r\n        });\r\n      }\r\n    }\r\n    const unevaluatedItems = schema.unevaluatedItems;\r\n    if (unevaluatedItems !== void 0) {\r\n      for (let i = 0; i < node2.items.length; i++) {\r\n        if (!validationResult.processedProperties.has(String(i))) {\r\n          if (unevaluatedItems === false) {\r\n            validationResult.problems.push({\r\n              location: { offset: node2.offset, length: node2.length },\r\n              message: t(\"Item does not match any validation rule from the array.\")\r\n            });\r\n          } else {\r\n            const itemValidationResult = new ValidationResult();\r\n            validate(node2.items[i], schema.unevaluatedItems, itemValidationResult, matchingSchemas, context);\r\n            validationResult.mergePropertyMatch(itemValidationResult);\r\n          }\r\n        }\r\n        validationResult.processedProperties.add(String(i));\r\n        validationResult.propertiesValueMatches++;\r\n      }\r\n    }\r\n    if (isNumber(schema.minItems) && node2.items.length < schema.minItems) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"Array has too few items. Expected {0} or more.\", schema.minItems)\r\n      });\r\n    }\r\n    if (isNumber(schema.maxItems) && node2.items.length > schema.maxItems) {\r\n      validationResult.problems.push({\r\n        location: { offset: node2.offset, length: node2.length },\r\n        message: t(\"Array has too many items. Expected {0} or fewer.\", schema.maxItems)\r\n      });\r\n    }\r\n    if (schema.uniqueItems === true) {\r\n      let hasDuplicates = function() {\r\n        for (let i = 0; i < values.length - 1; i++) {\r\n          const value = values[i];\r\n          for (let j = i + 1; j < values.length; j++) {\r\n            if (equals(value, values[j])) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      const values = getNodeValue3(node2);\r\n      if (hasDuplicates()) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: t(\"Array has duplicate items.\")\r\n        });\r\n      }\r\n    }\r\n  }\r\n  function _validateObjectNode(node2) {\r\n    const seenKeys = /* @__PURE__ */ Object.create(null);\r\n    const unprocessedProperties = /* @__PURE__ */ new Set();\r\n    for (const propertyNode of node2.properties) {\r\n      const key = propertyNode.keyNode.value;\r\n      seenKeys[key] = propertyNode.valueNode;\r\n      unprocessedProperties.add(key);\r\n    }\r\n    if (Array.isArray(schema.required)) {\r\n      for (const propertyName of schema.required) {\r\n        if (!seenKeys[propertyName]) {\r\n          const keyNode = node2.parent && node2.parent.type === \"property\" && node2.parent.keyNode;\r\n          const location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node2.offset, length: 1 };\r\n          validationResult.problems.push({\r\n            location,\r\n            message: t('Missing property \"{0}\".', propertyName)\r\n          });\r\n        }\r\n      }\r\n    }\r\n    const propertyProcessed = (prop) => {\r\n      unprocessedProperties.delete(prop);\r\n      validationResult.processedProperties.add(prop);\r\n    };\r\n    if (schema.properties) {\r\n      for (const propertyName of Object.keys(schema.properties)) {\r\n        propertyProcessed(propertyName);\r\n        const propertySchema = schema.properties[propertyName];\r\n        const child = seenKeys[propertyName];\r\n        if (child) {\r\n          if (isBoolean(propertySchema)) {\r\n            if (!propertySchema) {\r\n              const propertyNode = child.parent;\r\n              validationResult.problems.push({\r\n                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\r\n                message: schema.errorMessage || t(\"Property {0} is not allowed.\", propertyName)\r\n              });\r\n            } else {\r\n              validationResult.propertiesMatches++;\r\n              validationResult.propertiesValueMatches++;\r\n            }\r\n          } else {\r\n            const propertyValidationResult = new ValidationResult();\r\n            validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);\r\n            validationResult.mergePropertyMatch(propertyValidationResult);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (schema.patternProperties) {\r\n      for (const propertyPattern of Object.keys(schema.patternProperties)) {\r\n        const regex = extendedRegExp(propertyPattern);\r\n        if (regex) {\r\n          const processed = [];\r\n          for (const propertyName of unprocessedProperties) {\r\n            if (regex.test(propertyName)) {\r\n              processed.push(propertyName);\r\n              const child = seenKeys[propertyName];\r\n              if (child) {\r\n                const propertySchema = schema.patternProperties[propertyPattern];\r\n                if (isBoolean(propertySchema)) {\r\n                  if (!propertySchema) {\r\n                    const propertyNode = child.parent;\r\n                    validationResult.problems.push({\r\n                      location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\r\n                      message: schema.errorMessage || t(\"Property {0} is not allowed.\", propertyName)\r\n                    });\r\n                  } else {\r\n                    validationResult.propertiesMatches++;\r\n                    validationResult.propertiesValueMatches++;\r\n                  }\r\n                } else {\r\n                  const propertyValidationResult = new ValidationResult();\r\n                  validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);\r\n                  validationResult.mergePropertyMatch(propertyValidationResult);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          processed.forEach(propertyProcessed);\r\n        }\r\n      }\r\n    }\r\n    const additionalProperties = schema.additionalProperties;\r\n    if (additionalProperties !== void 0) {\r\n      for (const propertyName of unprocessedProperties) {\r\n        propertyProcessed(propertyName);\r\n        const child = seenKeys[propertyName];\r\n        if (child) {\r\n          if (additionalProperties === false) {\r\n            const propertyNode = child.parent;\r\n            validationResult.problems.push({\r\n              location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\r\n              message: schema.errorMessage || t(\"Property {0} is not allowed.\", propertyName)\r\n            });\r\n          } else if (additionalProperties !== true) {\r\n            const propertyValidationResult = new ValidationResult();\r\n            validate(child, additionalProperties, propertyValidationResult, matchingSchemas, context);\r\n            validationResult.mergePropertyMatch(propertyValidationResult);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    const unevaluatedProperties = schema.unevaluatedProperties;\r\n    if (unevaluatedProperties !== void 0) {\r\n      const processed = [];\r\n      for (const propertyName of unprocessedProperties) {\r\n        if (!validationResult.processedProperties.has(propertyName)) {\r\n          processed.push(propertyName);\r\n          const child = seenKeys[propertyName];\r\n          if (child) {\r\n            if (unevaluatedProperties === false) {\r\n              const propertyNode = child.parent;\r\n              validationResult.problems.push({\r\n                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\r\n                message: schema.errorMessage || t(\"Property {0} is not allowed.\", propertyName)\r\n              });\r\n            } else if (unevaluatedProperties !== true) {\r\n              const propertyValidationResult = new ValidationResult();\r\n              validate(child, unevaluatedProperties, propertyValidationResult, matchingSchemas, context);\r\n              validationResult.mergePropertyMatch(propertyValidationResult);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      processed.forEach(propertyProcessed);\r\n    }\r\n    if (isNumber(schema.maxProperties)) {\r\n      if (node2.properties.length > schema.maxProperties) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: t(\"Object has more properties than limit of {0}.\", schema.maxProperties)\r\n        });\r\n      }\r\n    }\r\n    if (isNumber(schema.minProperties)) {\r\n      if (node2.properties.length < schema.minProperties) {\r\n        validationResult.problems.push({\r\n          location: { offset: node2.offset, length: node2.length },\r\n          message: t(\"Object has fewer properties than the required number of {0}\", schema.minProperties)\r\n        });\r\n      }\r\n    }\r\n    if (schema.dependentRequired) {\r\n      for (const key in schema.dependentRequired) {\r\n        const prop = seenKeys[key];\r\n        const propertyDeps = schema.dependentRequired[key];\r\n        if (prop && Array.isArray(propertyDeps)) {\r\n          _validatePropertyDependencies(key, propertyDeps);\r\n        }\r\n      }\r\n    }\r\n    if (schema.dependentSchemas) {\r\n      for (const key in schema.dependentSchemas) {\r\n        const prop = seenKeys[key];\r\n        const propertyDeps = schema.dependentSchemas[key];\r\n        if (prop && isObject(propertyDeps)) {\r\n          _validatePropertyDependencies(key, propertyDeps);\r\n        }\r\n      }\r\n    }\r\n    if (schema.dependencies) {\r\n      for (const key in schema.dependencies) {\r\n        const prop = seenKeys[key];\r\n        if (prop) {\r\n          _validatePropertyDependencies(key, schema.dependencies[key]);\r\n        }\r\n      }\r\n    }\r\n    const propertyNames = asSchema(schema.propertyNames);\r\n    if (propertyNames) {\r\n      for (const f2 of node2.properties) {\r\n        const key = f2.keyNode;\r\n        if (key) {\r\n          validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance, context);\r\n        }\r\n      }\r\n    }\r\n    function _validatePropertyDependencies(key, propertyDep) {\r\n      if (Array.isArray(propertyDep)) {\r\n        for (const requiredProp of propertyDep) {\r\n          if (!seenKeys[requiredProp]) {\r\n            validationResult.problems.push({\r\n              location: { offset: node2.offset, length: node2.length },\r\n              message: t(\"Object is missing property {0} required by property {1}.\", requiredProp, key)\r\n            });\r\n          } else {\r\n            validationResult.propertiesValueMatches++;\r\n          }\r\n        }\r\n      } else {\r\n        const propertySchema = asSchema(propertyDep);\r\n        if (propertySchema) {\r\n          const propertyValidationResult = new ValidationResult();\r\n          validate(node2, propertySchema, propertyValidationResult, matchingSchemas, context);\r\n          validationResult.mergePropertyMatch(propertyValidationResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction parse3(textDocument, config) {\r\n  const problems = [];\r\n  let lastProblemOffset = -1;\r\n  const text = textDocument.getText();\r\n  const scanner = createScanner2(text, false);\r\n  const commentRanges = config && config.collectComments ? [] : void 0;\r\n  function _scanNext() {\r\n    while (true) {\r\n      const token2 = scanner.scan();\r\n      _checkScanError();\r\n      switch (token2) {\r\n        case 12:\r\n        case 13:\r\n          if (Array.isArray(commentRanges)) {\r\n            commentRanges.push(Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));\r\n          }\r\n          break;\r\n        case 15:\r\n        case 14:\r\n          break;\r\n        default:\r\n          return token2;\r\n      }\r\n    }\r\n  }\r\n  function _accept(token2) {\r\n    if (scanner.getToken() === token2) {\r\n      _scanNext();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  function _errorAtRange(message, code, startOffset, endOffset, severity = DiagnosticSeverity.Error) {\r\n    if (problems.length === 0 || startOffset !== lastProblemOffset) {\r\n      const range = Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));\r\n      problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));\r\n      lastProblemOffset = startOffset;\r\n    }\r\n  }\r\n  function _error(message, code, node = void 0, skipUntilAfter = [], skipUntil = []) {\r\n    let start = scanner.getTokenOffset();\r\n    let end = scanner.getTokenOffset() + scanner.getTokenLength();\r\n    if (start === end && start > 0) {\r\n      start--;\r\n      while (start > 0 && /\\s/.test(text.charAt(start))) {\r\n        start--;\r\n      }\r\n      end = start + 1;\r\n    }\r\n    _errorAtRange(message, code, start, end);\r\n    if (node) {\r\n      _finalize(node, false);\r\n    }\r\n    if (skipUntilAfter.length + skipUntil.length > 0) {\r\n      let token2 = scanner.getToken();\r\n      while (token2 !== 17) {\r\n        if (skipUntilAfter.indexOf(token2) !== -1) {\r\n          _scanNext();\r\n          break;\r\n        } else if (skipUntil.indexOf(token2) !== -1) {\r\n          break;\r\n        }\r\n        token2 = _scanNext();\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n  function _checkScanError() {\r\n    switch (scanner.getTokenError()) {\r\n      case 4:\r\n        _error(t(\"Invalid unicode sequence in string.\"), ErrorCode.InvalidUnicode);\r\n        return true;\r\n      case 5:\r\n        _error(t(\"Invalid escape character in string.\"), ErrorCode.InvalidEscapeCharacter);\r\n        return true;\r\n      case 3:\r\n        _error(t(\"Unexpected end of number.\"), ErrorCode.UnexpectedEndOfNumber);\r\n        return true;\r\n      case 1:\r\n        _error(t(\"Unexpected end of comment.\"), ErrorCode.UnexpectedEndOfComment);\r\n        return true;\r\n      case 2:\r\n        _error(t(\"Unexpected end of string.\"), ErrorCode.UnexpectedEndOfString);\r\n        return true;\r\n      case 6:\r\n        _error(t(\"Invalid characters in string. Control characters must be escaped.\"), ErrorCode.InvalidCharacter);\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n  function _finalize(node, scanNext) {\r\n    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;\r\n    if (scanNext) {\r\n      _scanNext();\r\n    }\r\n    return node;\r\n  }\r\n  function _parseArray(parent) {\r\n    if (scanner.getToken() !== 3) {\r\n      return void 0;\r\n    }\r\n    const node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());\r\n    _scanNext();\r\n    const count = 0;\r\n    let needsComma = false;\r\n    while (scanner.getToken() !== 4 && scanner.getToken() !== 17) {\r\n      if (scanner.getToken() === 5) {\r\n        if (!needsComma) {\r\n          _error(t(\"Value expected\"), ErrorCode.ValueExpected);\r\n        }\r\n        const commaOffset = scanner.getTokenOffset();\r\n        _scanNext();\r\n        if (scanner.getToken() === 4) {\r\n          if (needsComma) {\r\n            _errorAtRange(t(\"Trailing comma\"), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\r\n          }\r\n          continue;\r\n        }\r\n      } else if (needsComma) {\r\n        _error(t(\"Expected comma\"), ErrorCode.CommaExpected);\r\n      }\r\n      const item = _parseValue(node);\r\n      if (!item) {\r\n        _error(t(\"Value expected\"), ErrorCode.ValueExpected, void 0, [], [\r\n          4,\r\n          5\r\n          /* Json.SyntaxKind.CommaToken */\r\n        ]);\r\n      } else {\r\n        node.items.push(item);\r\n      }\r\n      needsComma = true;\r\n    }\r\n    if (scanner.getToken() !== 4) {\r\n      return _error(t(\"Expected comma or closing bracket\"), ErrorCode.CommaOrCloseBacketExpected, node);\r\n    }\r\n    return _finalize(node, true);\r\n  }\r\n  const keyPlaceholder = new StringASTNodeImpl(void 0, 0, 0);\r\n  function _parseProperty(parent, keysSeen) {\r\n    const node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);\r\n    let key = _parseString(node);\r\n    if (!key) {\r\n      if (scanner.getToken() === 16) {\r\n        _error(t(\"Property keys must be doublequoted\"), ErrorCode.PropertyKeysMustBeDoublequoted);\r\n        const keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());\r\n        keyNode.value = scanner.getTokenValue();\r\n        key = keyNode;\r\n        _scanNext();\r\n      } else {\r\n        return void 0;\r\n      }\r\n    }\r\n    node.keyNode = key;\r\n    if (key.value !== \"//\") {\r\n      const seen = keysSeen[key.value];\r\n      if (seen) {\r\n        _errorAtRange(t(\"Duplicate object key\"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);\r\n        if (isObject(seen)) {\r\n          _errorAtRange(t(\"Duplicate object key\"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);\r\n        }\r\n        keysSeen[key.value] = true;\r\n      } else {\r\n        keysSeen[key.value] = node;\r\n      }\r\n    }\r\n    if (scanner.getToken() === 6) {\r\n      node.colonOffset = scanner.getTokenOffset();\r\n      _scanNext();\r\n    } else {\r\n      _error(t(\"Colon expected\"), ErrorCode.ColonExpected);\r\n      if (scanner.getToken() === 10 && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {\r\n        node.length = key.length;\r\n        return node;\r\n      }\r\n    }\r\n    const value = _parseValue(node);\r\n    if (!value) {\r\n      return _error(t(\"Value expected\"), ErrorCode.ValueExpected, node, [], [\r\n        2,\r\n        5\r\n        /* Json.SyntaxKind.CommaToken */\r\n      ]);\r\n    }\r\n    node.valueNode = value;\r\n    node.length = value.offset + value.length - node.offset;\r\n    return node;\r\n  }\r\n  function _parseObject(parent) {\r\n    if (scanner.getToken() !== 1) {\r\n      return void 0;\r\n    }\r\n    const node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());\r\n    const keysSeen = /* @__PURE__ */ Object.create(null);\r\n    _scanNext();\r\n    let needsComma = false;\r\n    while (scanner.getToken() !== 2 && scanner.getToken() !== 17) {\r\n      if (scanner.getToken() === 5) {\r\n        if (!needsComma) {\r\n          _error(t(\"Property expected\"), ErrorCode.PropertyExpected);\r\n        }\r\n        const commaOffset = scanner.getTokenOffset();\r\n        _scanNext();\r\n        if (scanner.getToken() === 2) {\r\n          if (needsComma) {\r\n            _errorAtRange(t(\"Trailing comma\"), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\r\n          }\r\n          continue;\r\n        }\r\n      } else if (needsComma) {\r\n        _error(t(\"Expected comma\"), ErrorCode.CommaExpected);\r\n      }\r\n      const property = _parseProperty(node, keysSeen);\r\n      if (!property) {\r\n        _error(t(\"Property expected\"), ErrorCode.PropertyExpected, void 0, [], [\r\n          2,\r\n          5\r\n          /* Json.SyntaxKind.CommaToken */\r\n        ]);\r\n      } else {\r\n        node.properties.push(property);\r\n      }\r\n      needsComma = true;\r\n    }\r\n    if (scanner.getToken() !== 2) {\r\n      return _error(t(\"Expected comma or closing brace\"), ErrorCode.CommaOrCloseBraceExpected, node);\r\n    }\r\n    return _finalize(node, true);\r\n  }\r\n  function _parseString(parent) {\r\n    if (scanner.getToken() !== 10) {\r\n      return void 0;\r\n    }\r\n    const node = new StringASTNodeImpl(parent, scanner.getTokenOffset());\r\n    node.value = scanner.getTokenValue();\r\n    return _finalize(node, true);\r\n  }\r\n  function _parseNumber(parent) {\r\n    if (scanner.getToken() !== 11) {\r\n      return void 0;\r\n    }\r\n    const node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());\r\n    if (scanner.getTokenError() === 0) {\r\n      const tokenValue = scanner.getTokenValue();\r\n      try {\r\n        const numberValue = JSON.parse(tokenValue);\r\n        if (!isNumber(numberValue)) {\r\n          return _error(t(\"Invalid number format.\"), ErrorCode.Undefined, node);\r\n        }\r\n        node.value = numberValue;\r\n      } catch (e) {\r\n        return _error(t(\"Invalid number format.\"), ErrorCode.Undefined, node);\r\n      }\r\n      node.isInteger = tokenValue.indexOf(\".\") === -1;\r\n    }\r\n    return _finalize(node, true);\r\n  }\r\n  function _parseLiteral(parent) {\r\n    let node;\r\n    switch (scanner.getToken()) {\r\n      case 7:\r\n        return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);\r\n      case 8:\r\n        return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);\r\n      case 9:\r\n        return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);\r\n      default:\r\n        return void 0;\r\n    }\r\n  }\r\n  function _parseValue(parent) {\r\n    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);\r\n  }\r\n  let _root = void 0;\r\n  const token = _scanNext();\r\n  if (token !== 17) {\r\n    _root = _parseValue(_root);\r\n    if (!_root) {\r\n      _error(t(\"Expected a JSON object, array or literal.\"), ErrorCode.Undefined);\r\n    } else if (scanner.getToken() !== 17) {\r\n      _error(t(\"End of file expected.\"), ErrorCode.Undefined);\r\n    }\r\n  }\r\n  return new JSONDocument(_root, problems, commentRanges);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/json.js\r\nfunction stringifyObject(obj, indent, stringifyLiteral) {\r\n  if (obj !== null && typeof obj === \"object\") {\r\n    const newIndent = indent + \"\t\";\r\n    if (Array.isArray(obj)) {\r\n      if (obj.length === 0) {\r\n        return \"[]\";\r\n      }\r\n      let result = \"[\\n\";\r\n      for (let i = 0; i < obj.length; i++) {\r\n        result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);\r\n        if (i < obj.length - 1) {\r\n          result += \",\";\r\n        }\r\n        result += \"\\n\";\r\n      }\r\n      result += indent + \"]\";\r\n      return result;\r\n    } else {\r\n      const keys = Object.keys(obj);\r\n      if (keys.length === 0) {\r\n        return \"{}\";\r\n      }\r\n      let result = \"{\\n\";\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i];\r\n        result += newIndent + JSON.stringify(key) + \": \" + stringifyObject(obj[key], newIndent, stringifyLiteral);\r\n        if (i < keys.length - 1) {\r\n          result += \",\";\r\n        }\r\n        result += \"\\n\";\r\n      }\r\n      result += indent + \"}\";\r\n      return result;\r\n    }\r\n  }\r\n  return stringifyLiteral(obj);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonCompletion.js\r\nvar valueCommitCharacters = [\",\", \"}\", \"]\"];\r\nvar propertyCommitCharacters = [\":\"];\r\nvar JSONCompletion = class {\r\n  constructor(schemaService, contributions = [], promiseConstructor = Promise, clientCapabilities = {}) {\r\n    this.schemaService = schemaService;\r\n    this.contributions = contributions;\r\n    this.promiseConstructor = promiseConstructor;\r\n    this.clientCapabilities = clientCapabilities;\r\n  }\r\n  doResolve(item) {\r\n    for (let i = this.contributions.length - 1; i >= 0; i--) {\r\n      const resolveCompletion = this.contributions[i].resolveCompletion;\r\n      if (resolveCompletion) {\r\n        const resolver = resolveCompletion(item);\r\n        if (resolver) {\r\n          return resolver;\r\n        }\r\n      }\r\n    }\r\n    return this.promiseConstructor.resolve(item);\r\n  }\r\n  doComplete(document, position, doc) {\r\n    const result = {\r\n      items: [],\r\n      isIncomplete: false\r\n    };\r\n    const text = document.getText();\r\n    const offset = document.offsetAt(position);\r\n    let node = doc.getNodeFromOffset(offset, true);\r\n    if (this.isInComment(document, node ? node.offset : 0, offset)) {\r\n      return Promise.resolve(result);\r\n    }\r\n    if (node && offset === node.offset + node.length && offset > 0) {\r\n      const ch = text[offset - 1];\r\n      if (node.type === \"object\" && ch === \"}\" || node.type === \"array\" && ch === \"]\") {\r\n        node = node.parent;\r\n      }\r\n    }\r\n    const currentWord = this.getCurrentWord(document, offset);\r\n    let overwriteRange;\r\n    if (node && (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\r\n      overwriteRange = Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\r\n    } else {\r\n      let overwriteStart = offset - currentWord.length;\r\n      if (overwriteStart > 0 && text[overwriteStart - 1] === '\"') {\r\n        overwriteStart--;\r\n      }\r\n      overwriteRange = Range.create(document.positionAt(overwriteStart), position);\r\n    }\r\n    const supportsCommitCharacters = false;\r\n    const proposed = /* @__PURE__ */ new Map();\r\n    const collector = {\r\n      add: (suggestion) => {\r\n        let label = suggestion.label;\r\n        const existing = proposed.get(label);\r\n        if (!existing) {\r\n          label = label.replace(/[\\n]/g, \"\\u21B5\");\r\n          if (label.length > 60) {\r\n            const shortendedLabel = label.substr(0, 57).trim() + \"...\";\r\n            if (!proposed.has(shortendedLabel)) {\r\n              label = shortendedLabel;\r\n            }\r\n          }\r\n          suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);\r\n          if (supportsCommitCharacters) {\r\n            suggestion.commitCharacters = suggestion.kind === CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;\r\n          }\r\n          suggestion.label = label;\r\n          proposed.set(label, suggestion);\r\n          result.items.push(suggestion);\r\n        } else {\r\n          if (!existing.documentation) {\r\n            existing.documentation = suggestion.documentation;\r\n          }\r\n          if (!existing.detail) {\r\n            existing.detail = suggestion.detail;\r\n          }\r\n          if (!existing.labelDetails) {\r\n            existing.labelDetails = suggestion.labelDetails;\r\n          }\r\n        }\r\n      },\r\n      setAsIncomplete: () => {\r\n        result.isIncomplete = true;\r\n      },\r\n      error: (message) => {\r\n        console.error(message);\r\n      },\r\n      getNumberOfProposals: () => {\r\n        return result.items.length;\r\n      }\r\n    };\r\n    return this.schemaService.getSchemaForResource(document.uri, doc).then((schema) => {\r\n      const collectionPromises = [];\r\n      let addValue = true;\r\n      let currentKey = \"\";\r\n      let currentProperty = void 0;\r\n      if (node) {\r\n        if (node.type === \"string\") {\r\n          const parent = node.parent;\r\n          if (parent && parent.type === \"property\" && parent.keyNode === node) {\r\n            addValue = !parent.valueNode;\r\n            currentProperty = parent;\r\n            currentKey = text.substr(node.offset + 1, node.length - 2);\r\n            if (parent) {\r\n              node = parent.parent;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (node && node.type === \"object\") {\r\n        if (node.offset === offset) {\r\n          return result;\r\n        }\r\n        const properties = node.properties;\r\n        properties.forEach((p) => {\r\n          if (!currentProperty || currentProperty !== p) {\r\n            proposed.set(p.keyNode.value, CompletionItem.create(\"__\"));\r\n          }\r\n        });\r\n        let separatorAfter = \"\";\r\n        if (addValue) {\r\n          separatorAfter = this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));\r\n        }\r\n        if (schema) {\r\n          this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector);\r\n        } else {\r\n          this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);\r\n        }\r\n        const location = getNodePath3(node);\r\n        this.contributions.forEach((contribution) => {\r\n          const collectPromise = contribution.collectPropertyCompletions(document.uri, location, currentWord, addValue, separatorAfter === \"\", collector);\r\n          if (collectPromise) {\r\n            collectionPromises.push(collectPromise);\r\n          }\r\n        });\r\n        if (!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '\"') {\r\n          collector.add({\r\n            kind: CompletionItemKind.Property,\r\n            label: this.getLabelForValue(currentWord),\r\n            insertText: this.getInsertTextForProperty(currentWord, void 0, false, separatorAfter),\r\n            insertTextFormat: InsertTextFormat.Snippet,\r\n            documentation: \"\"\r\n          });\r\n          collector.setAsIncomplete();\r\n        }\r\n      }\r\n      const types = {};\r\n      if (schema) {\r\n        this.getValueCompletions(schema, doc, node, offset, document, collector, types);\r\n      } else {\r\n        this.getSchemaLessValueCompletions(doc, node, offset, document, collector);\r\n      }\r\n      if (this.contributions.length > 0) {\r\n        this.getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises);\r\n      }\r\n      return this.promiseConstructor.all(collectionPromises).then(() => {\r\n        if (collector.getNumberOfProposals() === 0) {\r\n          let offsetForSeparator = offset;\r\n          if (node && (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\r\n            offsetForSeparator = node.offset + node.length;\r\n          }\r\n          const separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\r\n          this.addFillerValueCompletions(types, separatorAfter, collector);\r\n        }\r\n        return result;\r\n      });\r\n    });\r\n  }\r\n  getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector) {\r\n    const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\r\n    matchingSchemas.forEach((s) => {\r\n      if (s.node === node && !s.inverted) {\r\n        const schemaProperties = s.schema.properties;\r\n        if (schemaProperties) {\r\n          Object.keys(schemaProperties).forEach((key) => {\r\n            const propertySchema = schemaProperties[key];\r\n            if (typeof propertySchema === \"object\" && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {\r\n              const proposal = {\r\n                kind: CompletionItemKind.Property,\r\n                label: key,\r\n                insertText: this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),\r\n                insertTextFormat: InsertTextFormat.Snippet,\r\n                filterText: this.getFilterTextForValue(key),\r\n                documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || \"\"\r\n              };\r\n              if (propertySchema.suggestSortText !== void 0) {\r\n                proposal.sortText = propertySchema.suggestSortText;\r\n              }\r\n              if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {\r\n                proposal.command = {\r\n                  title: \"Suggest\",\r\n                  command: \"editor.action.triggerSuggest\"\r\n                };\r\n              }\r\n              collector.add(proposal);\r\n            }\r\n          });\r\n        }\r\n        const schemaPropertyNames = s.schema.propertyNames;\r\n        if (typeof schemaPropertyNames === \"object\" && !schemaPropertyNames.deprecationMessage && !schemaPropertyNames.doNotSuggest) {\r\n          const propertyNameCompletionItem = (name, enumDescription = void 0) => {\r\n            const proposal = {\r\n              kind: CompletionItemKind.Property,\r\n              label: name,\r\n              insertText: this.getInsertTextForProperty(name, void 0, addValue, separatorAfter),\r\n              insertTextFormat: InsertTextFormat.Snippet,\r\n              filterText: this.getFilterTextForValue(name),\r\n              documentation: enumDescription || this.fromMarkup(schemaPropertyNames.markdownDescription) || schemaPropertyNames.description || \"\"\r\n            };\r\n            if (schemaPropertyNames.suggestSortText !== void 0) {\r\n              proposal.sortText = schemaPropertyNames.suggestSortText;\r\n            }\r\n            if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {\r\n              proposal.command = {\r\n                title: \"Suggest\",\r\n                command: \"editor.action.triggerSuggest\"\r\n              };\r\n            }\r\n            collector.add(proposal);\r\n          };\r\n          if (schemaPropertyNames.enum) {\r\n            for (let i = 0; i < schemaPropertyNames.enum.length; i++) {\r\n              let enumDescription = void 0;\r\n              if (schemaPropertyNames.markdownEnumDescriptions && i < schemaPropertyNames.markdownEnumDescriptions.length) {\r\n                enumDescription = this.fromMarkup(schemaPropertyNames.markdownEnumDescriptions[i]);\r\n              } else if (schemaPropertyNames.enumDescriptions && i < schemaPropertyNames.enumDescriptions.length) {\r\n                enumDescription = schemaPropertyNames.enumDescriptions[i];\r\n              }\r\n              propertyNameCompletionItem(schemaPropertyNames.enum[i], enumDescription);\r\n            }\r\n          }\r\n          if (schemaPropertyNames.const) {\r\n            propertyNameCompletionItem(schemaPropertyNames.const);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  getSchemaLessPropertyCompletions(doc, node, currentKey, collector) {\r\n    const collectCompletionsForSimilarObject = (obj) => {\r\n      obj.properties.forEach((p) => {\r\n        const key = p.keyNode.value;\r\n        collector.add({\r\n          kind: CompletionItemKind.Property,\r\n          label: key,\r\n          insertText: this.getInsertTextForValue(key, \"\"),\r\n          insertTextFormat: InsertTextFormat.Snippet,\r\n          filterText: this.getFilterTextForValue(key),\r\n          documentation: \"\"\r\n        });\r\n      });\r\n    };\r\n    if (node.parent) {\r\n      if (node.parent.type === \"property\") {\r\n        const parentKey = node.parent.keyNode.value;\r\n        doc.visit((n) => {\r\n          if (n.type === \"property\" && n !== node.parent && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === \"object\") {\r\n            collectCompletionsForSimilarObject(n.valueNode);\r\n          }\r\n          return true;\r\n        });\r\n      } else if (node.parent.type === \"array\") {\r\n        node.parent.items.forEach((n) => {\r\n          if (n.type === \"object\" && n !== node) {\r\n            collectCompletionsForSimilarObject(n);\r\n          }\r\n        });\r\n      }\r\n    } else if (node.type === \"object\") {\r\n      collector.add({\r\n        kind: CompletionItemKind.Property,\r\n        label: \"$schema\",\r\n        insertText: this.getInsertTextForProperty(\"$schema\", void 0, true, \"\"),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        documentation: \"\",\r\n        filterText: this.getFilterTextForValue(\"$schema\")\r\n      });\r\n    }\r\n  }\r\n  getSchemaLessValueCompletions(doc, node, offset, document, collector) {\r\n    let offsetForSeparator = offset;\r\n    if (node && (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\r\n      offsetForSeparator = node.offset + node.length;\r\n      node = node.parent;\r\n    }\r\n    if (!node) {\r\n      collector.add({\r\n        kind: this.getSuggestionKind(\"object\"),\r\n        label: \"Empty object\",\r\n        insertText: this.getInsertTextForValue({}, \"\"),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        documentation: \"\"\r\n      });\r\n      collector.add({\r\n        kind: this.getSuggestionKind(\"array\"),\r\n        label: \"Empty array\",\r\n        insertText: this.getInsertTextForValue([], \"\"),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        documentation: \"\"\r\n      });\r\n      return;\r\n    }\r\n    const separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\r\n    const collectSuggestionsForValues = (value) => {\r\n      if (value.parent && !contains2(value.parent, offset, true)) {\r\n        collector.add({\r\n          kind: this.getSuggestionKind(value.type),\r\n          label: this.getLabelTextForMatchingNode(value, document),\r\n          insertText: this.getInsertTextForMatchingNode(value, document, separatorAfter),\r\n          insertTextFormat: InsertTextFormat.Snippet,\r\n          documentation: \"\"\r\n        });\r\n      }\r\n      if (value.type === \"boolean\") {\r\n        this.addBooleanValueCompletion(!value.value, separatorAfter, collector);\r\n      }\r\n    };\r\n    if (node.type === \"property\") {\r\n      if (offset > (node.colonOffset || 0)) {\r\n        const valueNode = node.valueNode;\r\n        if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === \"object\" || valueNode.type === \"array\")) {\r\n          return;\r\n        }\r\n        const parentKey = node.keyNode.value;\r\n        doc.visit((n) => {\r\n          if (n.type === \"property\" && n.keyNode.value === parentKey && n.valueNode) {\r\n            collectSuggestionsForValues(n.valueNode);\r\n          }\r\n          return true;\r\n        });\r\n        if (parentKey === \"$schema\" && node.parent && !node.parent.parent) {\r\n          this.addDollarSchemaCompletions(separatorAfter, collector);\r\n        }\r\n      }\r\n    }\r\n    if (node.type === \"array\") {\r\n      if (node.parent && node.parent.type === \"property\") {\r\n        const parentKey = node.parent.keyNode.value;\r\n        doc.visit((n) => {\r\n          if (n.type === \"property\" && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === \"array\") {\r\n            n.valueNode.items.forEach(collectSuggestionsForValues);\r\n          }\r\n          return true;\r\n        });\r\n      } else {\r\n        node.items.forEach(collectSuggestionsForValues);\r\n      }\r\n    }\r\n  }\r\n  getValueCompletions(schema, doc, node, offset, document, collector, types) {\r\n    let offsetForSeparator = offset;\r\n    let parentKey = void 0;\r\n    let valueNode = void 0;\r\n    if (node && (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\r\n      offsetForSeparator = node.offset + node.length;\r\n      valueNode = node;\r\n      node = node.parent;\r\n    }\r\n    if (!node) {\r\n      this.addSchemaValueCompletions(schema.schema, \"\", collector, types);\r\n      return;\r\n    }\r\n    if (node.type === \"property\" && offset > (node.colonOffset || 0)) {\r\n      const valueNode2 = node.valueNode;\r\n      if (valueNode2 && offset > valueNode2.offset + valueNode2.length) {\r\n        return;\r\n      }\r\n      parentKey = node.keyNode.value;\r\n      node = node.parent;\r\n    }\r\n    if (node && (parentKey !== void 0 || node.type === \"array\")) {\r\n      const separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\r\n      const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);\r\n      for (const s of matchingSchemas) {\r\n        if (s.node === node && !s.inverted && s.schema) {\r\n          if (node.type === \"array\" && s.schema.items) {\r\n            let c = collector;\r\n            if (s.schema.uniqueItems) {\r\n              const existingValues = /* @__PURE__ */ new Set();\r\n              node.children.forEach((n) => {\r\n                if (n.type !== \"array\" && n.type !== \"object\") {\r\n                  existingValues.add(this.getLabelForValue(getNodeValue3(n)));\r\n                }\r\n              });\r\n              c = {\r\n                ...collector,\r\n                add(suggestion) {\r\n                  if (!existingValues.has(suggestion.label)) {\r\n                    collector.add(suggestion);\r\n                  }\r\n                }\r\n              };\r\n            }\r\n            if (Array.isArray(s.schema.items)) {\r\n              const index = this.findItemAtOffset(node, document, offset);\r\n              if (index < s.schema.items.length) {\r\n                this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, c, types);\r\n              }\r\n            } else {\r\n              this.addSchemaValueCompletions(s.schema.items, separatorAfter, c, types);\r\n            }\r\n          }\r\n          if (parentKey !== void 0) {\r\n            let propertyMatched = false;\r\n            if (s.schema.properties) {\r\n              const propertySchema = s.schema.properties[parentKey];\r\n              if (propertySchema) {\r\n                propertyMatched = true;\r\n                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\r\n              }\r\n            }\r\n            if (s.schema.patternProperties && !propertyMatched) {\r\n              for (const pattern of Object.keys(s.schema.patternProperties)) {\r\n                const regex = extendedRegExp(pattern);\r\n                if (regex?.test(parentKey)) {\r\n                  propertyMatched = true;\r\n                  const propertySchema = s.schema.patternProperties[pattern];\r\n                  this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\r\n                }\r\n              }\r\n            }\r\n            if (s.schema.additionalProperties && !propertyMatched) {\r\n              const propertySchema = s.schema.additionalProperties;\r\n              this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (parentKey === \"$schema\" && !node.parent) {\r\n        this.addDollarSchemaCompletions(separatorAfter, collector);\r\n      }\r\n      if (types[\"boolean\"]) {\r\n        this.addBooleanValueCompletion(true, separatorAfter, collector);\r\n        this.addBooleanValueCompletion(false, separatorAfter, collector);\r\n      }\r\n      if (types[\"null\"]) {\r\n        this.addNullValueCompletion(separatorAfter, collector);\r\n      }\r\n    }\r\n  }\r\n  getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises) {\r\n    if (!node) {\r\n      this.contributions.forEach((contribution) => {\r\n        const collectPromise = contribution.collectDefaultCompletions(document.uri, collector);\r\n        if (collectPromise) {\r\n          collectionPromises.push(collectPromise);\r\n        }\r\n      });\r\n    } else {\r\n      if (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\") {\r\n        node = node.parent;\r\n      }\r\n      if (node && node.type === \"property\" && offset > (node.colonOffset || 0)) {\r\n        const parentKey = node.keyNode.value;\r\n        const valueNode = node.valueNode;\r\n        if ((!valueNode || offset <= valueNode.offset + valueNode.length) && node.parent) {\r\n          const location = getNodePath3(node.parent);\r\n          this.contributions.forEach((contribution) => {\r\n            const collectPromise = contribution.collectValueCompletions(document.uri, location, parentKey, collector);\r\n            if (collectPromise) {\r\n              collectionPromises.push(collectPromise);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n  addSchemaValueCompletions(schema, separatorAfter, collector, types) {\r\n    if (typeof schema === \"object\") {\r\n      this.addEnumValueCompletions(schema, separatorAfter, collector);\r\n      this.addDefaultValueCompletions(schema, separatorAfter, collector);\r\n      this.collectTypes(schema, types);\r\n      if (Array.isArray(schema.allOf)) {\r\n        schema.allOf.forEach((s) => this.addSchemaValueCompletions(s, separatorAfter, collector, types));\r\n      }\r\n      if (Array.isArray(schema.anyOf)) {\r\n        schema.anyOf.forEach((s) => this.addSchemaValueCompletions(s, separatorAfter, collector, types));\r\n      }\r\n      if (Array.isArray(schema.oneOf)) {\r\n        schema.oneOf.forEach((s) => this.addSchemaValueCompletions(s, separatorAfter, collector, types));\r\n      }\r\n    }\r\n  }\r\n  addDefaultValueCompletions(schema, separatorAfter, collector, arrayDepth = 0) {\r\n    let hasProposals = false;\r\n    if (isDefined(schema.default)) {\r\n      let type = schema.type;\r\n      let value = schema.default;\r\n      for (let i = arrayDepth; i > 0; i--) {\r\n        value = [value];\r\n        type = \"array\";\r\n      }\r\n      const completionItem = {\r\n        kind: this.getSuggestionKind(type),\r\n        label: this.getLabelForValue(value),\r\n        insertText: this.getInsertTextForValue(value, separatorAfter),\r\n        insertTextFormat: InsertTextFormat.Snippet\r\n      };\r\n      if (this.doesSupportsLabelDetails()) {\r\n        completionItem.labelDetails = { description: t(\"Default value\") };\r\n      } else {\r\n        completionItem.detail = t(\"Default value\");\r\n      }\r\n      collector.add(completionItem);\r\n      hasProposals = true;\r\n    }\r\n    if (Array.isArray(schema.examples)) {\r\n      schema.examples.forEach((example) => {\r\n        let type = schema.type;\r\n        let value = example;\r\n        for (let i = arrayDepth; i > 0; i--) {\r\n          value = [value];\r\n          type = \"array\";\r\n        }\r\n        collector.add({\r\n          kind: this.getSuggestionKind(type),\r\n          label: this.getLabelForValue(value),\r\n          insertText: this.getInsertTextForValue(value, separatorAfter),\r\n          insertTextFormat: InsertTextFormat.Snippet\r\n        });\r\n        hasProposals = true;\r\n      });\r\n    }\r\n    if (Array.isArray(schema.defaultSnippets)) {\r\n      schema.defaultSnippets.forEach((s) => {\r\n        let type = schema.type;\r\n        let value = s.body;\r\n        let label = s.label;\r\n        let insertText;\r\n        let filterText;\r\n        if (isDefined(value)) {\r\n          let type2 = schema.type;\r\n          for (let i = arrayDepth; i > 0; i--) {\r\n            value = [value];\r\n            type2 = \"array\";\r\n          }\r\n          insertText = this.getInsertTextForSnippetValue(value, separatorAfter);\r\n          filterText = this.getFilterTextForSnippetValue(value);\r\n          label = label || this.getLabelForSnippetValue(value);\r\n        } else if (typeof s.bodyText === \"string\") {\r\n          let prefix = \"\", suffix = \"\", indent = \"\";\r\n          for (let i = arrayDepth; i > 0; i--) {\r\n            prefix = prefix + indent + \"[\\n\";\r\n            suffix = suffix + \"\\n\" + indent + \"]\";\r\n            indent += \"\t\";\r\n            type = \"array\";\r\n          }\r\n          insertText = prefix + indent + s.bodyText.split(\"\\n\").join(\"\\n\" + indent) + suffix + separatorAfter;\r\n          label = label || insertText, filterText = insertText.replace(/[\\n]/g, \"\");\r\n        } else {\r\n          return;\r\n        }\r\n        collector.add({\r\n          kind: this.getSuggestionKind(type),\r\n          label,\r\n          documentation: this.fromMarkup(s.markdownDescription) || s.description,\r\n          insertText,\r\n          insertTextFormat: InsertTextFormat.Snippet,\r\n          filterText\r\n        });\r\n        hasProposals = true;\r\n      });\r\n    }\r\n    if (!hasProposals && typeof schema.items === \"object\" && !Array.isArray(schema.items) && arrayDepth < 5) {\r\n      this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);\r\n    }\r\n  }\r\n  addEnumValueCompletions(schema, separatorAfter, collector) {\r\n    if (isDefined(schema.const)) {\r\n      collector.add({\r\n        kind: this.getSuggestionKind(schema.type),\r\n        label: this.getLabelForValue(schema.const),\r\n        insertText: this.getInsertTextForValue(schema.const, separatorAfter),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        documentation: this.fromMarkup(schema.markdownDescription) || schema.description\r\n      });\r\n    }\r\n    if (Array.isArray(schema.enum)) {\r\n      for (let i = 0, length = schema.enum.length; i < length; i++) {\r\n        const enm = schema.enum[i];\r\n        let documentation = this.fromMarkup(schema.markdownDescription) || schema.description;\r\n        if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {\r\n          documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);\r\n        } else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {\r\n          documentation = schema.enumDescriptions[i];\r\n        }\r\n        collector.add({\r\n          kind: this.getSuggestionKind(schema.type),\r\n          label: this.getLabelForValue(enm),\r\n          insertText: this.getInsertTextForValue(enm, separatorAfter),\r\n          insertTextFormat: InsertTextFormat.Snippet,\r\n          documentation\r\n        });\r\n      }\r\n    }\r\n  }\r\n  collectTypes(schema, types) {\r\n    if (Array.isArray(schema.enum) || isDefined(schema.const)) {\r\n      return;\r\n    }\r\n    const type = schema.type;\r\n    if (Array.isArray(type)) {\r\n      type.forEach((t2) => types[t2] = true);\r\n    } else if (type) {\r\n      types[type] = true;\r\n    }\r\n  }\r\n  addFillerValueCompletions(types, separatorAfter, collector) {\r\n    if (types[\"object\"]) {\r\n      collector.add({\r\n        kind: this.getSuggestionKind(\"object\"),\r\n        label: \"{}\",\r\n        insertText: this.getInsertTextForGuessedValue({}, separatorAfter),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        detail: t(\"New object\"),\r\n        documentation: \"\"\r\n      });\r\n    }\r\n    if (types[\"array\"]) {\r\n      collector.add({\r\n        kind: this.getSuggestionKind(\"array\"),\r\n        label: \"[]\",\r\n        insertText: this.getInsertTextForGuessedValue([], separatorAfter),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        detail: t(\"New array\"),\r\n        documentation: \"\"\r\n      });\r\n    }\r\n  }\r\n  addBooleanValueCompletion(value, separatorAfter, collector) {\r\n    collector.add({\r\n      kind: this.getSuggestionKind(\"boolean\"),\r\n      label: value ? \"true\" : \"false\",\r\n      insertText: this.getInsertTextForValue(value, separatorAfter),\r\n      insertTextFormat: InsertTextFormat.Snippet,\r\n      documentation: \"\"\r\n    });\r\n  }\r\n  addNullValueCompletion(separatorAfter, collector) {\r\n    collector.add({\r\n      kind: this.getSuggestionKind(\"null\"),\r\n      label: \"null\",\r\n      insertText: \"null\" + separatorAfter,\r\n      insertTextFormat: InsertTextFormat.Snippet,\r\n      documentation: \"\"\r\n    });\r\n  }\r\n  addDollarSchemaCompletions(separatorAfter, collector) {\r\n    const schemaIds = this.schemaService.getRegisteredSchemaIds((schema) => schema === \"http\" || schema === \"https\");\r\n    schemaIds.forEach((schemaId) => {\r\n      if (schemaId.startsWith(\"http://json-schema.org/draft-\")) {\r\n        schemaId = schemaId + \"#\";\r\n      }\r\n      collector.add({\r\n        kind: CompletionItemKind.Module,\r\n        label: this.getLabelForValue(schemaId),\r\n        filterText: this.getFilterTextForValue(schemaId),\r\n        insertText: this.getInsertTextForValue(schemaId, separatorAfter),\r\n        insertTextFormat: InsertTextFormat.Snippet,\r\n        documentation: \"\"\r\n      });\r\n    });\r\n  }\r\n  getLabelForValue(value) {\r\n    return JSON.stringify(value);\r\n  }\r\n  getValueFromLabel(value) {\r\n    return JSON.parse(value);\r\n  }\r\n  getFilterTextForValue(value) {\r\n    return JSON.stringify(value);\r\n  }\r\n  getFilterTextForSnippetValue(value) {\r\n    return JSON.stringify(value).replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, \"$1\");\r\n  }\r\n  getLabelForSnippetValue(value) {\r\n    const label = JSON.stringify(value);\r\n    return label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, \"$1\");\r\n  }\r\n  getInsertTextForPlainText(text) {\r\n    return text.replace(/[\\\\\\$\\}]/g, \"\\\\$&\");\r\n  }\r\n  getInsertTextForValue(value, separatorAfter) {\r\n    const text = JSON.stringify(value, null, \"\t\");\r\n    if (text === \"{}\") {\r\n      return \"{$1}\" + separatorAfter;\r\n    } else if (text === \"[]\") {\r\n      return \"[$1]\" + separatorAfter;\r\n    }\r\n    return this.getInsertTextForPlainText(text + separatorAfter);\r\n  }\r\n  getInsertTextForSnippetValue(value, separatorAfter) {\r\n    const replacer = (value2) => {\r\n      if (typeof value2 === \"string\") {\r\n        if (value2[0] === \"^\") {\r\n          return value2.substr(1);\r\n        }\r\n      }\r\n      return JSON.stringify(value2);\r\n    };\r\n    return stringifyObject(value, \"\", replacer) + separatorAfter;\r\n  }\r\n  getInsertTextForGuessedValue(value, separatorAfter) {\r\n    switch (typeof value) {\r\n      case \"object\":\r\n        if (value === null) {\r\n          return \"${1:null}\" + separatorAfter;\r\n        }\r\n        return this.getInsertTextForValue(value, separatorAfter);\r\n      case \"string\":\r\n        let snippetValue = JSON.stringify(value);\r\n        snippetValue = snippetValue.substr(1, snippetValue.length - 2);\r\n        snippetValue = this.getInsertTextForPlainText(snippetValue);\r\n        return '\"${1:' + snippetValue + '}\"' + separatorAfter;\r\n      case \"number\":\r\n      case \"boolean\":\r\n        return \"${1:\" + JSON.stringify(value) + \"}\" + separatorAfter;\r\n    }\r\n    return this.getInsertTextForValue(value, separatorAfter);\r\n  }\r\n  getSuggestionKind(type) {\r\n    if (Array.isArray(type)) {\r\n      const array = type;\r\n      type = array.length > 0 ? array[0] : void 0;\r\n    }\r\n    if (!type) {\r\n      return CompletionItemKind.Value;\r\n    }\r\n    switch (type) {\r\n      case \"string\":\r\n        return CompletionItemKind.Value;\r\n      case \"object\":\r\n        return CompletionItemKind.Module;\r\n      case \"property\":\r\n        return CompletionItemKind.Property;\r\n      default:\r\n        return CompletionItemKind.Value;\r\n    }\r\n  }\r\n  getLabelTextForMatchingNode(node, document) {\r\n    switch (node.type) {\r\n      case \"array\":\r\n        return \"[]\";\r\n      case \"object\":\r\n        return \"{}\";\r\n      default:\r\n        const content = document.getText().substr(node.offset, node.length);\r\n        return content;\r\n    }\r\n  }\r\n  getInsertTextForMatchingNode(node, document, separatorAfter) {\r\n    switch (node.type) {\r\n      case \"array\":\r\n        return this.getInsertTextForValue([], separatorAfter);\r\n      case \"object\":\r\n        return this.getInsertTextForValue({}, separatorAfter);\r\n      default:\r\n        const content = document.getText().substr(node.offset, node.length) + separatorAfter;\r\n        return this.getInsertTextForPlainText(content);\r\n    }\r\n  }\r\n  getInsertTextForProperty(key, propertySchema, addValue, separatorAfter) {\r\n    const propertyText = this.getInsertTextForValue(key, \"\");\r\n    if (!addValue) {\r\n      return propertyText;\r\n    }\r\n    const resultText = propertyText + \": \";\r\n    let value;\r\n    let nValueProposals = 0;\r\n    if (propertySchema) {\r\n      if (Array.isArray(propertySchema.defaultSnippets)) {\r\n        if (propertySchema.defaultSnippets.length === 1) {\r\n          const body = propertySchema.defaultSnippets[0].body;\r\n          if (isDefined(body)) {\r\n            value = this.getInsertTextForSnippetValue(body, \"\");\r\n          }\r\n        }\r\n        nValueProposals += propertySchema.defaultSnippets.length;\r\n      }\r\n      if (propertySchema.enum) {\r\n        if (!value && propertySchema.enum.length === 1) {\r\n          value = this.getInsertTextForGuessedValue(propertySchema.enum[0], \"\");\r\n        }\r\n        nValueProposals += propertySchema.enum.length;\r\n      }\r\n      if (isDefined(propertySchema.const)) {\r\n        if (!value) {\r\n          value = this.getInsertTextForGuessedValue(propertySchema.const, \"\");\r\n        }\r\n        nValueProposals++;\r\n      }\r\n      if (isDefined(propertySchema.default)) {\r\n        if (!value) {\r\n          value = this.getInsertTextForGuessedValue(propertySchema.default, \"\");\r\n        }\r\n        nValueProposals++;\r\n      }\r\n      if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {\r\n        if (!value) {\r\n          value = this.getInsertTextForGuessedValue(propertySchema.examples[0], \"\");\r\n        }\r\n        nValueProposals += propertySchema.examples.length;\r\n      }\r\n      if (nValueProposals === 0) {\r\n        let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\r\n        if (!type) {\r\n          if (propertySchema.properties) {\r\n            type = \"object\";\r\n          } else if (propertySchema.items) {\r\n            type = \"array\";\r\n          }\r\n        }\r\n        switch (type) {\r\n          case \"boolean\":\r\n            value = \"$1\";\r\n            break;\r\n          case \"string\":\r\n            value = '\"$1\"';\r\n            break;\r\n          case \"object\":\r\n            value = \"{$1}\";\r\n            break;\r\n          case \"array\":\r\n            value = \"[$1]\";\r\n            break;\r\n          case \"number\":\r\n          case \"integer\":\r\n            value = \"${1:0}\";\r\n            break;\r\n          case \"null\":\r\n            value = \"${1:null}\";\r\n            break;\r\n          default:\r\n            return propertyText;\r\n        }\r\n      }\r\n    }\r\n    if (!value || nValueProposals > 1) {\r\n      value = \"$1\";\r\n    }\r\n    return resultText + value + separatorAfter;\r\n  }\r\n  getCurrentWord(document, offset) {\r\n    let i = offset - 1;\r\n    const text = document.getText();\r\n    while (i >= 0 && ' \t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\r\n      i--;\r\n    }\r\n    return text.substring(i + 1, offset);\r\n  }\r\n  evaluateSeparatorAfter(document, offset) {\r\n    const scanner = createScanner2(document.getText(), true);\r\n    scanner.setPosition(offset);\r\n    const token = scanner.scan();\r\n    switch (token) {\r\n      case 5:\r\n      case 2:\r\n      case 4:\r\n      case 17:\r\n        return \"\";\r\n      default:\r\n        return \",\";\r\n    }\r\n  }\r\n  findItemAtOffset(node, document, offset) {\r\n    const scanner = createScanner2(document.getText(), true);\r\n    const children = node.items;\r\n    for (let i = children.length - 1; i >= 0; i--) {\r\n      const child = children[i];\r\n      if (offset > child.offset + child.length) {\r\n        scanner.setPosition(child.offset + child.length);\r\n        const token = scanner.scan();\r\n        if (token === 5 && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {\r\n          return i + 1;\r\n        }\r\n        return i;\r\n      } else if (offset >= child.offset) {\r\n        return i;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n  isInComment(document, start, offset) {\r\n    const scanner = createScanner2(document.getText(), false);\r\n    scanner.setPosition(start);\r\n    let token = scanner.scan();\r\n    while (token !== 17 && scanner.getTokenOffset() + scanner.getTokenLength() < offset) {\r\n      token = scanner.scan();\r\n    }\r\n    return (token === 12 || token === 13) && scanner.getTokenOffset() <= offset;\r\n  }\r\n  fromMarkup(markupString) {\r\n    if (markupString && this.doesSupportMarkdown()) {\r\n      return {\r\n        kind: MarkupKind.Markdown,\r\n        value: markupString\r\n      };\r\n    }\r\n    return void 0;\r\n  }\r\n  doesSupportMarkdown() {\r\n    if (!isDefined(this.supportsMarkdown)) {\r\n      const documentationFormat = this.clientCapabilities.textDocument?.completion?.completionItem?.documentationFormat;\r\n      this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(MarkupKind.Markdown) !== -1;\r\n    }\r\n    return this.supportsMarkdown;\r\n  }\r\n  doesSupportsCommitCharacters() {\r\n    if (!isDefined(this.supportsCommitCharacters)) {\r\n      this.labelDetailsSupport = this.clientCapabilities.textDocument?.completion?.completionItem?.commitCharactersSupport;\r\n    }\r\n    return this.supportsCommitCharacters;\r\n  }\r\n  doesSupportsLabelDetails() {\r\n    if (!isDefined(this.labelDetailsSupport)) {\r\n      this.labelDetailsSupport = this.clientCapabilities.textDocument?.completion?.completionItem?.labelDetailsSupport;\r\n    }\r\n    return this.labelDetailsSupport;\r\n  }\r\n};\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonHover.js\r\nvar JSONHover = class {\r\n  constructor(schemaService, contributions = [], promiseConstructor) {\r\n    this.schemaService = schemaService;\r\n    this.contributions = contributions;\r\n    this.promise = promiseConstructor || Promise;\r\n  }\r\n  doHover(document, position, doc) {\r\n    const offset = document.offsetAt(position);\r\n    let node = doc.getNodeFromOffset(offset);\r\n    if (!node || (node.type === \"object\" || node.type === \"array\") && offset > node.offset + 1 && offset < node.offset + node.length - 1) {\r\n      return this.promise.resolve(null);\r\n    }\r\n    const hoverRangeNode = node;\r\n    if (node.type === \"string\") {\r\n      const parent = node.parent;\r\n      if (parent && parent.type === \"property\" && parent.keyNode === node) {\r\n        node = parent.valueNode;\r\n        if (!node) {\r\n          return this.promise.resolve(null);\r\n        }\r\n      }\r\n    }\r\n    const hoverRange = Range.create(document.positionAt(hoverRangeNode.offset), document.positionAt(hoverRangeNode.offset + hoverRangeNode.length));\r\n    const createHover = (contents) => {\r\n      const result = {\r\n        contents,\r\n        range: hoverRange\r\n      };\r\n      return result;\r\n    };\r\n    const location = getNodePath3(node);\r\n    for (let i = this.contributions.length - 1; i >= 0; i--) {\r\n      const contribution = this.contributions[i];\r\n      const promise = contribution.getInfoContribution(document.uri, location);\r\n      if (promise) {\r\n        return promise.then((htmlContent) => createHover(htmlContent));\r\n      }\r\n    }\r\n    return this.schemaService.getSchemaForResource(document.uri, doc).then((schema) => {\r\n      if (schema && node) {\r\n        const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\r\n        let title = void 0;\r\n        let markdownDescription = void 0;\r\n        let markdownEnumValueDescription = void 0, enumValue = void 0;\r\n        matchingSchemas.every((s) => {\r\n          if (s.node === node && !s.inverted && s.schema) {\r\n            title = title || s.schema.title;\r\n            markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown(s.schema.description);\r\n            if (s.schema.enum) {\r\n              const idx = s.schema.enum.indexOf(getNodeValue3(node));\r\n              if (s.schema.markdownEnumDescriptions) {\r\n                markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];\r\n              } else if (s.schema.enumDescriptions) {\r\n                markdownEnumValueDescription = toMarkdown(s.schema.enumDescriptions[idx]);\r\n              }\r\n              if (markdownEnumValueDescription) {\r\n                enumValue = s.schema.enum[idx];\r\n                if (typeof enumValue !== \"string\") {\r\n                  enumValue = JSON.stringify(enumValue);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return true;\r\n        });\r\n        let result = \"\";\r\n        if (title) {\r\n          result = toMarkdown(title);\r\n        }\r\n        if (markdownDescription) {\r\n          if (result.length > 0) {\r\n            result += \"\\n\\n\";\r\n          }\r\n          result += markdownDescription;\r\n        }\r\n        if (markdownEnumValueDescription) {\r\n          if (result.length > 0) {\r\n            result += \"\\n\\n\";\r\n          }\r\n          result += `\\`${toMarkdownCodeBlock(enumValue)}\\`: ${markdownEnumValueDescription}`;\r\n        }\r\n        return createHover([result]);\r\n      }\r\n      return null;\r\n    });\r\n  }\r\n};\r\nfunction toMarkdown(plain) {\r\n  if (plain) {\r\n    const res = plain.replace(/([^\\n\\r])(\\r?\\n)([^\\n\\r])/gm, \"$1\\n\\n$3\");\r\n    return res.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\");\r\n  }\r\n  return void 0;\r\n}\r\nfunction toMarkdownCodeBlock(content) {\r\n  if (content.indexOf(\"`\") !== -1) {\r\n    return \"`` \" + content + \" ``\";\r\n  }\r\n  return content;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonValidation.js\r\nvar JSONValidation = class {\r\n  constructor(jsonSchemaService, promiseConstructor) {\r\n    this.jsonSchemaService = jsonSchemaService;\r\n    this.promise = promiseConstructor;\r\n    this.validationEnabled = true;\r\n  }\r\n  configure(raw) {\r\n    if (raw) {\r\n      this.validationEnabled = raw.validate !== false;\r\n      this.commentSeverity = raw.allowComments ? void 0 : DiagnosticSeverity.Error;\r\n    }\r\n  }\r\n  doValidation(textDocument, jsonDocument, documentSettings, schema) {\r\n    if (!this.validationEnabled) {\r\n      return this.promise.resolve([]);\r\n    }\r\n    const diagnostics = [];\r\n    const added = {};\r\n    const addProblem = (problem) => {\r\n      const signature = problem.range.start.line + \" \" + problem.range.start.character + \" \" + problem.message;\r\n      if (!added[signature]) {\r\n        added[signature] = true;\r\n        diagnostics.push(problem);\r\n      }\r\n    };\r\n    const getDiagnostics = (schema2) => {\r\n      let trailingCommaSeverity = documentSettings?.trailingCommas ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;\r\n      let commentSeverity = documentSettings?.comments ? toDiagnosticSeverity(documentSettings.comments) : this.commentSeverity;\r\n      let schemaValidation = documentSettings?.schemaValidation ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;\r\n      let schemaRequest = documentSettings?.schemaRequest ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;\r\n      if (schema2) {\r\n        const addSchemaProblem = (errorMessage, errorCode) => {\r\n          if (jsonDocument.root && schemaRequest) {\r\n            const astRoot = jsonDocument.root;\r\n            const property = astRoot.type === \"object\" ? astRoot.properties[0] : void 0;\r\n            if (property && property.keyNode.value === \"$schema\") {\r\n              const node = property.valueNode || property;\r\n              const range = Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));\r\n              addProblem(Diagnostic.create(range, errorMessage, schemaRequest, errorCode));\r\n            } else {\r\n              const range = Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));\r\n              addProblem(Diagnostic.create(range, errorMessage, schemaRequest, errorCode));\r\n            }\r\n          }\r\n        };\r\n        if (schema2.errors.length) {\r\n          addSchemaProblem(schema2.errors[0], ErrorCode.SchemaResolveError);\r\n        } else if (schemaValidation) {\r\n          for (const warning of schema2.warnings) {\r\n            addSchemaProblem(warning, ErrorCode.SchemaUnsupportedFeature);\r\n          }\r\n          const semanticErrors = jsonDocument.validate(textDocument, schema2.schema, schemaValidation, documentSettings?.schemaDraft);\r\n          if (semanticErrors) {\r\n            semanticErrors.forEach(addProblem);\r\n          }\r\n        }\r\n        if (schemaAllowsComments(schema2.schema)) {\r\n          commentSeverity = void 0;\r\n        }\r\n        if (schemaAllowsTrailingCommas(schema2.schema)) {\r\n          trailingCommaSeverity = void 0;\r\n        }\r\n      }\r\n      for (const p of jsonDocument.syntaxErrors) {\r\n        if (p.code === ErrorCode.TrailingComma) {\r\n          if (typeof trailingCommaSeverity !== \"number\") {\r\n            continue;\r\n          }\r\n          p.severity = trailingCommaSeverity;\r\n        }\r\n        addProblem(p);\r\n      }\r\n      if (typeof commentSeverity === \"number\") {\r\n        const message = t(\"Comments are not permitted in JSON.\");\r\n        jsonDocument.comments.forEach((c) => {\r\n          addProblem(Diagnostic.create(c, message, commentSeverity, ErrorCode.CommentNotPermitted));\r\n        });\r\n      }\r\n      return diagnostics;\r\n    };\r\n    if (schema) {\r\n      const uri = schema.id || \"schemaservice://untitled/\" + idCounter++;\r\n      const handle = this.jsonSchemaService.registerExternalSchema({ uri, schema });\r\n      return handle.getResolvedSchema().then((resolvedSchema) => {\r\n        return getDiagnostics(resolvedSchema);\r\n      });\r\n    }\r\n    return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then((schema2) => {\r\n      return getDiagnostics(schema2);\r\n    });\r\n  }\r\n  getLanguageStatus(textDocument, jsonDocument) {\r\n    return { schemas: this.jsonSchemaService.getSchemaURIsForResource(textDocument.uri, jsonDocument) };\r\n  }\r\n};\r\nvar idCounter = 0;\r\nfunction schemaAllowsComments(schemaRef) {\r\n  if (schemaRef && typeof schemaRef === \"object\") {\r\n    if (isBoolean(schemaRef.allowComments)) {\r\n      return schemaRef.allowComments;\r\n    }\r\n    if (schemaRef.allOf) {\r\n      for (const schema of schemaRef.allOf) {\r\n        const allow = schemaAllowsComments(schema);\r\n        if (isBoolean(allow)) {\r\n          return allow;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return void 0;\r\n}\r\nfunction schemaAllowsTrailingCommas(schemaRef) {\r\n  if (schemaRef && typeof schemaRef === \"object\") {\r\n    if (isBoolean(schemaRef.allowTrailingCommas)) {\r\n      return schemaRef.allowTrailingCommas;\r\n    }\r\n    const deprSchemaRef = schemaRef;\r\n    if (isBoolean(deprSchemaRef[\"allowsTrailingCommas\"])) {\r\n      return deprSchemaRef[\"allowsTrailingCommas\"];\r\n    }\r\n    if (schemaRef.allOf) {\r\n      for (const schema of schemaRef.allOf) {\r\n        const allow = schemaAllowsTrailingCommas(schema);\r\n        if (isBoolean(allow)) {\r\n          return allow;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return void 0;\r\n}\r\nfunction toDiagnosticSeverity(severityLevel) {\r\n  switch (severityLevel) {\r\n    case \"error\":\r\n      return DiagnosticSeverity.Error;\r\n    case \"warning\":\r\n      return DiagnosticSeverity.Warning;\r\n    case \"ignore\":\r\n      return void 0;\r\n  }\r\n  return void 0;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/colors.js\r\nvar Digit0 = 48;\r\nvar Digit9 = 57;\r\nvar A = 65;\r\nvar a = 97;\r\nvar f = 102;\r\nfunction hexDigit(charCode) {\r\n  if (charCode < Digit0) {\r\n    return 0;\r\n  }\r\n  if (charCode <= Digit9) {\r\n    return charCode - Digit0;\r\n  }\r\n  if (charCode < a) {\r\n    charCode += a - A;\r\n  }\r\n  if (charCode >= a && charCode <= f) {\r\n    return charCode - a + 10;\r\n  }\r\n  return 0;\r\n}\r\nfunction colorFromHex(text) {\r\n  if (text[0] !== \"#\") {\r\n    return void 0;\r\n  }\r\n  switch (text.length) {\r\n    case 4:\r\n      return {\r\n        red: hexDigit(text.charCodeAt(1)) * 17 / 255,\r\n        green: hexDigit(text.charCodeAt(2)) * 17 / 255,\r\n        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,\r\n        alpha: 1\r\n      };\r\n    case 5:\r\n      return {\r\n        red: hexDigit(text.charCodeAt(1)) * 17 / 255,\r\n        green: hexDigit(text.charCodeAt(2)) * 17 / 255,\r\n        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,\r\n        alpha: hexDigit(text.charCodeAt(4)) * 17 / 255\r\n      };\r\n    case 7:\r\n      return {\r\n        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,\r\n        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,\r\n        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,\r\n        alpha: 1\r\n      };\r\n    case 9:\r\n      return {\r\n        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,\r\n        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,\r\n        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,\r\n        alpha: (hexDigit(text.charCodeAt(7)) * 16 + hexDigit(text.charCodeAt(8))) / 255\r\n      };\r\n  }\r\n  return void 0;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonDocumentSymbols.js\r\nvar JSONDocumentSymbols = class {\r\n  constructor(schemaService) {\r\n    this.schemaService = schemaService;\r\n  }\r\n  findDocumentSymbols(document, doc, context = { resultLimit: Number.MAX_VALUE }) {\r\n    const root = doc.root;\r\n    if (!root) {\r\n      return [];\r\n    }\r\n    let limit = context.resultLimit || Number.MAX_VALUE;\r\n    const resourceString = document.uri;\r\n    if (resourceString === \"vscode://defaultsettings/keybindings.json\" || endsWith(resourceString.toLowerCase(), \"/user/keybindings.json\")) {\r\n      if (root.type === \"array\") {\r\n        const result2 = [];\r\n        for (const item of root.items) {\r\n          if (item.type === \"object\") {\r\n            for (const property of item.properties) {\r\n              if (property.keyNode.value === \"key\" && property.valueNode) {\r\n                const location = Location.create(document.uri, getRange(document, item));\r\n                result2.push({ name: getName(property.valueNode), kind: SymbolKind.Function, location });\r\n                limit--;\r\n                if (limit <= 0) {\r\n                  if (context && context.onResultLimitExceeded) {\r\n                    context.onResultLimitExceeded(resourceString);\r\n                  }\r\n                  return result2;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result2;\r\n      }\r\n    }\r\n    const toVisit = [\r\n      { node: root, containerName: \"\" }\r\n    ];\r\n    let nextToVisit = 0;\r\n    let limitExceeded = false;\r\n    const result = [];\r\n    const collectOutlineEntries = (node, containerName) => {\r\n      if (node.type === \"array\") {\r\n        node.items.forEach((node2) => {\r\n          if (node2) {\r\n            toVisit.push({ node: node2, containerName });\r\n          }\r\n        });\r\n      } else if (node.type === \"object\") {\r\n        node.properties.forEach((property) => {\r\n          const valueNode = property.valueNode;\r\n          if (valueNode) {\r\n            if (limit > 0) {\r\n              limit--;\r\n              const location = Location.create(document.uri, getRange(document, property));\r\n              const childContainerName = containerName ? containerName + \".\" + property.keyNode.value : property.keyNode.value;\r\n              result.push({ name: this.getKeyLabel(property), kind: this.getSymbolKind(valueNode.type), location, containerName });\r\n              toVisit.push({ node: valueNode, containerName: childContainerName });\r\n            } else {\r\n              limitExceeded = true;\r\n            }\r\n          }\r\n        });\r\n      }\r\n    };\r\n    while (nextToVisit < toVisit.length) {\r\n      const next = toVisit[nextToVisit++];\r\n      collectOutlineEntries(next.node, next.containerName);\r\n    }\r\n    if (limitExceeded && context && context.onResultLimitExceeded) {\r\n      context.onResultLimitExceeded(resourceString);\r\n    }\r\n    return result;\r\n  }\r\n  findDocumentSymbols2(document, doc, context = { resultLimit: Number.MAX_VALUE }) {\r\n    const root = doc.root;\r\n    if (!root) {\r\n      return [];\r\n    }\r\n    let limit = context.resultLimit || Number.MAX_VALUE;\r\n    const resourceString = document.uri;\r\n    if (resourceString === \"vscode://defaultsettings/keybindings.json\" || endsWith(resourceString.toLowerCase(), \"/user/keybindings.json\")) {\r\n      if (root.type === \"array\") {\r\n        const result2 = [];\r\n        for (const item of root.items) {\r\n          if (item.type === \"object\") {\r\n            for (const property of item.properties) {\r\n              if (property.keyNode.value === \"key\" && property.valueNode) {\r\n                const range = getRange(document, item);\r\n                const selectionRange = getRange(document, property.keyNode);\r\n                result2.push({ name: getName(property.valueNode), kind: SymbolKind.Function, range, selectionRange });\r\n                limit--;\r\n                if (limit <= 0) {\r\n                  if (context && context.onResultLimitExceeded) {\r\n                    context.onResultLimitExceeded(resourceString);\r\n                  }\r\n                  return result2;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result2;\r\n      }\r\n    }\r\n    const result = [];\r\n    const toVisit = [\r\n      { node: root, result }\r\n    ];\r\n    let nextToVisit = 0;\r\n    let limitExceeded = false;\r\n    const collectOutlineEntries = (node, result2) => {\r\n      if (node.type === \"array\") {\r\n        node.items.forEach((node2, index) => {\r\n          if (node2) {\r\n            if (limit > 0) {\r\n              limit--;\r\n              const range = getRange(document, node2);\r\n              const selectionRange = range;\r\n              const name = String(index);\r\n              const symbol = { name, kind: this.getSymbolKind(node2.type), range, selectionRange, children: [] };\r\n              result2.push(symbol);\r\n              toVisit.push({ result: symbol.children, node: node2 });\r\n            } else {\r\n              limitExceeded = true;\r\n            }\r\n          }\r\n        });\r\n      } else if (node.type === \"object\") {\r\n        node.properties.forEach((property) => {\r\n          const valueNode = property.valueNode;\r\n          if (valueNode) {\r\n            if (limit > 0) {\r\n              limit--;\r\n              const range = getRange(document, property);\r\n              const selectionRange = getRange(document, property.keyNode);\r\n              const children = [];\r\n              const symbol = { name: this.getKeyLabel(property), kind: this.getSymbolKind(valueNode.type), range, selectionRange, children, detail: this.getDetail(valueNode) };\r\n              result2.push(symbol);\r\n              toVisit.push({ result: children, node: valueNode });\r\n            } else {\r\n              limitExceeded = true;\r\n            }\r\n          }\r\n        });\r\n      }\r\n    };\r\n    while (nextToVisit < toVisit.length) {\r\n      const next = toVisit[nextToVisit++];\r\n      collectOutlineEntries(next.node, next.result);\r\n    }\r\n    if (limitExceeded && context && context.onResultLimitExceeded) {\r\n      context.onResultLimitExceeded(resourceString);\r\n    }\r\n    return result;\r\n  }\r\n  getSymbolKind(nodeType) {\r\n    switch (nodeType) {\r\n      case \"object\":\r\n        return SymbolKind.Module;\r\n      case \"string\":\r\n        return SymbolKind.String;\r\n      case \"number\":\r\n        return SymbolKind.Number;\r\n      case \"array\":\r\n        return SymbolKind.Array;\r\n      case \"boolean\":\r\n        return SymbolKind.Boolean;\r\n      default:\r\n        return SymbolKind.Variable;\r\n    }\r\n  }\r\n  getKeyLabel(property) {\r\n    let name = property.keyNode.value;\r\n    if (name) {\r\n      name = name.replace(/[\\n]/g, \"\\u21B5\");\r\n    }\r\n    if (name && name.trim()) {\r\n      return name;\r\n    }\r\n    return `\"${name}\"`;\r\n  }\r\n  getDetail(node) {\r\n    if (!node) {\r\n      return void 0;\r\n    }\r\n    if (node.type === \"boolean\" || node.type === \"number\" || node.type === \"null\" || node.type === \"string\") {\r\n      return String(node.value);\r\n    } else {\r\n      if (node.type === \"array\") {\r\n        return node.children.length ? void 0 : \"[]\";\r\n      } else if (node.type === \"object\") {\r\n        return node.children.length ? void 0 : \"{}\";\r\n      }\r\n    }\r\n    return void 0;\r\n  }\r\n  findDocumentColors(document, doc, context) {\r\n    return this.schemaService.getSchemaForResource(document.uri, doc).then((schema) => {\r\n      const result = [];\r\n      if (schema) {\r\n        let limit = context && typeof context.resultLimit === \"number\" ? context.resultLimit : Number.MAX_VALUE;\r\n        const matchingSchemas = doc.getMatchingSchemas(schema.schema);\r\n        const visitedNode = {};\r\n        for (const s of matchingSchemas) {\r\n          if (!s.inverted && s.schema && (s.schema.format === \"color\" || s.schema.format === \"color-hex\") && s.node && s.node.type === \"string\") {\r\n            const nodeId = String(s.node.offset);\r\n            if (!visitedNode[nodeId]) {\r\n              const color = colorFromHex(getNodeValue3(s.node));\r\n              if (color) {\r\n                const range = getRange(document, s.node);\r\n                result.push({ color, range });\r\n              }\r\n              visitedNode[nodeId] = true;\r\n              limit--;\r\n              if (limit <= 0) {\r\n                if (context && context.onResultLimitExceeded) {\r\n                  context.onResultLimitExceeded(document.uri);\r\n                }\r\n                return result;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    });\r\n  }\r\n  getColorPresentations(document, doc, color, range) {\r\n    const result = [];\r\n    const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);\r\n    function toTwoDigitHex(n) {\r\n      const r = n.toString(16);\r\n      return r.length !== 2 ? \"0\" + r : r;\r\n    }\r\n    let label;\r\n    if (color.alpha === 1) {\r\n      label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;\r\n    } else {\r\n      label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}${toTwoDigitHex(Math.round(color.alpha * 255))}`;\r\n    }\r\n    result.push({ label, textEdit: TextEdit.replace(range, JSON.stringify(label)) });\r\n    return result;\r\n  }\r\n};\r\nfunction getRange(document, node) {\r\n  return Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\r\n}\r\nfunction getName(node) {\r\n  return getNodeValue3(node) || t(\"<empty>\");\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/configuration.js\r\nvar schemaContributions = {\r\n  schemaAssociations: [],\r\n  schemas: {\r\n    // bundle the schema-schema to include (localized) descriptions\r\n    \"http://json-schema.org/draft-04/schema#\": {\r\n      \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n      \"definitions\": {\r\n        \"schemaArray\": {\r\n          \"type\": \"array\",\r\n          \"minItems\": 1,\r\n          \"items\": {\r\n            \"$ref\": \"#\"\r\n          }\r\n        },\r\n        \"positiveInteger\": {\r\n          \"type\": \"integer\",\r\n          \"minimum\": 0\r\n        },\r\n        \"positiveIntegerDefault0\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveInteger\"\r\n            },\r\n            {\r\n              \"default\": 0\r\n            }\r\n          ]\r\n        },\r\n        \"simpleTypes\": {\r\n          \"type\": \"string\",\r\n          \"enum\": [\r\n            \"array\",\r\n            \"boolean\",\r\n            \"integer\",\r\n            \"null\",\r\n            \"number\",\r\n            \"object\",\r\n            \"string\"\r\n          ]\r\n        },\r\n        \"stringArray\": {\r\n          \"type\": \"array\",\r\n          \"items\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"minItems\": 1,\r\n          \"uniqueItems\": true\r\n        }\r\n      },\r\n      \"type\": \"object\",\r\n      \"properties\": {\r\n        \"id\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"uri\"\r\n        },\r\n        \"$schema\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"uri\"\r\n        },\r\n        \"title\": {\r\n          \"type\": \"string\"\r\n        },\r\n        \"description\": {\r\n          \"type\": \"string\"\r\n        },\r\n        \"default\": {},\r\n        \"multipleOf\": {\r\n          \"type\": \"number\",\r\n          \"minimum\": 0,\r\n          \"exclusiveMinimum\": true\r\n        },\r\n        \"maximum\": {\r\n          \"type\": \"number\"\r\n        },\r\n        \"exclusiveMaximum\": {\r\n          \"type\": \"boolean\",\r\n          \"default\": false\r\n        },\r\n        \"minimum\": {\r\n          \"type\": \"number\"\r\n        },\r\n        \"exclusiveMinimum\": {\r\n          \"type\": \"boolean\",\r\n          \"default\": false\r\n        },\r\n        \"maxLength\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveInteger\"\r\n            }\r\n          ]\r\n        },\r\n        \"minLength\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveIntegerDefault0\"\r\n            }\r\n          ]\r\n        },\r\n        \"pattern\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"regex\"\r\n        },\r\n        \"additionalItems\": {\r\n          \"anyOf\": [\r\n            {\r\n              \"type\": \"boolean\"\r\n            },\r\n            {\r\n              \"$ref\": \"#\"\r\n            }\r\n          ],\r\n          \"default\": {}\r\n        },\r\n        \"items\": {\r\n          \"anyOf\": [\r\n            {\r\n              \"$ref\": \"#\"\r\n            },\r\n            {\r\n              \"$ref\": \"#/definitions/schemaArray\"\r\n            }\r\n          ],\r\n          \"default\": {}\r\n        },\r\n        \"maxItems\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveInteger\"\r\n            }\r\n          ]\r\n        },\r\n        \"minItems\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveIntegerDefault0\"\r\n            }\r\n          ]\r\n        },\r\n        \"uniqueItems\": {\r\n          \"type\": \"boolean\",\r\n          \"default\": false\r\n        },\r\n        \"maxProperties\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveInteger\"\r\n            }\r\n          ]\r\n        },\r\n        \"minProperties\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/positiveIntegerDefault0\"\r\n            }\r\n          ]\r\n        },\r\n        \"required\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/stringArray\"\r\n            }\r\n          ]\r\n        },\r\n        \"additionalProperties\": {\r\n          \"anyOf\": [\r\n            {\r\n              \"type\": \"boolean\"\r\n            },\r\n            {\r\n              \"$ref\": \"#\"\r\n            }\r\n          ],\r\n          \"default\": {}\r\n        },\r\n        \"definitions\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": {\r\n            \"$ref\": \"#\"\r\n          },\r\n          \"default\": {}\r\n        },\r\n        \"properties\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": {\r\n            \"$ref\": \"#\"\r\n          },\r\n          \"default\": {}\r\n        },\r\n        \"patternProperties\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": {\r\n            \"$ref\": \"#\"\r\n          },\r\n          \"default\": {}\r\n        },\r\n        \"dependencies\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": {\r\n            \"anyOf\": [\r\n              {\r\n                \"$ref\": \"#\"\r\n              },\r\n              {\r\n                \"$ref\": \"#/definitions/stringArray\"\r\n              }\r\n            ]\r\n          }\r\n        },\r\n        \"enum\": {\r\n          \"type\": \"array\",\r\n          \"minItems\": 1,\r\n          \"uniqueItems\": true\r\n        },\r\n        \"type\": {\r\n          \"anyOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/simpleTypes\"\r\n            },\r\n            {\r\n              \"type\": \"array\",\r\n              \"items\": {\r\n                \"$ref\": \"#/definitions/simpleTypes\"\r\n              },\r\n              \"minItems\": 1,\r\n              \"uniqueItems\": true\r\n            }\r\n          ]\r\n        },\r\n        \"format\": {\r\n          \"anyOf\": [\r\n            {\r\n              \"type\": \"string\",\r\n              \"enum\": [\r\n                \"date-time\",\r\n                \"uri\",\r\n                \"email\",\r\n                \"hostname\",\r\n                \"ipv4\",\r\n                \"ipv6\",\r\n                \"regex\"\r\n              ]\r\n            },\r\n            {\r\n              \"type\": \"string\"\r\n            }\r\n          ]\r\n        },\r\n        \"allOf\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/schemaArray\"\r\n            }\r\n          ]\r\n        },\r\n        \"anyOf\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/schemaArray\"\r\n            }\r\n          ]\r\n        },\r\n        \"oneOf\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#/definitions/schemaArray\"\r\n            }\r\n          ]\r\n        },\r\n        \"not\": {\r\n          \"allOf\": [\r\n            {\r\n              \"$ref\": \"#\"\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      \"dependencies\": {\r\n        \"exclusiveMaximum\": [\r\n          \"maximum\"\r\n        ],\r\n        \"exclusiveMinimum\": [\r\n          \"minimum\"\r\n        ]\r\n      },\r\n      \"default\": {}\r\n    },\r\n    \"http://json-schema.org/draft-07/schema#\": {\r\n      \"definitions\": {\r\n        \"schemaArray\": {\r\n          \"type\": \"array\",\r\n          \"minItems\": 1,\r\n          \"items\": { \"$ref\": \"#\" }\r\n        },\r\n        \"nonNegativeInteger\": {\r\n          \"type\": \"integer\",\r\n          \"minimum\": 0\r\n        },\r\n        \"nonNegativeIntegerDefault0\": {\r\n          \"allOf\": [\r\n            { \"$ref\": \"#/definitions/nonNegativeInteger\" },\r\n            { \"default\": 0 }\r\n          ]\r\n        },\r\n        \"simpleTypes\": {\r\n          \"enum\": [\r\n            \"array\",\r\n            \"boolean\",\r\n            \"integer\",\r\n            \"null\",\r\n            \"number\",\r\n            \"object\",\r\n            \"string\"\r\n          ]\r\n        },\r\n        \"stringArray\": {\r\n          \"type\": \"array\",\r\n          \"items\": { \"type\": \"string\" },\r\n          \"uniqueItems\": true,\r\n          \"default\": []\r\n        }\r\n      },\r\n      \"type\": [\"object\", \"boolean\"],\r\n      \"properties\": {\r\n        \"$id\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"uri-reference\"\r\n        },\r\n        \"$schema\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"uri\"\r\n        },\r\n        \"$ref\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"uri-reference\"\r\n        },\r\n        \"$comment\": {\r\n          \"type\": \"string\"\r\n        },\r\n        \"title\": {\r\n          \"type\": \"string\"\r\n        },\r\n        \"description\": {\r\n          \"type\": \"string\"\r\n        },\r\n        \"default\": true,\r\n        \"readOnly\": {\r\n          \"type\": \"boolean\",\r\n          \"default\": false\r\n        },\r\n        \"examples\": {\r\n          \"type\": \"array\",\r\n          \"items\": true\r\n        },\r\n        \"multipleOf\": {\r\n          \"type\": \"number\",\r\n          \"exclusiveMinimum\": 0\r\n        },\r\n        \"maximum\": {\r\n          \"type\": \"number\"\r\n        },\r\n        \"exclusiveMaximum\": {\r\n          \"type\": \"number\"\r\n        },\r\n        \"minimum\": {\r\n          \"type\": \"number\"\r\n        },\r\n        \"exclusiveMinimum\": {\r\n          \"type\": \"number\"\r\n        },\r\n        \"maxLength\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\r\n        \"minLength\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\r\n        \"pattern\": {\r\n          \"type\": \"string\",\r\n          \"format\": \"regex\"\r\n        },\r\n        \"additionalItems\": { \"$ref\": \"#\" },\r\n        \"items\": {\r\n          \"anyOf\": [\r\n            { \"$ref\": \"#\" },\r\n            { \"$ref\": \"#/definitions/schemaArray\" }\r\n          ],\r\n          \"default\": true\r\n        },\r\n        \"maxItems\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\r\n        \"minItems\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\r\n        \"uniqueItems\": {\r\n          \"type\": \"boolean\",\r\n          \"default\": false\r\n        },\r\n        \"contains\": { \"$ref\": \"#\" },\r\n        \"maxProperties\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\r\n        \"minProperties\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\r\n        \"required\": { \"$ref\": \"#/definitions/stringArray\" },\r\n        \"additionalProperties\": { \"$ref\": \"#\" },\r\n        \"definitions\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": { \"$ref\": \"#\" },\r\n          \"default\": {}\r\n        },\r\n        \"properties\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": { \"$ref\": \"#\" },\r\n          \"default\": {}\r\n        },\r\n        \"patternProperties\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": { \"$ref\": \"#\" },\r\n          \"propertyNames\": { \"format\": \"regex\" },\r\n          \"default\": {}\r\n        },\r\n        \"dependencies\": {\r\n          \"type\": \"object\",\r\n          \"additionalProperties\": {\r\n            \"anyOf\": [\r\n              { \"$ref\": \"#\" },\r\n              { \"$ref\": \"#/definitions/stringArray\" }\r\n            ]\r\n          }\r\n        },\r\n        \"propertyNames\": { \"$ref\": \"#\" },\r\n        \"const\": true,\r\n        \"enum\": {\r\n          \"type\": \"array\",\r\n          \"items\": true,\r\n          \"minItems\": 1,\r\n          \"uniqueItems\": true\r\n        },\r\n        \"type\": {\r\n          \"anyOf\": [\r\n            { \"$ref\": \"#/definitions/simpleTypes\" },\r\n            {\r\n              \"type\": \"array\",\r\n              \"items\": { \"$ref\": \"#/definitions/simpleTypes\" },\r\n              \"minItems\": 1,\r\n              \"uniqueItems\": true\r\n            }\r\n          ]\r\n        },\r\n        \"format\": { \"type\": \"string\" },\r\n        \"contentMediaType\": { \"type\": \"string\" },\r\n        \"contentEncoding\": { \"type\": \"string\" },\r\n        \"if\": { \"$ref\": \"#\" },\r\n        \"then\": { \"$ref\": \"#\" },\r\n        \"else\": { \"$ref\": \"#\" },\r\n        \"allOf\": { \"$ref\": \"#/definitions/schemaArray\" },\r\n        \"anyOf\": { \"$ref\": \"#/definitions/schemaArray\" },\r\n        \"oneOf\": { \"$ref\": \"#/definitions/schemaArray\" },\r\n        \"not\": { \"$ref\": \"#\" }\r\n      },\r\n      \"default\": true\r\n    }\r\n  }\r\n};\r\nvar descriptions = {\r\n  id: t(\"A unique identifier for the schema.\"),\r\n  $schema: t(\"The schema to verify this document against.\"),\r\n  title: t(\"A descriptive title of the element.\"),\r\n  description: t(\"A long description of the element. Used in hover menus and suggestions.\"),\r\n  default: t(\"A default value. Used by suggestions.\"),\r\n  multipleOf: t(\"A number that should cleanly divide the current value (i.e. have no remainder).\"),\r\n  maximum: t(\"The maximum numerical value, inclusive by default.\"),\r\n  exclusiveMaximum: t(\"Makes the maximum property exclusive.\"),\r\n  minimum: t(\"The minimum numerical value, inclusive by default.\"),\r\n  exclusiveMinimum: t(\"Makes the minimum property exclusive.\"),\r\n  maxLength: t(\"The maximum length of a string.\"),\r\n  minLength: t(\"The minimum length of a string.\"),\r\n  pattern: t(\"A regular expression to match the string against. It is not implicitly anchored.\"),\r\n  additionalItems: t(\"For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail.\"),\r\n  items: t(\"For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on.\"),\r\n  maxItems: t(\"The maximum number of items that can be inside an array. Inclusive.\"),\r\n  minItems: t(\"The minimum number of items that can be inside an array. Inclusive.\"),\r\n  uniqueItems: t(\"If all of the items in the array must be unique. Defaults to false.\"),\r\n  maxProperties: t(\"The maximum number of properties an object can have. Inclusive.\"),\r\n  minProperties: t(\"The minimum number of properties an object can have. Inclusive.\"),\r\n  required: t(\"An array of strings that lists the names of all properties required on this object.\"),\r\n  additionalProperties: t(\"Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail.\"),\r\n  definitions: t(\"Not used for validation. Place subschemas here that you wish to reference inline with $ref.\"),\r\n  properties: t(\"A map of property names to schemas for each property.\"),\r\n  patternProperties: t(\"A map of regular expressions on property names to schemas for matching properties.\"),\r\n  dependencies: t(\"A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object.\"),\r\n  enum: t(\"The set of literal values that are valid.\"),\r\n  type: t(\"Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types.\"),\r\n  format: t(\"Describes the format expected for the value.\"),\r\n  allOf: t(\"An array of schemas, all of which must match.\"),\r\n  anyOf: t(\"An array of schemas, where at least one must match.\"),\r\n  oneOf: t(\"An array of schemas, exactly one of which must match.\"),\r\n  not: t(\"A schema which must not match.\"),\r\n  $id: t(\"A unique identifier for the schema.\"),\r\n  $ref: t(\"Reference a definition hosted on any location.\"),\r\n  $comment: t(\"Comments from schema authors to readers or maintainers of the schema.\"),\r\n  readOnly: t(\"Indicates that the value of the instance is managed exclusively by the owning authority.\"),\r\n  examples: t(\"Sample JSON values associated with a particular schema, for the purpose of illustrating usage.\"),\r\n  contains: t('An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema.'),\r\n  propertyNames: t(\"If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema.\"),\r\n  const: t(\"An instance validates successfully against this keyword if its value is equal to the value of the keyword.\"),\r\n  contentMediaType: t(\"Describes the media type of a string property.\"),\r\n  contentEncoding: t(\"Describes the content encoding of a string property.\"),\r\n  if: t('The validation outcome of the \"if\" subschema controls which of the \"then\" or \"else\" keywords are evaluated.'),\r\n  then: t('The \"if\" subschema is used for validation when the \"if\" subschema succeeds.'),\r\n  else: t('The \"else\" subschema is used for validation when the \"if\" subschema fails.')\r\n};\r\nfor (const schemaName in schemaContributions.schemas) {\r\n  const schema = schemaContributions.schemas[schemaName];\r\n  for (const property in schema.properties) {\r\n    let propertyObject = schema.properties[property];\r\n    if (typeof propertyObject === \"boolean\") {\r\n      propertyObject = schema.properties[property] = {};\r\n    }\r\n    const description = descriptions[property];\r\n    if (description) {\r\n      propertyObject[\"description\"] = description;\r\n    }\r\n  }\r\n}\r\n\r\n// node_modules/vscode-uri/lib/esm/index.mjs\r\nvar LIB;\r\n(() => {\r\n  \"use strict\";\r\n  var t2 = { 470: (t3) => {\r\n    function e2(t4) {\r\n      if (\"string\" != typeof t4)\r\n        throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(t4));\r\n    }\r\n    function r2(t4, e3) {\r\n      for (var r3, n3 = \"\", i = 0, o = -1, s = 0, h = 0; h <= t4.length; ++h) {\r\n        if (h < t4.length)\r\n          r3 = t4.charCodeAt(h);\r\n        else {\r\n          if (47 === r3)\r\n            break;\r\n          r3 = 47;\r\n        }\r\n        if (47 === r3) {\r\n          if (o === h - 1 || 1 === s)\r\n            ;\r\n          else if (o !== h - 1 && 2 === s) {\r\n            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {\r\n              if (n3.length > 2) {\r\n                var a2 = n3.lastIndexOf(\"/\");\r\n                if (a2 !== n3.length - 1) {\r\n                  -1 === a2 ? (n3 = \"\", i = 0) : i = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf(\"/\"), o = h, s = 0;\r\n                  continue;\r\n                }\r\n              } else if (2 === n3.length || 1 === n3.length) {\r\n                n3 = \"\", i = 0, o = h, s = 0;\r\n                continue;\r\n              }\r\n            }\r\n            e3 && (n3.length > 0 ? n3 += \"/..\" : n3 = \"..\", i = 2);\r\n          } else\r\n            n3.length > 0 ? n3 += \"/\" + t4.slice(o + 1, h) : n3 = t4.slice(o + 1, h), i = h - o - 1;\r\n          o = h, s = 0;\r\n        } else\r\n          46 === r3 && -1 !== s ? ++s : s = -1;\r\n      }\r\n      return n3;\r\n    }\r\n    var n2 = { resolve: function() {\r\n      for (var t4, n3 = \"\", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {\r\n        var s;\r\n        o >= 0 ? s = arguments[o] : (void 0 === t4 && (t4 = process.cwd()), s = t4), e2(s), 0 !== s.length && (n3 = s + \"/\" + n3, i = 47 === s.charCodeAt(0));\r\n      }\r\n      return n3 = r2(n3, !i), i ? n3.length > 0 ? \"/\" + n3 : \"/\" : n3.length > 0 ? n3 : \".\";\r\n    }, normalize: function(t4) {\r\n      if (e2(t4), 0 === t4.length)\r\n        return \".\";\r\n      var n3 = 47 === t4.charCodeAt(0), i = 47 === t4.charCodeAt(t4.length - 1);\r\n      return 0 !== (t4 = r2(t4, !n3)).length || n3 || (t4 = \".\"), t4.length > 0 && i && (t4 += \"/\"), n3 ? \"/\" + t4 : t4;\r\n    }, isAbsolute: function(t4) {\r\n      return e2(t4), t4.length > 0 && 47 === t4.charCodeAt(0);\r\n    }, join: function() {\r\n      if (0 === arguments.length)\r\n        return \".\";\r\n      for (var t4, r3 = 0; r3 < arguments.length; ++r3) {\r\n        var i = arguments[r3];\r\n        e2(i), i.length > 0 && (void 0 === t4 ? t4 = i : t4 += \"/\" + i);\r\n      }\r\n      return void 0 === t4 ? \".\" : n2.normalize(t4);\r\n    }, relative: function(t4, r3) {\r\n      if (e2(t4), e2(r3), t4 === r3)\r\n        return \"\";\r\n      if ((t4 = n2.resolve(t4)) === (r3 = n2.resolve(r3)))\r\n        return \"\";\r\n      for (var i = 1; i < t4.length && 47 === t4.charCodeAt(i); ++i)\r\n        ;\r\n      for (var o = t4.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h)\r\n        ;\r\n      for (var a2 = r3.length - h, c = s < a2 ? s : a2, f2 = -1, u = 0; u <= c; ++u) {\r\n        if (u === c) {\r\n          if (a2 > c) {\r\n            if (47 === r3.charCodeAt(h + u))\r\n              return r3.slice(h + u + 1);\r\n            if (0 === u)\r\n              return r3.slice(h + u);\r\n          } else\r\n            s > c && (47 === t4.charCodeAt(i + u) ? f2 = u : 0 === u && (f2 = 0));\r\n          break;\r\n        }\r\n        var l = t4.charCodeAt(i + u);\r\n        if (l !== r3.charCodeAt(h + u))\r\n          break;\r\n        47 === l && (f2 = u);\r\n      }\r\n      var g = \"\";\r\n      for (u = i + f2 + 1; u <= o; ++u)\r\n        u !== o && 47 !== t4.charCodeAt(u) || (0 === g.length ? g += \"..\" : g += \"/..\");\r\n      return g.length > 0 ? g + r3.slice(h + f2) : (h += f2, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));\r\n    }, _makeLong: function(t4) {\r\n      return t4;\r\n    }, dirname: function(t4) {\r\n      if (e2(t4), 0 === t4.length)\r\n        return \".\";\r\n      for (var r3 = t4.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t4.length - 1; s >= 1; --s)\r\n        if (47 === (r3 = t4.charCodeAt(s))) {\r\n          if (!o) {\r\n            i = s;\r\n            break;\r\n          }\r\n        } else\r\n          o = false;\r\n      return -1 === i ? n3 ? \"/\" : \".\" : n3 && 1 === i ? \"//\" : t4.slice(0, i);\r\n    }, basename: function(t4, r3) {\r\n      if (void 0 !== r3 && \"string\" != typeof r3)\r\n        throw new TypeError('\"ext\" argument must be a string');\r\n      e2(t4);\r\n      var n3, i = 0, o = -1, s = true;\r\n      if (void 0 !== r3 && r3.length > 0 && r3.length <= t4.length) {\r\n        if (r3.length === t4.length && r3 === t4)\r\n          return \"\";\r\n        var h = r3.length - 1, a2 = -1;\r\n        for (n3 = t4.length - 1; n3 >= 0; --n3) {\r\n          var c = t4.charCodeAt(n3);\r\n          if (47 === c) {\r\n            if (!s) {\r\n              i = n3 + 1;\r\n              break;\r\n            }\r\n          } else\r\n            -1 === a2 && (s = false, a2 = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a2));\r\n        }\r\n        return i === o ? o = a2 : -1 === o && (o = t4.length), t4.slice(i, o);\r\n      }\r\n      for (n3 = t4.length - 1; n3 >= 0; --n3)\r\n        if (47 === t4.charCodeAt(n3)) {\r\n          if (!s) {\r\n            i = n3 + 1;\r\n            break;\r\n          }\r\n        } else\r\n          -1 === o && (s = false, o = n3 + 1);\r\n      return -1 === o ? \"\" : t4.slice(i, o);\r\n    }, extname: function(t4) {\r\n      e2(t4);\r\n      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t4.length - 1; h >= 0; --h) {\r\n        var a2 = t4.charCodeAt(h);\r\n        if (47 !== a2)\r\n          -1 === i && (o = false, i = h + 1), 46 === a2 ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);\r\n        else if (!o) {\r\n          n3 = h + 1;\r\n          break;\r\n        }\r\n      }\r\n      return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? \"\" : t4.slice(r3, i);\r\n    }, format: function(t4) {\r\n      if (null === t4 || \"object\" != typeof t4)\r\n        throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof t4);\r\n      return function(t5, e3) {\r\n        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || \"\") + (e3.ext || \"\");\r\n        return r3 ? r3 === e3.root ? r3 + n3 : r3 + \"/\" + n3 : n3;\r\n      }(0, t4);\r\n    }, parse: function(t4) {\r\n      e2(t4);\r\n      var r3 = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\r\n      if (0 === t4.length)\r\n        return r3;\r\n      var n3, i = t4.charCodeAt(0), o = 47 === i;\r\n      o ? (r3.root = \"/\", n3 = 1) : n3 = 0;\r\n      for (var s = -1, h = 0, a2 = -1, c = true, f2 = t4.length - 1, u = 0; f2 >= n3; --f2)\r\n        if (47 !== (i = t4.charCodeAt(f2)))\r\n          -1 === a2 && (c = false, a2 = f2 + 1), 46 === i ? -1 === s ? s = f2 : 1 !== u && (u = 1) : -1 !== s && (u = -1);\r\n        else if (!c) {\r\n          h = f2 + 1;\r\n          break;\r\n        }\r\n      return -1 === s || -1 === a2 || 0 === u || 1 === u && s === a2 - 1 && s === h + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h && o ? t4.slice(1, a2) : t4.slice(h, a2)) : (0 === h && o ? (r3.name = t4.slice(1, s), r3.base = t4.slice(1, a2)) : (r3.name = t4.slice(h, s), r3.base = t4.slice(h, a2)), r3.ext = t4.slice(s, a2)), h > 0 ? r3.dir = t4.slice(0, h - 1) : o && (r3.dir = \"/\"), r3;\r\n    }, sep: \"/\", delimiter: \":\", win32: null, posix: null };\r\n    n2.posix = n2, t3.exports = n2;\r\n  } }, e = {};\r\n  function r(n2) {\r\n    var i = e[n2];\r\n    if (void 0 !== i)\r\n      return i.exports;\r\n    var o = e[n2] = { exports: {} };\r\n    return t2[n2](o, o.exports, r), o.exports;\r\n  }\r\n  r.d = (t3, e2) => {\r\n    for (var n2 in e2)\r\n      r.o(e2, n2) && !r.o(t3, n2) && Object.defineProperty(t3, n2, { enumerable: true, get: e2[n2] });\r\n  }, r.o = (t3, e2) => Object.prototype.hasOwnProperty.call(t3, e2), r.r = (t3) => {\r\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t3, \"__esModule\", { value: true });\r\n  };\r\n  var n = {};\r\n  (() => {\r\n    let t3;\r\n    if (r.r(n), r.d(n, { URI: () => f2, Utils: () => P }), \"object\" == typeof process)\r\n      t3 = \"win32\" === process.platform;\r\n    else if (\"object\" == typeof navigator) {\r\n      let e3 = navigator.userAgent;\r\n      t3 = e3.indexOf(\"Windows\") >= 0;\r\n    }\r\n    const e2 = /^\\w[\\w\\d+.-]*$/, i = /^\\//, o = /^\\/\\//;\r\n    function s(t4, r2) {\r\n      if (!t4.scheme && r2)\r\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t4.authority}\", path: \"${t4.path}\", query: \"${t4.query}\", fragment: \"${t4.fragment}\"}`);\r\n      if (t4.scheme && !e2.test(t4.scheme))\r\n        throw new Error(\"[UriError]: Scheme contains illegal characters.\");\r\n      if (t4.path) {\r\n        if (t4.authority) {\r\n          if (!i.test(t4.path))\r\n            throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\r\n        } else if (o.test(t4.path))\r\n          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\r\n      }\r\n    }\r\n    const h = \"\", a2 = \"/\", c = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n    class f2 {\r\n      static isUri(t4) {\r\n        return t4 instanceof f2 || !!t4 && \"string\" == typeof t4.authority && \"string\" == typeof t4.fragment && \"string\" == typeof t4.path && \"string\" == typeof t4.query && \"string\" == typeof t4.scheme && \"string\" == typeof t4.fsPath && \"function\" == typeof t4.with && \"function\" == typeof t4.toString;\r\n      }\r\n      scheme;\r\n      authority;\r\n      path;\r\n      query;\r\n      fragment;\r\n      constructor(t4, e3, r2, n2, i2, o2 = false) {\r\n        \"object\" == typeof t4 ? (this.scheme = t4.scheme || h, this.authority = t4.authority || h, this.path = t4.path || h, this.query = t4.query || h, this.fragment = t4.fragment || h) : (this.scheme = /* @__PURE__ */ function(t5, e4) {\r\n          return t5 || e4 ? t5 : \"file\";\r\n        }(t4, o2), this.authority = e3 || h, this.path = function(t5, e4) {\r\n          switch (t5) {\r\n            case \"https\":\r\n            case \"http\":\r\n            case \"file\":\r\n              e4 ? e4[0] !== a2 && (e4 = a2 + e4) : e4 = a2;\r\n          }\r\n          return e4;\r\n        }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));\r\n      }\r\n      get fsPath() {\r\n        return m(this, false);\r\n      }\r\n      with(t4) {\r\n        if (!t4)\r\n          return this;\r\n        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t4;\r\n        return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);\r\n      }\r\n      static parse(t4, e3 = false) {\r\n        const r2 = c.exec(t4);\r\n        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);\r\n      }\r\n      static file(e3) {\r\n        let r2 = h;\r\n        if (t3 && (e3 = e3.replace(/\\\\/g, a2)), e3[0] === a2 && e3[1] === a2) {\r\n          const t4 = e3.indexOf(a2, 2);\r\n          -1 === t4 ? (r2 = e3.substring(2), e3 = a2) : (r2 = e3.substring(2, t4), e3 = e3.substring(t4) || a2);\r\n        }\r\n        return new l(\"file\", r2, e3, h, h);\r\n      }\r\n      static from(t4) {\r\n        const e3 = new l(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);\r\n        return s(e3, true), e3;\r\n      }\r\n      toString(t4 = false) {\r\n        return y(this, t4);\r\n      }\r\n      toJSON() {\r\n        return this;\r\n      }\r\n      static revive(t4) {\r\n        if (t4) {\r\n          if (t4 instanceof f2)\r\n            return t4;\r\n          {\r\n            const e3 = new l(t4);\r\n            return e3._formatted = t4.external, e3._fsPath = t4._sep === u ? t4.fsPath : null, e3;\r\n          }\r\n        }\r\n        return t4;\r\n      }\r\n    }\r\n    const u = t3 ? 1 : void 0;\r\n    class l extends f2 {\r\n      _formatted = null;\r\n      _fsPath = null;\r\n      get fsPath() {\r\n        return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;\r\n      }\r\n      toString(t4 = false) {\r\n        return t4 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);\r\n      }\r\n      toJSON() {\r\n        const t4 = { $mid: 1 };\r\n        return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = u), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;\r\n      }\r\n    }\r\n    const g = { 58: \"%3A\", 47: \"%2F\", 63: \"%3F\", 35: \"%23\", 91: \"%5B\", 93: \"%5D\", 64: \"%40\", 33: \"%21\", 36: \"%24\", 38: \"%26\", 39: \"%27\", 40: \"%28\", 41: \"%29\", 42: \"%2A\", 43: \"%2B\", 44: \"%2C\", 59: \"%3B\", 61: \"%3D\", 32: \"%20\" };\r\n    function d(t4, e3, r2) {\r\n      let n2, i2 = -1;\r\n      for (let o2 = 0; o2 < t4.length; o2++) {\r\n        const s2 = t4.charCodeAt(o2);\r\n        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2)\r\n          -1 !== i2 && (n2 += encodeURIComponent(t4.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t4.charAt(o2));\r\n        else {\r\n          void 0 === n2 && (n2 = t4.substr(0, o2));\r\n          const e4 = g[s2];\r\n          void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t4.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);\r\n        }\r\n      }\r\n      return -1 !== i2 && (n2 += encodeURIComponent(t4.substring(i2))), void 0 !== n2 ? n2 : t4;\r\n    }\r\n    function p(t4) {\r\n      let e3;\r\n      for (let r2 = 0; r2 < t4.length; r2++) {\r\n        const n2 = t4.charCodeAt(r2);\r\n        35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t4.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t4[r2]);\r\n      }\r\n      return void 0 !== e3 ? e3 : t4;\r\n    }\r\n    function m(e3, r2) {\r\n      let n2;\r\n      return n2 = e3.authority && e3.path.length > 1 && \"file\" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t3 && (n2 = n2.replace(/\\//g, \"\\\\\")), n2;\r\n    }\r\n    function y(t4, e3) {\r\n      const r2 = e3 ? p : d;\r\n      let n2 = \"\", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t4;\r\n      if (i2 && (n2 += i2, n2 += \":\"), (o2 || \"file\" === i2) && (n2 += a2, n2 += a2), o2) {\r\n        let t5 = o2.indexOf(\"@\");\r\n        if (-1 !== t5) {\r\n          const e4 = o2.substr(0, t5);\r\n          o2 = o2.substr(t5 + 1), t5 = e4.lastIndexOf(\":\"), -1 === t5 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t5), false, false), n2 += \":\", n2 += r2(e4.substr(t5 + 1), false, true)), n2 += \"@\";\r\n        }\r\n        o2 = o2.toLowerCase(), t5 = o2.lastIndexOf(\":\"), -1 === t5 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t5), false, true), n2 += o2.substr(t5));\r\n      }\r\n      if (s2) {\r\n        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {\r\n          const t5 = s2.charCodeAt(1);\r\n          t5 >= 65 && t5 <= 90 && (s2 = `/${String.fromCharCode(t5 + 32)}:${s2.substr(3)}`);\r\n        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {\r\n          const t5 = s2.charCodeAt(0);\r\n          t5 >= 65 && t5 <= 90 && (s2 = `${String.fromCharCode(t5 + 32)}:${s2.substr(2)}`);\r\n        }\r\n        n2 += r2(s2, true, false);\r\n      }\r\n      return h2 && (n2 += \"?\", n2 += r2(h2, false, false)), c2 && (n2 += \"#\", n2 += e3 ? c2 : d(c2, false, false)), n2;\r\n    }\r\n    function v(t4) {\r\n      try {\r\n        return decodeURIComponent(t4);\r\n      } catch {\r\n        return t4.length > 3 ? t4.substr(0, 3) + v(t4.substr(3)) : t4;\r\n      }\r\n    }\r\n    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\r\n    function C(t4) {\r\n      return t4.match(b) ? t4.replace(b, (t5) => v(t5)) : t4;\r\n    }\r\n    var A2 = r(470);\r\n    const w = A2.posix || A2, x = \"/\";\r\n    var P;\r\n    !function(t4) {\r\n      t4.joinPath = function(t5, ...e3) {\r\n        return t5.with({ path: w.join(t5.path, ...e3) });\r\n      }, t4.resolvePath = function(t5, ...e3) {\r\n        let r2 = t5.path, n2 = false;\r\n        r2[0] !== x && (r2 = x + r2, n2 = true);\r\n        let i2 = w.resolve(r2, ...e3);\r\n        return n2 && i2[0] === x && !t5.authority && (i2 = i2.substring(1)), t5.with({ path: i2 });\r\n      }, t4.dirname = function(t5) {\r\n        if (0 === t5.path.length || t5.path === x)\r\n          return t5;\r\n        let e3 = w.dirname(t5.path);\r\n        return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = \"\"), t5.with({ path: e3 });\r\n      }, t4.basename = function(t5) {\r\n        return w.basename(t5.path);\r\n      }, t4.extname = function(t5) {\r\n        return w.extname(t5.path);\r\n      };\r\n    }(P || (P = {}));\r\n  })(), LIB = n;\r\n})();\r\nvar { URI: URI2, Utils } = LIB;\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/glob.js\r\nfunction createRegex(glob, opts) {\r\n  if (typeof glob !== \"string\") {\r\n    throw new TypeError(\"Expected a string\");\r\n  }\r\n  const str = String(glob);\r\n  let reStr = \"\";\r\n  const extended = opts ? !!opts.extended : false;\r\n  const globstar = opts ? !!opts.globstar : false;\r\n  let inGroup = false;\r\n  const flags = opts && typeof opts.flags === \"string\" ? opts.flags : \"\";\r\n  let c;\r\n  for (let i = 0, len = str.length; i < len; i++) {\r\n    c = str[i];\r\n    switch (c) {\r\n      case \"/\":\r\n      case \"$\":\r\n      case \"^\":\r\n      case \"+\":\r\n      case \".\":\r\n      case \"(\":\r\n      case \")\":\r\n      case \"=\":\r\n      case \"!\":\r\n      case \"|\":\r\n        reStr += \"\\\\\" + c;\r\n        break;\r\n      case \"?\":\r\n        if (extended) {\r\n          reStr += \".\";\r\n          break;\r\n        }\r\n      case \"[\":\r\n      case \"]\":\r\n        if (extended) {\r\n          reStr += c;\r\n          break;\r\n        }\r\n      case \"{\":\r\n        if (extended) {\r\n          inGroup = true;\r\n          reStr += \"(\";\r\n          break;\r\n        }\r\n      case \"}\":\r\n        if (extended) {\r\n          inGroup = false;\r\n          reStr += \")\";\r\n          break;\r\n        }\r\n      case \",\":\r\n        if (inGroup) {\r\n          reStr += \"|\";\r\n          break;\r\n        }\r\n        reStr += \"\\\\\" + c;\r\n        break;\r\n      case \"*\":\r\n        const prevChar = str[i - 1];\r\n        let starCount = 1;\r\n        while (str[i + 1] === \"*\") {\r\n          starCount++;\r\n          i++;\r\n        }\r\n        const nextChar = str[i + 1];\r\n        if (!globstar) {\r\n          reStr += \".*\";\r\n        } else {\r\n          const isGlobstar = starCount > 1 && (prevChar === \"/\" || prevChar === void 0 || prevChar === \"{\" || prevChar === \",\") && (nextChar === \"/\" || nextChar === void 0 || nextChar === \",\" || nextChar === \"}\");\r\n          if (isGlobstar) {\r\n            if (nextChar === \"/\") {\r\n              i++;\r\n            } else if (prevChar === \"/\" && reStr.endsWith(\"\\\\/\")) {\r\n              reStr = reStr.substr(0, reStr.length - 2);\r\n            }\r\n            reStr += \"((?:[^/]*(?:/|$))*)\";\r\n          } else {\r\n            reStr += \"([^/]*)\";\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        reStr += c;\r\n    }\r\n  }\r\n  if (!flags || !~flags.indexOf(\"g\")) {\r\n    reStr = \"^\" + reStr + \"$\";\r\n  }\r\n  return new RegExp(reStr, flags);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonSchemaService.js\r\nvar BANG = \"!\";\r\nvar PATH_SEP = \"/\";\r\nvar FilePatternAssociation = class {\r\n  constructor(pattern, folderUri, uris) {\r\n    this.folderUri = folderUri;\r\n    this.uris = uris;\r\n    this.globWrappers = [];\r\n    try {\r\n      for (let patternString of pattern) {\r\n        const include = patternString[0] !== BANG;\r\n        if (!include) {\r\n          patternString = patternString.substring(1);\r\n        }\r\n        if (patternString.length > 0) {\r\n          if (patternString[0] === PATH_SEP) {\r\n            patternString = patternString.substring(1);\r\n          }\r\n          this.globWrappers.push({\r\n            regexp: createRegex(\"**/\" + patternString, { extended: true, globstar: true }),\r\n            include\r\n          });\r\n        }\r\n      }\r\n      ;\r\n      if (folderUri) {\r\n        folderUri = normalizeResourceForMatching(folderUri);\r\n        if (!folderUri.endsWith(\"/\")) {\r\n          folderUri = folderUri + \"/\";\r\n        }\r\n        this.folderUri = folderUri;\r\n      }\r\n    } catch (e) {\r\n      this.globWrappers.length = 0;\r\n      this.uris = [];\r\n    }\r\n  }\r\n  matchesPattern(fileName) {\r\n    if (this.folderUri && !fileName.startsWith(this.folderUri)) {\r\n      return false;\r\n    }\r\n    let match = false;\r\n    for (const { regexp, include } of this.globWrappers) {\r\n      if (regexp.test(fileName)) {\r\n        match = include;\r\n      }\r\n    }\r\n    return match;\r\n  }\r\n  getURIs() {\r\n    return this.uris;\r\n  }\r\n};\r\nvar SchemaHandle = class {\r\n  constructor(service, uri, unresolvedSchemaContent) {\r\n    this.service = service;\r\n    this.uri = uri;\r\n    this.dependencies = /* @__PURE__ */ new Set();\r\n    this.anchors = void 0;\r\n    if (unresolvedSchemaContent) {\r\n      this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\r\n    }\r\n  }\r\n  getUnresolvedSchema() {\r\n    if (!this.unresolvedSchema) {\r\n      this.unresolvedSchema = this.service.loadSchema(this.uri);\r\n    }\r\n    return this.unresolvedSchema;\r\n  }\r\n  getResolvedSchema() {\r\n    if (!this.resolvedSchema) {\r\n      this.resolvedSchema = this.getUnresolvedSchema().then((unresolved) => {\r\n        return this.service.resolveSchemaContent(unresolved, this);\r\n      });\r\n    }\r\n    return this.resolvedSchema;\r\n  }\r\n  clearSchema() {\r\n    const hasChanges = !!this.unresolvedSchema;\r\n    this.resolvedSchema = void 0;\r\n    this.unresolvedSchema = void 0;\r\n    this.dependencies.clear();\r\n    this.anchors = void 0;\r\n    return hasChanges;\r\n  }\r\n};\r\nvar UnresolvedSchema = class {\r\n  constructor(schema, errors = []) {\r\n    this.schema = schema;\r\n    this.errors = errors;\r\n  }\r\n};\r\nvar ResolvedSchema = class {\r\n  constructor(schema, errors = [], warnings = [], schemaDraft) {\r\n    this.schema = schema;\r\n    this.errors = errors;\r\n    this.warnings = warnings;\r\n    this.schemaDraft = schemaDraft;\r\n  }\r\n  getSection(path) {\r\n    const schemaRef = this.getSectionRecursive(path, this.schema);\r\n    if (schemaRef) {\r\n      return asSchema(schemaRef);\r\n    }\r\n    return void 0;\r\n  }\r\n  getSectionRecursive(path, schema) {\r\n    if (!schema || typeof schema === \"boolean\" || path.length === 0) {\r\n      return schema;\r\n    }\r\n    const next = path.shift();\r\n    if (schema.properties && typeof schema.properties[next]) {\r\n      return this.getSectionRecursive(path, schema.properties[next]);\r\n    } else if (schema.patternProperties) {\r\n      for (const pattern of Object.keys(schema.patternProperties)) {\r\n        const regex = extendedRegExp(pattern);\r\n        if (regex?.test(next)) {\r\n          return this.getSectionRecursive(path, schema.patternProperties[pattern]);\r\n        }\r\n      }\r\n    } else if (typeof schema.additionalProperties === \"object\") {\r\n      return this.getSectionRecursive(path, schema.additionalProperties);\r\n    } else if (next.match(\"[0-9]+\")) {\r\n      if (Array.isArray(schema.items)) {\r\n        const index = parseInt(next, 10);\r\n        if (!isNaN(index) && schema.items[index]) {\r\n          return this.getSectionRecursive(path, schema.items[index]);\r\n        }\r\n      } else if (schema.items) {\r\n        return this.getSectionRecursive(path, schema.items);\r\n      }\r\n    }\r\n    return void 0;\r\n  }\r\n};\r\nvar JSONSchemaService = class {\r\n  constructor(requestService, contextService, promiseConstructor) {\r\n    this.contextService = contextService;\r\n    this.requestService = requestService;\r\n    this.promiseConstructor = promiseConstructor || Promise;\r\n    this.callOnDispose = [];\r\n    this.contributionSchemas = {};\r\n    this.contributionAssociations = [];\r\n    this.schemasById = {};\r\n    this.filePatternAssociations = [];\r\n    this.registeredSchemasIds = {};\r\n  }\r\n  getRegisteredSchemaIds(filter) {\r\n    return Object.keys(this.registeredSchemasIds).filter((id) => {\r\n      const scheme = URI2.parse(id).scheme;\r\n      return scheme !== \"schemaservice\" && (!filter || filter(scheme));\r\n    });\r\n  }\r\n  get promise() {\r\n    return this.promiseConstructor;\r\n  }\r\n  dispose() {\r\n    while (this.callOnDispose.length > 0) {\r\n      this.callOnDispose.pop()();\r\n    }\r\n  }\r\n  onResourceChange(uri) {\r\n    this.cachedSchemaForResource = void 0;\r\n    let hasChanges = false;\r\n    uri = normalizeId(uri);\r\n    const toWalk = [uri];\r\n    const all = Object.keys(this.schemasById).map((key) => this.schemasById[key]);\r\n    while (toWalk.length) {\r\n      const curr = toWalk.pop();\r\n      for (let i = 0; i < all.length; i++) {\r\n        const handle = all[i];\r\n        if (handle && (handle.uri === curr || handle.dependencies.has(curr))) {\r\n          if (handle.uri !== curr) {\r\n            toWalk.push(handle.uri);\r\n          }\r\n          if (handle.clearSchema()) {\r\n            hasChanges = true;\r\n          }\r\n          all[i] = void 0;\r\n        }\r\n      }\r\n    }\r\n    return hasChanges;\r\n  }\r\n  setSchemaContributions(schemaContributions2) {\r\n    if (schemaContributions2.schemas) {\r\n      const schemas = schemaContributions2.schemas;\r\n      for (const id in schemas) {\r\n        const normalizedId = normalizeId(id);\r\n        this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\r\n      }\r\n    }\r\n    if (Array.isArray(schemaContributions2.schemaAssociations)) {\r\n      const schemaAssociations = schemaContributions2.schemaAssociations;\r\n      for (let schemaAssociation of schemaAssociations) {\r\n        const uris = schemaAssociation.uris.map(normalizeId);\r\n        const association = this.addFilePatternAssociation(schemaAssociation.pattern, schemaAssociation.folderUri, uris);\r\n        this.contributionAssociations.push(association);\r\n      }\r\n    }\r\n  }\r\n  addSchemaHandle(id, unresolvedSchemaContent) {\r\n    const schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\r\n    this.schemasById[id] = schemaHandle;\r\n    return schemaHandle;\r\n  }\r\n  getOrAddSchemaHandle(id, unresolvedSchemaContent) {\r\n    return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\r\n  }\r\n  addFilePatternAssociation(pattern, folderUri, uris) {\r\n    const fpa = new FilePatternAssociation(pattern, folderUri, uris);\r\n    this.filePatternAssociations.push(fpa);\r\n    return fpa;\r\n  }\r\n  registerExternalSchema(config) {\r\n    const id = normalizeId(config.uri);\r\n    this.registeredSchemasIds[id] = true;\r\n    this.cachedSchemaForResource = void 0;\r\n    if (config.fileMatch && config.fileMatch.length) {\r\n      this.addFilePatternAssociation(config.fileMatch, config.folderUri, [id]);\r\n    }\r\n    return config.schema ? this.addSchemaHandle(id, config.schema) : this.getOrAddSchemaHandle(id);\r\n  }\r\n  clearExternalSchemas() {\r\n    this.schemasById = {};\r\n    this.filePatternAssociations = [];\r\n    this.registeredSchemasIds = {};\r\n    this.cachedSchemaForResource = void 0;\r\n    for (const id in this.contributionSchemas) {\r\n      this.schemasById[id] = this.contributionSchemas[id];\r\n      this.registeredSchemasIds[id] = true;\r\n    }\r\n    for (const contributionAssociation of this.contributionAssociations) {\r\n      this.filePatternAssociations.push(contributionAssociation);\r\n    }\r\n  }\r\n  getResolvedSchema(schemaId) {\r\n    const id = normalizeId(schemaId);\r\n    const schemaHandle = this.schemasById[id];\r\n    if (schemaHandle) {\r\n      return schemaHandle.getResolvedSchema();\r\n    }\r\n    return this.promise.resolve(void 0);\r\n  }\r\n  loadSchema(url) {\r\n    if (!this.requestService) {\r\n      const errorMessage = t(\"Unable to load schema from '{0}'. No schema request service available\", toDisplayString(url));\r\n      return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\r\n    }\r\n    if (url.startsWith(\"http://json-schema.org/\")) {\r\n      url = \"https\" + url.substring(4);\r\n    }\r\n    return this.requestService(url).then((content) => {\r\n      if (!content) {\r\n        const errorMessage = t(\"Unable to load schema from '{0}': No content.\", toDisplayString(url));\r\n        return new UnresolvedSchema({}, [errorMessage]);\r\n      }\r\n      const errors = [];\r\n      if (content.charCodeAt(0) === 65279) {\r\n        errors.push(t(\"Problem reading content from '{0}': UTF-8 with BOM detected, only UTF 8 is allowed.\", toDisplayString(url)));\r\n        content = content.trimStart();\r\n      }\r\n      let schemaContent = {};\r\n      const jsonErrors = [];\r\n      schemaContent = parse2(content, jsonErrors);\r\n      if (jsonErrors.length) {\r\n        errors.push(t(\"Unable to parse content from '{0}': Parse error at offset {1}.\", toDisplayString(url), jsonErrors[0].offset));\r\n      }\r\n      return new UnresolvedSchema(schemaContent, errors);\r\n    }, (error) => {\r\n      let errorMessage = error.toString();\r\n      const errorSplit = error.toString().split(\"Error: \");\r\n      if (errorSplit.length > 1) {\r\n        errorMessage = errorSplit[1];\r\n      }\r\n      if (endsWith(errorMessage, \".\")) {\r\n        errorMessage = errorMessage.substr(0, errorMessage.length - 1);\r\n      }\r\n      return new UnresolvedSchema({}, [t(\"Unable to load schema from '{0}': {1}.\", toDisplayString(url), errorMessage)]);\r\n    });\r\n  }\r\n  resolveSchemaContent(schemaToResolve, handle) {\r\n    const resolveErrors = schemaToResolve.errors.slice(0);\r\n    const schema = schemaToResolve.schema;\r\n    let schemaDraft = schema.$schema ? normalizeId(schema.$schema) : void 0;\r\n    if (schemaDraft === \"http://json-schema.org/draft-03/schema\") {\r\n      return this.promise.resolve(new ResolvedSchema({}, [t(\"Draft-03 schemas are not supported.\")], [], schemaDraft));\r\n    }\r\n    let usesUnsupportedFeatures = /* @__PURE__ */ new Set();\r\n    const contextService = this.contextService;\r\n    const findSectionByJSONPointer = (schema2, path) => {\r\n      path = decodeURIComponent(path);\r\n      let current = schema2;\r\n      if (path[0] === \"/\") {\r\n        path = path.substring(1);\r\n      }\r\n      path.split(\"/\").some((part) => {\r\n        part = part.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\r\n        current = current[part];\r\n        return !current;\r\n      });\r\n      return current;\r\n    };\r\n    const findSchemaById = (schema2, handle2, id) => {\r\n      if (!handle2.anchors) {\r\n        handle2.anchors = collectAnchors(schema2);\r\n      }\r\n      return handle2.anchors.get(id);\r\n    };\r\n    const merge = (target, section) => {\r\n      for (const key in section) {\r\n        if (section.hasOwnProperty(key) && key !== \"id\" && key !== \"$id\") {\r\n          target[key] = section[key];\r\n        }\r\n      }\r\n    };\r\n    const mergeRef = (target, sourceRoot, sourceHandle, refSegment) => {\r\n      let section;\r\n      if (refSegment === void 0 || refSegment.length === 0) {\r\n        section = sourceRoot;\r\n      } else if (refSegment.charAt(0) === \"/\") {\r\n        section = findSectionByJSONPointer(sourceRoot, refSegment);\r\n      } else {\r\n        section = findSchemaById(sourceRoot, sourceHandle, refSegment);\r\n      }\r\n      if (section) {\r\n        merge(target, section);\r\n      } else {\r\n        resolveErrors.push(t(\"$ref '{0}' in '{1}' can not be resolved.\", refSegment || \"\", sourceHandle.uri));\r\n      }\r\n    };\r\n    const resolveExternalLink = (node, uri, refSegment, parentHandle) => {\r\n      if (contextService && !/^[A-Za-z][A-Za-z0-9+\\-.+]*:\\/\\/.*/.test(uri)) {\r\n        uri = contextService.resolveRelativePath(uri, parentHandle.uri);\r\n      }\r\n      uri = normalizeId(uri);\r\n      const referencedHandle = this.getOrAddSchemaHandle(uri);\r\n      return referencedHandle.getUnresolvedSchema().then((unresolvedSchema) => {\r\n        parentHandle.dependencies.add(uri);\r\n        if (unresolvedSchema.errors.length) {\r\n          const loc = refSegment ? uri + \"#\" + refSegment : uri;\r\n          resolveErrors.push(t(\"Problems loading reference '{0}': {1}\", loc, unresolvedSchema.errors[0]));\r\n        }\r\n        mergeRef(node, unresolvedSchema.schema, referencedHandle, refSegment);\r\n        return resolveRefs(node, unresolvedSchema.schema, referencedHandle);\r\n      });\r\n    };\r\n    const resolveRefs = (node, parentSchema, parentHandle) => {\r\n      const openPromises = [];\r\n      this.traverseNodes(node, (next) => {\r\n        const seenRefs = /* @__PURE__ */ new Set();\r\n        while (next.$ref) {\r\n          const ref = next.$ref;\r\n          const segments = ref.split(\"#\", 2);\r\n          delete next.$ref;\r\n          if (segments[0].length > 0) {\r\n            openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentHandle));\r\n            return;\r\n          } else {\r\n            if (!seenRefs.has(ref)) {\r\n              const id = segments[1];\r\n              mergeRef(next, parentSchema, parentHandle, id);\r\n              seenRefs.add(ref);\r\n            }\r\n          }\r\n        }\r\n        if (next.$recursiveRef) {\r\n          usesUnsupportedFeatures.add(\"$recursiveRef\");\r\n        }\r\n        if (next.$dynamicRef) {\r\n          usesUnsupportedFeatures.add(\"$dynamicRef\");\r\n        }\r\n      });\r\n      return this.promise.all(openPromises);\r\n    };\r\n    const collectAnchors = (root) => {\r\n      const result = /* @__PURE__ */ new Map();\r\n      this.traverseNodes(root, (next) => {\r\n        const id = next.$id || next.id;\r\n        const anchor = isString(id) && id.charAt(0) === \"#\" ? id.substring(1) : next.$anchor;\r\n        if (anchor) {\r\n          if (result.has(anchor)) {\r\n            resolveErrors.push(t(\"Duplicate anchor declaration: '{0}'\", anchor));\r\n          } else {\r\n            result.set(anchor, next);\r\n          }\r\n        }\r\n        if (next.$recursiveAnchor) {\r\n          usesUnsupportedFeatures.add(\"$recursiveAnchor\");\r\n        }\r\n        if (next.$dynamicAnchor) {\r\n          usesUnsupportedFeatures.add(\"$dynamicAnchor\");\r\n        }\r\n      });\r\n      return result;\r\n    };\r\n    return resolveRefs(schema, schema, handle).then((_) => {\r\n      let resolveWarnings = [];\r\n      if (usesUnsupportedFeatures.size) {\r\n        resolveWarnings.push(t(\"The schema uses meta-schema features ({0}) that are not yet supported by the validator.\", Array.from(usesUnsupportedFeatures.keys()).join(\", \")));\r\n      }\r\n      return new ResolvedSchema(schema, resolveErrors, resolveWarnings, schemaDraft);\r\n    });\r\n  }\r\n  traverseNodes(root, handle) {\r\n    if (!root || typeof root !== \"object\") {\r\n      return Promise.resolve(null);\r\n    }\r\n    const seen = /* @__PURE__ */ new Set();\r\n    const collectEntries = (...entries) => {\r\n      for (const entry of entries) {\r\n        if (isObject(entry)) {\r\n          toWalk.push(entry);\r\n        }\r\n      }\r\n    };\r\n    const collectMapEntries = (...maps) => {\r\n      for (const map of maps) {\r\n        if (isObject(map)) {\r\n          for (const k in map) {\r\n            const key = k;\r\n            const entry = map[key];\r\n            if (isObject(entry)) {\r\n              toWalk.push(entry);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const collectArrayEntries = (...arrays) => {\r\n      for (const array of arrays) {\r\n        if (Array.isArray(array)) {\r\n          for (const entry of array) {\r\n            if (isObject(entry)) {\r\n              toWalk.push(entry);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const collectEntryOrArrayEntries = (items) => {\r\n      if (Array.isArray(items)) {\r\n        for (const entry of items) {\r\n          if (isObject(entry)) {\r\n            toWalk.push(entry);\r\n          }\r\n        }\r\n      } else if (isObject(items)) {\r\n        toWalk.push(items);\r\n      }\r\n    };\r\n    const toWalk = [root];\r\n    let next = toWalk.pop();\r\n    while (next) {\r\n      if (!seen.has(next)) {\r\n        seen.add(next);\r\n        handle(next);\r\n        collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);\r\n        collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);\r\n        collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);\r\n        collectEntryOrArrayEntries(next.items);\r\n      }\r\n      next = toWalk.pop();\r\n    }\r\n  }\r\n  getSchemaFromProperty(resource, document) {\r\n    if (document.root?.type === \"object\") {\r\n      for (const p of document.root.properties) {\r\n        if (p.keyNode.value === \"$schema\" && p.valueNode?.type === \"string\") {\r\n          let schemaId = p.valueNode.value;\r\n          if (this.contextService && !/^\\w[\\w\\d+.-]*:/.test(schemaId)) {\r\n            schemaId = this.contextService.resolveRelativePath(schemaId, resource);\r\n          }\r\n          return schemaId;\r\n        }\r\n      }\r\n    }\r\n    return void 0;\r\n  }\r\n  getAssociatedSchemas(resource) {\r\n    const seen = /* @__PURE__ */ Object.create(null);\r\n    const schemas = [];\r\n    const normalizedResource = normalizeResourceForMatching(resource);\r\n    for (const entry of this.filePatternAssociations) {\r\n      if (entry.matchesPattern(normalizedResource)) {\r\n        for (const schemaId of entry.getURIs()) {\r\n          if (!seen[schemaId]) {\r\n            schemas.push(schemaId);\r\n            seen[schemaId] = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return schemas;\r\n  }\r\n  getSchemaURIsForResource(resource, document) {\r\n    let schemeId = document && this.getSchemaFromProperty(resource, document);\r\n    if (schemeId) {\r\n      return [schemeId];\r\n    }\r\n    return this.getAssociatedSchemas(resource);\r\n  }\r\n  getSchemaForResource(resource, document) {\r\n    if (document) {\r\n      let schemeId = this.getSchemaFromProperty(resource, document);\r\n      if (schemeId) {\r\n        const id = normalizeId(schemeId);\r\n        return this.getOrAddSchemaHandle(id).getResolvedSchema();\r\n      }\r\n    }\r\n    if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {\r\n      return this.cachedSchemaForResource.resolvedSchema;\r\n    }\r\n    const schemas = this.getAssociatedSchemas(resource);\r\n    const resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(void 0);\r\n    this.cachedSchemaForResource = { resource, resolvedSchema };\r\n    return resolvedSchema;\r\n  }\r\n  createCombinedSchema(resource, schemaIds) {\r\n    if (schemaIds.length === 1) {\r\n      return this.getOrAddSchemaHandle(schemaIds[0]);\r\n    } else {\r\n      const combinedSchemaId = \"schemaservice://combinedSchema/\" + encodeURIComponent(resource);\r\n      const combinedSchema = {\r\n        allOf: schemaIds.map((schemaId) => ({ $ref: schemaId }))\r\n      };\r\n      return this.addSchemaHandle(combinedSchemaId, combinedSchema);\r\n    }\r\n  }\r\n  getMatchingSchemas(document, jsonDocument, schema) {\r\n    if (schema) {\r\n      const id = schema.id || \"schemaservice://untitled/matchingSchemas/\" + idCounter2++;\r\n      const handle = this.addSchemaHandle(id, schema);\r\n      return handle.getResolvedSchema().then((resolvedSchema) => {\r\n        return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter((s) => !s.inverted);\r\n      });\r\n    }\r\n    return this.getSchemaForResource(document.uri, jsonDocument).then((schema2) => {\r\n      if (schema2) {\r\n        return jsonDocument.getMatchingSchemas(schema2.schema).filter((s) => !s.inverted);\r\n      }\r\n      return [];\r\n    });\r\n  }\r\n};\r\nvar idCounter2 = 0;\r\nfunction normalizeId(id) {\r\n  try {\r\n    return URI2.parse(id).toString(true);\r\n  } catch (e) {\r\n    return id;\r\n  }\r\n}\r\nfunction normalizeResourceForMatching(resource) {\r\n  try {\r\n    return URI2.parse(resource).with({ fragment: null, query: null }).toString(true);\r\n  } catch (e) {\r\n    return resource;\r\n  }\r\n}\r\nfunction toDisplayString(url) {\r\n  try {\r\n    const uri = URI2.parse(url);\r\n    if (uri.scheme === \"file\") {\r\n      return uri.fsPath;\r\n    }\r\n  } catch (e) {\r\n  }\r\n  return url;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonFolding.js\r\nfunction getFoldingRanges(document, context) {\r\n  const ranges = [];\r\n  const nestingLevels = [];\r\n  const stack = [];\r\n  let prevStart = -1;\r\n  const scanner = createScanner2(document.getText(), false);\r\n  let token = scanner.scan();\r\n  function addRange(range) {\r\n    ranges.push(range);\r\n    nestingLevels.push(stack.length);\r\n  }\r\n  while (token !== 17) {\r\n    switch (token) {\r\n      case 1:\r\n      case 3: {\r\n        const startLine = document.positionAt(scanner.getTokenOffset()).line;\r\n        const range = { startLine, endLine: startLine, kind: token === 1 ? \"object\" : \"array\" };\r\n        stack.push(range);\r\n        break;\r\n      }\r\n      case 2:\r\n      case 4: {\r\n        const kind = token === 2 ? \"object\" : \"array\";\r\n        if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\r\n          const range = stack.pop();\r\n          const line = document.positionAt(scanner.getTokenOffset()).line;\r\n          if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\r\n            range.endLine = line - 1;\r\n            addRange(range);\r\n            prevStart = range.startLine;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 13: {\r\n        const startLine = document.positionAt(scanner.getTokenOffset()).line;\r\n        const endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\r\n        if (scanner.getTokenError() === 1 && startLine + 1 < document.lineCount) {\r\n          scanner.setPosition(document.offsetAt(Position.create(startLine + 1, 0)));\r\n        } else {\r\n          if (startLine < endLine) {\r\n            addRange({ startLine, endLine, kind: FoldingRangeKind.Comment });\r\n            prevStart = startLine;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 12: {\r\n        const text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\r\n        const m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\r\n        if (m) {\r\n          const line = document.positionAt(scanner.getTokenOffset()).line;\r\n          if (m[1]) {\r\n            const range = { startLine: line, endLine: line, kind: FoldingRangeKind.Region };\r\n            stack.push(range);\r\n          } else {\r\n            let i = stack.length - 1;\r\n            while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\r\n              i--;\r\n            }\r\n            if (i >= 0) {\r\n              const range = stack[i];\r\n              stack.length = i;\r\n              if (line > range.startLine && prevStart !== range.startLine) {\r\n                range.endLine = line;\r\n                addRange(range);\r\n                prevStart = range.startLine;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    token = scanner.scan();\r\n  }\r\n  const rangeLimit = context && context.rangeLimit;\r\n  if (typeof rangeLimit !== \"number\" || ranges.length <= rangeLimit) {\r\n    return ranges;\r\n  }\r\n  if (context && context.onRangeLimitExceeded) {\r\n    context.onRangeLimitExceeded(document.uri);\r\n  }\r\n  const counts = [];\r\n  for (let level of nestingLevels) {\r\n    if (level < 30) {\r\n      counts[level] = (counts[level] || 0) + 1;\r\n    }\r\n  }\r\n  let entries = 0;\r\n  let maxLevel = 0;\r\n  for (let i = 0; i < counts.length; i++) {\r\n    const n = counts[i];\r\n    if (n) {\r\n      if (n + entries > rangeLimit) {\r\n        maxLevel = i;\r\n        break;\r\n      }\r\n      entries += n;\r\n    }\r\n  }\r\n  const result = [];\r\n  for (let i = 0; i < ranges.length; i++) {\r\n    const level = nestingLevels[i];\r\n    if (typeof level === \"number\") {\r\n      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {\r\n        result.push(ranges[i]);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonSelectionRanges.js\r\nfunction getSelectionRanges(document, positions, doc) {\r\n  function getSelectionRange(position) {\r\n    let offset = document.offsetAt(position);\r\n    let node = doc.getNodeFromOffset(offset, true);\r\n    const result = [];\r\n    while (node) {\r\n      switch (node.type) {\r\n        case \"string\":\r\n        case \"object\":\r\n        case \"array\":\r\n          const cStart = node.offset + 1, cEnd = node.offset + node.length - 1;\r\n          if (cStart < cEnd && offset >= cStart && offset <= cEnd) {\r\n            result.push(newRange(cStart, cEnd));\r\n          }\r\n          result.push(newRange(node.offset, node.offset + node.length));\r\n          break;\r\n        case \"number\":\r\n        case \"boolean\":\r\n        case \"null\":\r\n        case \"property\":\r\n          result.push(newRange(node.offset, node.offset + node.length));\r\n          break;\r\n      }\r\n      if (node.type === \"property\" || node.parent && node.parent.type === \"array\") {\r\n        const afterCommaOffset = getOffsetAfterNextToken(\r\n          node.offset + node.length,\r\n          5\r\n          /* SyntaxKind.CommaToken */\r\n        );\r\n        if (afterCommaOffset !== -1) {\r\n          result.push(newRange(node.offset, afterCommaOffset));\r\n        }\r\n      }\r\n      node = node.parent;\r\n    }\r\n    let current = void 0;\r\n    for (let index = result.length - 1; index >= 0; index--) {\r\n      current = SelectionRange.create(result[index], current);\r\n    }\r\n    if (!current) {\r\n      current = SelectionRange.create(Range.create(position, position));\r\n    }\r\n    return current;\r\n  }\r\n  function newRange(start, end) {\r\n    return Range.create(document.positionAt(start), document.positionAt(end));\r\n  }\r\n  const scanner = createScanner2(document.getText(), true);\r\n  function getOffsetAfterNextToken(offset, expectedToken) {\r\n    scanner.setPosition(offset);\r\n    let token = scanner.scan();\r\n    if (token === expectedToken) {\r\n      return scanner.getTokenOffset() + scanner.getTokenLength();\r\n    }\r\n    return -1;\r\n  }\r\n  return positions.map(getSelectionRange);\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/format.js\r\nfunction format4(documentToFormat, formattingOptions, formattingRange) {\r\n  let range = void 0;\r\n  if (formattingRange) {\r\n    const offset = documentToFormat.offsetAt(formattingRange.start);\r\n    const length = documentToFormat.offsetAt(formattingRange.end) - offset;\r\n    range = { offset, length };\r\n  }\r\n  const options = {\r\n    tabSize: formattingOptions ? formattingOptions.tabSize : 4,\r\n    insertSpaces: formattingOptions?.insertSpaces === true,\r\n    insertFinalNewline: formattingOptions?.insertFinalNewline === true,\r\n    eol: \"\\n\",\r\n    keepLines: formattingOptions?.keepLines === true\r\n  };\r\n  return format2(documentToFormat.getText(), range, options).map((edit) => {\r\n    return TextEdit.replace(Range.create(documentToFormat.positionAt(edit.offset), documentToFormat.positionAt(edit.offset + edit.length)), edit.content);\r\n  });\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/propertyTree.js\r\nvar Container;\r\n(function(Container2) {\r\n  Container2[Container2[\"Object\"] = 0] = \"Object\";\r\n  Container2[Container2[\"Array\"] = 1] = \"Array\";\r\n})(Container || (Container = {}));\r\nvar PropertyTree = class {\r\n  constructor(propertyName, beginningLineNumber) {\r\n    this.propertyName = propertyName ?? \"\";\r\n    this.beginningLineNumber = beginningLineNumber;\r\n    this.childrenProperties = [];\r\n    this.lastProperty = false;\r\n    this.noKeyName = false;\r\n  }\r\n  addChildProperty(childProperty) {\r\n    childProperty.parent = this;\r\n    if (this.childrenProperties.length > 0) {\r\n      let insertionIndex = 0;\r\n      if (childProperty.noKeyName) {\r\n        insertionIndex = this.childrenProperties.length;\r\n      } else {\r\n        insertionIndex = binarySearchOnPropertyArray(this.childrenProperties, childProperty, compareProperties);\r\n      }\r\n      if (insertionIndex < 0) {\r\n        insertionIndex = insertionIndex * -1 - 1;\r\n      }\r\n      this.childrenProperties.splice(insertionIndex, 0, childProperty);\r\n    } else {\r\n      this.childrenProperties.push(childProperty);\r\n    }\r\n    return childProperty;\r\n  }\r\n};\r\nfunction compareProperties(propertyTree1, propertyTree2) {\r\n  const propertyName1 = propertyTree1.propertyName.toLowerCase();\r\n  const propertyName2 = propertyTree2.propertyName.toLowerCase();\r\n  if (propertyName1 < propertyName2) {\r\n    return -1;\r\n  } else if (propertyName1 > propertyName2) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\nfunction binarySearchOnPropertyArray(propertyTreeArray, propertyTree, compare_fn) {\r\n  const propertyName = propertyTree.propertyName.toLowerCase();\r\n  const firstPropertyInArrayName = propertyTreeArray[0].propertyName.toLowerCase();\r\n  const lastPropertyInArrayName = propertyTreeArray[propertyTreeArray.length - 1].propertyName.toLowerCase();\r\n  if (propertyName < firstPropertyInArrayName) {\r\n    return 0;\r\n  }\r\n  if (propertyName > lastPropertyInArrayName) {\r\n    return propertyTreeArray.length;\r\n  }\r\n  let m = 0;\r\n  let n = propertyTreeArray.length - 1;\r\n  while (m <= n) {\r\n    let k = n + m >> 1;\r\n    let cmp = compare_fn(propertyTree, propertyTreeArray[k]);\r\n    if (cmp > 0) {\r\n      m = k + 1;\r\n    } else if (cmp < 0) {\r\n      n = k - 1;\r\n    } else {\r\n      return k;\r\n    }\r\n  }\r\n  return -m - 1;\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/utils/sort.js\r\nfunction sort(documentToSort, formattingOptions) {\r\n  const options = {\r\n    ...formattingOptions,\r\n    keepLines: false\r\n    // keepLines must be false so that the properties are on separate lines for the sorting\r\n  };\r\n  const formattedJsonString = TextDocument2.applyEdits(documentToSort, format4(documentToSort, options, void 0));\r\n  const formattedJsonDocument = TextDocument2.create(\"test://test.json\", \"json\", 0, formattedJsonString);\r\n  const jsonPropertyTree = findJsoncPropertyTree(formattedJsonDocument);\r\n  const sortedJsonDocument = sortJsoncDocument(formattedJsonDocument, jsonPropertyTree);\r\n  const edits = format4(sortedJsonDocument, options, void 0);\r\n  const sortedAndFormattedJsonDocument = TextDocument2.applyEdits(sortedJsonDocument, edits);\r\n  return [TextEdit.replace(Range.create(Position.create(0, 0), documentToSort.positionAt(documentToSort.getText().length)), sortedAndFormattedJsonDocument)];\r\n}\r\nfunction findJsoncPropertyTree(formattedDocument) {\r\n  const formattedString = formattedDocument.getText();\r\n  const scanner = createScanner2(formattedString, false);\r\n  let rootTree = new PropertyTree();\r\n  let currentTree = rootTree;\r\n  let currentProperty = rootTree;\r\n  let lastProperty = rootTree;\r\n  let token = void 0;\r\n  let lastTokenLine = 0;\r\n  let numberOfCharactersOnPreviousLines = 0;\r\n  let lastNonTriviaNonCommentToken = void 0;\r\n  let secondToLastNonTriviaNonCommentToken = void 0;\r\n  let lineOfLastNonTriviaNonCommentToken = -1;\r\n  let endIndexOfLastNonTriviaNonCommentToken = -1;\r\n  let beginningLineNumber = 0;\r\n  let endLineNumber = 0;\r\n  let currentContainerStack = [];\r\n  let updateLastPropertyEndLineNumber = false;\r\n  let updateBeginningLineNumber = false;\r\n  while ((token = scanner.scan()) !== 17) {\r\n    if (updateLastPropertyEndLineNumber === true && token !== 14 && token !== 15 && token !== 12 && token !== 13 && currentProperty.endLineNumber === void 0) {\r\n      let endLineNumber2 = scanner.getTokenStartLine();\r\n      if (secondToLastNonTriviaNonCommentToken === 2 || secondToLastNonTriviaNonCommentToken === 4) {\r\n        lastProperty.endLineNumber = endLineNumber2 - 1;\r\n      } else {\r\n        currentProperty.endLineNumber = endLineNumber2 - 1;\r\n      }\r\n      beginningLineNumber = endLineNumber2;\r\n      updateLastPropertyEndLineNumber = false;\r\n    }\r\n    if (updateBeginningLineNumber === true && token !== 14 && token !== 15 && token !== 12 && token !== 13) {\r\n      beginningLineNumber = scanner.getTokenStartLine();\r\n      updateBeginningLineNumber = false;\r\n    }\r\n    if (scanner.getTokenStartLine() !== lastTokenLine) {\r\n      for (let i = lastTokenLine; i < scanner.getTokenStartLine(); i++) {\r\n        const lengthOfLine = formattedDocument.getText(Range.create(Position.create(i, 0), Position.create(i + 1, 0))).length;\r\n        numberOfCharactersOnPreviousLines = numberOfCharactersOnPreviousLines + lengthOfLine;\r\n      }\r\n      lastTokenLine = scanner.getTokenStartLine();\r\n    }\r\n    switch (token) {\r\n      case 10: {\r\n        if (lastNonTriviaNonCommentToken === void 0 || lastNonTriviaNonCommentToken === 1 || lastNonTriviaNonCommentToken === 5 && currentContainerStack[currentContainerStack.length - 1] === Container.Object) {\r\n          const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);\r\n          lastProperty = currentProperty;\r\n          currentProperty = currentTree.addChildProperty(childProperty);\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        if (rootTree.beginningLineNumber === void 0) {\r\n          rootTree.beginningLineNumber = scanner.getTokenStartLine();\r\n        }\r\n        if (currentContainerStack[currentContainerStack.length - 1] === Container.Object) {\r\n          currentTree = currentProperty;\r\n        } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {\r\n          const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);\r\n          childProperty.noKeyName = true;\r\n          lastProperty = currentProperty;\r\n          currentProperty = currentTree.addChildProperty(childProperty);\r\n          currentTree = currentProperty;\r\n        }\r\n        currentContainerStack.push(Container.Array);\r\n        currentProperty.type = Container.Array;\r\n        beginningLineNumber = scanner.getTokenStartLine();\r\n        beginningLineNumber++;\r\n        break;\r\n      }\r\n      case 1: {\r\n        if (rootTree.beginningLineNumber === void 0) {\r\n          rootTree.beginningLineNumber = scanner.getTokenStartLine();\r\n        } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {\r\n          const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);\r\n          childProperty.noKeyName = true;\r\n          lastProperty = currentProperty;\r\n          currentProperty = currentTree.addChildProperty(childProperty);\r\n        }\r\n        currentProperty.type = Container.Object;\r\n        currentContainerStack.push(Container.Object);\r\n        currentTree = currentProperty;\r\n        beginningLineNumber = scanner.getTokenStartLine();\r\n        beginningLineNumber++;\r\n        break;\r\n      }\r\n      case 4: {\r\n        endLineNumber = scanner.getTokenStartLine();\r\n        currentContainerStack.pop();\r\n        if (currentProperty.endLineNumber === void 0 && (lastNonTriviaNonCommentToken === 2 || lastNonTriviaNonCommentToken === 4)) {\r\n          currentProperty.endLineNumber = endLineNumber - 1;\r\n          currentProperty.lastProperty = true;\r\n          currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;\r\n          currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;\r\n          lastProperty = currentProperty;\r\n          currentProperty = currentProperty ? currentProperty.parent : void 0;\r\n          currentTree = currentProperty;\r\n        }\r\n        rootTree.endLineNumber = endLineNumber;\r\n        beginningLineNumber = endLineNumber + 1;\r\n        break;\r\n      }\r\n      case 2: {\r\n        endLineNumber = scanner.getTokenStartLine();\r\n        currentContainerStack.pop();\r\n        if (lastNonTriviaNonCommentToken !== 1) {\r\n          if (currentProperty.endLineNumber === void 0) {\r\n            currentProperty.endLineNumber = endLineNumber - 1;\r\n            currentProperty.lastProperty = true;\r\n            currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;\r\n            currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;\r\n          }\r\n          lastProperty = currentProperty;\r\n          currentProperty = currentProperty ? currentProperty.parent : void 0;\r\n          currentTree = currentProperty;\r\n        }\r\n        rootTree.endLineNumber = scanner.getTokenStartLine();\r\n        beginningLineNumber = endLineNumber + 1;\r\n        break;\r\n      }\r\n      case 5: {\r\n        endLineNumber = scanner.getTokenStartLine();\r\n        if (currentProperty.endLineNumber === void 0 && (currentContainerStack[currentContainerStack.length - 1] === Container.Object || currentContainerStack[currentContainerStack.length - 1] === Container.Array && (lastNonTriviaNonCommentToken === 2 || lastNonTriviaNonCommentToken === 4))) {\r\n          currentProperty.endLineNumber = endLineNumber;\r\n          currentProperty.commaIndex = scanner.getTokenOffset() - numberOfCharactersOnPreviousLines;\r\n          currentProperty.commaLine = endLineNumber;\r\n        }\r\n        if (lastNonTriviaNonCommentToken === 2 || lastNonTriviaNonCommentToken === 4) {\r\n          lastProperty = currentProperty;\r\n          currentProperty = currentProperty ? currentProperty.parent : void 0;\r\n          currentTree = currentProperty;\r\n        }\r\n        beginningLineNumber = endLineNumber + 1;\r\n        break;\r\n      }\r\n      case 13: {\r\n        if (lastNonTriviaNonCommentToken === 5 && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine() && (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 || secondToLastNonTriviaNonCommentToken === 4) || currentContainerStack[currentContainerStack.length - 1] === Container.Object)) {\r\n          if (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 || secondToLastNonTriviaNonCommentToken === 4) || currentContainerStack[currentContainerStack.length - 1] === Container.Object) {\r\n            currentProperty.endLineNumber = void 0;\r\n            updateLastPropertyEndLineNumber = true;\r\n          }\r\n        }\r\n        if ((lastNonTriviaNonCommentToken === 1 || lastNonTriviaNonCommentToken === 3) && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine()) {\r\n          updateBeginningLineNumber = true;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (token !== 14 && token !== 13 && token !== 12 && token !== 15) {\r\n      secondToLastNonTriviaNonCommentToken = lastNonTriviaNonCommentToken;\r\n      lastNonTriviaNonCommentToken = token;\r\n      lineOfLastNonTriviaNonCommentToken = scanner.getTokenStartLine();\r\n      endIndexOfLastNonTriviaNonCommentToken = scanner.getTokenOffset() + scanner.getTokenLength() - numberOfCharactersOnPreviousLines;\r\n    }\r\n  }\r\n  return rootTree;\r\n}\r\nfunction sortJsoncDocument(jsonDocument, propertyTree) {\r\n  if (propertyTree.childrenProperties.length === 0) {\r\n    return jsonDocument;\r\n  }\r\n  const sortedJsonDocument = TextDocument2.create(\"test://test.json\", \"json\", 0, jsonDocument.getText());\r\n  const queueToSort = [];\r\n  updateSortingQueue(queueToSort, propertyTree, propertyTree.beginningLineNumber);\r\n  while (queueToSort.length > 0) {\r\n    const dataToSort = queueToSort.shift();\r\n    const propertyTreeArray = dataToSort.propertyTreeArray;\r\n    let beginningLineNumber = dataToSort.beginningLineNumber;\r\n    for (let i = 0; i < propertyTreeArray.length; i++) {\r\n      const propertyTree2 = propertyTreeArray[i];\r\n      const range = Range.create(Position.create(propertyTree2.beginningLineNumber, 0), Position.create(propertyTree2.endLineNumber + 1, 0));\r\n      const jsonContentToReplace = jsonDocument.getText(range);\r\n      const jsonDocumentToReplace = TextDocument2.create(\"test://test.json\", \"json\", 0, jsonContentToReplace);\r\n      if (propertyTree2.lastProperty === true && i !== propertyTreeArray.length - 1) {\r\n        const lineWhereToAddComma = propertyTree2.lineWhereToAddComma - propertyTree2.beginningLineNumber;\r\n        const indexWhereToAddComma = propertyTree2.indexWhereToAddComa;\r\n        const edit2 = {\r\n          range: Range.create(Position.create(lineWhereToAddComma, indexWhereToAddComma), Position.create(lineWhereToAddComma, indexWhereToAddComma)),\r\n          text: \",\"\r\n        };\r\n        TextDocument2.update(jsonDocumentToReplace, [edit2], 1);\r\n      } else if (propertyTree2.lastProperty === false && i === propertyTreeArray.length - 1) {\r\n        const commaIndex = propertyTree2.commaIndex;\r\n        const commaLine = propertyTree2.commaLine;\r\n        const lineWhereToRemoveComma = commaLine - propertyTree2.beginningLineNumber;\r\n        const edit2 = {\r\n          range: Range.create(Position.create(lineWhereToRemoveComma, commaIndex), Position.create(lineWhereToRemoveComma, commaIndex + 1)),\r\n          text: \"\"\r\n        };\r\n        TextDocument2.update(jsonDocumentToReplace, [edit2], 1);\r\n      }\r\n      const length = propertyTree2.endLineNumber - propertyTree2.beginningLineNumber + 1;\r\n      const edit = {\r\n        range: Range.create(Position.create(beginningLineNumber, 0), Position.create(beginningLineNumber + length, 0)),\r\n        text: jsonDocumentToReplace.getText()\r\n      };\r\n      TextDocument2.update(sortedJsonDocument, [edit], 1);\r\n      updateSortingQueue(queueToSort, propertyTree2, beginningLineNumber);\r\n      beginningLineNumber = beginningLineNumber + length;\r\n    }\r\n  }\r\n  return sortedJsonDocument;\r\n}\r\nfunction updateSortingQueue(queue, propertyTree, beginningLineNumber) {\r\n  if (propertyTree.childrenProperties.length === 0) {\r\n    return;\r\n  }\r\n  if (propertyTree.type === Container.Object) {\r\n    let minimumBeginningLineNumber = Infinity;\r\n    for (const childProperty of propertyTree.childrenProperties) {\r\n      if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {\r\n        minimumBeginningLineNumber = childProperty.beginningLineNumber;\r\n      }\r\n    }\r\n    const diff = minimumBeginningLineNumber - propertyTree.beginningLineNumber;\r\n    beginningLineNumber = beginningLineNumber + diff;\r\n    queue.push(new SortingRange(beginningLineNumber, propertyTree.childrenProperties));\r\n  } else if (propertyTree.type === Container.Array) {\r\n    updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber);\r\n  }\r\n}\r\nfunction updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber) {\r\n  for (const subObject of propertyTree.childrenProperties) {\r\n    if (subObject.type === Container.Object) {\r\n      let minimumBeginningLineNumber = Infinity;\r\n      for (const childProperty of subObject.childrenProperties) {\r\n        if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {\r\n          minimumBeginningLineNumber = childProperty.beginningLineNumber;\r\n        }\r\n      }\r\n      const diff = minimumBeginningLineNumber - subObject.beginningLineNumber;\r\n      queue.push(new SortingRange(beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber + diff, subObject.childrenProperties));\r\n    }\r\n    if (subObject.type === Container.Array) {\r\n      updateSortingQueueForArrayProperties(queue, subObject, beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber);\r\n    }\r\n  }\r\n}\r\nvar SortingRange = class {\r\n  constructor(beginningLineNumber, propertyTreeArray) {\r\n    this.beginningLineNumber = beginningLineNumber;\r\n    this.propertyTreeArray = propertyTreeArray;\r\n  }\r\n};\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/services/jsonLinks.js\r\nfunction findLinks(document, doc) {\r\n  const links = [];\r\n  doc.visit((node) => {\r\n    if (node.type === \"property\" && node.keyNode.value === \"$ref\" && node.valueNode?.type === \"string\") {\r\n      const path = node.valueNode.value;\r\n      const targetNode = findTargetNode(doc, path);\r\n      if (targetNode) {\r\n        const targetPos = document.positionAt(targetNode.offset);\r\n        links.push({\r\n          target: `${document.uri}#${targetPos.line + 1},${targetPos.character + 1}`,\r\n          range: createRange(document, node.valueNode)\r\n        });\r\n      }\r\n    }\r\n    return true;\r\n  });\r\n  return Promise.resolve(links);\r\n}\r\nfunction createRange(document, node) {\r\n  return Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + node.length - 1));\r\n}\r\nfunction findTargetNode(doc, path) {\r\n  const tokens = parseJSONPointer(path);\r\n  if (!tokens) {\r\n    return null;\r\n  }\r\n  return findNode(tokens, doc.root);\r\n}\r\nfunction findNode(pointer, node) {\r\n  if (!node) {\r\n    return null;\r\n  }\r\n  if (pointer.length === 0) {\r\n    return node;\r\n  }\r\n  const token = pointer.shift();\r\n  if (node && node.type === \"object\") {\r\n    const propertyNode = node.properties.find((propertyNode2) => propertyNode2.keyNode.value === token);\r\n    if (!propertyNode) {\r\n      return null;\r\n    }\r\n    return findNode(pointer, propertyNode.valueNode);\r\n  } else if (node && node.type === \"array\") {\r\n    if (token.match(/^(0|[1-9][0-9]*)$/)) {\r\n      const index = Number.parseInt(token);\r\n      const arrayItem = node.items[index];\r\n      if (!arrayItem) {\r\n        return null;\r\n      }\r\n      return findNode(pointer, arrayItem);\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction parseJSONPointer(path) {\r\n  if (path === \"#\") {\r\n    return [];\r\n  }\r\n  if (path[0] !== \"#\" || path[1] !== \"/\") {\r\n    return null;\r\n  }\r\n  return path.substring(2).split(/\\//).map(unescape);\r\n}\r\nfunction unescape(str) {\r\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\r\n}\r\n\r\n// node_modules/vscode-json-languageservice/lib/esm/jsonLanguageService.js\r\nfunction getLanguageService(params) {\r\n  const promise = params.promiseConstructor || Promise;\r\n  const jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);\r\n  jsonSchemaService.setSchemaContributions(schemaContributions);\r\n  const jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);\r\n  const jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);\r\n  const jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);\r\n  const jsonValidation = new JSONValidation(jsonSchemaService, promise);\r\n  return {\r\n    configure: (settings) => {\r\n      jsonSchemaService.clearExternalSchemas();\r\n      settings.schemas?.forEach(jsonSchemaService.registerExternalSchema.bind(jsonSchemaService));\r\n      jsonValidation.configure(settings);\r\n    },\r\n    resetSchema: (uri) => jsonSchemaService.onResourceChange(uri),\r\n    doValidation: jsonValidation.doValidation.bind(jsonValidation),\r\n    getLanguageStatus: jsonValidation.getLanguageStatus.bind(jsonValidation),\r\n    parseJSONDocument: (document) => parse3(document, { collectComments: true }),\r\n    newJSONDocument: (root, diagnostics) => newJSONDocument(root, diagnostics),\r\n    getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),\r\n    doResolve: jsonCompletion.doResolve.bind(jsonCompletion),\r\n    doComplete: jsonCompletion.doComplete.bind(jsonCompletion),\r\n    findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),\r\n    findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),\r\n    findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),\r\n    getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),\r\n    doHover: jsonHover.doHover.bind(jsonHover),\r\n    getFoldingRanges,\r\n    getSelectionRanges,\r\n    findDefinition: () => Promise.resolve([]),\r\n    findLinks,\r\n    format: (document, range, options) => format4(document, options, range),\r\n    sort: (document, options) => sort(document, options)\r\n  };\r\n}\r\n\r\n// src/language/json/jsonWorker.ts\r\nvar defaultSchemaRequestService;\r\nif (typeof fetch !== \"undefined\") {\r\n  defaultSchemaRequestService = function(url) {\r\n    return fetch(url).then((response) => response.text());\r\n  };\r\n}\r\nvar JSONWorker = class {\r\n  constructor(ctx, createData) {\r\n    this._ctx = ctx;\r\n    this._languageSettings = createData.languageSettings;\r\n    this._languageId = createData.languageId;\r\n    this._languageService = getLanguageService({\r\n      workspaceContext: {\r\n        resolveRelativePath: (relativePath, resource) => {\r\n          const base = resource.substr(0, resource.lastIndexOf(\"/\") + 1);\r\n          return resolvePath(base, relativePath);\r\n        }\r\n      },\r\n      schemaRequestService: createData.enableSchemaRequest ? defaultSchemaRequestService : void 0,\r\n      clientCapabilities: ClientCapabilities.LATEST\r\n    });\r\n    this._languageService.configure(this._languageSettings);\r\n  }\r\n  async doValidation(uri) {\r\n    let document = this._getTextDocument(uri);\r\n    if (document) {\r\n      let jsonDocument = this._languageService.parseJSONDocument(document);\r\n      return this._languageService.doValidation(document, jsonDocument, this._languageSettings);\r\n    }\r\n    return Promise.resolve([]);\r\n  }\r\n  async doComplete(uri, position) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return null;\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    return this._languageService.doComplete(document, position, jsonDocument);\r\n  }\r\n  async doResolve(item) {\r\n    return this._languageService.doResolve(item);\r\n  }\r\n  async doHover(uri, position) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return null;\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    return this._languageService.doHover(document, position, jsonDocument);\r\n  }\r\n  async format(uri, range, options) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let textEdits = this._languageService.format(document, range, options);\r\n    return Promise.resolve(textEdits);\r\n  }\r\n  async resetSchema(uri) {\r\n    return Promise.resolve(this._languageService.resetSchema(uri));\r\n  }\r\n  async findDocumentSymbols(uri) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    let symbols = this._languageService.findDocumentSymbols2(document, jsonDocument);\r\n    return Promise.resolve(symbols);\r\n  }\r\n  async findDocumentColors(uri) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    let colorSymbols = this._languageService.findDocumentColors(document, jsonDocument);\r\n    return Promise.resolve(colorSymbols);\r\n  }\r\n  async getColorPresentations(uri, color, range) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    let colorPresentations = this._languageService.getColorPresentations(\r\n      document,\r\n      jsonDocument,\r\n      color,\r\n      range\r\n    );\r\n    return Promise.resolve(colorPresentations);\r\n  }\r\n  async getFoldingRanges(uri, context) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let ranges = this._languageService.getFoldingRanges(document, context);\r\n    return Promise.resolve(ranges);\r\n  }\r\n  async getSelectionRanges(uri, positions) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    let ranges = this._languageService.getSelectionRanges(document, positions, jsonDocument);\r\n    return Promise.resolve(ranges);\r\n  }\r\n  async parseJSONDocument(uri) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return null;\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    return Promise.resolve(jsonDocument);\r\n  }\r\n  async getMatchingSchemas(uri) {\r\n    let document = this._getTextDocument(uri);\r\n    if (!document) {\r\n      return [];\r\n    }\r\n    let jsonDocument = this._languageService.parseJSONDocument(document);\r\n    return Promise.resolve(this._languageService.getMatchingSchemas(document, jsonDocument));\r\n  }\r\n  _getTextDocument(uri) {\r\n    let models = this._ctx.getMirrorModels();\r\n    for (let model of models) {\r\n      if (model.uri.toString() === uri) {\r\n        return TextDocument2.create(\r\n          uri,\r\n          this._languageId,\r\n          model.version,\r\n          model.getValue()\r\n        );\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n};\r\nvar Slash = \"/\".charCodeAt(0);\r\nvar Dot = \".\".charCodeAt(0);\r\nfunction isAbsolutePath(path) {\r\n  return path.charCodeAt(0) === Slash;\r\n}\r\nfunction resolvePath(uriString, path) {\r\n  if (isAbsolutePath(path)) {\r\n    const uri = URI2.parse(uriString);\r\n    const parts = path.split(\"/\");\r\n    return uri.with({ path: normalizePath(parts) }).toString();\r\n  }\r\n  return joinPath(uriString, path);\r\n}\r\nfunction normalizePath(parts) {\r\n  const newParts = [];\r\n  for (const part of parts) {\r\n    if (part.length === 0 || part.length === 1 && part.charCodeAt(0) === Dot) {\r\n    } else if (part.length === 2 && part.charCodeAt(0) === Dot && part.charCodeAt(1) === Dot) {\r\n      newParts.pop();\r\n    } else {\r\n      newParts.push(part);\r\n    }\r\n  }\r\n  if (parts.length > 1 && parts[parts.length - 1].length === 0) {\r\n    newParts.push(\"\");\r\n  }\r\n  let res = newParts.join(\"/\");\r\n  if (parts[0].length === 0) {\r\n    res = \"/\" + res;\r\n  }\r\n  return res;\r\n}\r\nfunction joinPath(uriString, ...paths) {\r\n  const uri = URI2.parse(uriString);\r\n  const parts = uri.path.split(\"/\");\r\n  for (let path of paths) {\r\n    parts.push(...path.split(\"/\"));\r\n  }\r\n  return uri.with({ path: normalizePath(parts) }).toString();\r\n}\r\n\r\n// src/language/json/json.worker.ts\r\nself.onmessage = () => {\r\n  _editor_editor_worker_js__WEBPACK_IMPORTED_MODULE_0__.initialize((ctx, createData) => {\r\n    return new JSONWorker(ctx, createData);\r\n  });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9qc29uLndvcmtlci5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBcUU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2YsTUFBTTtBQUNOLG9FQUFvRSxJQUFJLElBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0VBQW9FO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBFQUEwRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBGQUEwRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUIsSUFBSTtBQUN4RDtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCLGVBQWUsSUFBSSx3QkFBd0I7QUFDbkc7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0RUFBNEU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUMsd0RBQXdEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsU0FBUztBQUNuRztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsZUFBZSxFQUFFLE9BQU87QUFDeEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0VBQStFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBHQUEwRyxJQUFJLGNBQWMsRUFBRSxFQUFFLElBQUksS0FBSztBQUMxSixpQkFBaUIsc0VBQXNFLEVBQUUsbUpBQW1KO0FBQzVPLFlBQVksaUVBQWlFLEVBQUUsK0NBQStDO0FBQzlILFlBQVkscUtBQXFLO0FBQ2pMLGFBQWEsaUZBQWlGLHlCQUF5Qiw2QkFBNkIsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSwrQkFBK0IsR0FBRyxNQUFNO0FBQ3BPLGdCQUFnQiw4REFBOEQsTUFBTSwwQkFBMEIsS0FBSyxvQ0FBb0MsS0FBSyxvQkFBb0I7QUFDaEwsWUFBWSx3R0FBd0csRUFBRSx1Q0FBdUM7QUFDN0osWUFBWSwwRUFBMEUsSUFBSSxHQUFHLEVBQUUsVUFBVSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUkseUVBQXlFLEVBQUUsaUJBQWlCLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksMkVBQTJFLEVBQUUsaUJBQWlCLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksY0FBYyxJQUFJLDJFQUEyRSxFQUFFLGtCQUFrQixJQUFJLEdBQUcsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGNBQWMsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUUsa0JBQWtCLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksY0FBYyxJQUFJLEVBQUUsSUFBSSx5RUFBeUUsRUFBRSxrQkFBa0IsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLEVBQUUsSUFBSSxjQUFjLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHNCQUFzQixJQUFJLEVBQUUsSUFBSSxjQUFjLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFO0FBQ2hqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLCtCQUErQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRSw4RUFBOEUsRUFBRTtBQUNoRixTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEUsd0VBQXdFLEVBQUU7QUFDMUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQTBDO0FBQ2hFO0FBQ0EsbUZBQW1GLEVBQUU7QUFDckYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEU7QUFDQSw0REFBNEQsRUFBRTtBQUM5RCxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFzRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRSxpREFBaUQsRUFBRTtBQUNuRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEUsNkRBQTZELEVBQUU7QUFDL0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRSw2REFBNkQsRUFBRTtBQUMvRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQTRDO0FBQ2hFLG1EQUFtRCxFQUFFO0FBQ3JELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEUsbURBQW1ELEVBQUU7QUFDckQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQTRDO0FBQ2hFLGtFQUFrRSxFQUFFO0FBQ3BFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQTRDO0FBQ2hFLGlFQUFpRSxFQUFFO0FBQ25FLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRSxrSEFBa0gsRUFBRTtBQUNwSCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDO0FBQ3hFLHVHQUF1RyxFQUFFO0FBQ3pHLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQTRDO0FBQ3BFLGdGQUFnRixHQUFHO0FBQ25GLFdBQVc7QUFDWDtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFLGtIQUFrSCxHQUFHO0FBQ3JILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFLG1IQUFtSCxHQUFHO0FBQ3RILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEUsdURBQXVELEdBQUc7QUFDMUQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEUsd0RBQXdELEdBQUc7QUFDM0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaURBQWlELElBQUk7QUFDNUY7QUFDQTtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBFQUEwRTtBQUN0Ryw2REFBNkQsR0FBRztBQUNoRSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwRUFBMEU7QUFDNUcsbUVBQW1FLEdBQUc7QUFDdEUscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwRUFBMEU7QUFDcEcsMkRBQTJELEdBQUc7QUFDOUQsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEVBQTBFO0FBQ3RHLDZEQUE2RCxHQUFHO0FBQ2hFLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRSxnRUFBZ0UsRUFBRTtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBNEM7QUFDbEUsK0VBQStFLEVBQUU7QUFDakYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBNEM7QUFDdEUsc0RBQXNELEdBQUcsc0JBQXNCLEVBQUU7QUFDakYsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVEsS0FBSztBQUMzQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixlQUFlLEdBQUc7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixHQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQixNQUFNLDZCQUE2QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdFQUF3RTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFHQUFxRztBQUNqSSw2QkFBNkIsb0RBQW9EO0FBQ2pGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwrQkFBK0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQixFQUFFLHdCQUF3QixFQUFFLHVCQUF1QjtBQUMzRixNQUFNO0FBQ04sa0JBQWtCLHNCQUFzQixFQUFFLHdCQUF3QixFQUFFLHVCQUF1QixFQUFFLDZDQUE2QztBQUMxSTtBQUNBLGtCQUFrQixpRUFBaUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYyw0Q0FBNEM7QUFDMUQsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULHVCQUF1Qiw0Q0FBNEM7QUFDbkUsdUJBQXVCLG9EQUFvRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsNENBQTRDO0FBQ2xFLHNCQUFzQixvREFBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQixhQUFhO0FBQ25DLDJCQUEyQiw0Q0FBNEM7QUFDdkUsMkJBQTJCLG9EQUFvRDtBQUMvRSxzQkFBc0IscUNBQXFDO0FBQzNELGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pELDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9CQUFvQixrQkFBa0I7QUFDdEMsOEJBQThCLGtCQUFrQjtBQUNoRCw2QkFBNkIsa0JBQWtCO0FBQy9DLGdCQUFnQixhQUFhO0FBQzdCLGtCQUFrQixhQUFhO0FBQy9CLGtCQUFrQixhQUFhO0FBQy9CLG1CQUFtQixxQ0FBcUM7QUFDeEQsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hELGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEU7QUFDQSxnREFBZ0QsMENBQTBDO0FBQzFGO0FBQ0Esd0VBQXdFLFFBQVE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJGQUEyRixRQUFRO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEVBQTRFLFFBQVE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFVBQVU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsK0JBQStCO0FBQ3BHLEdBQUc7QUFDSCwwR0FBMEcsaUJBQWlCLDZDQUE2QyxhQUFhO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBCQUEwQixhQUFhLFlBQVksUUFBUSxhQUFhLFNBQVMsZ0JBQWdCLFlBQVksRUFBRTtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsYUFBYSxFQUFFLFFBQVE7QUFDM0c7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUErRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QixHQUFHLGFBQWE7QUFDekYsVUFBVTtBQUNWO0FBQ0EsMkNBQTJDLDZCQUE2QixHQUFHLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsVUFBVTtBQUNqRyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFVBQVU7QUFDNUYsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLGFBQWE7QUFDbEIsR0FBRztBQUNILENBQUM7QUFDRCxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUdBQXlHLHlHQUF5RztBQUNsTjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQ0FBZ0M7QUFDekY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9ELHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxzREFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsRUFBRSwwQkFBMEIsRUFBRTtBQUNwRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DLEVBQUUsSUFBSSxFQUFFO0FBQy9FLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUNBQXFDLEVBQUUsT0FBTyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFLElBQUksRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxFQUFFO0FBQ3BFLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1QkFBdUIsb0RBQW9EO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCO0FBQ25GO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdFQUFpQjtBQUNuQjtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL2pzb24ud29ya2VyLmpzP2YxOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFZlcnNpb246IDAuNTAuMChjMzIxZDBmYmVjYjUwYWI4YTUzNjVmYTE5NjU0NzZiMGFlNjNmYzg3KVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9tb25hY28tZWRpdG9yL2Jsb2IvbWFpbi9MSUNFTlNFLnR4dFxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblxyXG4vLyBzcmMvbGFuZ3VhZ2UvanNvbi9qc29uLndvcmtlci50c1xyXG5pbXBvcnQgKiBhcyB3b3JrZXIgZnJvbSBcIi4uLy4uL2VkaXRvci9lZGl0b3Iud29ya2VyLmpzXCI7XHJcblxyXG4vLyBub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9zY2FubmVyLmpzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNjYW5uZXIodGV4dCwgaWdub3JlVHJpdmlhID0gZmFsc2UpIHtcclxuICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcclxuICBsZXQgcG9zID0gMCwgdmFsdWUgPSBcIlwiLCB0b2tlbk9mZnNldCA9IDAsIHRva2VuID0gMTYsIGxpbmVOdW1iZXIgPSAwLCBsaW5lU3RhcnRPZmZzZXQgPSAwLCB0b2tlbkxpbmVTdGFydE9mZnNldCA9IDAsIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldCA9IDAsIHNjYW5FcnJvciA9IDA7XHJcbiAgZnVuY3Rpb24gc2NhbkhleERpZ2l0cyhjb3VudCwgZXhhY3QpIHtcclxuICAgIGxldCBkaWdpdHMgPSAwO1xyXG4gICAgbGV0IHZhbHVlMiA9IDA7XHJcbiAgICB3aGlsZSAoZGlnaXRzIDwgY291bnQgfHwgIWV4YWN0KSB7XHJcbiAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTcpIHtcclxuICAgICAgICB2YWx1ZTIgPSB2YWx1ZTIgKiAxNiArIGNoIC0gNDg7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2ggPj0gNjUgJiYgY2ggPD0gNzApIHtcclxuICAgICAgICB2YWx1ZTIgPSB2YWx1ZTIgKiAxNiArIGNoIC0gNjUgKyAxMDtcclxuICAgICAgfSBlbHNlIGlmIChjaCA+PSA5NyAmJiBjaCA8PSAxMDIpIHtcclxuICAgICAgICB2YWx1ZTIgPSB2YWx1ZTIgKiAxNiArIGNoIC0gOTcgKyAxMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBwb3MrKztcclxuICAgICAgZGlnaXRzKys7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlnaXRzIDwgY291bnQpIHtcclxuICAgICAgdmFsdWUyID0gLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUyO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzZXRQb3NpdGlvbihuZXdQb3NpdGlvbikge1xyXG4gICAgcG9zID0gbmV3UG9zaXRpb247XHJcbiAgICB2YWx1ZSA9IFwiXCI7XHJcbiAgICB0b2tlbk9mZnNldCA9IDA7XHJcbiAgICB0b2tlbiA9IDE2O1xyXG4gICAgc2NhbkVycm9yID0gMDtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2Nhbk51bWJlcigpIHtcclxuICAgIGxldCBzdGFydCA9IHBvcztcclxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDgpIHtcclxuICAgICAgcG9zKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwb3MrKztcclxuICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDYpIHtcclxuICAgICAgcG9zKys7XHJcbiAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xyXG4gICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjYW5FcnJvciA9IDM7XHJcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgZW5kID0gcG9zO1xyXG4gICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmICh0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNjkgfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwMSkpIHtcclxuICAgICAgcG9zKys7XHJcbiAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDMgfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1KSB7XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XHJcbiAgICAgICAgICBwb3MrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kID0gcG9zO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjYW5FcnJvciA9IDM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2NhblN0cmluZygpIHtcclxuICAgIGxldCByZXN1bHQgPSBcIlwiLCBzdGFydCA9IHBvcztcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGlmIChwb3MgPj0gbGVuKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xyXG4gICAgICAgIHNjYW5FcnJvciA9IDI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcclxuICAgICAgaWYgKGNoID09PSAzNCkge1xyXG4gICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcclxuICAgICAgICBwb3MrKztcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2ggPT09IDkyKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XHJcbiAgICAgICAgICBzY2FuRXJyb3IgPSAyO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoMiA9IHRleHQuY2hhckNvZGVBdChwb3MrKyk7XHJcbiAgICAgICAgc3dpdGNoIChjaDIpIHtcclxuICAgICAgICAgIGNhc2UgMzQ6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXCInO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgOTI6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcXFxcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDQ3OlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIvXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA5ODpcclxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxiXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxMDI6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcZlwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMTEwOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDExNDpcclxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxyXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxMTY6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlx0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxMTc6XHJcbiAgICAgICAgICAgIGNvbnN0IGNoMyA9IHNjYW5IZXhEaWdpdHMoNCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjaDMgPj0gMCkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoMyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc2NhbkVycm9yID0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHNjYW5FcnJvciA9IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0ID0gcG9zO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaCA+PSAwICYmIGNoIDw9IDMxKSB7XHJcbiAgICAgICAgaWYgKGlzTGluZUJyZWFrKGNoKSkge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xyXG4gICAgICAgICAgc2NhbkVycm9yID0gMjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzY2FuRXJyb3IgPSA2O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwb3MrKztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xyXG4gICAgdmFsdWUgPSBcIlwiO1xyXG4gICAgc2NhbkVycm9yID0gMDtcclxuICAgIHRva2VuT2Zmc2V0ID0gcG9zO1xyXG4gICAgbGluZVN0YXJ0T2Zmc2V0ID0gbGluZU51bWJlcjtcclxuICAgIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldCA9IHRva2VuTGluZVN0YXJ0T2Zmc2V0O1xyXG4gICAgaWYgKHBvcyA+PSBsZW4pIHtcclxuICAgICAgdG9rZW5PZmZzZXQgPSBsZW47XHJcbiAgICAgIHJldHVybiB0b2tlbiA9IDE3O1xyXG4gICAgfVxyXG4gICAgbGV0IGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcclxuICAgIGlmIChpc1doaXRlU3BhY2UoY29kZSkpIHtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICB9IHdoaWxlIChpc1doaXRlU3BhY2UoY29kZSkpO1xyXG4gICAgICByZXR1cm4gdG9rZW4gPSAxNTtcclxuICAgIH1cclxuICAgIGlmIChpc0xpbmVCcmVhayhjb2RlKSkge1xyXG4gICAgICBwb3MrKztcclxuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuICAgICAgaWYgKGNvZGUgPT09IDEzICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIHZhbHVlICs9IFwiXFxuXCI7XHJcbiAgICAgIH1cclxuICAgICAgbGluZU51bWJlcisrO1xyXG4gICAgICB0b2tlbkxpbmVTdGFydE9mZnNldCA9IHBvcztcclxuICAgICAgcmV0dXJuIHRva2VuID0gMTQ7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgY2FzZSAxMjM6XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuID0gMTtcclxuICAgICAgY2FzZSAxMjU6XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuID0gMjtcclxuICAgICAgY2FzZSA5MTpcclxuICAgICAgICBwb3MrKztcclxuICAgICAgICByZXR1cm4gdG9rZW4gPSAzO1xyXG4gICAgICBjYXNlIDkzOlxyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIHJldHVybiB0b2tlbiA9IDQ7XHJcbiAgICAgIGNhc2UgNTg6XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuID0gNjtcclxuICAgICAgY2FzZSA0NDpcclxuICAgICAgICBwb3MrKztcclxuICAgICAgICByZXR1cm4gdG9rZW4gPSA1O1xyXG4gICAgICBjYXNlIDM0OlxyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIHZhbHVlID0gc2NhblN0cmluZygpO1xyXG4gICAgICAgIHJldHVybiB0b2tlbiA9IDEwO1xyXG4gICAgICBjYXNlIDQ3OlxyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcG9zIC0gMTtcclxuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0Nykge1xyXG4gICAgICAgICAgcG9zICs9IDI7XHJcbiAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3MrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhbHVlID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XHJcbiAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDIpIHtcclxuICAgICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgICAgY29uc3Qgc2FmZUxlbmd0aCA9IGxlbiAtIDE7XHJcbiAgICAgICAgICBsZXQgY29tbWVudENsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgd2hpbGUgKHBvcyA8IHNhZmVMZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcclxuICAgICAgICAgICAgaWYgKGNoID09PSA0MiAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3KSB7XHJcbiAgICAgICAgICAgICAgcG9zICs9IDI7XHJcbiAgICAgICAgICAgICAgY29tbWVudENsb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayhjaCkpIHtcclxuICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXIrKztcclxuICAgICAgICAgICAgICB0b2tlbkxpbmVTdGFydE9mZnNldCA9IHBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb21tZW50Q2xvc2VkKSB7XHJcbiAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgICBzY2FuRXJyb3IgPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcclxuICAgICAgICAgIHJldHVybiB0b2tlbiA9IDEzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG4gICAgICAgIHBvcysrO1xyXG4gICAgICAgIHJldHVybiB0b2tlbiA9IDE2O1xyXG4gICAgICBjYXNlIDQ1OlxyXG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgaWYgKHBvcyA9PT0gbGVuIHx8ICFpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRva2VuID0gMTY7XHJcbiAgICAgICAgfVxyXG4gICAgICBjYXNlIDQ4OlxyXG4gICAgICBjYXNlIDQ5OlxyXG4gICAgICBjYXNlIDUwOlxyXG4gICAgICBjYXNlIDUxOlxyXG4gICAgICBjYXNlIDUyOlxyXG4gICAgICBjYXNlIDUzOlxyXG4gICAgICBjYXNlIDU0OlxyXG4gICAgICBjYXNlIDU1OlxyXG4gICAgICBjYXNlIDU2OlxyXG4gICAgICBjYXNlIDU3OlxyXG4gICAgICAgIHZhbHVlICs9IHNjYW5OdW1iZXIoKTtcclxuICAgICAgICByZXR1cm4gdG9rZW4gPSAxMTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB3aGlsZSAocG9zIDwgbGVuICYmIGlzVW5rbm93bkNvbnRlbnRDaGFyYWN0ZXIoY29kZSkpIHtcclxuICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5PZmZzZXQgIT09IHBvcykge1xyXG4gICAgICAgICAgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZyh0b2tlbk9mZnNldCwgcG9zKTtcclxuICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInRydWVcIjpcclxuICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSA4O1xyXG4gICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjpcclxuICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSA5O1xyXG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuICAgICAgICBwb3MrKztcclxuICAgICAgICByZXR1cm4gdG9rZW4gPSAxNjtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gaXNVbmtub3duQ29udGVudENoYXJhY3Rlcihjb2RlKSB7XHJcbiAgICBpZiAoaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGlzTGluZUJyZWFrKGNvZGUpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICBjYXNlIDEyNTpcclxuICAgICAgY2FzZSA5MzpcclxuICAgICAgY2FzZSAxMjM6XHJcbiAgICAgIGNhc2UgOTE6XHJcbiAgICAgIGNhc2UgMzQ6XHJcbiAgICAgIGNhc2UgNTg6XHJcbiAgICAgIGNhc2UgNDQ6XHJcbiAgICAgIGNhc2UgNDc6XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNjYW5OZXh0Tm9uVHJpdmlhKCkge1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGRvIHtcclxuICAgICAgcmVzdWx0ID0gc2Nhbk5leHQoKTtcclxuICAgIH0gd2hpbGUgKHJlc3VsdCA+PSAxMiAmJiByZXN1bHQgPD0gMTUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHNldFBvc2l0aW9uLFxyXG4gICAgZ2V0UG9zaXRpb246ICgpID0+IHBvcyxcclxuICAgIHNjYW46IGlnbm9yZVRyaXZpYSA/IHNjYW5OZXh0Tm9uVHJpdmlhIDogc2Nhbk5leHQsXHJcbiAgICBnZXRUb2tlbjogKCkgPT4gdG9rZW4sXHJcbiAgICBnZXRUb2tlblZhbHVlOiAoKSA9PiB2YWx1ZSxcclxuICAgIGdldFRva2VuT2Zmc2V0OiAoKSA9PiB0b2tlbk9mZnNldCxcclxuICAgIGdldFRva2VuTGVuZ3RoOiAoKSA9PiBwb3MgLSB0b2tlbk9mZnNldCxcclxuICAgIGdldFRva2VuU3RhcnRMaW5lOiAoKSA9PiBsaW5lU3RhcnRPZmZzZXQsXHJcbiAgICBnZXRUb2tlblN0YXJ0Q2hhcmFjdGVyOiAoKSA9PiB0b2tlbk9mZnNldCAtIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldCxcclxuICAgIGdldFRva2VuRXJyb3I6ICgpID0+IHNjYW5FcnJvclxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XHJcbiAgcmV0dXJuIGNoID09PSAzMiB8fCBjaCA9PT0gOTtcclxufVxyXG5mdW5jdGlvbiBpc0xpbmVCcmVhayhjaCkge1xyXG4gIHJldHVybiBjaCA9PT0gMTAgfHwgY2ggPT09IDEzO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHtcclxuICByZXR1cm4gY2ggPj0gNDggJiYgY2ggPD0gNTc7XHJcbn1cclxudmFyIENoYXJhY3RlckNvZGVzO1xyXG4oZnVuY3Rpb24oQ2hhcmFjdGVyQ29kZXMyKSB7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImxpbmVGZWVkXCJdID0gMTBdID0gXCJsaW5lRmVlZFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJjYXJyaWFnZVJldHVyblwiXSA9IDEzXSA9IFwiY2FycmlhZ2VSZXR1cm5cIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wic3BhY2VcIl0gPSAzMl0gPSBcInNwYWNlXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIl8wXCJdID0gNDhdID0gXCJfMFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJfMVwiXSA9IDQ5XSA9IFwiXzFcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiXzJcIl0gPSA1MF0gPSBcIl8yXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIl8zXCJdID0gNTFdID0gXCJfM1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJfNFwiXSA9IDUyXSA9IFwiXzRcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiXzVcIl0gPSA1M10gPSBcIl81XCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIl82XCJdID0gNTRdID0gXCJfNlwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJfN1wiXSA9IDU1XSA9IFwiXzdcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiXzhcIl0gPSA1Nl0gPSBcIl84XCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIl85XCJdID0gNTddID0gXCJfOVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJhXCJdID0gOTddID0gXCJhXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImJcIl0gPSA5OF0gPSBcImJcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiY1wiXSA9IDk5XSA9IFwiY1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJkXCJdID0gMTAwXSA9IFwiZFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJlXCJdID0gMTAxXSA9IFwiZVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJmXCJdID0gMTAyXSA9IFwiZlwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJnXCJdID0gMTAzXSA9IFwiZ1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJoXCJdID0gMTA0XSA9IFwiaFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJpXCJdID0gMTA1XSA9IFwiaVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJqXCJdID0gMTA2XSA9IFwialwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJrXCJdID0gMTA3XSA9IFwia1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJsXCJdID0gMTA4XSA9IFwibFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJtXCJdID0gMTA5XSA9IFwibVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJuXCJdID0gMTEwXSA9IFwiblwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJvXCJdID0gMTExXSA9IFwib1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJwXCJdID0gMTEyXSA9IFwicFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJxXCJdID0gMTEzXSA9IFwicVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJyXCJdID0gMTE0XSA9IFwiclwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJzXCJdID0gMTE1XSA9IFwic1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ0XCJdID0gMTE2XSA9IFwidFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ1XCJdID0gMTE3XSA9IFwidVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ2XCJdID0gMTE4XSA9IFwidlwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ3XCJdID0gMTE5XSA9IFwid1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ4XCJdID0gMTIwXSA9IFwieFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ5XCJdID0gMTIxXSA9IFwieVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ6XCJdID0gMTIyXSA9IFwielwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJBXCJdID0gNjVdID0gXCJBXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIkJcIl0gPSA2Nl0gPSBcIkJcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJEXCJdID0gNjhdID0gXCJEXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIkVcIl0gPSA2OV0gPSBcIkVcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJHXCJdID0gNzFdID0gXCJHXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIkhcIl0gPSA3Ml0gPSBcIkhcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJKXCJdID0gNzRdID0gXCJKXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIktcIl0gPSA3NV0gPSBcIktcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJNXCJdID0gNzddID0gXCJNXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIk5cIl0gPSA3OF0gPSBcIk5cIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJQXCJdID0gODBdID0gXCJQXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIlFcIl0gPSA4MV0gPSBcIlFcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJTXCJdID0gODNdID0gXCJTXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIlRcIl0gPSA4NF0gPSBcIlRcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJWXCJdID0gODZdID0gXCJWXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIldcIl0gPSA4N10gPSBcIldcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJZXCJdID0gODldID0gXCJZXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIlpcIl0gPSA5MF0gPSBcIlpcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiYXN0ZXJpc2tcIl0gPSA0Ml0gPSBcImFzdGVyaXNrXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImJhY2tzbGFzaFwiXSA9IDkyXSA9IFwiYmFja3NsYXNoXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImNsb3NlQnJhY2VcIl0gPSAxMjVdID0gXCJjbG9zZUJyYWNlXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImNsb3NlQnJhY2tldFwiXSA9IDkzXSA9IFwiY2xvc2VCcmFja2V0XCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImNvbG9uXCJdID0gNThdID0gXCJjb2xvblwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJjb21tYVwiXSA9IDQ0XSA9IFwiY29tbWFcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiZG90XCJdID0gNDZdID0gXCJkb3RcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wiZG91YmxlUXVvdGVcIl0gPSAzNF0gPSBcImRvdWJsZVF1b3RlXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcIm1pbnVzXCJdID0gNDVdID0gXCJtaW51c1wiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJvcGVuQnJhY2VcIl0gPSAxMjNdID0gXCJvcGVuQnJhY2VcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wib3BlbkJyYWNrZXRcIl0gPSA5MV0gPSBcIm9wZW5CcmFja2V0XCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcInBsdXNcIl0gPSA0M10gPSBcInBsdXNcIjtcclxuICBDaGFyYWN0ZXJDb2RlczJbQ2hhcmFjdGVyQ29kZXMyW1wic2xhc2hcIl0gPSA0N10gPSBcInNsYXNoXCI7XHJcbiAgQ2hhcmFjdGVyQ29kZXMyW0NoYXJhY3RlckNvZGVzMltcImZvcm1GZWVkXCJdID0gMTJdID0gXCJmb3JtRmVlZFwiO1xyXG4gIENoYXJhY3RlckNvZGVzMltDaGFyYWN0ZXJDb2RlczJbXCJ0YWJcIl0gPSA5XSA9IFwidGFiXCI7XHJcbn0pKENoYXJhY3RlckNvZGVzIHx8IChDaGFyYWN0ZXJDb2RlcyA9IHt9KSk7XHJcblxyXG4vLyBub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9zdHJpbmctaW50ZXJuLmpzXHJcbnZhciBjYWNoZWRTcGFjZXMgPSBuZXcgQXJyYXkoMjApLmZpbGwoMCkubWFwKChfLCBpbmRleCkgPT4ge1xyXG4gIHJldHVybiBcIiBcIi5yZXBlYXQoaW5kZXgpO1xyXG59KTtcclxudmFyIG1heENhY2hlZFZhbHVlcyA9IDIwMDtcclxudmFyIGNhY2hlZEJyZWFrTGluZXNXaXRoU3BhY2VzID0ge1xyXG4gIFwiIFwiOiB7XHJcbiAgICBcIlxcblwiOiBuZXcgQXJyYXkobWF4Q2FjaGVkVmFsdWVzKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBcIiBcIi5yZXBlYXQoaW5kZXgpO1xyXG4gICAgfSksXHJcbiAgICBcIlxcclwiOiBuZXcgQXJyYXkobWF4Q2FjaGVkVmFsdWVzKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIFwiXFxyXCIgKyBcIiBcIi5yZXBlYXQoaW5kZXgpO1xyXG4gICAgfSksXHJcbiAgICBcIlxcclxcblwiOiBuZXcgQXJyYXkobWF4Q2FjaGVkVmFsdWVzKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIFwiXFxyXFxuXCIgKyBcIiBcIi5yZXBlYXQoaW5kZXgpO1xyXG4gICAgfSlcclxuICB9LFxyXG4gIFwiXHRcIjoge1xyXG4gICAgXCJcXG5cIjogbmV3IEFycmF5KG1heENhY2hlZFZhbHVlcykuZmlsbCgwKS5tYXAoKF8sIGluZGV4KSA9PiB7XHJcbiAgICAgIHJldHVybiBcIlxcblwiICsgXCJcdFwiLnJlcGVhdChpbmRleCk7XHJcbiAgICB9KSxcclxuICAgIFwiXFxyXCI6IG5ldyBBcnJheShtYXhDYWNoZWRWYWx1ZXMpLmZpbGwoMCkubWFwKChfLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gXCJcXHJcIiArIFwiXHRcIi5yZXBlYXQoaW5kZXgpO1xyXG4gICAgfSksXHJcbiAgICBcIlxcclxcblwiOiBuZXcgQXJyYXkobWF4Q2FjaGVkVmFsdWVzKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIFwiXFxyXFxuXCIgKyBcIlx0XCIucmVwZWF0KGluZGV4KTtcclxuICAgIH0pXHJcbiAgfVxyXG59O1xyXG52YXIgc3VwcG9ydGVkRW9scyA9IFtcIlxcblwiLCBcIlxcclwiLCBcIlxcclxcblwiXTtcclxuXHJcbi8vIG5vZGVfbW9kdWxlcy9qc29uYy1wYXJzZXIvbGliL2VzbS9pbXBsL2Zvcm1hdC5qc1xyXG5mdW5jdGlvbiBmb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucykge1xyXG4gIGxldCBpbml0aWFsSW5kZW50TGV2ZWw7XHJcbiAgbGV0IGZvcm1hdFRleHQ7XHJcbiAgbGV0IGZvcm1hdFRleHRTdGFydDtcclxuICBsZXQgcmFuZ2VTdGFydDtcclxuICBsZXQgcmFuZ2VFbmQ7XHJcbiAgaWYgKHJhbmdlKSB7XHJcbiAgICByYW5nZVN0YXJ0ID0gcmFuZ2Uub2Zmc2V0O1xyXG4gICAgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgcmFuZ2UubGVuZ3RoO1xyXG4gICAgZm9ybWF0VGV4dFN0YXJ0ID0gcmFuZ2VTdGFydDtcclxuICAgIHdoaWxlIChmb3JtYXRUZXh0U3RhcnQgPiAwICYmICFpc0VPTChkb2N1bWVudFRleHQsIGZvcm1hdFRleHRTdGFydCAtIDEpKSB7XHJcbiAgICAgIGZvcm1hdFRleHRTdGFydC0tO1xyXG4gICAgfVxyXG4gICAgbGV0IGVuZE9mZnNldCA9IHJhbmdlRW5kO1xyXG4gICAgd2hpbGUgKGVuZE9mZnNldCA8IGRvY3VtZW50VGV4dC5sZW5ndGggJiYgIWlzRU9MKGRvY3VtZW50VGV4dCwgZW5kT2Zmc2V0KSkge1xyXG4gICAgICBlbmRPZmZzZXQrKztcclxuICAgIH1cclxuICAgIGZvcm1hdFRleHQgPSBkb2N1bWVudFRleHQuc3Vic3RyaW5nKGZvcm1hdFRleHRTdGFydCwgZW5kT2Zmc2V0KTtcclxuICAgIGluaXRpYWxJbmRlbnRMZXZlbCA9IGNvbXB1dGVJbmRlbnRMZXZlbChmb3JtYXRUZXh0LCBvcHRpb25zKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm9ybWF0VGV4dCA9IGRvY3VtZW50VGV4dDtcclxuICAgIGluaXRpYWxJbmRlbnRMZXZlbCA9IDA7XHJcbiAgICBmb3JtYXRUZXh0U3RhcnQgPSAwO1xyXG4gICAgcmFuZ2VTdGFydCA9IDA7XHJcbiAgICByYW5nZUVuZCA9IGRvY3VtZW50VGV4dC5sZW5ndGg7XHJcbiAgfVxyXG4gIGNvbnN0IGVvbCA9IGdldEVPTChvcHRpb25zLCBkb2N1bWVudFRleHQpO1xyXG4gIGNvbnN0IGVvbEZhc3RQYXRoU3VwcG9ydGVkID0gc3VwcG9ydGVkRW9scy5pbmNsdWRlcyhlb2wpO1xyXG4gIGxldCBudW1iZXJMaW5lQnJlYWtzID0gMDtcclxuICBsZXQgaW5kZW50TGV2ZWwgPSAwO1xyXG4gIGxldCBpbmRlbnRWYWx1ZTtcclxuICBpZiAob3B0aW9ucy5pbnNlcnRTcGFjZXMpIHtcclxuICAgIGluZGVudFZhbHVlID0gY2FjaGVkU3BhY2VzW29wdGlvbnMudGFiU2l6ZSB8fCA0XSA/PyByZXBlYXQoY2FjaGVkU3BhY2VzWzFdLCBvcHRpb25zLnRhYlNpemUgfHwgNCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGluZGVudFZhbHVlID0gXCJcdFwiO1xyXG4gIH1cclxuICBjb25zdCBpbmRlbnRUeXBlID0gaW5kZW50VmFsdWUgPT09IFwiXHRcIiA/IFwiXHRcIiA6IFwiIFwiO1xyXG4gIGxldCBzY2FubmVyID0gY3JlYXRlU2Nhbm5lcihmb3JtYXRUZXh0LCBmYWxzZSk7XHJcbiAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XHJcbiAgZnVuY3Rpb24gbmV3TGluZXNBbmRJbmRlbnQoKSB7XHJcbiAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDEpIHtcclxuICAgICAgcmV0dXJuIHJlcGVhdChlb2wsIG51bWJlckxpbmVCcmVha3MpICsgcmVwZWF0KGluZGVudFZhbHVlLCBpbml0aWFsSW5kZW50TGV2ZWwgKyBpbmRlbnRMZXZlbCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhbW91bnRPZlNwYWNlcyA9IGluZGVudFZhbHVlLmxlbmd0aCAqIChpbml0aWFsSW5kZW50TGV2ZWwgKyBpbmRlbnRMZXZlbCk7XHJcbiAgICBpZiAoIWVvbEZhc3RQYXRoU3VwcG9ydGVkIHx8IGFtb3VudE9mU3BhY2VzID4gY2FjaGVkQnJlYWtMaW5lc1dpdGhTcGFjZXNbaW5kZW50VHlwZV1bZW9sXS5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGVvbCArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFtb3VudE9mU3BhY2VzIDw9IDApIHtcclxuICAgICAgcmV0dXJuIGVvbDtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWNoZWRCcmVha0xpbmVzV2l0aFNwYWNlc1tpbmRlbnRUeXBlXVtlb2xdW2Ftb3VudE9mU3BhY2VzXTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XHJcbiAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcclxuICAgIG51bWJlckxpbmVCcmVha3MgPSAwO1xyXG4gICAgd2hpbGUgKHRva2VuID09PSAxNSB8fCB0b2tlbiA9PT0gMTQpIHtcclxuICAgICAgaWYgKHRva2VuID09PSAxNCAmJiBvcHRpb25zLmtlZXBMaW5lcykge1xyXG4gICAgICAgIG51bWJlckxpbmVCcmVha3MgKz0gMTtcclxuICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gMTQpIHtcclxuICAgICAgICBudW1iZXJMaW5lQnJlYWtzID0gMTtcclxuICAgICAgfVxyXG4gICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xyXG4gICAgfVxyXG4gICAgaGFzRXJyb3IgPSB0b2tlbiA9PT0gMTYgfHwgc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkgIT09IDA7XHJcbiAgICByZXR1cm4gdG9rZW47XHJcbiAgfVxyXG4gIGNvbnN0IGVkaXRPcGVyYXRpb25zID0gW107XHJcbiAgZnVuY3Rpb24gYWRkRWRpdCh0ZXh0LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XHJcbiAgICBpZiAoIWhhc0Vycm9yICYmICghcmFuZ2UgfHwgc3RhcnRPZmZzZXQgPCByYW5nZUVuZCAmJiBlbmRPZmZzZXQgPiByYW5nZVN0YXJ0KSAmJiBkb2N1bWVudFRleHQuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpICE9PSB0ZXh0KSB7XHJcbiAgICAgIGVkaXRPcGVyYXRpb25zLnB1c2goeyBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBsZW5ndGg6IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCBjb250ZW50OiB0ZXh0IH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgZmlyc3RUb2tlbiA9IHNjYW5OZXh0KCk7XHJcbiAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwKSB7XHJcbiAgICBhZGRFZGl0KHJlcGVhdChlb2wsIG51bWJlckxpbmVCcmVha3MpLCAwLCAwKTtcclxuICB9XHJcbiAgaWYgKGZpcnN0VG9rZW4gIT09IDE3KSB7XHJcbiAgICBsZXQgZmlyc3RUb2tlblN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xyXG4gICAgbGV0IGluaXRpYWxJbmRlbnQgPSBpbmRlbnRWYWx1ZS5sZW5ndGggKiBpbml0aWFsSW5kZW50TGV2ZWwgPCAyMCAmJiBvcHRpb25zLmluc2VydFNwYWNlcyA/IGNhY2hlZFNwYWNlc1tpbmRlbnRWYWx1ZS5sZW5ndGggKiBpbml0aWFsSW5kZW50TGV2ZWxdIDogcmVwZWF0KGluZGVudFZhbHVlLCBpbml0aWFsSW5kZW50TGV2ZWwpO1xyXG4gICAgYWRkRWRpdChpbml0aWFsSW5kZW50LCBmb3JtYXRUZXh0U3RhcnQsIGZpcnN0VG9rZW5TdGFydCk7XHJcbiAgfVxyXG4gIHdoaWxlIChmaXJzdFRva2VuICE9PSAxNykge1xyXG4gICAgbGV0IGZpcnN0VG9rZW5FbmQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgKyBmb3JtYXRUZXh0U3RhcnQ7XHJcbiAgICBsZXQgc2Vjb25kVG9rZW4gPSBzY2FuTmV4dCgpO1xyXG4gICAgbGV0IHJlcGxhY2VDb250ZW50ID0gXCJcIjtcclxuICAgIGxldCBuZWVkc0xpbmVCcmVhayA9IGZhbHNlO1xyXG4gICAgd2hpbGUgKG51bWJlckxpbmVCcmVha3MgPT09IDAgJiYgKHNlY29uZFRva2VuID09PSAxMiB8fCBzZWNvbmRUb2tlbiA9PT0gMTMpKSB7XHJcbiAgICAgIGxldCBjb21tZW50VG9rZW5TdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIGZvcm1hdFRleHRTdGFydDtcclxuICAgICAgYWRkRWRpdChjYWNoZWRTcGFjZXNbMV0sIGZpcnN0VG9rZW5FbmQsIGNvbW1lbnRUb2tlblN0YXJ0KTtcclxuICAgICAgZmlyc3RUb2tlbkVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSArIGZvcm1hdFRleHRTdGFydDtcclxuICAgICAgbmVlZHNMaW5lQnJlYWsgPSBzZWNvbmRUb2tlbiA9PT0gMTI7XHJcbiAgICAgIHJlcGxhY2VDb250ZW50ID0gbmVlZHNMaW5lQnJlYWsgPyBuZXdMaW5lc0FuZEluZGVudCgpIDogXCJcIjtcclxuICAgICAgc2Vjb25kVG9rZW4gPSBzY2FuTmV4dCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlY29uZFRva2VuID09PSAyKSB7XHJcbiAgICAgIGlmIChmaXJzdFRva2VuICE9PSAxKSB7XHJcbiAgICAgICAgaW5kZW50TGV2ZWwtLTtcclxuICAgICAgfVxyXG4gICAgICA7XHJcbiAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMgJiYgZmlyc3RUb2tlbiAhPT0gMSkge1xyXG4gICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcclxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmtlZXBMaW5lcykge1xyXG4gICAgICAgIHJlcGxhY2VDb250ZW50ID0gY2FjaGVkU3BhY2VzWzFdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHNlY29uZFRva2VuID09PSA0KSB7XHJcbiAgICAgIGlmIChmaXJzdFRva2VuICE9PSAzKSB7XHJcbiAgICAgICAgaW5kZW50TGV2ZWwtLTtcclxuICAgICAgfVxyXG4gICAgICA7XHJcbiAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMgJiYgZmlyc3RUb2tlbiAhPT0gMykge1xyXG4gICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcclxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmtlZXBMaW5lcykge1xyXG4gICAgICAgIHJlcGxhY2VDb250ZW50ID0gY2FjaGVkU3BhY2VzWzFdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzd2l0Y2ggKGZpcnN0VG9rZW4pIHtcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgaW5kZW50TGV2ZWwrKztcclxuICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMpIHtcclxuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBjYWNoZWRTcGFjZXNbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDAgfHwgIW9wdGlvbnMua2VlcExpbmVzKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gY2FjaGVkU3BhY2VzWzFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMjpcclxuICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDApIHtcclxuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghbmVlZHNMaW5lQnJlYWspIHtcclxuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBjYWNoZWRTcGFjZXNbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcclxuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghbmVlZHNMaW5lQnJlYWspIHtcclxuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBjYWNoZWRTcGFjZXNbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kVG9rZW4gPT09IDYgJiYgIW5lZWRzTGluZUJyZWFrKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gXCJcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xyXG4gICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHNlY29uZFRva2VuID09PSAxMiB8fCBzZWNvbmRUb2tlbiA9PT0gMTMpICYmICFuZWVkc0xpbmVCcmVhaykge1xyXG4gICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gY2FjaGVkU3BhY2VzWzFdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlY29uZFRva2VuICE9PSA1ICYmIHNlY29uZFRva2VuICE9PSAxNykge1xyXG4gICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNjpcclxuICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChudW1iZXJMaW5lQnJlYWtzID4gMCAmJiAoc2Vjb25kVG9rZW4gPT09IDEyIHx8IHNlY29uZFRva2VuID09PSAxMykpIHtcclxuICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzZWNvbmRUb2tlbiA9PT0gMTcpIHtcclxuICAgICAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwKSB7XHJcbiAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlcGxhY2VDb250ZW50ID0gb3B0aW9ucy5pbnNlcnRGaW5hbE5ld2xpbmUgPyBlb2wgOiBcIlwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZWNvbmRUb2tlblN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xyXG4gICAgYWRkRWRpdChyZXBsYWNlQ29udGVudCwgZmlyc3RUb2tlbkVuZCwgc2Vjb25kVG9rZW5TdGFydCk7XHJcbiAgICBmaXJzdFRva2VuID0gc2Vjb25kVG9rZW47XHJcbiAgfVxyXG4gIHJldHVybiBlZGl0T3BlcmF0aW9ucztcclxufVxyXG5mdW5jdGlvbiByZXBlYXQocywgY291bnQpIHtcclxuICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgIHJlc3VsdCArPSBzO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVJbmRlbnRMZXZlbChjb250ZW50LCBvcHRpb25zKSB7XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGxldCBuQ2hhcnMgPSAwO1xyXG4gIGNvbnN0IHRhYlNpemUgPSBvcHRpb25zLnRhYlNpemUgfHwgNDtcclxuICB3aGlsZSAoaSA8IGNvbnRlbnQubGVuZ3RoKSB7XHJcbiAgICBsZXQgY2ggPSBjb250ZW50LmNoYXJBdChpKTtcclxuICAgIGlmIChjaCA9PT0gY2FjaGVkU3BhY2VzWzFdKSB7XHJcbiAgICAgIG5DaGFycysrO1xyXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcdFwiKSB7XHJcbiAgICAgIG5DaGFycyArPSB0YWJTaXplO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpKys7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLmZsb29yKG5DaGFycyAvIHRhYlNpemUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVPTChvcHRpb25zLCB0ZXh0KSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjaCA9IHRleHQuY2hhckF0KGkpO1xyXG4gICAgaWYgKGNoID09PSBcIlxcclwiKSB7XHJcbiAgICAgIGlmIChpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCJcXG5cIikge1xyXG4gICAgICAgIHJldHVybiBcIlxcclxcblwiO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBcIlxcclwiO1xyXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXG5cIikge1xyXG4gICAgICByZXR1cm4gXCJcXG5cIjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5lb2wgfHwgXCJcXG5cIjtcclxufVxyXG5mdW5jdGlvbiBpc0VPTCh0ZXh0LCBvZmZzZXQpIHtcclxuICByZXR1cm4gXCJcXHJcXG5cIi5pbmRleE9mKHRleHQuY2hhckF0KG9mZnNldCkpICE9PSAtMTtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL2ltcGwvcGFyc2VyLmpzXHJcbnZhciBQYXJzZU9wdGlvbnM7XHJcbihmdW5jdGlvbihQYXJzZU9wdGlvbnMyKSB7XHJcbiAgUGFyc2VPcHRpb25zMi5ERUZBVUxUID0ge1xyXG4gICAgYWxsb3dUcmFpbGluZ0NvbW1hOiBmYWxzZVxyXG4gIH07XHJcbn0pKFBhcnNlT3B0aW9ucyB8fCAoUGFyc2VPcHRpb25zID0ge30pKTtcclxuZnVuY3Rpb24gcGFyc2UodGV4dCwgZXJyb3JzID0gW10sIG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVCkge1xyXG4gIGxldCBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xyXG4gIGxldCBjdXJyZW50UGFyZW50ID0gW107XHJcbiAgY29uc3QgcHJldmlvdXNQYXJlbnRzID0gW107XHJcbiAgZnVuY3Rpb24gb25WYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFBhcmVudCkpIHtcclxuICAgICAgY3VycmVudFBhcmVudC5wdXNoKHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudFByb3BlcnR5ICE9PSBudWxsKSB7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnRbY3VycmVudFByb3BlcnR5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCB2aXNpdG9yID0ge1xyXG4gICAgb25PYmplY3RCZWdpbjogKCkgPT4ge1xyXG4gICAgICBjb25zdCBvYmplY3QgPSB7fTtcclxuICAgICAgb25WYWx1ZShvYmplY3QpO1xyXG4gICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcclxuICAgICAgY3VycmVudFBhcmVudCA9IG9iamVjdDtcclxuICAgICAgY3VycmVudFByb3BlcnR5ID0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBvbk9iamVjdFByb3BlcnR5OiAobmFtZSkgPT4ge1xyXG4gICAgICBjdXJyZW50UHJvcGVydHkgPSBuYW1lO1xyXG4gICAgfSxcclxuICAgIG9uT2JqZWN0RW5kOiAoKSA9PiB7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2aW91c1BhcmVudHMucG9wKCk7XHJcbiAgICB9LFxyXG4gICAgb25BcnJheUJlZ2luOiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgIG9uVmFsdWUoYXJyYXkpO1xyXG4gICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcclxuICAgICAgY3VycmVudFBhcmVudCA9IGFycmF5O1xyXG4gICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xyXG4gICAgfSxcclxuICAgIG9uQXJyYXlFbmQ6ICgpID0+IHtcclxuICAgICAgY3VycmVudFBhcmVudCA9IHByZXZpb3VzUGFyZW50cy5wb3AoKTtcclxuICAgIH0sXHJcbiAgICBvbkxpdGVyYWxWYWx1ZTogb25WYWx1ZSxcclxuICAgIG9uRXJyb3I6IChlcnJvciwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcclxuICAgICAgZXJyb3JzLnB1c2goeyBlcnJvciwgb2Zmc2V0LCBsZW5ndGggfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICB2aXNpdCh0ZXh0LCB2aXNpdG9yLCBvcHRpb25zKTtcclxuICByZXR1cm4gY3VycmVudFBhcmVudFswXTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlUGF0aChub2RlKSB7XHJcbiAgaWYgKCFub2RlLnBhcmVudCB8fCAhbm9kZS5wYXJlbnQuY2hpbGRyZW4pIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgY29uc3QgcGF0aCA9IGdldE5vZGVQYXRoKG5vZGUucGFyZW50KTtcclxuICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJwcm9wZXJ0eVwiKSB7XHJcbiAgICBjb25zdCBrZXkgPSBub2RlLnBhcmVudC5jaGlsZHJlblswXS52YWx1ZTtcclxuICAgIHBhdGgucHVzaChrZXkpO1xyXG4gIH0gZWxzZSBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJhcnJheVwiKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IG5vZGUucGFyZW50LmNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHBhdGgucHVzaChpbmRleCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBwYXRoO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5vZGVWYWx1ZShub2RlKSB7XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgIGNhc2UgXCJhcnJheVwiOlxyXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZ2V0Tm9kZVZhbHVlKTtcclxuICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgY29uc3Qgb2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIGZvciAobGV0IHByb3Agb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHByb3AuY2hpbGRyZW5bMV07XHJcbiAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xyXG4gICAgICAgICAgb2JqW3Byb3AuY2hpbGRyZW5bMF0udmFsdWVdID0gZ2V0Tm9kZVZhbHVlKHZhbHVlTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmo7XHJcbiAgICBjYXNlIFwibnVsbFwiOlxyXG4gICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kID0gZmFsc2UpIHtcclxuICByZXR1cm4gb2Zmc2V0ID49IG5vZGUub2Zmc2V0ICYmIG9mZnNldCA8IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggfHwgaW5jbHVkZVJpZ2h0Qm91bmQgJiYgb2Zmc2V0ID09PSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmROb2RlQXRPZmZzZXQobm9kZSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XHJcbiAgaWYgKGNvbnRhaW5zKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5baV0ub2Zmc2V0IDw9IG9mZnNldDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGZpbmROb2RlQXRPZmZzZXQoY2hpbGRyZW5baV0sIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpO1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuICByZXR1cm4gdm9pZCAwO1xyXG59XHJcbmZ1bmN0aW9uIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVCkge1xyXG4gIGNvbnN0IF9zY2FubmVyID0gY3JlYXRlU2Nhbm5lcih0ZXh0LCBmYWxzZSk7XHJcbiAgY29uc3QgX2pzb25QYXRoID0gW107XHJcbiAgZnVuY3Rpb24gdG9Ob0FyZ1Zpc2l0KHZpc2l0RnVuY3Rpb24pIHtcclxuICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gKCkgPT4gdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpIDogKCkgPT4gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdG9Ob0FyZ1Zpc2l0V2l0aFBhdGgodmlzaXRGdW5jdGlvbikge1xyXG4gICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoKSA9PiB2aXNpdEZ1bmN0aW9uKF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSwgKCkgPT4gX2pzb25QYXRoLnNsaWNlKCkpIDogKCkgPT4gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XHJcbiAgICByZXR1cm4gdmlzaXRGdW5jdGlvbiA/IChhcmcpID0+IHZpc2l0RnVuY3Rpb24oYXJnLCBfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpIDogKCkgPT4gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0RnVuY3Rpb24pIHtcclxuICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gKGFyZykgPT4gdmlzaXRGdW5jdGlvbihhcmcsIF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSwgKCkgPT4gX2pzb25QYXRoLnNsaWNlKCkpIDogKCkgPT4gdHJ1ZTtcclxuICB9XHJcbiAgY29uc3Qgb25PYmplY3RCZWdpbiA9IHRvTm9BcmdWaXNpdFdpdGhQYXRoKHZpc2l0b3Iub25PYmplY3RCZWdpbiksIG9uT2JqZWN0UHJvcGVydHkgPSB0b09uZUFyZ1Zpc2l0V2l0aFBhdGgodmlzaXRvci5vbk9iamVjdFByb3BlcnR5KSwgb25PYmplY3RFbmQgPSB0b05vQXJnVmlzaXQodmlzaXRvci5vbk9iamVjdEVuZCksIG9uQXJyYXlCZWdpbiA9IHRvTm9BcmdWaXNpdFdpdGhQYXRoKHZpc2l0b3Iub25BcnJheUJlZ2luKSwgb25BcnJheUVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uQXJyYXlFbmQpLCBvbkxpdGVyYWxWYWx1ZSA9IHRvT25lQXJnVmlzaXRXaXRoUGF0aCh2aXNpdG9yLm9uTGl0ZXJhbFZhbHVlKSwgb25TZXBhcmF0b3IgPSB0b09uZUFyZ1Zpc2l0KHZpc2l0b3Iub25TZXBhcmF0b3IpLCBvbkNvbW1lbnQgPSB0b05vQXJnVmlzaXQodmlzaXRvci5vbkNvbW1lbnQpLCBvbkVycm9yID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uRXJyb3IpO1xyXG4gIGNvbnN0IGRpc2FsbG93Q29tbWVudHMgPSBvcHRpb25zICYmIG9wdGlvbnMuZGlzYWxsb3dDb21tZW50cztcclxuICBjb25zdCBhbGxvd1RyYWlsaW5nQ29tbWEgPSBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hO1xyXG4gIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBfc2Nhbm5lci5zY2FuKCk7XHJcbiAgICAgIHN3aXRjaCAoX3NjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoXHJcbiAgICAgICAgICAgIDE0XHJcbiAgICAgICAgICAgIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRVbmljb2RlICovXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoXHJcbiAgICAgICAgICAgIDE1XHJcbiAgICAgICAgICAgIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi9cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcihcclxuICAgICAgICAgICAgMTNcclxuICAgICAgICAgICAgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyICovXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgaWYgKCFkaXNhbGxvd0NvbW1lbnRzKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKFxyXG4gICAgICAgICAgICAgIDExXHJcbiAgICAgICAgICAgICAgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqL1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoXHJcbiAgICAgICAgICAgIDEyXHJcbiAgICAgICAgICAgIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqL1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgIGhhbmRsZUVycm9yKFxyXG4gICAgICAgICAgICAxNlxyXG4gICAgICAgICAgICAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkQ2hhcmFjdGVyICovXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgIGlmIChkaXNhbGxvd0NvbW1lbnRzKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKFxyXG4gICAgICAgICAgICAgIDEwXHJcbiAgICAgICAgICAgICAgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZENvbW1lbnRUb2tlbiAqL1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb25Db21tZW50KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE2OlxyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoXHJcbiAgICAgICAgICAgIDFcclxuICAgICAgICAgICAgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFN5bWJvbCAqL1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTU6XHJcbiAgICAgICAgY2FzZSAxNDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IsIHNraXBVbnRpbEFmdGVyID0gW10sIHNraXBVbnRpbCA9IFtdKSB7XHJcbiAgICBvbkVycm9yKGVycm9yKTtcclxuICAgIGlmIChza2lwVW50aWxBZnRlci5sZW5ndGggKyBza2lwVW50aWwubGVuZ3RoID4gMCkge1xyXG4gICAgICBsZXQgdG9rZW4gPSBfc2Nhbm5lci5nZXRUb2tlbigpO1xyXG4gICAgICB3aGlsZSAodG9rZW4gIT09IDE3KSB7XHJcbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xyXG4gICAgICAgICAgc2Nhbk5leHQoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2tpcFVudGlsLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuID0gc2Nhbk5leHQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVN0cmluZyhpc1ZhbHVlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IF9zY2FubmVyLmdldFRva2VuVmFsdWUoKTtcclxuICAgIGlmIChpc1ZhbHVlKSB7XHJcbiAgICAgIG9uTGl0ZXJhbFZhbHVlKHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9uT2JqZWN0UHJvcGVydHkodmFsdWUpO1xyXG4gICAgICBfanNvblBhdGgucHVzaCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzY2FuTmV4dCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCgpIHtcclxuICAgIHN3aXRjaCAoX3NjYW5uZXIuZ2V0VG9rZW4oKSkge1xyXG4gICAgICBjYXNlIDExOlxyXG4gICAgICAgIGNvbnN0IHRva2VuVmFsdWUgPSBfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gTnVtYmVyKHRva2VuVmFsdWUpO1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgIGhhbmRsZUVycm9yKFxyXG4gICAgICAgICAgICAyXHJcbiAgICAgICAgICAgIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWROdW1iZXJGb3JtYXQgKi9cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uTGl0ZXJhbFZhbHVlKHZhbHVlKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA3OlxyXG4gICAgICAgIG9uTGl0ZXJhbFZhbHVlKG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDg6XHJcbiAgICAgICAgb25MaXRlcmFsVmFsdWUodHJ1ZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgOTpcclxuICAgICAgICBvbkxpdGVyYWxWYWx1ZShmYWxzZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc2Nhbk5leHQoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5KCkge1xyXG4gICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDEwKSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKDMsIFtdLCBbXHJcbiAgICAgICAgMixcclxuICAgICAgICA1XHJcbiAgICAgICAgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBwYXJzZVN0cmluZyhmYWxzZSk7XHJcbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNikge1xyXG4gICAgICBvblNlcGFyYXRvcihcIjpcIik7XHJcbiAgICAgIHNjYW5OZXh0KCk7XHJcbiAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoNCwgW10sIFtcclxuICAgICAgICAgIDIsXHJcbiAgICAgICAgICA1XHJcbiAgICAgICAgICAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9cclxuICAgICAgICBdKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGFuZGxlRXJyb3IoNSwgW10sIFtcclxuICAgICAgICAyLFxyXG4gICAgICAgIDVcclxuICAgICAgICAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9cclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBfanNvblBhdGgucG9wKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VPYmplY3QoKSB7XHJcbiAgICBvbk9iamVjdEJlZ2luKCk7XHJcbiAgICBzY2FuTmV4dCgpO1xyXG4gICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcclxuICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3KSB7XHJcbiAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1KSB7XHJcbiAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcig0LCBbXSwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvblNlcGFyYXRvcihcIixcIik7XHJcbiAgICAgICAgc2Nhbk5leHQoKTtcclxuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMiAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoNiwgW10sIFtdKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXBhcnNlUHJvcGVydHkoKSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKDQsIFtdLCBbXHJcbiAgICAgICAgICAyLFxyXG4gICAgICAgICAgNVxyXG4gICAgICAgICAgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH1cclxuICAgICAgbmVlZHNDb21tYSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBvbk9iamVjdEVuZCgpO1xyXG4gICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDIpIHtcclxuICAgICAgaGFuZGxlRXJyb3IoNywgW1xyXG4gICAgICAgIDJcclxuICAgICAgICAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqL1xyXG4gICAgICBdLCBbXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY2FuTmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XHJcbiAgICBvbkFycmF5QmVnaW4oKTtcclxuICAgIHNjYW5OZXh0KCk7XHJcbiAgICBsZXQgaXNGaXJzdEVsZW1lbnQgPSB0cnVlO1xyXG4gICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcclxuICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSA0ICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3KSB7XHJcbiAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1KSB7XHJcbiAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcig0LCBbXSwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvblNlcGFyYXRvcihcIixcIik7XHJcbiAgICAgICAgc2Nhbk5leHQoKTtcclxuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoNiwgW10sIFtdKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNGaXJzdEVsZW1lbnQpIHtcclxuICAgICAgICBfanNvblBhdGgucHVzaCgwKTtcclxuICAgICAgICBpc0ZpcnN0RWxlbWVudCA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9qc29uUGF0aFtfanNvblBhdGgubGVuZ3RoIC0gMV0rKztcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXBhcnNlVmFsdWUoKSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKDQsIFtdLCBbXHJcbiAgICAgICAgICA0LFxyXG4gICAgICAgICAgNVxyXG4gICAgICAgICAgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH1cclxuICAgICAgbmVlZHNDb21tYSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBvbkFycmF5RW5kKCk7XHJcbiAgICBpZiAoIWlzRmlyc3RFbGVtZW50KSB7XHJcbiAgICAgIF9qc29uUGF0aC5wb3AoKTtcclxuICAgIH1cclxuICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSA0KSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKDgsIFtcclxuICAgICAgICA0XHJcbiAgICAgICAgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqL1xyXG4gICAgICBdLCBbXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY2FuTmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVmFsdWUoKSB7XHJcbiAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIHJldHVybiBwYXJzZUFycmF5KCk7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoKTtcclxuICAgICAgY2FzZSAxMDpcclxuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcodHJ1ZSk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlTGl0ZXJhbCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBzY2FuTmV4dCgpO1xyXG4gIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSAxNykge1xyXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dFbXB0eUNvbnRlbnQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVFcnJvcig0LCBbXSwgW10pO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoIXBhcnNlVmFsdWUoKSkge1xyXG4gICAgaGFuZGxlRXJyb3IoNCwgW10sIFtdKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3KSB7XHJcbiAgICBoYW5kbGVFcnJvcig5LCBbXSwgW10pO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL21haW4uanNcclxudmFyIGNyZWF0ZVNjYW5uZXIyID0gY3JlYXRlU2Nhbm5lcjtcclxudmFyIFNjYW5FcnJvcjtcclxuKGZ1bmN0aW9uKFNjYW5FcnJvcjIpIHtcclxuICBTY2FuRXJyb3IyW1NjYW5FcnJvcjJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICBTY2FuRXJyb3IyW1NjYW5FcnJvcjJbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMV0gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcclxuICBTY2FuRXJyb3IyW1NjYW5FcnJvcjJbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAyXSA9IFwiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCI7XHJcbiAgU2NhbkVycm9yMltTY2FuRXJyb3IyW1wiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCJdID0gM10gPSBcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiO1xyXG4gIFNjYW5FcnJvcjJbU2NhbkVycm9yMltcIkludmFsaWRVbmljb2RlXCJdID0gNF0gPSBcIkludmFsaWRVbmljb2RlXCI7XHJcbiAgU2NhbkVycm9yMltTY2FuRXJyb3IyW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDVdID0gXCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyXCI7XHJcbiAgU2NhbkVycm9yMltTY2FuRXJyb3IyW1wiSW52YWxpZENoYXJhY3RlclwiXSA9IDZdID0gXCJJbnZhbGlkQ2hhcmFjdGVyXCI7XHJcbn0pKFNjYW5FcnJvciB8fCAoU2NhbkVycm9yID0ge30pKTtcclxudmFyIFN5bnRheEtpbmQ7XHJcbihmdW5jdGlvbihTeW50YXhLaW5kMikge1xyXG4gIFN5bnRheEtpbmQyW1N5bnRheEtpbmQyW1wiT3BlbkJyYWNlVG9rZW5cIl0gPSAxXSA9IFwiT3BlbkJyYWNlVG9rZW5cIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIkNsb3NlQnJhY2VUb2tlblwiXSA9IDJdID0gXCJDbG9zZUJyYWNlVG9rZW5cIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIk9wZW5CcmFja2V0VG9rZW5cIl0gPSAzXSA9IFwiT3BlbkJyYWNrZXRUb2tlblwiO1xyXG4gIFN5bnRheEtpbmQyW1N5bnRheEtpbmQyW1wiQ2xvc2VCcmFja2V0VG9rZW5cIl0gPSA0XSA9IFwiQ2xvc2VCcmFja2V0VG9rZW5cIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIkNvbW1hVG9rZW5cIl0gPSA1XSA9IFwiQ29tbWFUb2tlblwiO1xyXG4gIFN5bnRheEtpbmQyW1N5bnRheEtpbmQyW1wiQ29sb25Ub2tlblwiXSA9IDZdID0gXCJDb2xvblRva2VuXCI7XHJcbiAgU3ludGF4S2luZDJbU3ludGF4S2luZDJbXCJOdWxsS2V5d29yZFwiXSA9IDddID0gXCJOdWxsS2V5d29yZFwiO1xyXG4gIFN5bnRheEtpbmQyW1N5bnRheEtpbmQyW1wiVHJ1ZUtleXdvcmRcIl0gPSA4XSA9IFwiVHJ1ZUtleXdvcmRcIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIkZhbHNlS2V5d29yZFwiXSA9IDldID0gXCJGYWxzZUtleXdvcmRcIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIlN0cmluZ0xpdGVyYWxcIl0gPSAxMF0gPSBcIlN0cmluZ0xpdGVyYWxcIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIk51bWVyaWNMaXRlcmFsXCJdID0gMTFdID0gXCJOdW1lcmljTGl0ZXJhbFwiO1xyXG4gIFN5bnRheEtpbmQyW1N5bnRheEtpbmQyW1wiTGluZUNvbW1lbnRUcml2aWFcIl0gPSAxMl0gPSBcIkxpbmVDb21tZW50VHJpdmlhXCI7XHJcbiAgU3ludGF4S2luZDJbU3ludGF4S2luZDJbXCJCbG9ja0NvbW1lbnRUcml2aWFcIl0gPSAxM10gPSBcIkJsb2NrQ29tbWVudFRyaXZpYVwiO1xyXG4gIFN5bnRheEtpbmQyW1N5bnRheEtpbmQyW1wiTGluZUJyZWFrVHJpdmlhXCJdID0gMTRdID0gXCJMaW5lQnJlYWtUcml2aWFcIjtcclxuICBTeW50YXhLaW5kMltTeW50YXhLaW5kMltcIlRyaXZpYVwiXSA9IDE1XSA9IFwiVHJpdmlhXCI7XHJcbiAgU3ludGF4S2luZDJbU3ludGF4S2luZDJbXCJVbmtub3duXCJdID0gMTZdID0gXCJVbmtub3duXCI7XHJcbiAgU3ludGF4S2luZDJbU3ludGF4S2luZDJbXCJFT0ZcIl0gPSAxN10gPSBcIkVPRlwiO1xyXG59KShTeW50YXhLaW5kIHx8IChTeW50YXhLaW5kID0ge30pKTtcclxudmFyIHBhcnNlMiA9IHBhcnNlO1xyXG52YXIgZmluZE5vZGVBdE9mZnNldDIgPSBmaW5kTm9kZUF0T2Zmc2V0O1xyXG52YXIgZ2V0Tm9kZVBhdGgyID0gZ2V0Tm9kZVBhdGg7XHJcbnZhciBnZXROb2RlVmFsdWUyID0gZ2V0Tm9kZVZhbHVlO1xyXG52YXIgUGFyc2VFcnJvckNvZGU7XHJcbihmdW5jdGlvbihQYXJzZUVycm9yQ29kZTIpIHtcclxuICBQYXJzZUVycm9yQ29kZTJbUGFyc2VFcnJvckNvZGUyW1wiSW52YWxpZFN5bWJvbFwiXSA9IDFdID0gXCJJbnZhbGlkU3ltYm9sXCI7XHJcbiAgUGFyc2VFcnJvckNvZGUyW1BhcnNlRXJyb3JDb2RlMltcIkludmFsaWROdW1iZXJGb3JtYXRcIl0gPSAyXSA9IFwiSW52YWxpZE51bWJlckZvcm1hdFwiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJQcm9wZXJ0eU5hbWVFeHBlY3RlZFwiXSA9IDNdID0gXCJQcm9wZXJ0eU5hbWVFeHBlY3RlZFwiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJWYWx1ZUV4cGVjdGVkXCJdID0gNF0gPSBcIlZhbHVlRXhwZWN0ZWRcIjtcclxuICBQYXJzZUVycm9yQ29kZTJbUGFyc2VFcnJvckNvZGUyW1wiQ29sb25FeHBlY3RlZFwiXSA9IDVdID0gXCJDb2xvbkV4cGVjdGVkXCI7XHJcbiAgUGFyc2VFcnJvckNvZGUyW1BhcnNlRXJyb3JDb2RlMltcIkNvbW1hRXhwZWN0ZWRcIl0gPSA2XSA9IFwiQ29tbWFFeHBlY3RlZFwiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJDbG9zZUJyYWNlRXhwZWN0ZWRcIl0gPSA3XSA9IFwiQ2xvc2VCcmFjZUV4cGVjdGVkXCI7XHJcbiAgUGFyc2VFcnJvckNvZGUyW1BhcnNlRXJyb3JDb2RlMltcIkNsb3NlQnJhY2tldEV4cGVjdGVkXCJdID0gOF0gPSBcIkNsb3NlQnJhY2tldEV4cGVjdGVkXCI7XHJcbiAgUGFyc2VFcnJvckNvZGUyW1BhcnNlRXJyb3JDb2RlMltcIkVuZE9mRmlsZUV4cGVjdGVkXCJdID0gOV0gPSBcIkVuZE9mRmlsZUV4cGVjdGVkXCI7XHJcbiAgUGFyc2VFcnJvckNvZGUyW1BhcnNlRXJyb3JDb2RlMltcIkludmFsaWRDb21tZW50VG9rZW5cIl0gPSAxMF0gPSBcIkludmFsaWRDb21tZW50VG9rZW5cIjtcclxuICBQYXJzZUVycm9yQ29kZTJbUGFyc2VFcnJvckNvZGUyW1wiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiXSA9IDExXSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAxMl0gPSBcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAxM10gPSBcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJJbnZhbGlkVW5pY29kZVwiXSA9IDE0XSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcclxuICBQYXJzZUVycm9yQ29kZTJbUGFyc2VFcnJvckNvZGUyW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDE1XSA9IFwiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiO1xyXG4gIFBhcnNlRXJyb3JDb2RlMltQYXJzZUVycm9yQ29kZTJbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gMTZdID0gXCJJbnZhbGlkQ2hhcmFjdGVyXCI7XHJcbn0pKFBhcnNlRXJyb3JDb2RlIHx8IChQYXJzZUVycm9yQ29kZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIGZvcm1hdDIoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBmb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIG5vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9vYmplY3RzLmpzXHJcbmZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyKSB7XHJcbiAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdm9pZCAwIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB2b2lkIDApIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBvbmUgIT09IHR5cGVvZiBvdGhlcikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIG9uZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShvbmUpICE9PSBBcnJheS5pc0FycmF5KG90aGVyKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBsZXQgaSwga2V5O1xyXG4gIGlmIChBcnJheS5pc0FycmF5KG9uZSkpIHtcclxuICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IG9uZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIWVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBvbmVLZXlzID0gW107XHJcbiAgICBmb3IgKGtleSBpbiBvbmUpIHtcclxuICAgICAgb25lS2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICBvbmVLZXlzLnNvcnQoKTtcclxuICAgIGNvbnN0IG90aGVyS2V5cyA9IFtdO1xyXG4gICAgZm9yIChrZXkgaW4gb3RoZXIpIHtcclxuICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIG90aGVyS2V5cy5zb3J0KCk7XHJcbiAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIjtcclxufVxyXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvc3RyaW5ncy5qc1xyXG5mdW5jdGlvbiBzdGFydHNXaXRoKGhheXN0YWNrLCBuZWVkbGUpIHtcclxuICBpZiAoaGF5c3RhY2subGVuZ3RoIDwgbmVlZGxlLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGhheXN0YWNrW2ldICE9PSBuZWVkbGVbaV0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBlbmRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgY29uc3QgZGlmZiA9IGhheXN0YWNrLmxlbmd0aCAtIG5lZWRsZS5sZW5ndGg7XHJcbiAgaWYgKGRpZmYgPiAwKSB7XHJcbiAgICByZXR1cm4gaGF5c3RhY2subGFzdEluZGV4T2YobmVlZGxlKSA9PT0gZGlmZjtcclxuICB9IGVsc2UgaWYgKGRpZmYgPT09IDApIHtcclxuICAgIHJldHVybiBoYXlzdGFjayA9PT0gbmVlZGxlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dGVuZGVkUmVnRXhwKHBhdHRlcm4pIHtcclxuICBsZXQgZmxhZ3MgPSBcIlwiO1xyXG4gIGlmIChzdGFydHNXaXRoKHBhdHRlcm4sIFwiKD9pKVwiKSkge1xyXG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyaW5nKDQpO1xyXG4gICAgZmxhZ3MgPSBcImlcIjtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzICsgXCJ1XCIpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuICAgIH0gY2F0Y2ggKGUyKSB7XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ0xlbmd0aChzdHIpIHtcclxuICBsZXQgY291bnQgPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb3VudCsrO1xyXG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgaWYgKDU1Mjk2IDw9IGNvZGUgJiYgY29kZSA8PSA1NjMxOSkge1xyXG4gICAgICBpKys7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb3VudDtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcy9saWIvZXNtL21haW4uanNcclxudmFyIERvY3VtZW50VXJpO1xyXG4oZnVuY3Rpb24oRG9jdW1lbnRVcmkyKSB7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XHJcbiAgfVxyXG4gIERvY3VtZW50VXJpMi5pcyA9IGlzO1xyXG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xyXG52YXIgVVJJO1xyXG4oZnVuY3Rpb24oVVJJMykge1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xyXG4gIH1cclxuICBVUkkzLmlzID0gaXM7XHJcbn0pKFVSSSB8fCAoVVJJID0ge30pKTtcclxudmFyIGludGVnZXI7XHJcbihmdW5jdGlvbihpbnRlZ2VyMikge1xyXG4gIGludGVnZXIyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xyXG4gIGludGVnZXIyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaW50ZWdlcjIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IGludGVnZXIyLk1BWF9WQUxVRTtcclxuICB9XHJcbiAgaW50ZWdlcjIuaXMgPSBpcztcclxufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XHJcbnZhciB1aW50ZWdlcjtcclxuKGZ1bmN0aW9uKHVpbnRlZ2VyMikge1xyXG4gIHVpbnRlZ2VyMi5NSU5fVkFMVUUgPSAwO1xyXG4gIHVpbnRlZ2VyMi5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHVpbnRlZ2VyMi5NSU5fVkFMVUUgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdWludGVnZXIyLk1BWF9WQUxVRTtcclxuICB9XHJcbiAgdWludGVnZXIyLmlzID0gaXM7XHJcbn0pKHVpbnRlZ2VyIHx8ICh1aW50ZWdlciA9IHt9KSk7XHJcbnZhciBQb3NpdGlvbjtcclxuKGZ1bmN0aW9uKFBvc2l0aW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcclxuICAgIGlmIChsaW5lID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hhcmFjdGVyID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgIGNoYXJhY3RlciA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xyXG4gIH1cclxuICBQb3NpdGlvbjIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcclxuICB9XHJcbiAgUG9zaXRpb24yLmlzID0gaXM7XHJcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XHJcbnZhciBSYW5nZTtcclxuKGZ1bmN0aW9uKFJhbmdlMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcclxuICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXJ0OiBQb3NpdGlvbi5jcmVhdGUob25lLCB0d28pLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSh0aHJlZSwgZm91cikgfTtcclxuICAgIH0gZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXJ0OiBvbmUsIGVuZDogdHdvIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJhbmdlI2NyZWF0ZSBjYWxsZWQgd2l0aCBpbnZhbGlkIGFyZ3VtZW50c1ske29uZX0sICR7dHdvfSwgJHt0aHJlZX0sICR7Zm91cn1dYCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFJhbmdlMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcclxuICB9XHJcbiAgUmFuZ2UyLmlzID0gaXM7XHJcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XHJcbnZhciBMb2NhdGlvbjtcclxuKGZ1bmN0aW9uKExvY2F0aW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHJhbmdlKSB7XHJcbiAgICByZXR1cm4geyB1cmksIHJhbmdlIH07XHJcbiAgfVxyXG4gIExvY2F0aW9uMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUudXJpKSk7XHJcbiAgfVxyXG4gIExvY2F0aW9uMi5pcyA9IGlzO1xyXG59KShMb2NhdGlvbiB8fCAoTG9jYXRpb24gPSB7fSkpO1xyXG52YXIgTG9jYXRpb25MaW5rO1xyXG4oZnVuY3Rpb24oTG9jYXRpb25MaW5rMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcclxuICAgIHJldHVybiB7IHRhcmdldFVyaSwgdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZSB9O1xyXG4gIH1cclxuICBMb2NhdGlvbkxpbmsyLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0U2VsZWN0aW9uUmFuZ2UpICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcclxuICB9XHJcbiAgTG9jYXRpb25MaW5rMi5pcyA9IGlzO1xyXG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XHJcbnZhciBDb2xvcjtcclxuKGZ1bmN0aW9uKENvbG9yMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVkLFxyXG4gICAgICBncmVlbixcclxuICAgICAgYmx1ZSxcclxuICAgICAgYWxwaGFcclxuICAgIH07XHJcbiAgfVxyXG4gIENvbG9yMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUucmVkLCAwLCAxKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuZ3JlZW4sIDAsIDEpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYWxwaGEsIDAsIDEpO1xyXG4gIH1cclxuICBDb2xvcjIuaXMgPSBpcztcclxufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcclxudmFyIENvbG9ySW5mb3JtYXRpb247XHJcbihmdW5jdGlvbihDb2xvckluZm9ybWF0aW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJhbmdlLFxyXG4gICAgICBjb2xvclxyXG4gICAgfTtcclxuICB9XHJcbiAgQ29sb3JJbmZvcm1hdGlvbjIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBDb2xvci5pcyhjYW5kaWRhdGUuY29sb3IpO1xyXG4gIH1cclxuICBDb2xvckluZm9ybWF0aW9uMi5pcyA9IGlzO1xyXG59KShDb2xvckluZm9ybWF0aW9uIHx8IChDb2xvckluZm9ybWF0aW9uID0ge30pKTtcclxudmFyIENvbG9yUHJlc2VudGF0aW9uO1xyXG4oZnVuY3Rpb24oQ29sb3JQcmVzZW50YXRpb24yKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGFiZWwsXHJcbiAgICAgIHRleHRFZGl0LFxyXG4gICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzXHJcbiAgICB9O1xyXG4gIH1cclxuICBDb2xvclByZXNlbnRhdGlvbjIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmFkZGl0aW9uYWxUZXh0RWRpdHMpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmFkZGl0aW9uYWxUZXh0RWRpdHMsIFRleHRFZGl0LmlzKSk7XHJcbiAgfVxyXG4gIENvbG9yUHJlc2VudGF0aW9uMi5pcyA9IGlzO1xyXG59KShDb2xvclByZXNlbnRhdGlvbiB8fCAoQ29sb3JQcmVzZW50YXRpb24gPSB7fSkpO1xyXG52YXIgRm9sZGluZ1JhbmdlS2luZDtcclxuKGZ1bmN0aW9uKEZvbGRpbmdSYW5nZUtpbmQyKSB7XHJcbiAgRm9sZGluZ1JhbmdlS2luZDIuQ29tbWVudCA9IFwiY29tbWVudFwiO1xyXG4gIEZvbGRpbmdSYW5nZUtpbmQyLkltcG9ydHMgPSBcImltcG9ydHNcIjtcclxuICBGb2xkaW5nUmFuZ2VLaW5kMi5SZWdpb24gPSBcInJlZ2lvblwiO1xyXG59KShGb2xkaW5nUmFuZ2VLaW5kIHx8IChGb2xkaW5nUmFuZ2VLaW5kID0ge30pKTtcclxudmFyIEZvbGRpbmdSYW5nZTtcclxuKGZ1bmN0aW9uKEZvbGRpbmdSYW5nZTIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgIHN0YXJ0TGluZSxcclxuICAgICAgZW5kTGluZVxyXG4gICAgfTtcclxuICAgIGlmIChJcy5kZWZpbmVkKHN0YXJ0Q2hhcmFjdGVyKSkge1xyXG4gICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcclxuICAgIH1cclxuICAgIGlmIChJcy5kZWZpbmVkKGVuZENoYXJhY3RlcikpIHtcclxuICAgICAgcmVzdWx0LmVuZENoYXJhY3RlciA9IGVuZENoYXJhY3RlcjtcclxuICAgIH1cclxuICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XHJcbiAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcclxuICAgIH1cclxuICAgIGlmIChJcy5kZWZpbmVkKGNvbGxhcHNlZFRleHQpKSB7XHJcbiAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIEZvbGRpbmdSYW5nZTIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpIHx8IElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmtpbmQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpO1xyXG4gIH1cclxuICBGb2xkaW5nUmFuZ2UyLmlzID0gaXM7XHJcbn0pKEZvbGRpbmdSYW5nZSB8fCAoRm9sZGluZ1JhbmdlID0ge30pKTtcclxudmFyIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb247XHJcbihmdW5jdGlvbihEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9jYXRpb24sXHJcbiAgICAgIG1lc3NhZ2VcclxuICAgIH07XHJcbiAgfVxyXG4gIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24yLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XHJcbiAgfVxyXG4gIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24yLmlzID0gaXM7XHJcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xyXG52YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xyXG4oZnVuY3Rpb24oRGlhZ25vc3RpY1NldmVyaXR5Mikge1xyXG4gIERpYWdub3N0aWNTZXZlcml0eTIuRXJyb3IgPSAxO1xyXG4gIERpYWdub3N0aWNTZXZlcml0eTIuV2FybmluZyA9IDI7XHJcbiAgRGlhZ25vc3RpY1NldmVyaXR5Mi5JbmZvcm1hdGlvbiA9IDM7XHJcbiAgRGlhZ25vc3RpY1NldmVyaXR5Mi5IaW50ID0gNDtcclxufSkoRGlhZ25vc3RpY1NldmVyaXR5IHx8IChEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xyXG52YXIgRGlhZ25vc3RpY1RhZztcclxuKGZ1bmN0aW9uKERpYWdub3N0aWNUYWcyKSB7XHJcbiAgRGlhZ25vc3RpY1RhZzIuVW5uZWNlc3NhcnkgPSAxO1xyXG4gIERpYWdub3N0aWNUYWcyLkRlcHJlY2F0ZWQgPSAyO1xyXG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcclxudmFyIENvZGVEZXNjcmlwdGlvbjtcclxuKGZ1bmN0aW9uKENvZGVEZXNjcmlwdGlvbjIpIHtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaHJlZik7XHJcbiAgfVxyXG4gIENvZGVEZXNjcmlwdGlvbjIuaXMgPSBpcztcclxufSkoQ29kZURlc2NyaXB0aW9uIHx8IChDb2RlRGVzY3JpcHRpb24gPSB7fSkpO1xyXG52YXIgRGlhZ25vc3RpYztcclxuKGZ1bmN0aW9uKERpYWdub3N0aWMyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgc291cmNlLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcclxuICAgIGxldCByZXN1bHQgPSB7IHJhbmdlLCBtZXNzYWdlIH07XHJcbiAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcclxuICAgICAgcmVzdWx0LnNldmVyaXR5ID0gc2V2ZXJpdHk7XHJcbiAgICB9XHJcbiAgICBpZiAoSXMuZGVmaW5lZChjb2RlKSkge1xyXG4gICAgICByZXN1bHQuY29kZSA9IGNvZGU7XHJcbiAgICB9XHJcbiAgICBpZiAoSXMuZGVmaW5lZChzb3VyY2UpKSB7XHJcbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XHJcbiAgICAgIHJlc3VsdC5yZWxhdGVkSW5mb3JtYXRpb24gPSByZWxhdGVkSW5mb3JtYXRpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBEaWFnbm9zdGljMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpICYmIChJcy5udW1iZXIoY2FuZGlkYXRlLnNldmVyaXR5KSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnNldmVyaXR5KSkgJiYgKElzLmludGVnZXIoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuY29kZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlKSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCBJcy5zdHJpbmcoKF9hID0gY2FuZGlkYXRlLmNvZGVEZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24sIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMpKTtcclxuICB9XHJcbiAgRGlhZ25vc3RpYzIuaXMgPSBpcztcclxufSkoRGlhZ25vc3RpYyB8fCAoRGlhZ25vc3RpYyA9IHt9KSk7XHJcbnZhciBDb21tYW5kO1xyXG4oZnVuY3Rpb24oQ29tbWFuZDIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQsIC4uLmFyZ3MpIHtcclxuICAgIGxldCByZXN1bHQgPSB7IHRpdGxlLCBjb21tYW5kIH07XHJcbiAgICBpZiAoSXMuZGVmaW5lZChhcmdzKSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBDb21tYW5kMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb21tYW5kKTtcclxuICB9XHJcbiAgQ29tbWFuZDIuaXMgPSBpcztcclxufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XHJcbnZhciBUZXh0RWRpdDtcclxuKGZ1bmN0aW9uKFRleHRFZGl0Mikge1xyXG4gIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcclxuICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0IH07XHJcbiAgfVxyXG4gIFRleHRFZGl0Mi5yZXBsYWNlID0gcmVwbGFjZTtcclxuICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcclxuICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0IH07XHJcbiAgfVxyXG4gIFRleHRFZGl0Mi5pbnNlcnQgPSBpbnNlcnQ7XHJcbiAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XHJcbiAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogXCJcIiB9O1xyXG4gIH1cclxuICBUZXh0RWRpdDIuZGVsID0gZGVsO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xyXG4gIH1cclxuICBUZXh0RWRpdDIuaXMgPSBpcztcclxufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcclxudmFyIENoYW5nZUFubm90YXRpb247XHJcbihmdW5jdGlvbihDaGFuZ2VBbm5vdGF0aW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7IGxhYmVsIH07XHJcbiAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHZvaWQgMCkge1xyXG4gICAgICByZXN1bHQubmVlZHNDb25maXJtYXRpb24gPSBuZWVkc0NvbmZpcm1hdGlvbjtcclxuICAgIH1cclxuICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgQ2hhbmdlQW5ub3RhdGlvbjIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgJiYgKElzLmJvb2xlYW4oY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uKSB8fCBjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24gPT09IHZvaWQgMCkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdm9pZCAwKTtcclxuICB9XHJcbiAgQ2hhbmdlQW5ub3RhdGlvbjIuaXMgPSBpcztcclxufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XHJcbnZhciBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcjtcclxuKGZ1bmN0aW9uKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyMikge1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKTtcclxuICB9XHJcbiAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIyLmlzID0gaXM7XHJcbn0pKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIHx8IChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciA9IHt9KSk7XHJcbnZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcclxuKGZ1bmN0aW9uKEFubm90YXRlZFRleHRFZGl0Mikge1xyXG4gIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcclxuICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcclxuICB9XHJcbiAgQW5ub3RhdGVkVGV4dEVkaXQyLnJlcGxhY2UgPSByZXBsYWNlO1xyXG4gIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xyXG4gICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xyXG4gIH1cclxuICBBbm5vdGF0ZWRUZXh0RWRpdDIuaW5zZXJ0ID0gaW5zZXJ0O1xyXG4gIGZ1bmN0aW9uIGRlbChyYW5nZSwgYW5ub3RhdGlvbikge1xyXG4gICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQ6IFwiXCIsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xyXG4gIH1cclxuICBBbm5vdGF0ZWRUZXh0RWRpdDIuZGVsID0gZGVsO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcclxuICB9XHJcbiAgQW5ub3RhdGVkVGV4dEVkaXQyLmlzID0gaXM7XHJcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XHJcbnZhciBUZXh0RG9jdW1lbnRFZGl0O1xyXG4oZnVuY3Rpb24oVGV4dERvY3VtZW50RWRpdDIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUodGV4dERvY3VtZW50LCBlZGl0cykge1xyXG4gICAgcmV0dXJuIHsgdGV4dERvY3VtZW50LCBlZGl0cyB9O1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnRFZGl0Mi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS50ZXh0RG9jdW1lbnQpICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcclxuICB9XHJcbiAgVGV4dERvY3VtZW50RWRpdDIuaXMgPSBpcztcclxufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XHJcbnZhciBDcmVhdGVGaWxlO1xyXG4oZnVuY3Rpb24oQ3JlYXRlRmlsZTIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICBraW5kOiBcImNyZWF0ZVwiLFxyXG4gICAgICB1cmlcclxuICAgIH07XHJcbiAgICBpZiAob3B0aW9ucyAhPT0gdm9pZCAwICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdm9pZCAwIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHZvaWQgMCkpIHtcclxuICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgfVxyXG4gICAgaWYgKGFubm90YXRpb24gIT09IHZvaWQgMCkge1xyXG4gICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIENyZWF0ZUZpbGUyLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gXCJjcmVhdGVcIiAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB2b2lkIDAgfHwgKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdm9pZCAwIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB2b2lkIDAgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdm9pZCAwIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcclxuICB9XHJcbiAgQ3JlYXRlRmlsZTIuaXMgPSBpcztcclxufSkoQ3JlYXRlRmlsZSB8fCAoQ3JlYXRlRmlsZSA9IHt9KSk7XHJcbnZhciBSZW5hbWVGaWxlO1xyXG4oZnVuY3Rpb24oUmVuYW1lRmlsZTIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcclxuICAgIGxldCByZXN1bHQgPSB7XHJcbiAgICAgIGtpbmQ6IFwicmVuYW1lXCIsXHJcbiAgICAgIG9sZFVyaSxcclxuICAgICAgbmV3VXJpXHJcbiAgICB9O1xyXG4gICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHZvaWQgMCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB2b2lkIDApKSB7XHJcbiAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmIChhbm5vdGF0aW9uICE9PSB2b2lkIDApIHtcclxuICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBSZW5hbWVGaWxlMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09IFwicmVuYW1lXCIgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5vbGRVcmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHZvaWQgMCB8fCAoY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlID09PSB2b2lkIDAgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMgPT09IHZvaWQgMCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB2b2lkIDAgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xyXG4gIH1cclxuICBSZW5hbWVGaWxlMi5pcyA9IGlzO1xyXG59KShSZW5hbWVGaWxlIHx8IChSZW5hbWVGaWxlID0ge30pKTtcclxudmFyIERlbGV0ZUZpbGU7XHJcbihmdW5jdGlvbihEZWxldGVGaWxlMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcclxuICAgIGxldCByZXN1bHQgPSB7XHJcbiAgICAgIGtpbmQ6IFwiZGVsZXRlXCIsXHJcbiAgICAgIHVyaVxyXG4gICAgfTtcclxuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB2b2lkIDAgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdm9pZCAwKSkge1xyXG4gICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgRGVsZXRlRmlsZTIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSBcImRlbGV0ZVwiICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHZvaWQgMCB8fCAoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB2b2lkIDAgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHZvaWQgMCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB2b2lkIDAgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xyXG4gIH1cclxuICBEZWxldGVGaWxlMi5pcyA9IGlzO1xyXG59KShEZWxldGVGaWxlIHx8IChEZWxldGVGaWxlID0ge30pKTtcclxudmFyIFdvcmtzcGFjZUVkaXQ7XHJcbihmdW5jdGlvbihXb3Jrc3BhY2VFZGl0Mikge1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdm9pZCAwIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHZvaWQgMCkgJiYgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHZvaWQgMCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KChjaGFuZ2UpID0+IHtcclxuICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG4gIH1cclxuICBXb3Jrc3BhY2VFZGl0Mi5pcyA9IGlzO1xyXG59KShXb3Jrc3BhY2VFZGl0IHx8IChXb3Jrc3BhY2VFZGl0ID0ge30pKTtcclxudmFyIFRleHREb2N1bWVudElkZW50aWZpZXI7XHJcbihmdW5jdGlvbihUZXh0RG9jdW1lbnRJZGVudGlmaWVyMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcclxuICAgIHJldHVybiB7IHVyaSB9O1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpO1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyMi5pcyA9IGlzO1xyXG59KShUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcclxudmFyIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XHJcbihmdW5jdGlvbihWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcclxuICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xyXG4gIH1cclxuICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xyXG4gIH1cclxuICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyMi5pcyA9IGlzO1xyXG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcclxudmFyIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcclxuKGZ1bmN0aW9uKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XHJcbiAgICByZXR1cm4geyB1cmksIHZlcnNpb24gfTtcclxuICB9XHJcbiAgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSk7XHJcbiAgfVxyXG4gIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjIuaXMgPSBpcztcclxufSkoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xyXG52YXIgVGV4dERvY3VtZW50SXRlbTtcclxuKGZ1bmN0aW9uKFRleHREb2N1bWVudEl0ZW0yKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xyXG4gICAgcmV0dXJuIHsgdXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0IH07XHJcbiAgfVxyXG4gIFRleHREb2N1bWVudEl0ZW0yLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnRJdGVtMi5pcyA9IGlzO1xyXG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcclxudmFyIE1hcmt1cEtpbmQ7XHJcbihmdW5jdGlvbihNYXJrdXBLaW5kMikge1xyXG4gIE1hcmt1cEtpbmQyLlBsYWluVGV4dCA9IFwicGxhaW50ZXh0XCI7XHJcbiAgTWFya3VwS2luZDIuTWFya2Rvd24gPSBcIm1hcmtkb3duXCI7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZDIuUGxhaW5UZXh0IHx8IGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZDIuTWFya2Rvd247XHJcbiAgfVxyXG4gIE1hcmt1cEtpbmQyLmlzID0gaXM7XHJcbn0pKE1hcmt1cEtpbmQgfHwgKE1hcmt1cEtpbmQgPSB7fSkpO1xyXG52YXIgTWFya3VwQ29udGVudDtcclxuKGZ1bmN0aW9uKE1hcmt1cENvbnRlbnQyKSB7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xyXG4gIH1cclxuICBNYXJrdXBDb250ZW50Mi5pcyA9IGlzO1xyXG59KShNYXJrdXBDb250ZW50IHx8IChNYXJrdXBDb250ZW50ID0ge30pKTtcclxudmFyIENvbXBsZXRpb25JdGVtS2luZDtcclxuKGZ1bmN0aW9uKENvbXBsZXRpb25JdGVtS2luZDIpIHtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLlRleHQgPSAxO1xyXG4gIENvbXBsZXRpb25JdGVtS2luZDIuTWV0aG9kID0gMjtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkZ1bmN0aW9uID0gMztcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkNvbnN0cnVjdG9yID0gNDtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkZpZWxkID0gNTtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLlZhcmlhYmxlID0gNjtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkNsYXNzID0gNztcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkludGVyZmFjZSA9IDg7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5Nb2R1bGUgPSA5O1xyXG4gIENvbXBsZXRpb25JdGVtS2luZDIuUHJvcGVydHkgPSAxMDtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLlVuaXQgPSAxMTtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLlZhbHVlID0gMTI7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5FbnVtID0gMTM7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5LZXl3b3JkID0gMTQ7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5TbmlwcGV0ID0gMTU7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5Db2xvciA9IDE2O1xyXG4gIENvbXBsZXRpb25JdGVtS2luZDIuRmlsZSA9IDE3O1xyXG4gIENvbXBsZXRpb25JdGVtS2luZDIuUmVmZXJlbmNlID0gMTg7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5Gb2xkZXIgPSAxOTtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkVudW1NZW1iZXIgPSAyMDtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkNvbnN0YW50ID0gMjE7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5TdHJ1Y3QgPSAyMjtcclxuICBDb21wbGV0aW9uSXRlbUtpbmQyLkV2ZW50ID0gMjM7XHJcbiAgQ29tcGxldGlvbkl0ZW1LaW5kMi5PcGVyYXRvciA9IDI0O1xyXG4gIENvbXBsZXRpb25JdGVtS2luZDIuVHlwZVBhcmFtZXRlciA9IDI1O1xyXG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XHJcbnZhciBJbnNlcnRUZXh0Rm9ybWF0O1xyXG4oZnVuY3Rpb24oSW5zZXJ0VGV4dEZvcm1hdDIpIHtcclxuICBJbnNlcnRUZXh0Rm9ybWF0Mi5QbGFpblRleHQgPSAxO1xyXG4gIEluc2VydFRleHRGb3JtYXQyLlNuaXBwZXQgPSAyO1xyXG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcclxudmFyIENvbXBsZXRpb25JdGVtVGFnO1xyXG4oZnVuY3Rpb24oQ29tcGxldGlvbkl0ZW1UYWcyKSB7XHJcbiAgQ29tcGxldGlvbkl0ZW1UYWcyLkRlcHJlY2F0ZWQgPSAxO1xyXG59KShDb21wbGV0aW9uSXRlbVRhZyB8fCAoQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xyXG52YXIgSW5zZXJ0UmVwbGFjZUVkaXQ7XHJcbihmdW5jdGlvbihJbnNlcnRSZXBsYWNlRWRpdDIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUobmV3VGV4dCwgaW5zZXJ0LCByZXBsYWNlKSB7XHJcbiAgICByZXR1cm4geyBuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UgfTtcclxuICB9XHJcbiAgSW5zZXJ0UmVwbGFjZUVkaXQyLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dCkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLmluc2VydCkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJlcGxhY2UpO1xyXG4gIH1cclxuICBJbnNlcnRSZXBsYWNlRWRpdDIuaXMgPSBpcztcclxufSkoSW5zZXJ0UmVwbGFjZUVkaXQgfHwgKEluc2VydFJlcGxhY2VFZGl0ID0ge30pKTtcclxudmFyIEluc2VydFRleHRNb2RlO1xyXG4oZnVuY3Rpb24oSW5zZXJ0VGV4dE1vZGUyKSB7XHJcbiAgSW5zZXJ0VGV4dE1vZGUyLmFzSXMgPSAxO1xyXG4gIEluc2VydFRleHRNb2RlMi5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XHJcbn0pKEluc2VydFRleHRNb2RlIHx8IChJbnNlcnRUZXh0TW9kZSA9IHt9KSk7XHJcbnZhciBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscztcclxuKGZ1bmN0aW9uKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzMikge1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB2b2lkIDApICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHZvaWQgMCk7XHJcbiAgfVxyXG4gIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzMi5pcyA9IGlzO1xyXG59KShDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyB8fCAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgPSB7fSkpO1xyXG52YXIgQ29tcGxldGlvbkl0ZW07XHJcbihmdW5jdGlvbihDb21wbGV0aW9uSXRlbTIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUobGFiZWwpIHtcclxuICAgIHJldHVybiB7IGxhYmVsIH07XHJcbiAgfVxyXG4gIENvbXBsZXRpb25JdGVtMi5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKENvbXBsZXRpb25JdGVtIHx8IChDb21wbGV0aW9uSXRlbSA9IHt9KSk7XHJcbnZhciBDb21wbGV0aW9uTGlzdDtcclxuKGZ1bmN0aW9uKENvbXBsZXRpb25MaXN0Mikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XHJcbiAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XHJcbiAgfVxyXG4gIENvbXBsZXRpb25MaXN0Mi5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XHJcbnZhciBNYXJrZWRTdHJpbmc7XHJcbihmdW5jdGlvbihNYXJrZWRTdHJpbmcyKSB7XHJcbiAgZnVuY3Rpb24gZnJvbVBsYWluVGV4dChwbGFpblRleHQpIHtcclxuICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csIFwiXFxcXCQmXCIpO1xyXG4gIH1cclxuICBNYXJrZWRTdHJpbmcyLmZyb21QbGFpblRleHQgPSBmcm9tUGxhaW5UZXh0O1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKSB8fCBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XHJcbiAgfVxyXG4gIE1hcmtlZFN0cmluZzIuaXMgPSBpcztcclxufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xyXG52YXIgSG92ZXI7XHJcbihmdW5jdGlvbihIb3ZlcjIpIHtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8IE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNvbnRlbnRzLCBNYXJrZWRTdHJpbmcuaXMpKSAmJiAodmFsdWUucmFuZ2UgPT09IHZvaWQgMCB8fCBSYW5nZS5pcyh2YWx1ZS5yYW5nZSkpO1xyXG4gIH1cclxuICBIb3ZlcjIuaXMgPSBpcztcclxufSkoSG92ZXIgfHwgKEhvdmVyID0ge30pKTtcclxudmFyIFBhcmFtZXRlckluZm9ybWF0aW9uO1xyXG4oZnVuY3Rpb24oUGFyYW1ldGVySW5mb3JtYXRpb24yKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnRhdGlvbiA/IHsgbGFiZWwsIGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWwgfTtcclxuICB9XHJcbiAgUGFyYW1ldGVySW5mb3JtYXRpb24yLmNyZWF0ZSA9IGNyZWF0ZTtcclxufSkoUGFyYW1ldGVySW5mb3JtYXRpb24gfHwgKFBhcmFtZXRlckluZm9ybWF0aW9uID0ge30pKTtcclxudmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xyXG4oZnVuY3Rpb24oU2lnbmF0dXJlSW5mb3JtYXRpb24yKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uLCAuLi5wYXJhbWV0ZXJzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0geyBsYWJlbCB9O1xyXG4gICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcclxuICAgICAgcmVzdWx0LmRvY3VtZW50YXRpb24gPSBkb2N1bWVudGF0aW9uO1xyXG4gICAgfVxyXG4gICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcclxuICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIFNpZ25hdHVyZUluZm9ybWF0aW9uMi5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKFNpZ25hdHVyZUluZm9ybWF0aW9uIHx8IChTaWduYXR1cmVJbmZvcm1hdGlvbiA9IHt9KSk7XHJcbnZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XHJcbihmdW5jdGlvbihEb2N1bWVudEhpZ2hsaWdodEtpbmQyKSB7XHJcbiAgRG9jdW1lbnRIaWdobGlnaHRLaW5kMi5UZXh0ID0gMTtcclxuICBEb2N1bWVudEhpZ2hsaWdodEtpbmQyLlJlYWQgPSAyO1xyXG4gIERvY3VtZW50SGlnaGxpZ2h0S2luZDIuV3JpdGUgPSAzO1xyXG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XHJcbnZhciBEb2N1bWVudEhpZ2hsaWdodDtcclxuKGZ1bmN0aW9uKERvY3VtZW50SGlnaGxpZ2h0Mikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwga2luZCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcclxuICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcclxuICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgRG9jdW1lbnRIaWdobGlnaHQyLmNyZWF0ZSA9IGNyZWF0ZTtcclxufSkoRG9jdW1lbnRIaWdobGlnaHQgfHwgKERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcclxudmFyIFN5bWJvbEtpbmQ7XHJcbihmdW5jdGlvbihTeW1ib2xLaW5kMikge1xyXG4gIFN5bWJvbEtpbmQyLkZpbGUgPSAxO1xyXG4gIFN5bWJvbEtpbmQyLk1vZHVsZSA9IDI7XHJcbiAgU3ltYm9sS2luZDIuTmFtZXNwYWNlID0gMztcclxuICBTeW1ib2xLaW5kMi5QYWNrYWdlID0gNDtcclxuICBTeW1ib2xLaW5kMi5DbGFzcyA9IDU7XHJcbiAgU3ltYm9sS2luZDIuTWV0aG9kID0gNjtcclxuICBTeW1ib2xLaW5kMi5Qcm9wZXJ0eSA9IDc7XHJcbiAgU3ltYm9sS2luZDIuRmllbGQgPSA4O1xyXG4gIFN5bWJvbEtpbmQyLkNvbnN0cnVjdG9yID0gOTtcclxuICBTeW1ib2xLaW5kMi5FbnVtID0gMTA7XHJcbiAgU3ltYm9sS2luZDIuSW50ZXJmYWNlID0gMTE7XHJcbiAgU3ltYm9sS2luZDIuRnVuY3Rpb24gPSAxMjtcclxuICBTeW1ib2xLaW5kMi5WYXJpYWJsZSA9IDEzO1xyXG4gIFN5bWJvbEtpbmQyLkNvbnN0YW50ID0gMTQ7XHJcbiAgU3ltYm9sS2luZDIuU3RyaW5nID0gMTU7XHJcbiAgU3ltYm9sS2luZDIuTnVtYmVyID0gMTY7XHJcbiAgU3ltYm9sS2luZDIuQm9vbGVhbiA9IDE3O1xyXG4gIFN5bWJvbEtpbmQyLkFycmF5ID0gMTg7XHJcbiAgU3ltYm9sS2luZDIuT2JqZWN0ID0gMTk7XHJcbiAgU3ltYm9sS2luZDIuS2V5ID0gMjA7XHJcbiAgU3ltYm9sS2luZDIuTnVsbCA9IDIxO1xyXG4gIFN5bWJvbEtpbmQyLkVudW1NZW1iZXIgPSAyMjtcclxuICBTeW1ib2xLaW5kMi5TdHJ1Y3QgPSAyMztcclxuICBTeW1ib2xLaW5kMi5FdmVudCA9IDI0O1xyXG4gIFN5bWJvbEtpbmQyLk9wZXJhdG9yID0gMjU7XHJcbiAgU3ltYm9sS2luZDIuVHlwZVBhcmFtZXRlciA9IDI2O1xyXG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcclxudmFyIFN5bWJvbFRhZztcclxuKGZ1bmN0aW9uKFN5bWJvbFRhZzIpIHtcclxuICBTeW1ib2xUYWcyLkRlcHJlY2F0ZWQgPSAxO1xyXG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XHJcbnZhciBTeW1ib2xJbmZvcm1hdGlvbjtcclxuKGZ1bmN0aW9uKFN5bWJvbEluZm9ybWF0aW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBraW5kLFxyXG4gICAgICBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH1cclxuICAgIH07XHJcbiAgICBpZiAoY29udGFpbmVyTmFtZSkge1xyXG4gICAgICByZXN1bHQuY29udGFpbmVyTmFtZSA9IGNvbnRhaW5lck5hbWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBTeW1ib2xJbmZvcm1hdGlvbjIuY3JlYXRlID0gY3JlYXRlO1xyXG59KShTeW1ib2xJbmZvcm1hdGlvbiB8fCAoU3ltYm9sSW5mb3JtYXRpb24gPSB7fSkpO1xyXG52YXIgV29ya3NwYWNlU3ltYm9sO1xyXG4oZnVuY3Rpb24oV29ya3NwYWNlU3ltYm9sMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCB1cmksIHJhbmdlKSB7XHJcbiAgICByZXR1cm4gcmFuZ2UgIT09IHZvaWQgMCA/IHsgbmFtZSwga2luZCwgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9IH0gOiB7IG5hbWUsIGtpbmQsIGxvY2F0aW9uOiB7IHVyaSB9IH07XHJcbiAgfVxyXG4gIFdvcmtzcGFjZVN5bWJvbDIuY3JlYXRlID0gY3JlYXRlO1xyXG59KShXb3Jrc3BhY2VTeW1ib2wgfHwgKFdvcmtzcGFjZVN5bWJvbCA9IHt9KSk7XHJcbnZhciBEb2N1bWVudFN5bWJvbDtcclxuKGZ1bmN0aW9uKERvY3VtZW50U3ltYm9sMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBkZXRhaWwsIGtpbmQsIHJhbmdlLCBzZWxlY3Rpb25SYW5nZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCByZXN1bHQgPSB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGRldGFpbCxcclxuICAgICAga2luZCxcclxuICAgICAgcmFuZ2UsXHJcbiAgICAgIHNlbGVjdGlvblJhbmdlXHJcbiAgICB9O1xyXG4gICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcclxuICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBEb2N1bWVudFN5bWJvbDIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5raW5kKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5zZWxlY3Rpb25SYW5nZSkgJiYgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHZvaWQgMCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmIChjYW5kaWRhdGUuZGVwcmVjYXRlZCA9PT0gdm9pZCAwIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmRlcHJlY2F0ZWQpKSAmJiAoY2FuZGlkYXRlLmNoaWxkcmVuID09PSB2b2lkIDAgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuY2hpbGRyZW4pKSAmJiAoY2FuZGlkYXRlLnRhZ3MgPT09IHZvaWQgMCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XHJcbiAgfVxyXG4gIERvY3VtZW50U3ltYm9sMi5pcyA9IGlzO1xyXG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xyXG52YXIgQ29kZUFjdGlvbktpbmQ7XHJcbihmdW5jdGlvbihDb2RlQWN0aW9uS2luZDIpIHtcclxuICBDb2RlQWN0aW9uS2luZDIuRW1wdHkgPSBcIlwiO1xyXG4gIENvZGVBY3Rpb25LaW5kMi5RdWlja0ZpeCA9IFwicXVpY2tmaXhcIjtcclxuICBDb2RlQWN0aW9uS2luZDIuUmVmYWN0b3IgPSBcInJlZmFjdG9yXCI7XHJcbiAgQ29kZUFjdGlvbktpbmQyLlJlZmFjdG9yRXh0cmFjdCA9IFwicmVmYWN0b3IuZXh0cmFjdFwiO1xyXG4gIENvZGVBY3Rpb25LaW5kMi5SZWZhY3RvcklubGluZSA9IFwicmVmYWN0b3IuaW5saW5lXCI7XHJcbiAgQ29kZUFjdGlvbktpbmQyLlJlZmFjdG9yUmV3cml0ZSA9IFwicmVmYWN0b3IucmV3cml0ZVwiO1xyXG4gIENvZGVBY3Rpb25LaW5kMi5Tb3VyY2UgPSBcInNvdXJjZVwiO1xyXG4gIENvZGVBY3Rpb25LaW5kMi5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSBcInNvdXJjZS5vcmdhbml6ZUltcG9ydHNcIjtcclxuICBDb2RlQWN0aW9uS2luZDIuU291cmNlRml4QWxsID0gXCJzb3VyY2UuZml4QWxsXCI7XHJcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XHJcbnZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XHJcbihmdW5jdGlvbihDb2RlQWN0aW9uVHJpZ2dlcktpbmQyKSB7XHJcbiAgQ29kZUFjdGlvblRyaWdnZXJLaW5kMi5JbnZva2VkID0gMTtcclxuICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQyLkF1dG9tYXRpYyA9IDI7XHJcbn0pKENvZGVBY3Rpb25UcmlnZ2VyS2luZCB8fCAoQ29kZUFjdGlvblRyaWdnZXJLaW5kID0ge30pKTtcclxudmFyIENvZGVBY3Rpb25Db250ZXh0O1xyXG4oZnVuY3Rpb24oQ29kZUFjdGlvbkNvbnRleHQyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5LCB0cmlnZ2VyS2luZCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHsgZGlhZ25vc3RpY3MgfTtcclxuICAgIGlmIChvbmx5ICE9PSB2b2lkIDAgJiYgb25seSAhPT0gbnVsbCkge1xyXG4gICAgICByZXN1bHQub25seSA9IG9ubHk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJpZ2dlcktpbmQgIT09IHZvaWQgMCAmJiB0cmlnZ2VyS2luZCAhPT0gbnVsbCkge1xyXG4gICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIENvZGVBY3Rpb25Db250ZXh0Mi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpICYmIChjYW5kaWRhdGUub25seSA9PT0gdm9pZCAwIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpICYmIChjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IHZvaWQgMCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkIHx8IGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyk7XHJcbiAgfVxyXG4gIENvZGVBY3Rpb25Db250ZXh0Mi5pcyA9IGlzO1xyXG59KShDb2RlQWN0aW9uQ29udGV4dCB8fCAoQ29kZUFjdGlvbkNvbnRleHQgPSB7fSkpO1xyXG52YXIgQ29kZUFjdGlvbjtcclxuKGZ1bmN0aW9uKENvZGVBY3Rpb24yKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0geyB0aXRsZSB9O1xyXG4gICAgbGV0IGNoZWNrS2luZCA9IHRydWU7XHJcbiAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XHJcbiAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcclxuICAgIH0gZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xyXG4gICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hlY2tLaW5kICYmIGtpbmQgIT09IHZvaWQgMCkge1xyXG4gICAgICByZXN1bHQua2luZCA9IGtpbmQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBDb2RlQWN0aW9uMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgKGNhbmRpZGF0ZS5kaWFnbm9zdGljcyA9PT0gdm9pZCAwIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSkgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB2b2lkIDAgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiYgKGNhbmRpZGF0ZS5lZGl0ICE9PSB2b2lkIDAgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHZvaWQgMCkgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB2b2lkIDAgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpICYmIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHZvaWQgMCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmIChjYW5kaWRhdGUuZWRpdCA9PT0gdm9pZCAwIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcclxuICB9XHJcbiAgQ29kZUFjdGlvbjIuaXMgPSBpcztcclxufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XHJcbnZhciBDb2RlTGVucztcclxuKGZ1bmN0aW9uKENvZGVMZW5zMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZGF0YSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcclxuICAgIGlmIChJcy5kZWZpbmVkKGRhdGEpKSB7XHJcbiAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIENvZGVMZW5zMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XHJcbiAgfVxyXG4gIENvZGVMZW5zMi5pcyA9IGlzO1xyXG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xyXG52YXIgRm9ybWF0dGluZ09wdGlvbnM7XHJcbihmdW5jdGlvbihGb3JtYXR0aW5nT3B0aW9uczIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUodGFiU2l6ZSwgaW5zZXJ0U3BhY2VzKSB7XHJcbiAgICByZXR1cm4geyB0YWJTaXplLCBpbnNlcnRTcGFjZXMgfTtcclxuICB9XHJcbiAgRm9ybWF0dGluZ09wdGlvbnMyLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcclxuICB9XHJcbiAgRm9ybWF0dGluZ09wdGlvbnMyLmlzID0gaXM7XHJcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XHJcbnZhciBEb2N1bWVudExpbms7XHJcbihmdW5jdGlvbihEb2N1bWVudExpbmsyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0YXJnZXQsIGRhdGEpIHtcclxuICAgIHJldHVybiB7IHJhbmdlLCB0YXJnZXQsIGRhdGEgfTtcclxuICB9XHJcbiAgRG9jdW1lbnRMaW5rMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XHJcbiAgfVxyXG4gIERvY3VtZW50TGluazIuaXMgPSBpcztcclxufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xyXG52YXIgU2VsZWN0aW9uUmFuZ2U7XHJcbihmdW5jdGlvbihTZWxlY3Rpb25SYW5nZTIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIHsgcmFuZ2UsIHBhcmVudCB9O1xyXG4gIH1cclxuICBTZWxlY3Rpb25SYW5nZTIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKGNhbmRpZGF0ZS5wYXJlbnQgPT09IHZvaWQgMCB8fCBTZWxlY3Rpb25SYW5nZTIuaXMoY2FuZGlkYXRlLnBhcmVudCkpO1xyXG4gIH1cclxuICBTZWxlY3Rpb25SYW5nZTIuaXMgPSBpcztcclxufSkoU2VsZWN0aW9uUmFuZ2UgfHwgKFNlbGVjdGlvblJhbmdlID0ge30pKTtcclxudmFyIFNlbWFudGljVG9rZW5UeXBlcztcclxuKGZ1bmN0aW9uKFNlbWFudGljVG9rZW5UeXBlczIpIHtcclxuICBTZW1hbnRpY1Rva2VuVHlwZXMyW1wibmFtZXNwYWNlXCJdID0gXCJuYW1lc3BhY2VcIjtcclxuICBTZW1hbnRpY1Rva2VuVHlwZXMyW1widHlwZVwiXSA9IFwidHlwZVwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcclxuICBTZW1hbnRpY1Rva2VuVHlwZXMyW1wiZW51bVwiXSA9IFwiZW51bVwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJpbnRlcmZhY2VcIl0gPSBcImludGVyZmFjZVwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJ0eXBlUGFyYW1ldGVyXCJdID0gXCJ0eXBlUGFyYW1ldGVyXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcInBhcmFtZXRlclwiXSA9IFwicGFyYW1ldGVyXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcclxuICBTZW1hbnRpY1Rva2VuVHlwZXMyW1wiZW51bU1lbWJlclwiXSA9IFwiZW51bU1lbWJlclwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcclxuICBTZW1hbnRpY1Rva2VuVHlwZXMyW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcIm1ldGhvZFwiXSA9IFwibWV0aG9kXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcIm1vZGlmaWVyXCJdID0gXCJtb2RpZmllclwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcIm51bWJlclwiXSA9IFwibnVtYmVyXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XHJcbiAgU2VtYW50aWNUb2tlblR5cGVzMltcIm9wZXJhdG9yXCJdID0gXCJvcGVyYXRvclwiO1xyXG4gIFNlbWFudGljVG9rZW5UeXBlczJbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xyXG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XHJcbnZhciBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzO1xyXG4oZnVuY3Rpb24oU2VtYW50aWNUb2tlbk1vZGlmaWVyczIpIHtcclxuICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzMltcImRlY2xhcmF0aW9uXCJdID0gXCJkZWNsYXJhdGlvblwiO1xyXG4gIFNlbWFudGljVG9rZW5Nb2RpZmllcnMyW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xyXG4gIFNlbWFudGljVG9rZW5Nb2RpZmllcnMyW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XHJcbiAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczJbXCJzdGF0aWNcIl0gPSBcInN0YXRpY1wiO1xyXG4gIFNlbWFudGljVG9rZW5Nb2RpZmllcnMyW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xyXG4gIFNlbWFudGljVG9rZW5Nb2RpZmllcnMyW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XHJcbiAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczJbXCJhc3luY1wiXSA9IFwiYXN5bmNcIjtcclxuICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzMltcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XHJcbiAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczJbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XHJcbiAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczJbXCJkZWZhdWx0TGlicmFyeVwiXSA9IFwiZGVmYXVsdExpYnJhcnlcIjtcclxufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XHJcbnZhciBTZW1hbnRpY1Rva2VucztcclxuKGZ1bmN0aW9uKFNlbWFudGljVG9rZW5zMikge1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBjYW5kaWRhdGUucmVzdWx0SWQgPT09IFwic3RyaW5nXCIpICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmRhdGEpICYmIChjYW5kaWRhdGUuZGF0YS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGNhbmRpZGF0ZS5kYXRhWzBdID09PSBcIm51bWJlclwiKTtcclxuICB9XHJcbiAgU2VtYW50aWNUb2tlbnMyLmlzID0gaXM7XHJcbn0pKFNlbWFudGljVG9rZW5zIHx8IChTZW1hbnRpY1Rva2VucyA9IHt9KSk7XHJcbnZhciBJbmxpbmVWYWx1ZVRleHQ7XHJcbihmdW5jdGlvbihJbmxpbmVWYWx1ZVRleHQyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XHJcbiAgICByZXR1cm4geyByYW5nZSwgdGV4dCB9O1xyXG4gIH1cclxuICBJbmxpbmVWYWx1ZVRleHQyLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB2b2lkIDAgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcclxuICB9XHJcbiAgSW5saW5lVmFsdWVUZXh0Mi5pcyA9IGlzO1xyXG59KShJbmxpbmVWYWx1ZVRleHQgfHwgKElubGluZVZhbHVlVGV4dCA9IHt9KSk7XHJcbnZhciBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwO1xyXG4oZnVuY3Rpb24oSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCkge1xyXG4gICAgcmV0dXJuIHsgcmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCB9O1xyXG4gIH1cclxuICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwMi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdm9pZCAwICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLmNhc2VTZW5zaXRpdmVMb29rdXApICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdm9pZCAwKTtcclxuICB9XHJcbiAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDIuaXMgPSBpcztcclxufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XHJcbnZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcclxuKGZ1bmN0aW9uKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZXhwcmVzc2lvbikge1xyXG4gICAgcmV0dXJuIHsgcmFuZ2UsIGV4cHJlc3Npb24gfTtcclxuICB9XHJcbiAgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24yLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB2b2lkIDAgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHZvaWQgMCk7XHJcbiAgfVxyXG4gIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uMi5pcyA9IGlzO1xyXG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xyXG52YXIgSW5saW5lVmFsdWVDb250ZXh0O1xyXG4oZnVuY3Rpb24oSW5saW5lVmFsdWVDb250ZXh0Mikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcclxuICAgIHJldHVybiB7IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbiB9O1xyXG4gIH1cclxuICBJbmxpbmVWYWx1ZUNvbnRleHQyLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKHZhbHVlLnN0b3BwZWRMb2NhdGlvbik7XHJcbiAgfVxyXG4gIElubGluZVZhbHVlQ29udGV4dDIuaXMgPSBpcztcclxufSkoSW5saW5lVmFsdWVDb250ZXh0IHx8IChJbmxpbmVWYWx1ZUNvbnRleHQgPSB7fSkpO1xyXG52YXIgSW5sYXlIaW50S2luZDtcclxuKGZ1bmN0aW9uKElubGF5SGludEtpbmQyKSB7XHJcbiAgSW5sYXlIaW50S2luZDIuVHlwZSA9IDE7XHJcbiAgSW5sYXlIaW50S2luZDIuUGFyYW1ldGVyID0gMjtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xyXG4gIH1cclxuICBJbmxheUhpbnRLaW5kMi5pcyA9IGlzO1xyXG59KShJbmxheUhpbnRLaW5kIHx8IChJbmxheUhpbnRLaW5kID0ge30pKTtcclxudmFyIElubGF5SGludExhYmVsUGFydDtcclxuKGZ1bmN0aW9uKElubGF5SGludExhYmVsUGFydDIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcclxuICAgIHJldHVybiB7IHZhbHVlIH07XHJcbiAgfVxyXG4gIElubGF5SGludExhYmVsUGFydDIuY3JlYXRlID0gY3JlYXRlO1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB2b2lkIDAgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSkgJiYgKGNhbmRpZGF0ZS5sb2NhdGlvbiA9PT0gdm9pZCAwIHx8IExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikpICYmIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdm9pZCAwIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcclxuICB9XHJcbiAgSW5sYXlIaW50TGFiZWxQYXJ0Mi5pcyA9IGlzO1xyXG59KShJbmxheUhpbnRMYWJlbFBhcnQgfHwgKElubGF5SGludExhYmVsUGFydCA9IHt9KSk7XHJcbnZhciBJbmxheUhpbnQ7XHJcbihmdW5jdGlvbihJbmxheUhpbnQyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHBvc2l0aW9uLCBsYWJlbCwga2luZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0geyBwb3NpdGlvbiwgbGFiZWwgfTtcclxuICAgIGlmIChraW5kICE9PSB2b2lkIDApIHtcclxuICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgSW5sYXlIaW50Mi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUucG9zaXRpb24pICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSkgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB2b2lkIDAgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpICYmIGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHZvaWQgMCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKSAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHZvaWQgMCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLnRvb2x0aXApKSAmJiAoY2FuZGlkYXRlLnBhZGRpbmdMZWZ0ID09PSB2b2lkIDAgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUucGFkZGluZ0xlZnQpKSAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdm9pZCAwIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xyXG4gIH1cclxuICBJbmxheUhpbnQyLmlzID0gaXM7XHJcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcclxudmFyIFN0cmluZ1ZhbHVlO1xyXG4oZnVuY3Rpb24oU3RyaW5nVmFsdWUyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlU25pcHBldCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHsga2luZDogXCJzbmlwcGV0XCIsIHZhbHVlIH07XHJcbiAgfVxyXG4gIFN0cmluZ1ZhbHVlMi5jcmVhdGVTbmlwcGV0ID0gY3JlYXRlU25pcHBldDtcclxufSkoU3RyaW5nVmFsdWUgfHwgKFN0cmluZ1ZhbHVlID0ge30pKTtcclxudmFyIElubGluZUNvbXBsZXRpb25JdGVtO1xyXG4oZnVuY3Rpb24oSW5saW5lQ29tcGxldGlvbkl0ZW0yKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKGluc2VydFRleHQsIGZpbHRlclRleHQsIHJhbmdlLCBjb21tYW5kKSB7XHJcbiAgICByZXR1cm4geyBpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCB9O1xyXG4gIH1cclxuICBJbmxpbmVDb21wbGV0aW9uSXRlbTIuY3JlYXRlID0gY3JlYXRlO1xyXG59KShJbmxpbmVDb21wbGV0aW9uSXRlbSB8fCAoSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xyXG52YXIgSW5saW5lQ29tcGxldGlvbkxpc3Q7XHJcbihmdW5jdGlvbihJbmxpbmVDb21wbGV0aW9uTGlzdDIpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMpIHtcclxuICAgIHJldHVybiB7IGl0ZW1zIH07XHJcbiAgfVxyXG4gIElubGluZUNvbXBsZXRpb25MaXN0Mi5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKElubGluZUNvbXBsZXRpb25MaXN0IHx8IChJbmxpbmVDb21wbGV0aW9uTGlzdCA9IHt9KSk7XHJcbnZhciBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XHJcbihmdW5jdGlvbihJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQyKSB7XHJcbiAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kMi5JbnZva2VkID0gMDtcclxuICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQyLkF1dG9tYXRpYyA9IDE7XHJcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcclxudmFyIFNlbGVjdGVkQ29tcGxldGlvbkluZm87XHJcbihmdW5jdGlvbihTZWxlY3RlZENvbXBsZXRpb25JbmZvMikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGV4dCkge1xyXG4gICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQgfTtcclxuICB9XHJcbiAgU2VsZWN0ZWRDb21wbGV0aW9uSW5mbzIuY3JlYXRlID0gY3JlYXRlO1xyXG59KShTZWxlY3RlZENvbXBsZXRpb25JbmZvIHx8IChTZWxlY3RlZENvbXBsZXRpb25JbmZvID0ge30pKTtcclxudmFyIElubGluZUNvbXBsZXRpb25Db250ZXh0O1xyXG4oZnVuY3Rpb24oSW5saW5lQ29tcGxldGlvbkNvbnRleHQyKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XHJcbiAgICByZXR1cm4geyB0cmlnZ2VyS2luZCwgc2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB9O1xyXG4gIH1cclxuICBJbmxpbmVDb21wbGV0aW9uQ29udGV4dDIuY3JlYXRlID0gY3JlYXRlO1xyXG59KShJbmxpbmVDb21wbGV0aW9uQ29udGV4dCB8fCAoSW5saW5lQ29tcGxldGlvbkNvbnRleHQgPSB7fSkpO1xyXG52YXIgV29ya3NwYWNlRm9sZGVyO1xyXG4oZnVuY3Rpb24oV29ya3NwYWNlRm9sZGVyMikge1xyXG4gIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XHJcbiAgfVxyXG4gIFdvcmtzcGFjZUZvbGRlcjIuaXMgPSBpcztcclxufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xyXG52YXIgVGV4dERvY3VtZW50O1xyXG4oZnVuY3Rpb24oVGV4dERvY3VtZW50Mykge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcclxuICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnQzLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmVDb3VudCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnQzLmlzID0gaXM7XHJcbiAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcclxuICAgIGxldCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xyXG4gICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0MihlZGl0cywgKGEyLCBiKSA9PiB7XHJcbiAgICAgIGxldCBkaWZmID0gYTIucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcclxuICAgICAgaWYgKGRpZmYgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gYTIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICB9KTtcclxuICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBsZXQgZSA9IHNvcnRlZEVkaXRzW2ldO1xyXG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLnN0YXJ0KTtcclxuICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcclxuICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcclxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcmxhcHBpbmcgZWRpdFwiKTtcclxuICAgICAgfVxyXG4gICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnQzLmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xyXG4gIGZ1bmN0aW9uIG1lcmdlU29ydDIoZGF0YSwgY29tcGFyZSkge1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwID0gZGF0YS5sZW5ndGggLyAyIHwgMDtcclxuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xyXG4gICAgY29uc3QgcmlnaHQgPSBkYXRhLnNsaWNlKHApO1xyXG4gICAgbWVyZ2VTb3J0MihsZWZ0LCBjb21wYXJlKTtcclxuICAgIG1lcmdlU29ydDIocmlnaHQsIGNvbXBhcmUpO1xyXG4gICAgbGV0IGxlZnRJZHggPSAwO1xyXG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcclxuICAgIGxldCBpID0gMDtcclxuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcclxuICAgICAgbGV0IHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcclxuICAgICAgaWYgKHJldCA8PSAwKSB7XHJcbiAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcclxuICAgIH1cclxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xyXG52YXIgRnVsbFRleHREb2N1bWVudCA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3Rvcih1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcclxuICAgIHRoaXMuX3VyaSA9IHVyaTtcclxuICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xyXG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdm9pZCAwO1xyXG4gIH1cclxuICBnZXQgdXJpKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3VyaTtcclxuICB9XHJcbiAgZ2V0IGxhbmd1YWdlSWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcclxuICB9XHJcbiAgZ2V0IHZlcnNpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcclxuICB9XHJcbiAgZ2V0VGV4dChyYW5nZSkge1xyXG4gICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xyXG4gICAgICBsZXQgZW5kID0gdGhpcy5vZmZzZXRBdChyYW5nZS5lbmQpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fY29udGVudDtcclxuICB9XHJcbiAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XHJcbiAgICB0aGlzLl9jb250ZW50ID0gZXZlbnQudGV4dDtcclxuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdGhpcy5fbGluZU9mZnNldHMgPSB2b2lkIDA7XHJcbiAgfVxyXG4gIGdldExpbmVPZmZzZXRzKCkge1xyXG4gICAgaWYgKHRoaXMuX2xpbmVPZmZzZXRzID09PSB2b2lkIDApIHtcclxuICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XHJcbiAgICAgIGxldCB0ZXh0ID0gdGhpcy5fY29udGVudDtcclxuICAgICAgbGV0IGlzTGluZVN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XHJcbiAgICAgICAgICBsaW5lT2Zmc2V0cy5wdXNoKGkpO1xyXG4gICAgICAgICAgaXNMaW5lU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNoID0gdGV4dC5jaGFyQXQoaSk7XHJcbiAgICAgICAgaXNMaW5lU3RhcnQgPSBjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXG5cIjtcclxuICAgICAgICBpZiAoY2ggPT09IFwiXFxyXCIgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09IFwiXFxuXCIpIHtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzTGluZVN0YXJ0ICYmIHRleHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxpbmVPZmZzZXRzLnB1c2godGV4dC5sZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gbGluZU9mZnNldHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fbGluZU9mZnNldHM7XHJcbiAgfVxyXG4gIHBvc2l0aW9uQXQob2Zmc2V0KSB7XHJcbiAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XHJcbiAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XHJcbiAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcclxuICAgIGlmIChoaWdoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgIGxldCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xyXG4gICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xyXG4gICAgICAgIGhpZ2ggPSBtaWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xyXG4gICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XHJcbiAgfVxyXG4gIG9mZnNldEF0KHBvc2l0aW9uKSB7XHJcbiAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XHJcbiAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGxldCBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XHJcbiAgICBsZXQgbmV4dExpbmVPZmZzZXQgPSBwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XHJcbiAgfVxyXG4gIGdldCBsaW5lQ291bnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcclxuICB9XHJcbn07XHJcbnZhciBJcztcclxuKGZ1bmN0aW9uKElzMikge1xyXG4gIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xyXG4gIH1cclxuICBJczIuZGVmaW5lZCA9IGRlZmluZWQ7XHJcbiAgZnVuY3Rpb24gdW5kZWZpbmVkMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcclxuICB9XHJcbiAgSXMyLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDI7XHJcbiAgZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcclxuICB9XHJcbiAgSXMyLmJvb2xlYW4gPSBib29sZWFuO1xyXG4gIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xyXG4gIH1cclxuICBJczIuc3RyaW5nID0gc3RyaW5nO1xyXG4gIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgTnVtYmVyXVwiO1xyXG4gIH1cclxuICBJczIubnVtYmVyID0gbnVtYmVyO1xyXG4gIGZ1bmN0aW9uIG51bWJlclJhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgTnVtYmVyXVwiICYmIG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXg7XHJcbiAgfVxyXG4gIElzMi5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xyXG4gIGZ1bmN0aW9uIGludGVnZXIyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBOdW1iZXJdXCIgJiYgLTIxNDc0ODM2NDggPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcclxuICB9XHJcbiAgSXMyLmludGVnZXIgPSBpbnRlZ2VyMjtcclxuICBmdW5jdGlvbiB1aW50ZWdlcjIodmFsdWUpIHtcclxuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE51bWJlcl1cIiAmJiAwIDw9IHZhbHVlICYmIHZhbHVlIDw9IDIxNDc0ODM2NDc7XHJcbiAgfVxyXG4gIElzMi51aW50ZWdlciA9IHVpbnRlZ2VyMjtcclxuICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcclxuICB9XHJcbiAgSXMyLmZ1bmMgPSBmdW5jO1xyXG4gIGZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XHJcbiAgfVxyXG4gIElzMi5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcclxuICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGNoZWNrKTtcclxuICB9XHJcbiAgSXMyLnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xyXG59KShJcyB8fCAoSXMgPSB7fSkpO1xyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQvbGliL2VzbS9tYWluLmpzXHJcbnZhciBGdWxsVGV4dERvY3VtZW50MiA9IGNsYXNzIF9GdWxsVGV4dERvY3VtZW50IHtcclxuICBjb25zdHJ1Y3Rvcih1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcclxuICAgIHRoaXMuX3VyaSA9IHVyaTtcclxuICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xyXG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdm9pZCAwO1xyXG4gIH1cclxuICBnZXQgdXJpKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3VyaTtcclxuICB9XHJcbiAgZ2V0IGxhbmd1YWdlSWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcclxuICB9XHJcbiAgZ2V0IHZlcnNpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcclxuICB9XHJcbiAgZ2V0VGV4dChyYW5nZSkge1xyXG4gICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XHJcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcbiAgfVxyXG4gIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XHJcbiAgICBmb3IgKGxldCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xyXG4gICAgICBpZiAoX0Z1bGxUZXh0RG9jdW1lbnQuaXNJbmNyZW1lbnRhbChjaGFuZ2UpKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRXZWxsZm9ybWVkUmFuZ2UoY2hhbmdlLnJhbmdlKTtcclxuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcclxuICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcclxuICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xyXG4gICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xyXG4gICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XHJcbiAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxZTQpIHtcclxuICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZSArIDEgKyBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCwgbGVuID0gbGluZU9mZnNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGluZU9mZnNldHNbaV0gPSBsaW5lT2Zmc2V0c1tpXSArIGRpZmY7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKF9GdWxsVGV4dERvY3VtZW50LmlzRnVsbChjaGFuZ2UpKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNoYW5nZS50ZXh0O1xyXG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdm9pZCAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcclxuICB9XHJcbiAgZ2V0TGluZU9mZnNldHMoKSB7XHJcbiAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHZvaWQgMCkge1xyXG4gICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGNvbXB1dGVMaW5lT2Zmc2V0cyh0aGlzLl9jb250ZW50LCB0cnVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcclxuICB9XHJcbiAgcG9zaXRpb25BdChvZmZzZXQpIHtcclxuICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcclxuICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcclxuICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xyXG4gICAgaWYgKGhpZ2ggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHsgbGluZTogMCwgY2hhcmFjdGVyOiBvZmZzZXQgfTtcclxuICAgIH1cclxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgIGxldCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xyXG4gICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xyXG4gICAgICAgIGhpZ2ggPSBtaWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xyXG4gICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xyXG4gIH1cclxuICBvZmZzZXRBdChwb3NpdGlvbikge1xyXG4gICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xyXG4gICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBsZXQgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xyXG4gICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gcG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGggPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcclxuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xyXG4gIH1cclxuICBnZXQgbGluZUNvdW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XHJcbiAgfVxyXG4gIHN0YXRpYyBpc0luY3JlbWVudGFsKGV2ZW50KSB7XHJcbiAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB2b2lkIDAgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gXCJzdHJpbmdcIiAmJiBjYW5kaWRhdGUucmFuZ2UgIT09IHZvaWQgMCAmJiAoY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB2b2lkIDAgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gXCJudW1iZXJcIik7XHJcbiAgfVxyXG4gIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSBldmVudDtcclxuICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHZvaWQgMCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgdHlwZW9mIGNhbmRpZGF0ZS50ZXh0ID09PSBcInN0cmluZ1wiICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdm9pZCAwICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdm9pZCAwO1xyXG4gIH1cclxufTtcclxudmFyIFRleHREb2N1bWVudDI7XHJcbihmdW5jdGlvbihUZXh0RG9jdW1lbnQzKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50Mih1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnQzLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICBmdW5jdGlvbiB1cGRhdGUoZG9jdW1lbnQsIGNoYW5nZXMsIHZlcnNpb24pIHtcclxuICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEZ1bGxUZXh0RG9jdW1lbnQyKSB7XHJcbiAgICAgIGRvY3VtZW50LnVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKTtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGV4dERvY3VtZW50LnVwZGF0ZTogZG9jdW1lbnQgbXVzdCBiZSBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGVcIik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFRleHREb2N1bWVudDMudXBkYXRlID0gdXBkYXRlO1xyXG4gIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XHJcbiAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcclxuICAgIGxldCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYTIsIGIpID0+IHtcclxuICAgICAgbGV0IGRpZmYgPSBhMi5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xyXG4gICAgICBpZiAoZGlmZiA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBhMi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGlmZjtcclxuICAgIH0pO1xyXG4gICAgbGV0IGxhc3RNb2RpZmllZE9mZnNldCA9IDA7XHJcbiAgICBjb25zdCBzcGFucyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBlIG9mIHNvcnRlZEVkaXRzKSB7XHJcbiAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xyXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdmVybGFwcGluZyBlZGl0XCIpO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XHJcbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcclxuICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xyXG4gICAgfVxyXG4gICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcclxuICAgIHJldHVybiBzcGFucy5qb2luKFwiXCIpO1xyXG4gIH1cclxuICBUZXh0RG9jdW1lbnQzLmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xyXG59KShUZXh0RG9jdW1lbnQyIHx8IChUZXh0RG9jdW1lbnQyID0ge30pKTtcclxuZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcclxuICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG4gIGNvbnN0IHAgPSBkYXRhLmxlbmd0aCAvIDIgfCAwO1xyXG4gIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xyXG4gIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcclxuICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XHJcbiAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcclxuICBsZXQgbGVmdElkeCA9IDA7XHJcbiAgbGV0IHJpZ2h0SWR4ID0gMDtcclxuICBsZXQgaSA9IDA7XHJcbiAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgbGV0IHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcclxuICAgIGlmIChyZXQgPD0gMCkge1xyXG4gICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xyXG4gICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xyXG4gIH1cclxuICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcclxuICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcclxuICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBsZXQgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XHJcbiAgICBpZiAoY2ggPT09IDEzIHx8IGNoID09PSAxMCkge1xyXG4gICAgICBpZiAoY2ggPT09IDEzICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTApIHtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0LnB1c2godGV4dE9mZnNldCArIGkgKyAxKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkUmFuZ2UocmFuZ2UpIHtcclxuICBjb25zdCBzdGFydCA9IHJhbmdlLnN0YXJ0O1xyXG4gIGNvbnN0IGVuZCA9IHJhbmdlLmVuZDtcclxuICBpZiAoc3RhcnQubGluZSA+IGVuZC5saW5lIHx8IHN0YXJ0LmxpbmUgPT09IGVuZC5saW5lICYmIHN0YXJ0LmNoYXJhY3RlciA+IGVuZC5jaGFyYWN0ZXIpIHtcclxuICAgIHJldHVybiB7IHN0YXJ0OiBlbmQsIGVuZDogc3RhcnQgfTtcclxuICB9XHJcbiAgcmV0dXJuIHJhbmdlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRFZGl0KHRleHRFZGl0KSB7XHJcbiAgY29uc3QgcmFuZ2UgPSBnZXRXZWxsZm9ybWVkUmFuZ2UodGV4dEVkaXQucmFuZ2UpO1xyXG4gIGlmIChyYW5nZSAhPT0gdGV4dEVkaXQucmFuZ2UpIHtcclxuICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XHJcbiAgfVxyXG4gIHJldHVybiB0ZXh0RWRpdDtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL2pzb25MYW5ndWFnZVR5cGVzLmpzXHJcbnZhciBFcnJvckNvZGU7XHJcbihmdW5jdGlvbihFcnJvckNvZGUyKSB7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiVW5kZWZpbmVkXCJdID0gMF0gPSBcIlVuZGVmaW5lZFwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIkVudW1WYWx1ZU1pc21hdGNoXCJdID0gMV0gPSBcIkVudW1WYWx1ZU1pc21hdGNoXCI7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiRGVwcmVjYXRlZFwiXSA9IDJdID0gXCJEZXByZWNhdGVkXCI7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiXSA9IDI1N10gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAyNThdID0gXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAyNTldID0gXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJJbnZhbGlkVW5pY29kZVwiXSA9IDI2MF0gPSBcIkludmFsaWRVbmljb2RlXCI7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDI2MV0gPSBcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gMjYyXSA9IFwiSW52YWxpZENoYXJhY3RlclwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIlByb3BlcnR5RXhwZWN0ZWRcIl0gPSA1MTNdID0gXCJQcm9wZXJ0eUV4cGVjdGVkXCI7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiQ29tbWFFeHBlY3RlZFwiXSA9IDUxNF0gPSBcIkNvbW1hRXhwZWN0ZWRcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJDb2xvbkV4cGVjdGVkXCJdID0gNTE1XSA9IFwiQ29sb25FeHBlY3RlZFwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIlZhbHVlRXhwZWN0ZWRcIl0gPSA1MTZdID0gXCJWYWx1ZUV4cGVjdGVkXCI7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWRcIl0gPSA1MTddID0gXCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZFwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIkNvbW1hT3JDbG9zZUJyYWNlRXhwZWN0ZWRcIl0gPSA1MThdID0gXCJDb21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkXCI7XHJcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiVHJhaWxpbmdDb21tYVwiXSA9IDUxOV0gPSBcIlRyYWlsaW5nQ29tbWFcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJEdXBsaWNhdGVLZXlcIl0gPSA1MjBdID0gXCJEdXBsaWNhdGVLZXlcIjtcclxuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJDb21tZW50Tm90UGVybWl0dGVkXCJdID0gNTIxXSA9IFwiQ29tbWVudE5vdFBlcm1pdHRlZFwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIlByb3BlcnR5S2V5c011c3RCZURvdWJsZXF1b3RlZFwiXSA9IDUyOF0gPSBcIlByb3BlcnR5S2V5c011c3RCZURvdWJsZXF1b3RlZFwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIlNjaGVtYVJlc29sdmVFcnJvclwiXSA9IDc2OF0gPSBcIlNjaGVtYVJlc29sdmVFcnJvclwiO1xyXG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZVwiXSA9IDc2OV0gPSBcIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZVwiO1xyXG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XHJcbnZhciBTY2hlbWFEcmFmdDtcclxuKGZ1bmN0aW9uKFNjaGVtYURyYWZ0Mikge1xyXG4gIFNjaGVtYURyYWZ0MltTY2hlbWFEcmFmdDJbXCJ2M1wiXSA9IDNdID0gXCJ2M1wiO1xyXG4gIFNjaGVtYURyYWZ0MltTY2hlbWFEcmFmdDJbXCJ2NFwiXSA9IDRdID0gXCJ2NFwiO1xyXG4gIFNjaGVtYURyYWZ0MltTY2hlbWFEcmFmdDJbXCJ2NlwiXSA9IDZdID0gXCJ2NlwiO1xyXG4gIFNjaGVtYURyYWZ0MltTY2hlbWFEcmFmdDJbXCJ2N1wiXSA9IDddID0gXCJ2N1wiO1xyXG4gIFNjaGVtYURyYWZ0MltTY2hlbWFEcmFmdDJbXCJ2MjAxOV8wOVwiXSA9IDE5XSA9IFwidjIwMTlfMDlcIjtcclxuICBTY2hlbWFEcmFmdDJbU2NoZW1hRHJhZnQyW1widjIwMjBfMTJcIl0gPSAyMF0gPSBcInYyMDIwXzEyXCI7XHJcbn0pKFNjaGVtYURyYWZ0IHx8IChTY2hlbWFEcmFmdCA9IHt9KSk7XHJcbnZhciBDbGllbnRDYXBhYmlsaXRpZXM7XHJcbihmdW5jdGlvbihDbGllbnRDYXBhYmlsaXRpZXMyKSB7XHJcbiAgQ2xpZW50Q2FwYWJpbGl0aWVzMi5MQVRFU1QgPSB7XHJcbiAgICB0ZXh0RG9jdW1lbnQ6IHtcclxuICAgICAgY29tcGxldGlvbjoge1xyXG4gICAgICAgIGNvbXBsZXRpb25JdGVtOiB7XHJcbiAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbTWFya3VwS2luZC5NYXJrZG93biwgTWFya3VwS2luZC5QbGFpblRleHRdLFxyXG4gICAgICAgICAgY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ6IHRydWUsXHJcbiAgICAgICAgICBsYWJlbERldGFpbHNTdXBwb3J0OiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufSkoQ2xpZW50Q2FwYWJpbGl0aWVzIHx8IChDbGllbnRDYXBhYmlsaXRpZXMgPSB7fSkpO1xyXG5cclxuLy8gbm9kZV9tb2R1bGVzL0B2c2NvZGUvbDEwbi9kaXN0L2Jyb3dzZXIuanNcclxudmFyIGJ1bmRsZTtcclxuZnVuY3Rpb24gdCguLi5hcmdzKSB7XHJcbiAgY29uc3QgZmlyc3RBcmcgPSBhcmdzWzBdO1xyXG4gIGxldCBrZXk7XHJcbiAgbGV0IG1lc3NhZ2U7XHJcbiAgbGV0IGZvcm1hdEFyZ3M7XHJcbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAga2V5ID0gZmlyc3RBcmc7XHJcbiAgICBtZXNzYWdlID0gZmlyc3RBcmc7XHJcbiAgICBhcmdzLnNwbGljZSgwLCAxKTtcclxuICAgIGZvcm1hdEFyZ3MgPSAhYXJncyB8fCB0eXBlb2YgYXJnc1swXSAhPT0gXCJvYmplY3RcIiA/IGFyZ3MgOiBhcmdzWzBdO1xyXG4gIH0gZWxzZSBpZiAoZmlyc3RBcmcgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0gYXJncy5zbGljZSgxKTtcclxuICAgIGlmIChmaXJzdEFyZy5sZW5ndGggIT09IHJlcGxhY2VtZW50cy5sZW5ndGggKyAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGEgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBsMTBuLnRcIik7XHJcbiAgICB9XHJcbiAgICBsZXQgc3RyID0gZmlyc3RBcmdbMF07XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZpcnN0QXJnLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHN0ciArPSBgeyR7aSAtIDF9fWAgKyBmaXJzdEFyZ1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0KHN0ciwgLi4ucmVwbGFjZW1lbnRzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWVzc2FnZSA9IGZpcnN0QXJnLm1lc3NhZ2U7XHJcbiAgICBrZXkgPSBtZXNzYWdlO1xyXG4gICAgaWYgKGZpcnN0QXJnLmNvbW1lbnQgJiYgZmlyc3RBcmcuY29tbWVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGtleSArPSBgLyR7QXJyYXkuaXNBcnJheShmaXJzdEFyZy5jb21tZW50KSA/IGZpcnN0QXJnLmNvbW1lbnQuam9pbihcIlwiKSA6IGZpcnN0QXJnLmNvbW1lbnR9YDtcclxuICAgIH1cclxuICAgIGZvcm1hdEFyZ3MgPSBmaXJzdEFyZy5hcmdzID8/IHt9O1xyXG4gIH1cclxuICBjb25zdCBtZXNzYWdlRnJvbUJ1bmRsZSA9IGJ1bmRsZT8uW2tleV07XHJcbiAgaWYgKCFtZXNzYWdlRnJvbUJ1bmRsZSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdDMobWVzc2FnZSwgZm9ybWF0QXJncyk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgbWVzc2FnZUZyb21CdW5kbGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBmb3JtYXQzKG1lc3NhZ2VGcm9tQnVuZGxlLCBmb3JtYXRBcmdzKTtcclxuICB9XHJcbiAgaWYgKG1lc3NhZ2VGcm9tQnVuZGxlLmNvbW1lbnQpIHtcclxuICAgIHJldHVybiBmb3JtYXQzKG1lc3NhZ2VGcm9tQnVuZGxlLm1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xyXG4gIH1cclxuICByZXR1cm4gZm9ybWF0MyhtZXNzYWdlLCBmb3JtYXRBcmdzKTtcclxufVxyXG52YXIgX2Zvcm1hdDJSZWdleHAgPSAveyhbXn1dKyl9L2c7XHJcbmZ1bmN0aW9uIGZvcm1hdDModGVtcGxhdGUsIHZhbHVlcykge1xyXG4gIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gIH1cclxuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShfZm9ybWF0MlJlZ2V4cCwgKG1hdGNoLCBncm91cCkgPT4gdmFsdWVzW2dyb3VwXSA/PyBtYXRjaCk7XHJcbn1cclxuXHJcbi8vIG5vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9wYXJzZXIvanNvblBhcnNlci5qc1xyXG52YXIgZm9ybWF0cyA9IHtcclxuICBcImNvbG9yLWhleFwiOiB7IGVycm9yTWVzc2FnZTogdChcIkludmFsaWQgY29sb3IgZm9ybWF0LiBVc2UgI1JHQiwgI1JHQkEsICNSUkdHQkIgb3IgI1JSR0dCQkFBLlwiKSwgcGF0dGVybjogL14jKFswLTlBLUZhLWZdezMsNH18KFswLTlBLUZhLWZdezJ9KXszLDR9KSQvIH0sXHJcbiAgXCJkYXRlLXRpbWVcIjogeyBlcnJvck1lc3NhZ2U6IHQoXCJTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLXRpbWUuXCIpLCBwYXR0ZXJuOiAvXihcXGR7NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlUKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnwoXFwrfC0pKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSkkL2kgfSxcclxuICBcImRhdGVcIjogeyBlcnJvck1lc3NhZ2U6IHQoXCJTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLlwiKSwgcGF0dGVybjogL14oXFxkezR9KS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXxbMTJdWzAtOV18M1swMV0pJC9pIH0sXHJcbiAgXCJ0aW1lXCI6IHsgZXJyb3JNZXNzYWdlOiB0KFwiU3RyaW5nIGlzIG5vdCBhIFJGQzMzMzkgdGltZS5cIiksIHBhdHRlcm46IC9eKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnwoXFwrfC0pKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSkkL2kgfSxcclxuICBcImVtYWlsXCI6IHsgZXJyb3JNZXNzYWdlOiB0KFwiU3RyaW5nIGlzIG5vdCBhbiBlLW1haWwgYWRkcmVzcy5cIiksIHBhdHRlcm46IC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWjAtOS1dK1xcLikrW2EtekEtWl17Mix9KSkkLyB9LFxyXG4gIFwiaG9zdG5hbWVcIjogeyBlcnJvck1lc3NhZ2U6IHQoXCJTdHJpbmcgaXMgbm90IGEgaG9zdG5hbWUuXCIpLCBwYXR0ZXJuOiAvXig/PS57MSwyNTN9XFwuPyQpW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbLTAtOWEtel17MCw2MX1bMC05YS16XSk/KSpcXC4/JC9pIH0sXHJcbiAgXCJpcHY0XCI6IHsgZXJyb3JNZXNzYWdlOiB0KFwiU3RyaW5nIGlzIG5vdCBhbiBJUHY0IGFkZHJlc3MuXCIpLCBwYXR0ZXJuOiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkkLyB9LFxyXG4gIFwiaXB2NlwiOiB7IGVycm9yTWVzc2FnZTogdChcIlN0cmluZyBpcyBub3QgYW4gSVB2NiBhZGRyZXNzLlwiKSwgcGF0dGVybjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2kgfVxyXG59O1xyXG52YXIgQVNUTm9kZUltcGwgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGxlbmd0aCA9IDApIHtcclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICB9XHJcbiAgZ2V0IGNoaWxkcmVuKCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBcInR5cGU6IFwiICsgdGhpcy50eXBlICsgXCIgKFwiICsgdGhpcy5vZmZzZXQgKyBcIi9cIiArIHRoaXMubGVuZ3RoICsgXCIpXCIgKyAodGhpcy5wYXJlbnQgPyBcIiBwYXJlbnQ6IHtcIiArIHRoaXMucGFyZW50LnRvU3RyaW5nKCkgKyBcIn1cIiA6IFwiXCIpO1xyXG4gIH1cclxufTtcclxudmFyIE51bGxBU1ROb2RlSW1wbCA9IGNsYXNzIGV4dGVuZHMgQVNUTm9kZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XHJcbiAgICBzdXBlcihwYXJlbnQsIG9mZnNldCk7XHJcbiAgICB0aGlzLnR5cGUgPSBcIm51bGxcIjtcclxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xyXG4gIH1cclxufTtcclxudmFyIEJvb2xlYW5BU1ROb2RlSW1wbCA9IGNsYXNzIGV4dGVuZHMgQVNUTm9kZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgYm9vbFZhbHVlLCBvZmZzZXQpIHtcclxuICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcclxuICAgIHRoaXMudHlwZSA9IFwiYm9vbGVhblwiO1xyXG4gICAgdGhpcy52YWx1ZSA9IGJvb2xWYWx1ZTtcclxuICB9XHJcbn07XHJcbnZhciBBcnJheUFTVE5vZGVJbXBsID0gY2xhc3MgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XHJcbiAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQpIHtcclxuICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcclxuICAgIHRoaXMudHlwZSA9IFwiYXJyYXlcIjtcclxuICAgIHRoaXMuaXRlbXMgPSBbXTtcclxuICB9XHJcbiAgZ2V0IGNoaWxkcmVuKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXRlbXM7XHJcbiAgfVxyXG59O1xyXG52YXIgTnVtYmVyQVNUTm9kZUltcGwgPSBjbGFzcyBleHRlbmRzIEFTVE5vZGVJbXBsIHtcclxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9mZnNldCkge1xyXG4gICAgc3VwZXIocGFyZW50LCBvZmZzZXQpO1xyXG4gICAgdGhpcy50eXBlID0gXCJudW1iZXJcIjtcclxuICAgIHRoaXMuaXNJbnRlZ2VyID0gdHJ1ZTtcclxuICAgIHRoaXMudmFsdWUgPSBOdW1iZXIuTmFOO1xyXG4gIH1cclxufTtcclxudmFyIFN0cmluZ0FTVE5vZGVJbXBsID0gY2xhc3MgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XHJcbiAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgc3VwZXIocGFyZW50LCBvZmZzZXQsIGxlbmd0aCk7XHJcbiAgICB0aGlzLnR5cGUgPSBcInN0cmluZ1wiO1xyXG4gICAgdGhpcy52YWx1ZSA9IFwiXCI7XHJcbiAgfVxyXG59O1xyXG52YXIgUHJvcGVydHlBU1ROb2RlSW1wbCA9IGNsYXNzIGV4dGVuZHMgQVNUTm9kZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0LCBrZXlOb2RlKSB7XHJcbiAgICBzdXBlcihwYXJlbnQsIG9mZnNldCk7XHJcbiAgICB0aGlzLnR5cGUgPSBcInByb3BlcnR5XCI7XHJcbiAgICB0aGlzLmNvbG9uT2Zmc2V0ID0gLTE7XHJcbiAgICB0aGlzLmtleU5vZGUgPSBrZXlOb2RlO1xyXG4gIH1cclxuICBnZXQgY2hpbGRyZW4oKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZU5vZGUgPyBbdGhpcy5rZXlOb2RlLCB0aGlzLnZhbHVlTm9kZV0gOiBbdGhpcy5rZXlOb2RlXTtcclxuICB9XHJcbn07XHJcbnZhciBPYmplY3RBU1ROb2RlSW1wbCA9IGNsYXNzIGV4dGVuZHMgQVNUTm9kZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XHJcbiAgICBzdXBlcihwYXJlbnQsIG9mZnNldCk7XHJcbiAgICB0aGlzLnR5cGUgPSBcIm9iamVjdFwiO1xyXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gW107XHJcbiAgfVxyXG4gIGdldCBjaGlsZHJlbigpIHtcclxuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcclxuICBpZiAoaXNCb29sZWFuKHNjaGVtYSkpIHtcclxuICAgIHJldHVybiBzY2hlbWEgPyB7fSA6IHsgXCJub3RcIjoge30gfTtcclxuICB9XHJcbiAgcmV0dXJuIHNjaGVtYTtcclxufVxyXG52YXIgRW51bU1hdGNoO1xyXG4oZnVuY3Rpb24oRW51bU1hdGNoMikge1xyXG4gIEVudW1NYXRjaDJbRW51bU1hdGNoMltcIktleVwiXSA9IDBdID0gXCJLZXlcIjtcclxuICBFbnVtTWF0Y2gyW0VudW1NYXRjaDJbXCJFbnVtXCJdID0gMV0gPSBcIkVudW1cIjtcclxufSkoRW51bU1hdGNoIHx8IChFbnVtTWF0Y2ggPSB7fSkpO1xyXG52YXIgc2NoZW1hRHJhZnRGcm9tSWQgPSB7XHJcbiAgXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTAzL3NjaGVtYSNcIjogU2NoZW1hRHJhZnQudjMsXHJcbiAgXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIjogU2NoZW1hRHJhZnQudjQsXHJcbiAgXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA2L3NjaGVtYSNcIjogU2NoZW1hRHJhZnQudjYsXHJcbiAgXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIjogU2NoZW1hRHJhZnQudjcsXHJcbiAgXCJodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L3NjaGVtYVwiOiBTY2hlbWFEcmFmdC52MjAxOV8wOSxcclxuICBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hXCI6IFNjaGVtYURyYWZ0LnYyMDIwXzEyXHJcbn07XHJcbnZhciBFdmFsdWF0aW9uQ29udGV4dCA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihzY2hlbWFEcmFmdCkge1xyXG4gICAgdGhpcy5zY2hlbWFEcmFmdCA9IHNjaGVtYURyYWZ0O1xyXG4gIH1cclxufTtcclxudmFyIFNjaGVtYUNvbGxlY3RvciA9IGNsYXNzIF9TY2hlbWFDb2xsZWN0b3Ige1xyXG4gIGNvbnN0cnVjdG9yKGZvY3VzT2Zmc2V0ID0gLTEsIGV4Y2x1ZGUpIHtcclxuICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBmb2N1c09mZnNldDtcclxuICAgIHRoaXMuZXhjbHVkZSA9IGV4Y2x1ZGU7XHJcbiAgICB0aGlzLnNjaGVtYXMgPSBbXTtcclxuICB9XHJcbiAgYWRkKHNjaGVtYSkge1xyXG4gICAgdGhpcy5zY2hlbWFzLnB1c2goc2NoZW1hKTtcclxuICB9XHJcbiAgbWVyZ2Uob3RoZXIpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2NoZW1hcywgb3RoZXIuc2NoZW1hcyk7XHJcbiAgfVxyXG4gIGluY2x1ZGUobm9kZSkge1xyXG4gICAgcmV0dXJuICh0aGlzLmZvY3VzT2Zmc2V0ID09PSAtMSB8fCBjb250YWluczIobm9kZSwgdGhpcy5mb2N1c09mZnNldCkpICYmIG5vZGUgIT09IHRoaXMuZXhjbHVkZTtcclxuICB9XHJcbiAgbmV3U3ViKCkge1xyXG4gICAgcmV0dXJuIG5ldyBfU2NoZW1hQ29sbGVjdG9yKC0xLCB0aGlzLmV4Y2x1ZGUpO1xyXG4gIH1cclxufTtcclxudmFyIE5vT3BTY2hlbWFDb2xsZWN0b3IgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgfVxyXG4gIGdldCBzY2hlbWFzKCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBhZGQoX3NjaGVtYSkge1xyXG4gIH1cclxuICBtZXJnZShfb3RoZXIpIHtcclxuICB9XHJcbiAgaW5jbHVkZShfbm9kZSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIG5ld1N1YigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufTtcclxuTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSA9IG5ldyBOb09wU2NoZW1hQ29sbGVjdG9yKCk7XHJcbnZhciBWYWxpZGF0aW9uUmVzdWx0ID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5wcm9ibGVtcyA9IFtdO1xyXG4gICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyA9IDA7XHJcbiAgICB0aGlzLnByb2Nlc3NlZFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzID0gMDtcclxuICAgIHRoaXMucHJpbWFyeVZhbHVlTWF0Y2hlcyA9IDA7XHJcbiAgICB0aGlzLmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XHJcbiAgICB0aGlzLmVudW1WYWx1ZXMgPSB2b2lkIDA7XHJcbiAgfVxyXG4gIGhhc1Byb2JsZW1zKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5wcm9ibGVtcy5sZW5ndGg7XHJcbiAgfVxyXG4gIG1lcmdlKHZhbGlkYXRpb25SZXN1bHQpIHtcclxuICAgIHRoaXMucHJvYmxlbXMgPSB0aGlzLnByb2JsZW1zLmNvbmNhdCh2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zKTtcclxuICAgIHRoaXMucHJvcGVydGllc01hdGNoZXMgKz0gdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcztcclxuICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyArPSB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXM7XHJcbiAgICB0aGlzLm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyh2YWxpZGF0aW9uUmVzdWx0KTtcclxuICB9XHJcbiAgbWVyZ2VFbnVtVmFsdWVzKHZhbGlkYXRpb25SZXN1bHQpIHtcclxuICAgIGlmICghdGhpcy5lbnVtVmFsdWVNYXRjaCAmJiAhdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCAmJiB0aGlzLmVudW1WYWx1ZXMgJiYgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzKSB7XHJcbiAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHRoaXMuZW51bVZhbHVlcy5jb25jYXQodmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzKTtcclxuICAgICAgZm9yIChjb25zdCBlcnJvciBvZiB0aGlzLnByb2JsZW1zKSB7XHJcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IEVycm9yQ29kZS5FbnVtVmFsdWVNaXNtYXRjaCkge1xyXG4gICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHQoXCJWYWx1ZSBpcyBub3QgYWNjZXB0ZWQuIFZhbGlkIHZhbHVlczogezB9LlwiLCB0aGlzLmVudW1WYWx1ZXMubWFwKCh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KSkuam9pbihcIiwgXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgbWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCkge1xyXG4gICAgdGhpcy5wcm9ibGVtcyA9IHRoaXMucHJvYmxlbXMuY29uY2F0KHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcyk7XHJcbiAgICB0aGlzLnByb3BlcnRpZXNNYXRjaGVzKys7XHJcbiAgICBpZiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoIHx8ICFwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSAmJiBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMpIHtcclxuICAgICAgdGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoICYmIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzICYmIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMrKztcclxuICAgIH1cclxuICB9XHJcbiAgbWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzKHZhbGlkYXRpb25SZXN1bHQpIHtcclxuICAgIHZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5mb3JFYWNoKChwKSA9PiB0aGlzLnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKHApKTtcclxuICB9XHJcbiAgY29tcGFyZShvdGhlcikge1xyXG4gICAgY29uc3QgaGFzUHJvYmxlbXMgPSB0aGlzLmhhc1Byb2JsZW1zKCk7XHJcbiAgICBpZiAoaGFzUHJvYmxlbXMgIT09IG90aGVyLmhhc1Byb2JsZW1zKCkpIHtcclxuICAgICAgcmV0dXJuIGhhc1Byb2JsZW1zID8gLTEgOiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZW51bVZhbHVlTWF0Y2ggIT09IG90aGVyLmVudW1WYWx1ZU1hdGNoKSB7XHJcbiAgICAgIHJldHVybiBvdGhlci5lbnVtVmFsdWVNYXRjaCA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgIT09IG90aGVyLnByaW1hcnlWYWx1ZU1hdGNoZXMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeVZhbHVlTWF0Y2hlcyAtIG90aGVyLnByaW1hcnlWYWx1ZU1hdGNoZXM7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgLSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllc01hdGNoZXMgLSBvdGhlci5wcm9wZXJ0aWVzTWF0Y2hlcztcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIG5ld0pTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcyA9IFtdKSB7XHJcbiAgcmV0dXJuIG5ldyBKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MsIFtdKTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlVmFsdWUzKG5vZGUpIHtcclxuICByZXR1cm4gZ2V0Tm9kZVZhbHVlMihub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlUGF0aDMobm9kZSkge1xyXG4gIHJldHVybiBnZXROb2RlUGF0aDIobm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gY29udGFpbnMyKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZSkge1xyXG4gIHJldHVybiBvZmZzZXQgPj0gbm9kZS5vZmZzZXQgJiYgb2Zmc2V0IDwgbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCB8fCBpbmNsdWRlUmlnaHRCb3VuZCAmJiBvZmZzZXQgPT09IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGg7XHJcbn1cclxudmFyIEpTT05Eb2N1bWVudCA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3Rvcihyb290LCBzeW50YXhFcnJvcnMgPSBbXSwgY29tbWVudHMgPSBbXSkge1xyXG4gICAgdGhpcy5yb290ID0gcm9vdDtcclxuICAgIHRoaXMuc3ludGF4RXJyb3JzID0gc3ludGF4RXJyb3JzO1xyXG4gICAgdGhpcy5jb21tZW50cyA9IGNvbW1lbnRzO1xyXG4gIH1cclxuICBnZXROb2RlRnJvbU9mZnNldChvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0aGlzLnJvb3QpIHtcclxuICAgICAgcmV0dXJuIGZpbmROb2RlQXRPZmZzZXQyKHRoaXMucm9vdCwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm9pZCAwO1xyXG4gIH1cclxuICB2aXNpdCh2aXNpdG9yKSB7XHJcbiAgICBpZiAodGhpcy5yb290KSB7XHJcbiAgICAgIGNvbnN0IGRvVmlzaXQgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBjdG4gPSB2aXNpdG9yKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGN0bjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN0biA9IGRvVmlzaXQoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3RuO1xyXG4gICAgICB9O1xyXG4gICAgICBkb1Zpc2l0KHRoaXMucm9vdCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhbGlkYXRlKHRleHREb2N1bWVudCwgc2NoZW1hLCBzZXZlcml0eSA9IERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nLCBzY2hlbWFEcmFmdCkge1xyXG4gICAgaWYgKHRoaXMucm9vdCAmJiBzY2hlbWEpIHtcclxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XHJcbiAgICAgIHZhbGlkYXRlKHRoaXMucm9vdCwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBuZXcgRXZhbHVhdGlvbkNvbnRleHQoc2NoZW1hRHJhZnQgPz8gZ2V0U2NoZW1hRHJhZnQoc2NoZW1hKSkpO1xyXG4gICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5tYXAoKHApID0+IHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChwLmxvY2F0aW9uLm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHAubG9jYXRpb24ub2Zmc2V0ICsgcC5sb2NhdGlvbi5sZW5ndGgpKTtcclxuICAgICAgICByZXR1cm4gRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIHAubWVzc2FnZSwgcC5zZXZlcml0eSA/PyBzZXZlcml0eSwgcC5jb2RlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm9pZCAwO1xyXG4gIH1cclxuICBnZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLCBmb2N1c09mZnNldCA9IC0xLCBleGNsdWRlKSB7XHJcbiAgICBpZiAodGhpcy5yb290ICYmIHNjaGVtYSkge1xyXG4gICAgICBjb25zdCBtYXRjaGluZ1NjaGVtYXMgPSBuZXcgU2NoZW1hQ29sbGVjdG9yKGZvY3VzT2Zmc2V0LCBleGNsdWRlKTtcclxuICAgICAgY29uc3Qgc2NoZW1hRHJhZnQgPSBnZXRTY2hlbWFEcmFmdChzY2hlbWEpO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KHNjaGVtYURyYWZ0KTtcclxuICAgICAgdmFsaWRhdGUodGhpcy5yb290LCBzY2hlbWEsIG5ldyBWYWxpZGF0aW9uUmVzdWx0KCksIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XHJcbiAgICAgIHJldHVybiBtYXRjaGluZ1NjaGVtYXMuc2NoZW1hcztcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGdldFNjaGVtYURyYWZ0KHNjaGVtYSwgZmFsbEJhY2sgPSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xyXG4gIGxldCBzY2hlbWFJZCA9IHNjaGVtYS4kc2NoZW1hO1xyXG4gIGlmIChzY2hlbWFJZCkge1xyXG4gICAgcmV0dXJuIHNjaGVtYURyYWZ0RnJvbUlkW3NjaGVtYUlkXSA/PyBmYWxsQmFjaztcclxuICB9XHJcbiAgcmV0dXJuIGZhbGxCYWNrO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlKG4sIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KSB7XHJcbiAgaWYgKCFuIHx8ICFtYXRjaGluZ1NjaGVtYXMuaW5jbHVkZShuKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAobi50eXBlID09PSBcInByb3BlcnR5XCIpIHtcclxuICAgIHJldHVybiB2YWxpZGF0ZShuLnZhbHVlTm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xyXG4gIH1cclxuICBjb25zdCBub2RlID0gbjtcclxuICBfdmFsaWRhdGVOb2RlKCk7XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiYXJyYXlcIjpcclxuICAgICAgX3ZhbGlkYXRlQXJyYXlOb2RlKG5vZGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgX3ZhbGlkYXRlU3RyaW5nTm9kZShub2RlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICBtYXRjaGluZ1NjaGVtYXMuYWRkKHsgbm9kZSwgc2NoZW1hIH0pO1xyXG4gIGZ1bmN0aW9uIF92YWxpZGF0ZU5vZGUoKSB7XHJcbiAgICBmdW5jdGlvbiBtYXRjaGVzVHlwZSh0eXBlKSB7XHJcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IHR5cGUgfHwgdHlwZSA9PT0gXCJpbnRlZ2VyXCIgJiYgbm9kZS50eXBlID09PSBcIm51bWJlclwiICYmIG5vZGUuaXNJbnRlZ2VyO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XHJcbiAgICAgIGlmICghc2NoZW1hLnR5cGUuc29tZShtYXRjaGVzVHlwZSkpIHtcclxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxyXG4gICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KFwiSW5jb3JyZWN0IHR5cGUuIEV4cGVjdGVkIG9uZSBvZiB7MH0uXCIsIHNjaGVtYS50eXBlLmpvaW4oXCIsIFwiKSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSkge1xyXG4gICAgICBpZiAoIW1hdGNoZXNUeXBlKHNjaGVtYS50eXBlKSkge1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXHJcbiAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBcInswfVwiLicsIHNjaGVtYS50eXBlKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XHJcbiAgICAgIGZvciAoY29uc3Qgc3ViU2NoZW1hUmVmIG9mIHNjaGVtYS5hbGxPZikge1xyXG4gICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xyXG4gICAgICAgIGNvbnN0IHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcclxuICAgICAgICB2YWxpZGF0ZShub2RlLCBhc1NjaGVtYShzdWJTY2hlbWFSZWYpLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2Uoc3ViVmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG5vdFNjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYS5ub3QpO1xyXG4gICAgaWYgKG5vdFNjaGVtYSkge1xyXG4gICAgICBjb25zdCBzdWJWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcclxuICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xyXG4gICAgICB2YWxpZGF0ZShub2RlLCBub3RTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XHJcbiAgICAgIGlmICghc3ViVmFsaWRhdGlvblJlc3VsdC5oYXNQcm9ibGVtcygpKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcclxuICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdChcIk1hdGNoZXMgYSBzY2hlbWEgdGhhdCBpcyBub3QgYWxsb3dlZC5cIilcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IG1zIG9mIHN1Yk1hdGNoaW5nU2NoZW1hcy5zY2hlbWFzKSB7XHJcbiAgICAgICAgbXMuaW52ZXJ0ZWQgPSAhbXMuaW52ZXJ0ZWQ7XHJcbiAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmFkZChtcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHRlc3RBbHRlcm5hdGl2ZXMgPSAoYWx0ZXJuYXRpdmVzLCBtYXhPbmVNYXRjaCkgPT4ge1xyXG4gICAgICBjb25zdCBtYXRjaGVzID0gW107XHJcbiAgICAgIGxldCBiZXN0TWF0Y2ggPSB2b2lkIDA7XHJcbiAgICAgIGZvciAoY29uc3Qgc3ViU2NoZW1hUmVmIG9mIGFsdGVybmF0aXZlcykge1xyXG4gICAgICAgIGNvbnN0IHN1YlNjaGVtYSA9IGFzU2NoZW1hKHN1YlNjaGVtYVJlZik7XHJcbiAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XHJcbiAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xyXG4gICAgICAgIHZhbGlkYXRlKG5vZGUsIHN1YlNjaGVtYSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xyXG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YlNjaGVtYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYmVzdE1hdGNoKSB7XHJcbiAgICAgICAgICBiZXN0TWF0Y2ggPSB7IHNjaGVtYTogc3ViU2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0OiBzdWJWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXM6IHN1Yk1hdGNoaW5nU2NoZW1hcyB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIW1heE9uZU1hdGNoICYmICFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkgJiYgIWJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcclxuICAgICAgICAgICAgYmVzdE1hdGNoLm1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xyXG4gICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcyArPSBzdWJWYWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzO1xyXG4gICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcclxuICAgICAgICAgICAgYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzKHN1YlZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlc3VsdCA9IHN1YlZhbGlkYXRpb25SZXN1bHQuY29tcGFyZShiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlUmVzdWx0ID4gMCkge1xyXG4gICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHsgc2NoZW1hOiBzdWJTY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQ6IHN1YlZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hczogc3ViTWF0Y2hpbmdTY2hlbWFzIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZVJlc3VsdCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcclxuICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5tZXJnZUVudW1WYWx1ZXMoc3ViVmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSAmJiBtYXhPbmVNYXRjaCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfSxcclxuICAgICAgICAgIG1lc3NhZ2U6IHQoXCJNYXRjaGVzIG11bHRpcGxlIHNjaGVtYXMgd2hlbiBvbmx5IG9uZSBtdXN0IHZhbGlkYXRlLlwiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChiZXN0TWF0Y2gpIHtcclxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlKGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0KTtcclxuICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2UoYmVzdE1hdGNoLm1hdGNoaW5nU2NoZW1hcyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHtcclxuICAgICAgdGVzdEFsdGVybmF0aXZlcyhzY2hlbWEuYW55T2YsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcclxuICAgICAgdGVzdEFsdGVybmF0aXZlcyhzY2hlbWEub25lT2YsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGVzdEJyYW5jaCA9IChzY2hlbWEyKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xyXG4gICAgICBjb25zdCBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XHJcbiAgICAgIHZhbGlkYXRlKG5vZGUsIGFzU2NoZW1hKHNjaGVtYTIpLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xyXG4gICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlKHN1YlZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB0ZXN0Q29uZGl0aW9uID0gKGlmU2NoZW1hMiwgdGhlblNjaGVtYSwgZWxzZVNjaGVtYSkgPT4ge1xyXG4gICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShpZlNjaGVtYTIpO1xyXG4gICAgICBjb25zdCBzdWJWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcclxuICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xyXG4gICAgICB2YWxpZGF0ZShub2RlLCBzdWJTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XHJcbiAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xyXG4gICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyhzdWJWYWxpZGF0aW9uUmVzdWx0KTtcclxuICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcclxuICAgICAgICBpZiAodGhlblNjaGVtYSkge1xyXG4gICAgICAgICAgdGVzdEJyYW5jaCh0aGVuU2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZWxzZVNjaGVtYSkge1xyXG4gICAgICAgIHRlc3RCcmFuY2goZWxzZVNjaGVtYSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBpZlNjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYS5pZik7XHJcbiAgICBpZiAoaWZTY2hlbWEpIHtcclxuICAgICAgdGVzdENvbmRpdGlvbihpZlNjaGVtYSwgYXNTY2hlbWEoc2NoZW1hLnRoZW4pLCBhc1NjaGVtYShzY2hlbWEuZWxzZSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XHJcbiAgICAgIGNvbnN0IHZhbCA9IGdldE5vZGVWYWx1ZTMobm9kZSk7XHJcbiAgICAgIGxldCBlbnVtVmFsdWVNYXRjaCA9IGZhbHNlO1xyXG4gICAgICBmb3IgKGNvbnN0IGUgb2Ygc2NoZW1hLmVudW0pIHtcclxuICAgICAgICBpZiAoZXF1YWxzKHZhbCwgZSkpIHtcclxuICAgICAgICAgIGVudW1WYWx1ZU1hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgPSBzY2hlbWEuZW51bTtcclxuICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IGVudW1WYWx1ZU1hdGNoO1xyXG4gICAgICBpZiAoIWVudW1WYWx1ZU1hdGNoKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcclxuICAgICAgICAgIGNvZGU6IEVycm9yQ29kZS5FbnVtVmFsdWVNaXNtYXRjaCxcclxuICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdChcIlZhbHVlIGlzIG5vdCBhY2NlcHRlZC4gVmFsaWQgdmFsdWVzOiB7MH0uXCIsIHNjaGVtYS5lbnVtLm1hcCgodikgPT4gSlNPTi5zdHJpbmdpZnkodikpLmpvaW4oXCIsIFwiKSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XHJcbiAgICAgIGNvbnN0IHZhbCA9IGdldE5vZGVWYWx1ZTMobm9kZSk7XHJcbiAgICAgIGlmICghZXF1YWxzKHZhbCwgc2NoZW1hLmNvbnN0KSkge1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXHJcbiAgICAgICAgICBjb2RlOiBFcnJvckNvZGUuRW51bVZhbHVlTWlzbWF0Y2gsXHJcbiAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoXCJWYWx1ZSBtdXN0IGJlIHswfS5cIiwgSlNPTi5zdHJpbmdpZnkoc2NoZW1hLmNvbnN0KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzID0gW3NjaGVtYS5jb25zdF07XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwcmVjYXRpb25NZXNzYWdlID0gc2NoZW1hLmRlcHJlY2F0aW9uTWVzc2FnZTtcclxuICAgIGlmIChkZXByZWNhdGlvbk1lc3NhZ2UgfHwgc2NoZW1hLmRlcHJlY2F0ZWQpIHtcclxuICAgICAgZGVwcmVjYXRpb25NZXNzYWdlID0gZGVwcmVjYXRpb25NZXNzYWdlIHx8IHQoXCJWYWx1ZSBpcyBkZXByZWNhdGVkXCIpO1xyXG4gICAgICBsZXQgdGFyZ2V0Tm9kZSA9IG5vZGUucGFyZW50Py50eXBlID09PSBcInByb3BlcnR5XCIgPyBub2RlLnBhcmVudCA6IG5vZGU7XHJcbiAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiB0YXJnZXROb2RlLm9mZnNldCwgbGVuZ3RoOiB0YXJnZXROb2RlLmxlbmd0aCB9LFxyXG4gICAgICAgIHNldmVyaXR5OiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyxcclxuICAgICAgICBtZXNzYWdlOiBkZXByZWNhdGlvbk1lc3NhZ2UsXHJcbiAgICAgICAgY29kZTogRXJyb3JDb2RlLkRlcHJlY2F0ZWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZTIpIHtcclxuICAgIGNvbnN0IHZhbCA9IG5vZGUyLnZhbHVlO1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRmxvYXRzKGZsb2F0KSB7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gL14oLT9cXGQrKSg/OlxcLihcXGQrKSk/KD86ZShbLStdXFxkKykpPyQvLmV4ZWMoZmxvYXQudG9TdHJpbmcoKSk7XHJcbiAgICAgIHJldHVybiBwYXJ0cyAmJiB7XHJcbiAgICAgICAgdmFsdWU6IE51bWJlcihwYXJ0c1sxXSArIChwYXJ0c1syXSB8fCBcIlwiKSksXHJcbiAgICAgICAgbXVsdGlwbGllcjogKHBhcnRzWzJdPy5sZW5ndGggfHwgMCkgLSAocGFyc2VJbnQocGFydHNbM10pIHx8IDApXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XHJcbiAgICAgIGxldCByZW1haW5kZXIgPSAtMTtcclxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XHJcbiAgICAgICAgcmVtYWluZGVyID0gdmFsICUgc2NoZW1hLm11bHRpcGxlT2Y7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IG5vcm1NdWx0aXBsZU9mID0gbm9ybWFsaXplRmxvYXRzKHNjaGVtYS5tdWx0aXBsZU9mKTtcclxuICAgICAgICBsZXQgbm9ybVZhbHVlID0gbm9ybWFsaXplRmxvYXRzKHZhbCk7XHJcbiAgICAgICAgaWYgKG5vcm1NdWx0aXBsZU9mICYmIG5vcm1WYWx1ZSkge1xyXG4gICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IDEwICoqIE1hdGguYWJzKG5vcm1WYWx1ZS5tdWx0aXBsaWVyIC0gbm9ybU11bHRpcGxlT2YubXVsdGlwbGllcik7XHJcbiAgICAgICAgICBpZiAobm9ybVZhbHVlLm11bHRpcGxpZXIgPCBub3JtTXVsdGlwbGVPZi5tdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgICAgIG5vcm1WYWx1ZS52YWx1ZSAqPSBtdWx0aXBsaWVyO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybU11bHRpcGxlT2YudmFsdWUgKj0gbXVsdGlwbGllcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlbWFpbmRlciA9IG5vcm1WYWx1ZS52YWx1ZSAlIG5vcm1NdWx0aXBsZU9mLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocmVtYWluZGVyICE9PSAwKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgICAgbWVzc2FnZTogdChcIlZhbHVlIGlzIG5vdCBkaXZpc2libGUgYnkgezB9LlwiLCBzY2hlbWEubXVsdGlwbGVPZilcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0RXhjbHVzaXZlTGltaXQobGltaXQsIGV4Y2x1c2l2ZSkge1xyXG4gICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlKSkge1xyXG4gICAgICAgIHJldHVybiBleGNsdXNpdmU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzQm9vbGVhbihleGNsdXNpdmUpICYmIGV4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBsaW1pdDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0TGltaXQobGltaXQsIGV4Y2x1c2l2ZSkge1xyXG4gICAgICBpZiAoIWlzQm9vbGVhbihleGNsdXNpdmUpIHx8ICFleGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gbGltaXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4Y2x1c2l2ZU1pbmltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xyXG4gICAgaWYgKGlzTnVtYmVyKGV4Y2x1c2l2ZU1pbmltdW0pICYmIHZhbCA8PSBleGNsdXNpdmVNaW5pbXVtKSB7XHJcbiAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgbWVzc2FnZTogdChcIlZhbHVlIGlzIGJlbG93IHRoZSBleGNsdXNpdmUgbWluaW11bSBvZiB7MH0uXCIsIGV4Y2x1c2l2ZU1pbmltdW0pXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhjbHVzaXZlTWF4aW11bSA9IGdldEV4Y2x1c2l2ZUxpbWl0KHNjaGVtYS5tYXhpbXVtLCBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSk7XHJcbiAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWF4aW11bSkgJiYgdmFsID49IGV4Y2x1c2l2ZU1heGltdW0pIHtcclxuICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUyLm9mZnNldCwgbGVuZ3RoOiBub2RlMi5sZW5ndGggfSxcclxuICAgICAgICBtZXNzYWdlOiB0KFwiVmFsdWUgaXMgYWJvdmUgdGhlIGV4Y2x1c2l2ZSBtYXhpbXVtIG9mIHswfS5cIiwgZXhjbHVzaXZlTWF4aW11bSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtaW5pbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1pbmltdW0sIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKTtcclxuICAgIGlmIChpc051bWJlcihtaW5pbXVtKSAmJiB2YWwgPCBtaW5pbXVtKSB7XHJcbiAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgbWVzc2FnZTogdChcIlZhbHVlIGlzIGJlbG93IHRoZSBtaW5pbXVtIG9mIHswfS5cIiwgbWluaW11bSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXhpbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1heGltdW0sIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcclxuICAgIGlmIChpc051bWJlcihtYXhpbXVtKSAmJiB2YWwgPiBtYXhpbXVtKSB7XHJcbiAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgbWVzc2FnZTogdChcIlZhbHVlIGlzIGFib3ZlIHRoZSBtYXhpbXVtIG9mIHswfS5cIiwgbWF4aW11bSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF92YWxpZGF0ZVN0cmluZ05vZGUobm9kZTIpIHtcclxuICAgIGlmIChpc051bWJlcihzY2hlbWEubWluTGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZTIudmFsdWUpIDwgc2NoZW1hLm1pbkxlbmd0aCkge1xyXG4gICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgIG1lc3NhZ2U6IHQoXCJTdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB7MH0uXCIsIHNjaGVtYS5taW5MZW5ndGgpXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhMZW5ndGgpICYmIHN0cmluZ0xlbmd0aChub2RlMi52YWx1ZSkgPiBzY2hlbWEubWF4TGVuZ3RoKSB7XHJcbiAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgbWVzc2FnZTogdChcIlN0cmluZyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4aW11bSBsZW5ndGggb2YgezB9LlwiLCBzY2hlbWEubWF4TGVuZ3RoKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0cmluZyhzY2hlbWEucGF0dGVybikpIHtcclxuICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChzY2hlbWEucGF0dGVybik7XHJcbiAgICAgIGlmICghcmVnZXg/LnRlc3Qobm9kZTIudmFsdWUpKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgICAgbWVzc2FnZTogc2NoZW1hLnBhdHRlcm5FcnJvck1lc3NhZ2UgfHwgc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KCdTdHJpbmcgZG9lcyBub3QgbWF0Y2ggdGhlIHBhdHRlcm4gb2YgXCJ7MH1cIi4nLCBzY2hlbWEucGF0dGVybilcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcclxuICAgICAgc3dpdGNoIChzY2hlbWEuZm9ybWF0KSB7XHJcbiAgICAgICAgY2FzZSBcInVyaVwiOlxyXG4gICAgICAgIGNhc2UgXCJ1cmktcmVmZXJlbmNlXCI6XHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGlmICghbm9kZTIudmFsdWUpIHtcclxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KFwiVVJJIGV4cGVjdGVkLlwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IC9eKChbXjovPyNdKz8pOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8vLmV4ZWMobm9kZTIudmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHQoXCJVUkkgaXMgZXhwZWN0ZWQuXCIpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoWzJdICYmIHNjaGVtYS5mb3JtYXQgPT09IFwidXJpXCIpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHQoXCJVUkkgd2l0aCBhIHNjaGVtZSBpcyBleHBlY3RlZC5cIik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoXCJTdHJpbmcgaXMgbm90IGEgVVJJOiB7MH1cIiwgZXJyb3JNZXNzYWdlKVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiY29sb3ItaGV4XCI6XHJcbiAgICAgICAgY2FzZSBcImRhdGUtdGltZVwiOlxyXG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XHJcbiAgICAgICAgY2FzZSBcInRpbWVcIjpcclxuICAgICAgICBjYXNlIFwiZW1haWxcIjpcclxuICAgICAgICBjYXNlIFwiaG9zdG5hbWVcIjpcclxuICAgICAgICBjYXNlIFwiaXB2NFwiOlxyXG4gICAgICAgIGNhc2UgXCJpcHY2XCI6XHJcbiAgICAgICAgICBjb25zdCBmb3JtYXQ1ID0gZm9ybWF0c1tzY2hlbWEuZm9ybWF0XTtcclxuICAgICAgICAgIGlmICghbm9kZTIudmFsdWUgfHwgIWZvcm1hdDUucGF0dGVybi5leGVjKG5vZGUyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5wYXR0ZXJuRXJyb3JNZXNzYWdlIHx8IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgZm9ybWF0NS5lcnJvck1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBfdmFsaWRhdGVBcnJheU5vZGUobm9kZTIpIHtcclxuICAgIGxldCBwcmVmaXhJdGVtc1NjaGVtYXM7XHJcbiAgICBsZXQgYWRkaXRpb25hbEl0ZW1TY2hlbWE7XHJcbiAgICBpZiAoY29udGV4dC5zY2hlbWFEcmFmdCA+PSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xyXG4gICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBzY2hlbWEucHJlZml4SXRlbXM7XHJcbiAgICAgIGFkZGl0aW9uYWxJdGVtU2NoZW1hID0gIUFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSA/IHNjaGVtYS5pdGVtcyA6IHZvaWQgMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByZWZpeEl0ZW1zU2NoZW1hcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSA/IHNjaGVtYS5pdGVtcyA6IHZvaWQgMDtcclxuICAgICAgYWRkaXRpb25hbEl0ZW1TY2hlbWEgPSAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpID8gc2NoZW1hLml0ZW1zIDogc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcclxuICAgIH1cclxuICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICBpZiAocHJlZml4SXRlbXNTY2hlbWFzICE9PSB2b2lkIDApIHtcclxuICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4ocHJlZml4SXRlbXNTY2hlbWFzLmxlbmd0aCwgbm9kZTIuaXRlbXMubGVuZ3RoKTtcclxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViU2NoZW1hUmVmID0gcHJlZml4SXRlbXNTY2hlbWFzW2luZGV4XTtcclxuICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xyXG4gICAgICAgIGNvbnN0IGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcclxuICAgICAgICBjb25zdCBpdGVtID0gbm9kZTIuaXRlbXNbaW5kZXhdO1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZShpdGVtLCBzdWJTY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYWRkaXRpb25hbEl0ZW1TY2hlbWEgIT09IHZvaWQgMCAmJiBpbmRleCA8IG5vZGUyLml0ZW1zLmxlbmd0aCkge1xyXG4gICAgICBpZiAodHlwZW9mIGFkZGl0aW9uYWxJdGVtU2NoZW1hID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgICAgICBtZXNzYWdlOiB0KFwiQXJyYXkgaGFzIHRvbyBtYW55IGl0ZW1zIGFjY29yZGluZyB0byBzY2hlbWEuIEV4cGVjdGVkIHswfSBvciBmZXdlci5cIiwgaW5kZXgpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbm9kZTIuaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xyXG4gICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IG5vZGUyLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgY29uc3QgaXRlbVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xyXG4gICAgICAgICAgdmFsaWRhdGUobm9kZTIuaXRlbXNbaW5kZXhdLCBhZGRpdGlvbmFsSXRlbVNjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XHJcbiAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChpdGVtVmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbnNTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuY29udGFpbnMpO1xyXG4gICAgaWYgKGNvbnRhaW5zU2NoZW1hKSB7XHJcbiAgICAgIGxldCBjb250YWluc0NvdW50ID0gMDtcclxuICAgICAgZm9yIChsZXQgaW5kZXgyID0gMDsgaW5kZXgyIDwgbm9kZTIuaXRlbXMubGVuZ3RoOyBpbmRleDIrKykge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlMi5pdGVtc1tpbmRleDJdO1xyXG4gICAgICAgIGNvbnN0IGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcclxuICAgICAgICB2YWxpZGF0ZShpdGVtLCBjb250YWluc1NjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIE5vT3BTY2hlbWFDb2xsZWN0b3IuaW5zdGFuY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmICghaXRlbVZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xyXG4gICAgICAgICAgY29udGFpbnNDb3VudCsrO1xyXG4gICAgICAgICAgaWYgKGNvbnRleHQuc2NoZW1hRHJhZnQgPj0gU2NoZW1hRHJhZnQudjIwMjBfMTIpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgyKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb250YWluc0NvdW50ID09PSAwICYmICFpc051bWJlcihzY2hlbWEubWluQ29udGFpbnMpKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KFwiQXJyYXkgZG9lcyBub3QgY29udGFpbiByZXF1aXJlZCBpdGVtLlwiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluQ29udGFpbnMpICYmIGNvbnRhaW5zQ291bnQgPCBzY2hlbWEubWluQ29udGFpbnMpIHtcclxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoXCJBcnJheSBoYXMgdG9vIGZldyBpdGVtcyB0aGF0IG1hdGNoIHRoZSBjb250YWlucyBjb250cmFpbnQuIEV4cGVjdGVkIHswfSBvciBtb3JlLlwiLCBzY2hlbWEubWluQ29udGFpbnMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhDb250YWlucykgJiYgY29udGFpbnNDb3VudCA+IHNjaGVtYS5tYXhDb250YWlucykge1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUyLm9mZnNldCwgbGVuZ3RoOiBub2RlMi5sZW5ndGggfSxcclxuICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdChcIkFycmF5IGhhcyB0b28gbWFueSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBjb250YWlucyBjb250cmFpbnQuIEV4cGVjdGVkIHswfSBvciBsZXNzLlwiLCBzY2hlbWEubWF4Q29udGFpbnMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHVuZXZhbHVhdGVkSXRlbXMgPSBzY2hlbWEudW5ldmFsdWF0ZWRJdGVtcztcclxuICAgIGlmICh1bmV2YWx1YXRlZEl0ZW1zICE9PSB2b2lkIDApIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlMi5pdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmhhcyhTdHJpbmcoaSkpKSB7XHJcbiAgICAgICAgICBpZiAodW5ldmFsdWF0ZWRJdGVtcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUyLm9mZnNldCwgbGVuZ3RoOiBub2RlMi5sZW5ndGggfSxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiB0KFwiSXRlbSBkb2VzIG5vdCBtYXRjaCBhbnkgdmFsaWRhdGlvbiBydWxlIGZyb20gdGhlIGFycmF5LlwiKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcclxuICAgICAgICAgICAgdmFsaWRhdGUobm9kZTIuaXRlbXNbaV0sIHNjaGVtYS51bmV2YWx1YXRlZEl0ZW1zLCBpdGVtVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpKSk7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmIG5vZGUyLml0ZW1zLmxlbmd0aCA8IHNjaGVtYS5taW5JdGVtcykge1xyXG4gICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgIG1lc3NhZ2U6IHQoXCJBcnJheSBoYXMgdG9vIGZldyBpdGVtcy4gRXhwZWN0ZWQgezB9IG9yIG1vcmUuXCIsIHNjaGVtYS5taW5JdGVtcylcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1heEl0ZW1zKSAmJiBub2RlMi5pdGVtcy5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpIHtcclxuICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUyLm9mZnNldCwgbGVuZ3RoOiBub2RlMi5sZW5ndGggfSxcclxuICAgICAgICBtZXNzYWdlOiB0KFwiQXJyYXkgaGFzIHRvbyBtYW55IGl0ZW1zLiBFeHBlY3RlZCB7MH0gb3IgZmV3ZXIuXCIsIHNjaGVtYS5tYXhJdGVtcylcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hLnVuaXF1ZUl0ZW1zID09PSB0cnVlKSB7XHJcbiAgICAgIGxldCBoYXNEdXBsaWNhdGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoZXF1YWxzKHZhbHVlLCB2YWx1ZXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSBnZXROb2RlVmFsdWUzKG5vZGUyKTtcclxuICAgICAgaWYgKGhhc0R1cGxpY2F0ZXMoKSkge1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUyLm9mZnNldCwgbGVuZ3RoOiBub2RlMi5sZW5ndGggfSxcclxuICAgICAgICAgIG1lc3NhZ2U6IHQoXCJBcnJheSBoYXMgZHVwbGljYXRlIGl0ZW1zLlwiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF92YWxpZGF0ZU9iamVjdE5vZGUobm9kZTIpIHtcclxuICAgIGNvbnN0IHNlZW5LZXlzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBjb25zdCB1bnByb2Nlc3NlZFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eU5vZGUgb2Ygbm9kZTIucHJvcGVydGllcykge1xyXG4gICAgICBjb25zdCBrZXkgPSBwcm9wZXJ0eU5vZGUua2V5Tm9kZS52YWx1ZTtcclxuICAgICAgc2VlbktleXNba2V5XSA9IHByb3BlcnR5Tm9kZS52YWx1ZU5vZGU7XHJcbiAgICAgIHVucHJvY2Vzc2VkUHJvcGVydGllcy5hZGQoa2V5KTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkpIHtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgaWYgKCFzZWVuS2V5c1twcm9wZXJ0eU5hbWVdKSB7XHJcbiAgICAgICAgICBjb25zdCBrZXlOb2RlID0gbm9kZTIucGFyZW50ICYmIG5vZGUyLnBhcmVudC50eXBlID09PSBcInByb3BlcnR5XCIgJiYgbm9kZTIucGFyZW50LmtleU5vZGU7XHJcbiAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGtleU5vZGUgPyB7IG9mZnNldDoga2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDoga2V5Tm9kZS5sZW5ndGggfSA6IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogMSB9O1xyXG4gICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ01pc3NpbmcgcHJvcGVydHkgXCJ7MH1cIi4nLCBwcm9wZXJ0eU5hbWUpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BlcnR5UHJvY2Vzc2VkID0gKHByb3ApID0+IHtcclxuICAgICAgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKTtcclxuICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcclxuICAgIH07XHJcbiAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMpIHtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgcHJvcGVydHlQcm9jZXNzZWQocHJvcGVydHlOYW1lKTtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBzZWVuS2V5c1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgaWYgKGlzQm9vbGVhbihwcm9wZXJ0eVNjaGVtYSkpIHtcclxuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eVNjaGVtYSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IGNoaWxkLnBhcmVudDtcclxuICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoXCJQcm9wZXJ0eSB7MH0gaXMgbm90IGFsbG93ZWQuXCIsIHByb3BlcnR5TmFtZSlcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzKys7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlKGNoaWxkLCBwcm9wZXJ0eVNjaGVtYSwgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xyXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5UGF0dGVybiBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChwcm9wZXJ0eVBhdHRlcm4pO1xyXG4gICAgICAgIGlmIChyZWdleCkge1xyXG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gW107XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzZWVuS2V5c1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcHJvcGVydHlQYXR0ZXJuXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ocHJvcGVydHlTY2hlbWEpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlTY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KFwiUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLlwiLCBwcm9wZXJ0eU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xyXG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2gocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHByb2Nlc3NlZC5mb3JFYWNoKHByb3BlcnR5UHJvY2Vzc2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xyXG4gICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB2b2lkIDApIHtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgcHJvcGVydHlQcm9jZXNzZWQocHJvcGVydHlOYW1lKTtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IGNoaWxkLnBhcmVudDtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5sZW5ndGggfSxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoXCJQcm9wZXJ0eSB7MH0gaXMgbm90IGFsbG93ZWQuXCIsIHByb3BlcnR5TmFtZSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlKGNoaWxkLCBhZGRpdGlvbmFsUHJvcGVydGllcywgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzID0gc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcztcclxuICAgIGlmICh1bmV2YWx1YXRlZFByb3BlcnRpZXMgIT09IHZvaWQgMCkge1xyXG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuaGFzKHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KFwiUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLlwiLCBwcm9wZXJ0eU5hbWUpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5ldmFsdWF0ZWRQcm9wZXJ0aWVzICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcclxuICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2gocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwcm9jZXNzZWQuZm9yRWFjaChwcm9wZXJ0eVByb2Nlc3NlZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1heFByb3BlcnRpZXMpKSB7XHJcbiAgICAgIGlmIChub2RlMi5wcm9wZXJ0aWVzLmxlbmd0aCA+IHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcclxuICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZTIub2Zmc2V0LCBsZW5ndGg6IG5vZGUyLmxlbmd0aCB9LFxyXG4gICAgICAgICAgbWVzc2FnZTogdChcIk9iamVjdCBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gbGltaXQgb2YgezB9LlwiLCBzY2hlbWEubWF4UHJvcGVydGllcylcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xyXG4gICAgICBpZiAobm9kZTIucHJvcGVydGllcy5sZW5ndGggPCBzY2hlbWEubWluUHJvcGVydGllcykge1xyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUyLm9mZnNldCwgbGVuZ3RoOiBub2RlMi5sZW5ndGggfSxcclxuICAgICAgICAgIG1lc3NhZ2U6IHQoXCJPYmplY3QgaGFzIGZld2VyIHByb3BlcnRpZXMgdGhhbiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIHswfVwiLCBzY2hlbWEubWluUHJvcGVydGllcylcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYS5kZXBlbmRlbnRSZXF1aXJlZCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWQpIHtcclxuICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWRba2V5XTtcclxuICAgICAgICBpZiAocHJvcCAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5RGVwcykpIHtcclxuICAgICAgICAgIF92YWxpZGF0ZVByb3BlcnR5RGVwZW5kZW5jaWVzKGtleSwgcHJvcGVydHlEZXBzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzY2hlbWEuZGVwZW5kZW50U2NoZW1hcykge1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZGVwZW5kZW50U2NoZW1hcykge1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBzZWVuS2V5c1trZXldO1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHNjaGVtYS5kZXBlbmRlbnRTY2hlbWFzW2tleV07XHJcbiAgICAgICAgaWYgKHByb3AgJiYgaXNPYmplY3QocHJvcGVydHlEZXBzKSkge1xyXG4gICAgICAgICAgX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmRlcGVuZGVuY2llcykge1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBzZWVuS2V5c1trZXldO1xyXG4gICAgICAgIGlmIChwcm9wKSB7XHJcbiAgICAgICAgICBfdmFsaWRhdGVQcm9wZXJ0eURlcGVuZGVuY2llcyhrZXksIHNjaGVtYS5kZXBlbmRlbmNpZXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gYXNTY2hlbWEoc2NoZW1hLnByb3BlcnR5TmFtZXMpO1xyXG4gICAgaWYgKHByb3BlcnR5TmFtZXMpIHtcclxuICAgICAgZm9yIChjb25zdCBmMiBvZiBub2RlMi5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZjIua2V5Tm9kZTtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZShrZXksIHByb3BlcnR5TmFtZXMsIHZhbGlkYXRpb25SZXN1bHQsIE5vT3BTY2hlbWFDb2xsZWN0b3IuaW5zdGFuY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcCkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eURlcCkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkUHJvcCBvZiBwcm9wZXJ0eURlcCkge1xyXG4gICAgICAgICAgaWYgKCFzZWVuS2V5c1tyZXF1aXJlZFByb3BdKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlMi5vZmZzZXQsIGxlbmd0aDogbm9kZTIubGVuZ3RoIH0sXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogdChcIk9iamVjdCBpcyBtaXNzaW5nIHByb3BlcnR5IHswfSByZXF1aXJlZCBieSBwcm9wZXJ0eSB7MX0uXCIsIHJlcXVpcmVkUHJvcCwga2V5KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IGFzU2NoZW1hKHByb3BlcnR5RGVwKTtcclxuICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEpIHtcclxuICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XHJcbiAgICAgICAgICB2YWxpZGF0ZShub2RlMiwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcclxuICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlMyh0ZXh0RG9jdW1lbnQsIGNvbmZpZykge1xyXG4gIGNvbnN0IHByb2JsZW1zID0gW107XHJcbiAgbGV0IGxhc3RQcm9ibGVtT2Zmc2V0ID0gLTE7XHJcbiAgY29uc3QgdGV4dCA9IHRleHREb2N1bWVudC5nZXRUZXh0KCk7XHJcbiAgY29uc3Qgc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIyKHRleHQsIGZhbHNlKTtcclxuICBjb25zdCBjb21tZW50UmFuZ2VzID0gY29uZmlnICYmIGNvbmZpZy5jb2xsZWN0Q29tbWVudHMgPyBbXSA6IHZvaWQgMDtcclxuICBmdW5jdGlvbiBfc2Nhbk5leHQoKSB7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICBjb25zdCB0b2tlbjIgPSBzY2FubmVyLnNjYW4oKTtcclxuICAgICAgX2NoZWNrU2NhbkVycm9yKCk7XHJcbiAgICAgIHN3aXRjaCAodG9rZW4yKSB7XHJcbiAgICAgICAgY2FzZSAxMjpcclxuICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWVudFJhbmdlcykpIHtcclxuICAgICAgICAgICAgY29tbWVudFJhbmdlcy5wdXNoKFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIHRva2VuMjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBfYWNjZXB0KHRva2VuMikge1xyXG4gICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gdG9rZW4yKSB7XHJcbiAgICAgIF9zY2FuTmV4dCgpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBzZXZlcml0eSA9IERpYWdub3N0aWNTZXZlcml0eS5FcnJvcikge1xyXG4gICAgaWYgKHByb2JsZW1zLmxlbmd0aCA9PT0gMCB8fCBzdGFydE9mZnNldCAhPT0gbGFzdFByb2JsZW1PZmZzZXQpIHtcclxuICAgICAgY29uc3QgcmFuZ2UgPSBSYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc3RhcnRPZmZzZXQpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChlbmRPZmZzZXQpKTtcclxuICAgICAgcHJvYmxlbXMucHVzaChEaWFnbm9zdGljLmNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHRleHREb2N1bWVudC5sYW5ndWFnZUlkKSk7XHJcbiAgICAgIGxhc3RQcm9ibGVtT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF9lcnJvcihtZXNzYWdlLCBjb2RlLCBub2RlID0gdm9pZCAwLCBza2lwVW50aWxBZnRlciA9IFtdLCBza2lwVW50aWwgPSBbXSkge1xyXG4gICAgbGV0IHN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xyXG4gICAgbGV0IGVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKTtcclxuICAgIGlmIChzdGFydCA9PT0gZW5kICYmIHN0YXJ0ID4gMCkge1xyXG4gICAgICBzdGFydC0tO1xyXG4gICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIC9cXHMvLnRlc3QodGV4dC5jaGFyQXQoc3RhcnQpKSkge1xyXG4gICAgICAgIHN0YXJ0LS07XHJcbiAgICAgIH1cclxuICAgICAgZW5kID0gc3RhcnQgKyAxO1xyXG4gICAgfVxyXG4gICAgX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydCwgZW5kKTtcclxuICAgIGlmIChub2RlKSB7XHJcbiAgICAgIF9maW5hbGl6ZShub2RlLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2tpcFVudGlsQWZ0ZXIubGVuZ3RoICsgc2tpcFVudGlsLmxlbmd0aCA+IDApIHtcclxuICAgICAgbGV0IHRva2VuMiA9IHNjYW5uZXIuZ2V0VG9rZW4oKTtcclxuICAgICAgd2hpbGUgKHRva2VuMiAhPT0gMTcpIHtcclxuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIuaW5kZXhPZih0b2tlbjIpICE9PSAtMSkge1xyXG4gICAgICAgICAgX3NjYW5OZXh0KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKHNraXBVbnRpbC5pbmRleE9mKHRva2VuMikgIT09IC0xKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW4yID0gX3NjYW5OZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBfY2hlY2tTY2FuRXJyb3IoKSB7XHJcbiAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICBfZXJyb3IodChcIkludmFsaWQgdW5pY29kZSBzZXF1ZW5jZSBpbiBzdHJpbmcuXCIpLCBFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlIDU6XHJcbiAgICAgICAgX2Vycm9yKHQoXCJJbnZhbGlkIGVzY2FwZSBjaGFyYWN0ZXIgaW4gc3RyaW5nLlwiKSwgRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgX2Vycm9yKHQoXCJVbmV4cGVjdGVkIGVuZCBvZiBudW1iZXIuXCIpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIF9lcnJvcih0KFwiVW5leHBlY3RlZCBlbmQgb2YgY29tbWVudC5cIiksIEVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZDb21tZW50KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIF9lcnJvcih0KFwiVW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nLlwiKSwgRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgNjpcclxuICAgICAgICBfZXJyb3IodChcIkludmFsaWQgY2hhcmFjdGVycyBpbiBzdHJpbmcuIENvbnRyb2wgY2hhcmFjdGVycyBtdXN0IGJlIGVzY2FwZWQuXCIpLCBFcnJvckNvZGUuSW52YWxpZENoYXJhY3Rlcik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF9maW5hbGl6ZShub2RlLCBzY2FuTmV4dCkge1xyXG4gICAgbm9kZS5sZW5ndGggPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgLSBub2RlLm9mZnNldDtcclxuICAgIGlmIChzY2FuTmV4dCkge1xyXG4gICAgICBfc2Nhbk5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBfcGFyc2VBcnJheShwYXJlbnQpIHtcclxuICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDMpIHtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vZGUgPSBuZXcgQXJyYXlBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XHJcbiAgICBfc2Nhbk5leHQoKTtcclxuICAgIGNvbnN0IGNvdW50ID0gMDtcclxuICAgIGxldCBuZWVkc0NvbW1hID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSA0ICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcpIHtcclxuICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSkge1xyXG4gICAgICAgIGlmICghbmVlZHNDb21tYSkge1xyXG4gICAgICAgICAgX2Vycm9yKHQoXCJWYWx1ZSBleHBlY3RlZFwiKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcclxuICAgICAgICBfc2Nhbk5leHQoKTtcclxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA0KSB7XHJcbiAgICAgICAgICBpZiAobmVlZHNDb21tYSkge1xyXG4gICAgICAgICAgICBfZXJyb3JBdFJhbmdlKHQoXCJUcmFpbGluZyBjb21tYVwiKSwgRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEsIGNvbW1hT2Zmc2V0LCBjb21tYU9mZnNldCArIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcclxuICAgICAgICBfZXJyb3IodChcIkV4cGVjdGVkIGNvbW1hXCIpLCBFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaXRlbSA9IF9wYXJzZVZhbHVlKG5vZGUpO1xyXG4gICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICBfZXJyb3IodChcIlZhbHVlIGV4cGVjdGVkXCIpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCwgdm9pZCAwLCBbXSwgW1xyXG4gICAgICAgICAgNCxcclxuICAgICAgICAgIDVcclxuICAgICAgICAgIC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCkge1xyXG4gICAgICByZXR1cm4gX2Vycm9yKHQoXCJFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNrZXRcIiksIEVycm9yQ29kZS5Db21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xyXG4gIH1cclxuICBjb25zdCBrZXlQbGFjZWhvbGRlciA9IG5ldyBTdHJpbmdBU1ROb2RlSW1wbCh2b2lkIDAsIDAsIDApO1xyXG4gIGZ1bmN0aW9uIF9wYXJzZVByb3BlcnR5KHBhcmVudCwga2V5c1NlZW4pIHtcclxuICAgIGNvbnN0IG5vZGUgPSBuZXcgUHJvcGVydHlBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwga2V5UGxhY2Vob2xkZXIpO1xyXG4gICAgbGV0IGtleSA9IF9wYXJzZVN0cmluZyhub2RlKTtcclxuICAgIGlmICgha2V5KSB7XHJcbiAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDE2KSB7XHJcbiAgICAgICAgX2Vycm9yKHQoXCJQcm9wZXJ0eSBrZXlzIG11c3QgYmUgZG91YmxlcXVvdGVkXCIpLCBFcnJvckNvZGUuUHJvcGVydHlLZXlzTXVzdEJlRG91YmxlcXVvdGVkKTtcclxuICAgICAgICBjb25zdCBrZXlOb2RlID0gbmV3IFN0cmluZ0FTVE5vZGVJbXBsKG5vZGUsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKTtcclxuICAgICAgICBrZXlOb2RlLnZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XHJcbiAgICAgICAga2V5ID0ga2V5Tm9kZTtcclxuICAgICAgICBfc2Nhbk5leHQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBub2RlLmtleU5vZGUgPSBrZXk7XHJcbiAgICBpZiAoa2V5LnZhbHVlICE9PSBcIi8vXCIpIHtcclxuICAgICAgY29uc3Qgc2VlbiA9IGtleXNTZWVuW2tleS52YWx1ZV07XHJcbiAgICAgIGlmIChzZWVuKSB7XHJcbiAgICAgICAgX2Vycm9yQXRSYW5nZSh0KFwiRHVwbGljYXRlIG9iamVjdCBrZXlcIiksIEVycm9yQ29kZS5EdXBsaWNhdGVLZXksIG5vZGUua2V5Tm9kZS5vZmZzZXQsIG5vZGUua2V5Tm9kZS5vZmZzZXQgKyBub2RlLmtleU5vZGUubGVuZ3RoLCBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNlZW4pKSB7XHJcbiAgICAgICAgICBfZXJyb3JBdFJhbmdlKHQoXCJEdXBsaWNhdGUgb2JqZWN0IGtleVwiKSwgRXJyb3JDb2RlLkR1cGxpY2F0ZUtleSwgc2Vlbi5rZXlOb2RlLm9mZnNldCwgc2Vlbi5rZXlOb2RlLm9mZnNldCArIHNlZW4ua2V5Tm9kZS5sZW5ndGgsIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5c1NlZW5ba2V5LnZhbHVlXSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAga2V5c1NlZW5ba2V5LnZhbHVlXSA9IG5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDYpIHtcclxuICAgICAgbm9kZS5jb2xvbk9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcclxuICAgICAgX3NjYW5OZXh0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfZXJyb3IodChcIkNvbG9uIGV4cGVjdGVkXCIpLCBFcnJvckNvZGUuQ29sb25FeHBlY3RlZCk7XHJcbiAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDEwICYmIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGtleS5vZmZzZXQgKyBrZXkubGVuZ3RoKS5saW5lIDwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lKSB7XHJcbiAgICAgICAgbm9kZS5sZW5ndGggPSBrZXkubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZSA9IF9wYXJzZVZhbHVlKG5vZGUpO1xyXG4gICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gX2Vycm9yKHQoXCJWYWx1ZSBleHBlY3RlZFwiKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIG5vZGUsIFtdLCBbXHJcbiAgICAgICAgMixcclxuICAgICAgICA1XHJcbiAgICAgICAgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9cclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBub2RlLnZhbHVlTm9kZSA9IHZhbHVlO1xyXG4gICAgbm9kZS5sZW5ndGggPSB2YWx1ZS5vZmZzZXQgKyB2YWx1ZS5sZW5ndGggLSBub2RlLm9mZnNldDtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBfcGFyc2VPYmplY3QocGFyZW50KSB7XHJcbiAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxKSB7XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub2RlID0gbmV3IE9iamVjdEFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKTtcclxuICAgIGNvbnN0IGtleXNTZWVuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBfc2Nhbk5leHQoKTtcclxuICAgIGxldCBuZWVkc0NvbW1hID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcpIHtcclxuICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSkge1xyXG4gICAgICAgIGlmICghbmVlZHNDb21tYSkge1xyXG4gICAgICAgICAgX2Vycm9yKHQoXCJQcm9wZXJ0eSBleHBlY3RlZFwiKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcclxuICAgICAgICBfc2Nhbk5leHQoKTtcclxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSAyKSB7XHJcbiAgICAgICAgICBpZiAobmVlZHNDb21tYSkge1xyXG4gICAgICAgICAgICBfZXJyb3JBdFJhbmdlKHQoXCJUcmFpbGluZyBjb21tYVwiKSwgRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEsIGNvbW1hT2Zmc2V0LCBjb21tYU9mZnNldCArIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcclxuICAgICAgICBfZXJyb3IodChcIkV4cGVjdGVkIGNvbW1hXCIpLCBFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcHJvcGVydHkgPSBfcGFyc2VQcm9wZXJ0eShub2RlLCBrZXlzU2Vlbik7XHJcbiAgICAgIGlmICghcHJvcGVydHkpIHtcclxuICAgICAgICBfZXJyb3IodChcIlByb3BlcnR5IGV4cGVjdGVkXCIpLCBFcnJvckNvZGUuUHJvcGVydHlFeHBlY3RlZCwgdm9pZCAwLCBbXSwgW1xyXG4gICAgICAgICAgMixcclxuICAgICAgICAgIDVcclxuICAgICAgICAgIC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xyXG4gICAgICB9XHJcbiAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMikge1xyXG4gICAgICByZXR1cm4gX2Vycm9yKHQoXCJFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNlXCIpLCBFcnJvckNvZGUuQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBfcGFyc2VTdHJpbmcocGFyZW50KSB7XHJcbiAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxMCkge1xyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBTdHJpbmdBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XHJcbiAgICBub2RlLnZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XHJcbiAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBfcGFyc2VOdW1iZXIocGFyZW50KSB7XHJcbiAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxMSkge1xyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBOdW1iZXJBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XHJcbiAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkgPT09IDApIHtcclxuICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG51bWJlclZhbHVlID0gSlNPTi5wYXJzZSh0b2tlblZhbHVlKTtcclxuICAgICAgICBpZiAoIWlzTnVtYmVyKG51bWJlclZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIF9lcnJvcih0KFwiSW52YWxpZCBudW1iZXIgZm9ybWF0LlwiKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUudmFsdWUgPSBudW1iZXJWYWx1ZTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBfZXJyb3IodChcIkludmFsaWQgbnVtYmVyIGZvcm1hdC5cIiksIEVycm9yQ29kZS5VbmRlZmluZWQsIG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICAgIG5vZGUuaXNJbnRlZ2VyID0gdG9rZW5WYWx1ZS5pbmRleE9mKFwiLlwiKSA9PT0gLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBfcGFyc2VMaXRlcmFsKHBhcmVudCkge1xyXG4gICAgbGV0IG5vZGU7XHJcbiAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW4oKSkge1xyXG4gICAgICBjYXNlIDc6XHJcbiAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShuZXcgTnVsbEFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XHJcbiAgICAgIGNhc2UgODpcclxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCB0cnVlLCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcclxuICAgICAgY2FzZSA5OlxyXG4gICAgICAgIHJldHVybiBfZmluYWxpemUobmV3IEJvb2xlYW5BU1ROb2RlSW1wbChwYXJlbnQsIGZhbHNlLCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBfcGFyc2VWYWx1ZShwYXJlbnQpIHtcclxuICAgIHJldHVybiBfcGFyc2VBcnJheShwYXJlbnQpIHx8IF9wYXJzZU9iamVjdChwYXJlbnQpIHx8IF9wYXJzZVN0cmluZyhwYXJlbnQpIHx8IF9wYXJzZU51bWJlcihwYXJlbnQpIHx8IF9wYXJzZUxpdGVyYWwocGFyZW50KTtcclxuICB9XHJcbiAgbGV0IF9yb290ID0gdm9pZCAwO1xyXG4gIGNvbnN0IHRva2VuID0gX3NjYW5OZXh0KCk7XHJcbiAgaWYgKHRva2VuICE9PSAxNykge1xyXG4gICAgX3Jvb3QgPSBfcGFyc2VWYWx1ZShfcm9vdCk7XHJcbiAgICBpZiAoIV9yb290KSB7XHJcbiAgICAgIF9lcnJvcih0KFwiRXhwZWN0ZWQgYSBKU09OIG9iamVjdCwgYXJyYXkgb3IgbGl0ZXJhbC5cIiksIEVycm9yQ29kZS5VbmRlZmluZWQpO1xyXG4gICAgfSBlbHNlIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDE3KSB7XHJcbiAgICAgIF9lcnJvcih0KFwiRW5kIG9mIGZpbGUgZXhwZWN0ZWQuXCIpLCBFcnJvckNvZGUuVW5kZWZpbmVkKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5ldyBKU09ORG9jdW1lbnQoX3Jvb3QsIHByb2JsZW1zLCBjb21tZW50UmFuZ2VzKTtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2pzb24uanNcclxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iaiwgaW5kZW50LCBzdHJpbmdpZnlMaXRlcmFsKSB7XHJcbiAgaWYgKG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBjb25zdCBuZXdJbmRlbnQgPSBpbmRlbnQgKyBcIlx0XCI7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW11cIjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcmVzdWx0ID0gXCJbXFxuXCI7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIHN0cmluZ2lmeU9iamVjdChvYmpbaV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XHJcbiAgICAgICAgaWYgKGkgPCBvYmoubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IFwiLFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQgKz0gaW5kZW50ICsgXCJdXCI7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwie31cIjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcmVzdWx0ID0gXCJ7XFxuXCI7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjogXCIgKyBzdHJpbmdpZnlPYmplY3Qob2JqW2tleV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XHJcbiAgICAgICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIHJlc3VsdCArPSBcIixcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0ICs9IGluZGVudCArIFwifVwiO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RyaW5naWZ5TGl0ZXJhbChvYmopO1xyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvbkNvbXBsZXRpb24uanNcclxudmFyIHZhbHVlQ29tbWl0Q2hhcmFjdGVycyA9IFtcIixcIiwgXCJ9XCIsIFwiXVwiXTtcclxudmFyIHByb3BlcnR5Q29tbWl0Q2hhcmFjdGVycyA9IFtcIjpcIl07XHJcbnZhciBKU09OQ29tcGxldGlvbiA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihzY2hlbWFTZXJ2aWNlLCBjb250cmlidXRpb25zID0gW10sIHByb21pc2VDb25zdHJ1Y3RvciA9IFByb21pc2UsIGNsaWVudENhcGFiaWxpdGllcyA9IHt9KSB7XHJcbiAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xyXG4gICAgdGhpcy5jb250cmlidXRpb25zID0gY29udHJpYnV0aW9ucztcclxuICAgIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZUNvbnN0cnVjdG9yO1xyXG4gICAgdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMgPSBjbGllbnRDYXBhYmlsaXRpZXM7XHJcbiAgfVxyXG4gIGRvUmVzb2x2ZShpdGVtKSB7XHJcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jb250cmlidXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IHJlc29sdmVDb21wbGV0aW9uID0gdGhpcy5jb250cmlidXRpb25zW2ldLnJlc29sdmVDb21wbGV0aW9uO1xyXG4gICAgICBpZiAocmVzb2x2ZUNvbXBsZXRpb24pIHtcclxuICAgICAgICBjb25zdCByZXNvbHZlciA9IHJlc29sdmVDb21wbGV0aW9uKGl0ZW0pO1xyXG4gICAgICAgIGlmIChyZXNvbHZlcikge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoaXRlbSk7XHJcbiAgfVxyXG4gIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uLCBkb2MpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgaXRlbXM6IFtdLFxyXG4gICAgICBpc0luY29tcGxldGU6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcclxuICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcclxuICAgIGxldCBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCwgdHJ1ZSk7XHJcbiAgICBpZiAodGhpcy5pc0luQ29tbWVudChkb2N1bWVudCwgbm9kZSA/IG5vZGUub2Zmc2V0IDogMCwgb2Zmc2V0KSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZSAmJiBvZmZzZXQgPT09IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggJiYgb2Zmc2V0ID4gMCkge1xyXG4gICAgICBjb25zdCBjaCA9IHRleHRbb2Zmc2V0IC0gMV07XHJcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgY2ggPT09IFwifVwiIHx8IG5vZGUudHlwZSA9PT0gXCJhcnJheVwiICYmIGNoID09PSBcIl1cIikge1xyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY3VycmVudFdvcmQgPSB0aGlzLmdldEN1cnJlbnRXb3JkKGRvY3VtZW50LCBvZmZzZXQpO1xyXG4gICAgbGV0IG92ZXJ3cml0ZVJhbmdlO1xyXG4gICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZS50eXBlID09PSBcImJvb2xlYW5cIiB8fCBub2RlLnR5cGUgPT09IFwibnVsbFwiKSkge1xyXG4gICAgICBvdmVyd3JpdGVSYW5nZSA9IFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgb3ZlcndyaXRlU3RhcnQgPSBvZmZzZXQgLSBjdXJyZW50V29yZC5sZW5ndGg7XHJcbiAgICAgIGlmIChvdmVyd3JpdGVTdGFydCA+IDAgJiYgdGV4dFtvdmVyd3JpdGVTdGFydCAtIDFdID09PSAnXCInKSB7XHJcbiAgICAgICAgb3ZlcndyaXRlU3RhcnQtLTtcclxuICAgICAgfVxyXG4gICAgICBvdmVyd3JpdGVSYW5nZSA9IFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG92ZXJ3cml0ZVN0YXJ0KSwgcG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzID0gZmFsc2U7XHJcbiAgICBjb25zdCBwcm9wb3NlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBjb2xsZWN0b3IgPSB7XHJcbiAgICAgIGFkZDogKHN1Z2dlc3Rpb24pID0+IHtcclxuICAgICAgICBsZXQgbGFiZWwgPSBzdWdnZXN0aW9uLmxhYmVsO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJvcG9zZWQuZ2V0KGxhYmVsKTtcclxuICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XHJcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsLnJlcGxhY2UoL1tcXG5dL2csIFwiXFx1MjFCNVwiKTtcclxuICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGggPiA2MCkge1xyXG4gICAgICAgICAgICBjb25zdCBzaG9ydGVuZGVkTGFiZWwgPSBsYWJlbC5zdWJzdHIoMCwgNTcpLnRyaW0oKSArIFwiLi4uXCI7XHJcbiAgICAgICAgICAgIGlmICghcHJvcG9zZWQuaGFzKHNob3J0ZW5kZWRMYWJlbCkpIHtcclxuICAgICAgICAgICAgICBsYWJlbCA9IHNob3J0ZW5kZWRMYWJlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3VnZ2VzdGlvbi50ZXh0RWRpdCA9IFRleHRFZGl0LnJlcGxhY2Uob3ZlcndyaXRlUmFuZ2UsIHN1Z2dlc3Rpb24uaW5zZXJ0VGV4dCk7XHJcbiAgICAgICAgICBpZiAoc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKSB7XHJcbiAgICAgICAgICAgIHN1Z2dlc3Rpb24uY29tbWl0Q2hhcmFjdGVycyA9IHN1Z2dlc3Rpb24ua2luZCA9PT0gQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID8gcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzIDogdmFsdWVDb21taXRDaGFyYWN0ZXJzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3VnZ2VzdGlvbi5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgICAgcHJvcG9zZWQuc2V0KGxhYmVsLCBzdWdnZXN0aW9uKTtcclxuICAgICAgICAgIHJlc3VsdC5pdGVtcy5wdXNoKHN1Z2dlc3Rpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWV4aXN0aW5nLmRvY3VtZW50YXRpb24pIHtcclxuICAgICAgICAgICAgZXhpc3RpbmcuZG9jdW1lbnRhdGlvbiA9IHN1Z2dlc3Rpb24uZG9jdW1lbnRhdGlvbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghZXhpc3RpbmcuZGV0YWlsKSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nLmRldGFpbCA9IHN1Z2dlc3Rpb24uZGV0YWlsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFleGlzdGluZy5sYWJlbERldGFpbHMpIHtcclxuICAgICAgICAgICAgZXhpc3RpbmcubGFiZWxEZXRhaWxzID0gc3VnZ2VzdGlvbi5sYWJlbERldGFpbHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBzZXRBc0luY29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICByZXN1bHQuaXNJbmNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgfSxcclxuICAgICAgZXJyb3I6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0TnVtYmVyT2ZQcm9wb3NhbHM6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0Lml0ZW1zLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xyXG4gICAgICBjb25zdCBjb2xsZWN0aW9uUHJvbWlzZXMgPSBbXTtcclxuICAgICAgbGV0IGFkZFZhbHVlID0gdHJ1ZTtcclxuICAgICAgbGV0IGN1cnJlbnRLZXkgPSBcIlwiO1xyXG4gICAgICBsZXQgY3VycmVudFByb3BlcnR5ID0gdm9pZCAwO1xyXG4gICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJwcm9wZXJ0eVwiICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgIGFkZFZhbHVlID0gIXBhcmVudC52YWx1ZU5vZGU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IHBhcmVudDtcclxuICAgICAgICAgICAgY3VycmVudEtleSA9IHRleHQuc3Vic3RyKG5vZGUub2Zmc2V0ICsgMSwgbm9kZS5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGlmIChub2RlLm9mZnNldCA9PT0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gbm9kZS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvcGVydHkgfHwgY3VycmVudFByb3BlcnR5ICE9PSBwKSB7XHJcbiAgICAgICAgICAgIHByb3Bvc2VkLnNldChwLmtleU5vZGUudmFsdWUsIENvbXBsZXRpb25JdGVtLmNyZWF0ZShcIl9fXCIpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgc2VwYXJhdG9yQWZ0ZXIgPSBcIlwiO1xyXG4gICAgICAgIGlmIChhZGRWYWx1ZSkge1xyXG4gICAgICAgICAgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIGRvY3VtZW50Lm9mZnNldEF0KG92ZXJ3cml0ZVJhbmdlLmVuZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NoZW1hKSB7XHJcbiAgICAgICAgICB0aGlzLmdldFByb3BlcnR5Q29tcGxldGlvbnMoc2NoZW1hLCBkb2MsIG5vZGUsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5nZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyhkb2MsIG5vZGUsIGN1cnJlbnRLZXksIGNvbGxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2V0Tm9kZVBhdGgzKG5vZGUpO1xyXG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKChjb250cmlidXRpb24pID0+IHtcclxuICAgICAgICAgIGNvbnN0IGNvbGxlY3RQcm9taXNlID0gY29udHJpYnV0aW9uLmNvbGxlY3RQcm9wZXJ0eUNvbXBsZXRpb25zKGRvY3VtZW50LnVyaSwgbG9jYXRpb24sIGN1cnJlbnRXb3JkLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIgPT09IFwiXCIsIGNvbGxlY3Rvcik7XHJcbiAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghc2NoZW1hICYmIGN1cnJlbnRXb3JkLmxlbmd0aCA+IDAgJiYgdGV4dC5jaGFyQXQob2Zmc2V0IC0gY3VycmVudFdvcmQubGVuZ3RoIC0gMSkgIT09ICdcIicpIHtcclxuICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xyXG4gICAgICAgICAgICBraW5kOiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXHJcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUoY3VycmVudFdvcmQpLFxyXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShjdXJyZW50V29yZCwgdm9pZCAwLCBmYWxzZSwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb246IFwiXCJcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29sbGVjdG9yLnNldEFzSW5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0eXBlcyA9IHt9O1xyXG4gICAgICBpZiAoc2NoZW1hKSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIHR5cGVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jb250cmlidXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmdldENvbnRyaWJ1dGVkVmFsdWVDb21wbGV0aW9ucyhkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgY29sbGVjdGlvblByb21pc2VzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlQ29uc3RydWN0b3IuYWxsKGNvbGxlY3Rpb25Qcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbGxlY3Rvci5nZXROdW1iZXJPZlByb3Bvc2FscygpID09PSAwKSB7XHJcbiAgICAgICAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xyXG4gICAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZS50eXBlID09PSBcImJvb2xlYW5cIiB8fCBub2RlLnR5cGUgPT09IFwibnVsbFwiKSkge1xyXG4gICAgICAgICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3Qgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XHJcbiAgICAgICAgICB0aGlzLmFkZEZpbGxlclZhbHVlQ29tcGxldGlvbnModHlwZXMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXRQcm9wZXJ0eUNvbXBsZXRpb25zKHNjaGVtYSwgZG9jLCBub2RlLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XHJcbiAgICBtYXRjaGluZ1NjaGVtYXMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkKSB7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hUHJvcGVydGllcyA9IHMuc2NoZW1hLnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKHNjaGVtYVByb3BlcnRpZXMpIHtcclxuICAgICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYVByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYVByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eVNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiAhcHJvcGVydHlTY2hlbWEuZGVwcmVjYXRpb25NZXNzYWdlICYmICFwcm9wZXJ0eVNjaGVtYS5kb05vdFN1Z2dlc3QpIHtcclxuICAgICAgICAgICAgICBjb25zdCBwcm9wb3NhbCA9IHtcclxuICAgICAgICAgICAgICAgIGtpbmQ6IENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShrZXksIHByb3BlcnR5U2NoZW1hLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoa2V5KSxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHRoaXMuZnJvbU1hcmt1cChwcm9wZXJ0eVNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBwcm9wZXJ0eVNjaGVtYS5kZXNjcmlwdGlvbiB8fCBcIlwiXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEuc3VnZ2VzdFNvcnRUZXh0ICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgIHByb3Bvc2FsLnNvcnRUZXh0ID0gcHJvcGVydHlTY2hlbWEuc3VnZ2VzdFNvcnRUZXh0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAocHJvcG9zYWwuaW5zZXJ0VGV4dCAmJiBlbmRzV2l0aChwcm9wb3NhbC5pbnNlcnRUZXh0LCBgJDEke3NlcGFyYXRvckFmdGVyfWApKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wb3NhbC5jb21tYW5kID0ge1xyXG4gICAgICAgICAgICAgICAgICB0aXRsZTogXCJTdWdnZXN0XCIsXHJcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiZWRpdG9yLmFjdGlvbi50cmlnZ2VyU3VnZ2VzdFwiXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHByb3Bvc2FsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNjaGVtYVByb3BlcnR5TmFtZXMgPSBzLnNjaGVtYS5wcm9wZXJ0eU5hbWVzO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hUHJvcGVydHlOYW1lcyA9PT0gXCJvYmplY3RcIiAmJiAhc2NoZW1hUHJvcGVydHlOYW1lcy5kZXByZWNhdGlvbk1lc3NhZ2UgJiYgIXNjaGVtYVByb3BlcnR5TmFtZXMuZG9Ob3RTdWdnZXN0KSB7XHJcbiAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbSA9IChuYW1lLCBlbnVtRGVzY3JpcHRpb24gPSB2b2lkIDApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcG9zYWwgPSB7XHJcbiAgICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxyXG4gICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxyXG4gICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KG5hbWUsIHZvaWQgMCwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcclxuICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUobmFtZSksXHJcbiAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogZW51bURlc2NyaXB0aW9uIHx8IHRoaXMuZnJvbU1hcmt1cChzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHNjaGVtYVByb3BlcnR5TmFtZXMuZGVzY3JpcHRpb24gfHwgXCJcIlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5zdWdnZXN0U29ydFRleHQgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgIHByb3Bvc2FsLnNvcnRUZXh0ID0gc2NoZW1hUHJvcGVydHlOYW1lcy5zdWdnZXN0U29ydFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb3Bvc2FsLmluc2VydFRleHQgJiYgZW5kc1dpdGgocHJvcG9zYWwuaW5zZXJ0VGV4dCwgYCQxJHtzZXBhcmF0b3JBZnRlcn1gKSkge1xyXG4gICAgICAgICAgICAgIHByb3Bvc2FsLmNvbW1hbmQgPSB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJTdWdnZXN0XCIsXHJcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcImVkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3RcIlxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29sbGVjdG9yLmFkZChwcm9wb3NhbCk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGxldCBlbnVtRGVzY3JpcHRpb24gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGVudW1EZXNjcmlwdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzLmVudW1EZXNjcmlwdGlvbnMgJiYgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGVudW1EZXNjcmlwdGlvbiA9IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bURlc2NyaXB0aW9uc1tpXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0oc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtW2ldLCBlbnVtRGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5jb25zdCkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbShzY2hlbWFQcm9wZXJ0eU5hbWVzLmNvbnN0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyhkb2MsIG5vZGUsIGN1cnJlbnRLZXksIGNvbGxlY3Rvcikge1xyXG4gICAgY29uc3QgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdCA9IChvYmopID0+IHtcclxuICAgICAgb2JqLnByb3BlcnRpZXMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHAua2V5Tm9kZS52YWx1ZTtcclxuICAgICAgICBjb2xsZWN0b3IuYWRkKHtcclxuICAgICAgICAgIGtpbmQ6IENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcclxuICAgICAgICAgIGxhYmVsOiBrZXksXHJcbiAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShrZXksIFwiXCIpLFxyXG4gICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxyXG4gICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoa2V5KSxcclxuICAgICAgICAgIGRvY3VtZW50YXRpb246IFwiXCJcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcInByb3BlcnR5XCIpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBub2RlLnBhcmVudC5rZXlOb2RlLnZhbHVlO1xyXG4gICAgICAgIGRvYy52aXNpdCgobikgPT4ge1xyXG4gICAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJwcm9wZXJ0eVwiICYmIG4gIT09IG5vZGUucGFyZW50ICYmIG4ua2V5Tm9kZS52YWx1ZSA9PT0gcGFyZW50S2V5ICYmIG4udmFsdWVOb2RlICYmIG4udmFsdWVOb2RlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdChuLnZhbHVlTm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICBub2RlLnBhcmVudC5pdGVtcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIm9iamVjdFwiICYmIG4gIT09IG5vZGUpIHtcclxuICAgICAgICAgICAgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdChuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxyXG4gICAgICAgIGxhYmVsOiBcIiRzY2hlbWFcIixcclxuICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShcIiRzY2hlbWFcIiwgdm9pZCAwLCB0cnVlLCBcIlwiKSxcclxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogXCJcIixcclxuICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShcIiRzY2hlbWFcIilcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKSB7XHJcbiAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xyXG4gICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZS50eXBlID09PSBcImJvb2xlYW5cIiB8fCBub2RlLnR5cGUgPT09IFwibnVsbFwiKSkge1xyXG4gICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xyXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChcIm9iamVjdFwiKSxcclxuICAgICAgICBsYWJlbDogXCJFbXB0eSBvYmplY3RcIixcclxuICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh7fSwgXCJcIiksXHJcbiAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246IFwiXCJcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbGxlY3Rvci5hZGQoe1xyXG4gICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoXCJhcnJheVwiKSxcclxuICAgICAgICBsYWJlbDogXCJFbXB0eSBhcnJheVwiLFxyXG4gICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKFtdLCBcIlwiKSxcclxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogXCJcIlxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XHJcbiAgICBjb25zdCBjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMgPSAodmFsdWUpID0+IHtcclxuICAgICAgaWYgKHZhbHVlLnBhcmVudCAmJiAhY29udGFpbnMyKHZhbHVlLnBhcmVudCwgb2Zmc2V0LCB0cnVlKSkge1xyXG4gICAgICAgIGNvbGxlY3Rvci5hZGQoe1xyXG4gICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh2YWx1ZS50eXBlKSxcclxuICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsVGV4dEZvck1hdGNoaW5nTm9kZSh2YWx1ZSwgZG9jdW1lbnQpLFxyXG4gICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yTWF0Y2hpbmdOb2RlKHZhbHVlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxyXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogXCJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgIHRoaXMuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbighdmFsdWUudmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJwcm9wZXJ0eVwiKSB7XHJcbiAgICAgIGlmIChvZmZzZXQgPiAobm9kZS5jb2xvbk9mZnNldCB8fCAwKSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xyXG4gICAgICAgIGlmICh2YWx1ZU5vZGUgJiYgKG9mZnNldCA+IHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoIHx8IHZhbHVlTm9kZS50eXBlID09PSBcIm9iamVjdFwiIHx8IHZhbHVlTm9kZS50eXBlID09PSBcImFycmF5XCIpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcclxuICAgICAgICBkb2MudmlzaXQoKG4pID0+IHtcclxuICAgICAgICAgIGlmIChuLnR5cGUgPT09IFwicHJvcGVydHlcIiAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSkge1xyXG4gICAgICAgICAgICBjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMobi52YWx1ZU5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHBhcmVudEtleSA9PT0gXCIkc2NoZW1hXCIgJiYgbm9kZS5wYXJlbnQgJiYgIW5vZGUucGFyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgdGhpcy5hZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyhzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiYXJyYXlcIikge1xyXG4gICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJwcm9wZXJ0eVwiKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5wYXJlbnQua2V5Tm9kZS52YWx1ZTtcclxuICAgICAgICBkb2MudmlzaXQoKG4pID0+IHtcclxuICAgICAgICAgIGlmIChuLnR5cGUgPT09IFwicHJvcGVydHlcIiAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICAgICAgbi52YWx1ZU5vZGUuaXRlbXMuZm9yRWFjaChjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZ2V0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCB0eXBlcykge1xyXG4gICAgbGV0IG9mZnNldEZvclNlcGFyYXRvciA9IG9mZnNldDtcclxuICAgIGxldCBwYXJlbnRLZXkgPSB2b2lkIDA7XHJcbiAgICBsZXQgdmFsdWVOb2RlID0gdm9pZCAwO1xyXG4gICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZS50eXBlID09PSBcImJvb2xlYW5cIiB8fCBub2RlLnR5cGUgPT09IFwibnVsbFwiKSkge1xyXG4gICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xyXG4gICAgICB2YWx1ZU5vZGUgPSBub2RlO1xyXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYS5zY2hlbWEsIFwiXCIsIGNvbGxlY3RvciwgdHlwZXMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSBcInByb3BlcnR5XCIgJiYgb2Zmc2V0ID4gKG5vZGUuY29sb25PZmZzZXQgfHwgMCkpIHtcclxuICAgICAgY29uc3QgdmFsdWVOb2RlMiA9IG5vZGUudmFsdWVOb2RlO1xyXG4gICAgICBpZiAodmFsdWVOb2RlMiAmJiBvZmZzZXQgPiB2YWx1ZU5vZGUyLm9mZnNldCArIHZhbHVlTm9kZTIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudEtleSA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcclxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUgJiYgKHBhcmVudEtleSAhPT0gdm9pZCAwIHx8IG5vZGUudHlwZSA9PT0gXCJhcnJheVwiKSkge1xyXG4gICAgICBjb25zdCBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcclxuICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCwgdmFsdWVOb2RlKTtcclxuICAgICAgZm9yIChjb25zdCBzIG9mIG1hdGNoaW5nU2NoZW1hcykge1xyXG4gICAgICAgIGlmIChzLm5vZGUgPT09IG5vZGUgJiYgIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEpIHtcclxuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiYXJyYXlcIiAmJiBzLnNjaGVtYS5pdGVtcykge1xyXG4gICAgICAgICAgICBsZXQgYyA9IGNvbGxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnVuaXF1ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gXCJhcnJheVwiICYmIG4udHlwZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlcy5hZGQodGhpcy5nZXRMYWJlbEZvclZhbHVlKGdldE5vZGVWYWx1ZTMobikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjID0ge1xyXG4gICAgICAgICAgICAgICAgLi4uY29sbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgYWRkKHN1Z2dlc3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1ZhbHVlcy5oYXMoc3VnZ2VzdGlvbi5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHN1Z2dlc3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzLnNjaGVtYS5pdGVtcykpIHtcclxuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEl0ZW1BdE9mZnNldChub2RlLCBkb2N1bWVudCwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICBpZiAoaW5kZXggPCBzLnNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLnNjaGVtYS5pdGVtc1tpbmRleF0sIHNlcGFyYXRvckFmdGVyLCBjLCB0eXBlcyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLnNjaGVtYS5pdGVtcywgc2VwYXJhdG9yQWZ0ZXIsIGMsIHR5cGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcmVudEtleSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eU1hdGNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLnByb3BlcnRpZXNbcGFyZW50S2V5XTtcclxuICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5TWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocHJvcGVydHlTY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICYmICFwcm9wZXJ0eU1hdGNoZWQpIHtcclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgT2JqZWN0LmtleXMocy5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4dGVuZGVkUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4Py50ZXN0KHBhcmVudEtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgcHJvcGVydHlNYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXTtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzLnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAmJiAhcHJvcGVydHlNYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzLnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcclxuICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocHJvcGVydHlTY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyZW50S2V5ID09PSBcIiRzY2hlbWFcIiAmJiAhbm9kZS5wYXJlbnQpIHtcclxuICAgICAgICB0aGlzLmFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlc1tcImJvb2xlYW5cIl0pIHtcclxuICAgICAgICB0aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24odHJ1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XHJcbiAgICAgICAgdGhpcy5hZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uKGZhbHNlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZXNbXCJudWxsXCJdKSB7XHJcbiAgICAgICAgdGhpcy5hZGROdWxsVmFsdWVDb21wbGV0aW9uKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldENvbnRyaWJ1dGVkVmFsdWVDb21wbGV0aW9ucyhkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgY29sbGVjdGlvblByb21pc2VzKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgdGhpcy5jb250cmlidXRpb25zLmZvckVhY2goKGNvbnRyaWJ1dGlvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbGxlY3RQcm9taXNlID0gY29udHJpYnV0aW9uLmNvbGxlY3REZWZhdWx0Q29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBjb2xsZWN0b3IpO1xyXG4gICAgICAgIGlmIChjb2xsZWN0UHJvbWlzZSkge1xyXG4gICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobm9kZS50eXBlID09PSBcInN0cmluZ1wiIHx8IG5vZGUudHlwZSA9PT0gXCJudW1iZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IG5vZGUudHlwZSA9PT0gXCJudWxsXCIpIHtcclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBcInByb3BlcnR5XCIgJiYgb2Zmc2V0ID4gKG5vZGUuY29sb25PZmZzZXQgfHwgMCkpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBub2RlLmtleU5vZGUudmFsdWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XHJcbiAgICAgICAgaWYgKCghdmFsdWVOb2RlIHx8IG9mZnNldCA8PSB2YWx1ZU5vZGUub2Zmc2V0ICsgdmFsdWVOb2RlLmxlbmd0aCkgJiYgbm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2V0Tm9kZVBhdGgzKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKChjb250cmlidXRpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdFZhbHVlQ29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBsb2NhdGlvbiwgcGFyZW50S2V5LCBjb2xsZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcclxuICAgICAgICAgICAgICBjb2xsZWN0aW9uUHJvbWlzZXMucHVzaChjb2xsZWN0UHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBhZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpIHtcclxuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIHRoaXMuYWRkRW51bVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcclxuICAgICAgdGhpcy5hZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xyXG4gICAgICB0aGlzLmNvbGxlY3RUeXBlcyhzY2hlbWEsIHR5cGVzKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xyXG4gICAgICAgIHNjaGVtYS5hbGxPZi5mb3JFYWNoKChzKSA9PiB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB7XHJcbiAgICAgICAgc2NoZW1hLmFueU9mLmZvckVhY2goKHMpID0+IHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcykpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcclxuICAgICAgICBzY2hlbWEub25lT2YuZm9yRWFjaCgocykgPT4gdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCBhcnJheURlcHRoID0gMCkge1xyXG4gICAgbGV0IGhhc1Byb3Bvc2FscyA9IGZhbHNlO1xyXG4gICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuZGVmYXVsdCkpIHtcclxuICAgICAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcclxuICAgICAgbGV0IHZhbHVlID0gc2NoZW1hLmRlZmF1bHQ7XHJcbiAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xyXG4gICAgICAgIHR5cGUgPSBcImFycmF5XCI7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29tcGxldGlvbkl0ZW0gPSB7XHJcbiAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh0eXBlKSxcclxuICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSxcclxuICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldFxyXG4gICAgICB9O1xyXG4gICAgICBpZiAodGhpcy5kb2VzU3VwcG9ydHNMYWJlbERldGFpbHMoKSkge1xyXG4gICAgICAgIGNvbXBsZXRpb25JdGVtLmxhYmVsRGV0YWlscyA9IHsgZGVzY3JpcHRpb246IHQoXCJEZWZhdWx0IHZhbHVlXCIpIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29tcGxldGlvbkl0ZW0uZGV0YWlsID0gdChcIkRlZmF1bHQgdmFsdWVcIik7XHJcbiAgICAgIH1cclxuICAgICAgY29sbGVjdG9yLmFkZChjb21wbGV0aW9uSXRlbSk7XHJcbiAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZXhhbXBsZXMpKSB7XHJcbiAgICAgIHNjaGVtYS5leGFtcGxlcy5mb3JFYWNoKChleGFtcGxlKSA9PiB7XHJcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcclxuICAgICAgICBsZXQgdmFsdWUgPSBleGFtcGxlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgICB0eXBlID0gXCJhcnJheVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2xsZWN0b3IuYWRkKHtcclxuICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXHJcbiAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSxcclxuICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXHJcbiAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXRcclxuICAgICAgICB9KTtcclxuICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5kZWZhdWx0U25pcHBldHMpKSB7XHJcbiAgICAgIHNjaGVtYS5kZWZhdWx0U25pcHBldHMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLnR5cGU7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gcy5ib2R5O1xyXG4gICAgICAgIGxldCBsYWJlbCA9IHMubGFiZWw7XHJcbiAgICAgICAgbGV0IGluc2VydFRleHQ7XHJcbiAgICAgICAgbGV0IGZpbHRlclRleHQ7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgIGxldCB0eXBlMiA9IHNjaGVtYS50eXBlO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFycmF5RGVwdGg7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xyXG4gICAgICAgICAgICB0eXBlMiA9IFwiYXJyYXlcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGluc2VydFRleHQgPSB0aGlzLmdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcclxuICAgICAgICAgIGZpbHRlclRleHQgPSB0aGlzLmdldEZpbHRlclRleHRGb3JTbmlwcGV0VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgbGFiZWwgPSBsYWJlbCB8fCB0aGlzLmdldExhYmVsRm9yU25pcHBldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzLmJvZHlUZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBsZXQgcHJlZml4ID0gXCJcIiwgc3VmZml4ID0gXCJcIiwgaW5kZW50ID0gXCJcIjtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCArIGluZGVudCArIFwiW1xcblwiO1xyXG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXggKyBcIlxcblwiICsgaW5kZW50ICsgXCJdXCI7XHJcbiAgICAgICAgICAgIGluZGVudCArPSBcIlx0XCI7XHJcbiAgICAgICAgICAgIHR5cGUgPSBcImFycmF5XCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpbnNlcnRUZXh0ID0gcHJlZml4ICsgaW5kZW50ICsgcy5ib2R5VGV4dC5zcGxpdChcIlxcblwiKS5qb2luKFwiXFxuXCIgKyBpbmRlbnQpICsgc3VmZml4ICsgc2VwYXJhdG9yQWZ0ZXI7XHJcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IGluc2VydFRleHQsIGZpbHRlclRleHQgPSBpbnNlcnRUZXh0LnJlcGxhY2UoL1tcXG5dL2csIFwiXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbGxlY3Rvci5hZGQoe1xyXG4gICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh0eXBlKSxcclxuICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogdGhpcy5mcm9tTWFya3VwKHMubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgcy5kZXNjcmlwdGlvbixcclxuICAgICAgICAgIGluc2VydFRleHQsXHJcbiAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgICBmaWx0ZXJUZXh0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaGFzUHJvcG9zYWxzID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWhhc1Byb3Bvc2FscyAmJiB0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgJiYgYXJyYXlEZXB0aCA8IDUpIHtcclxuICAgICAgdGhpcy5hZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEuaXRlbXMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIGFycmF5RGVwdGggKyAxKTtcclxuICAgIH1cclxuICB9XHJcbiAgYWRkRW51bVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XHJcbiAgICBpZiAoaXNEZWZpbmVkKHNjaGVtYS5jb25zdCkpIHtcclxuICAgICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChzY2hlbWEudHlwZSksXHJcbiAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWEuY29uc3QpLFxyXG4gICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHNjaGVtYS5jb25zdCwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmZyb21NYXJrdXAoc2NoZW1hLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHNjaGVtYS5kZXNjcmlwdGlvblxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2NoZW1hLmVudW0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlbm0gPSBzY2hlbWEuZW51bVtpXTtcclxuICAgICAgICBsZXQgZG9jdW1lbnRhdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIGlmIChzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zLmxlbmd0aCAmJiB0aGlzLmRvZXNTdXBwb3J0TWFya2Rvd24oKSkge1xyXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zW2ldKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5lbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWEuZW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgIGRvY3VtZW50YXRpb24gPSBzY2hlbWEuZW51bURlc2NyaXB0aW9uc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHNjaGVtYS50eXBlKSxcclxuICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUoZW5tKSxcclxuICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGVubSwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxyXG4gICAgICAgICAgZG9jdW1lbnRhdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbGxlY3RUeXBlcyhzY2hlbWEsIHR5cGVzKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgfHwgaXNEZWZpbmVkKHNjaGVtYS5jb25zdCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS50eXBlO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcclxuICAgICAgdHlwZS5mb3JFYWNoKCh0MikgPT4gdHlwZXNbdDJdID0gdHJ1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUpIHtcclxuICAgICAgdHlwZXNbdHlwZV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBhZGRGaWxsZXJWYWx1ZUNvbXBsZXRpb25zKHR5cGVzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XHJcbiAgICBpZiAodHlwZXNbXCJvYmplY3RcIl0pIHtcclxuICAgICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChcIm9iamVjdFwiKSxcclxuICAgICAgICBsYWJlbDogXCJ7fVwiLFxyXG4gICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZSh7fSwgc2VwYXJhdG9yQWZ0ZXIpLFxyXG4gICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcclxuICAgICAgICBkZXRhaWw6IHQoXCJOZXcgb2JqZWN0XCIpLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246IFwiXCJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZXNbXCJhcnJheVwiXSkge1xyXG4gICAgICBjb2xsZWN0b3IuYWRkKHtcclxuICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKFwiYXJyYXlcIiksXHJcbiAgICAgICAgbGFiZWw6IFwiW11cIixcclxuICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUoW10sIHNlcGFyYXRvckFmdGVyKSxcclxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgZGV0YWlsOiB0KFwiTmV3IGFycmF5XCIpLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246IFwiXCJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24odmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcclxuICAgIGNvbGxlY3Rvci5hZGQoe1xyXG4gICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKFwiYm9vbGVhblwiKSxcclxuICAgICAgbGFiZWw6IHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsXHJcbiAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXHJcbiAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcclxuICAgICAgZG9jdW1lbnRhdGlvbjogXCJcIlxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFkZE51bGxWYWx1ZUNvbXBsZXRpb24oc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xyXG4gICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoXCJudWxsXCIpLFxyXG4gICAgICBsYWJlbDogXCJudWxsXCIsXHJcbiAgICAgIGluc2VydFRleHQ6IFwibnVsbFwiICsgc2VwYXJhdG9yQWZ0ZXIsXHJcbiAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcclxuICAgICAgZG9jdW1lbnRhdGlvbjogXCJcIlxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcclxuICAgIGNvbnN0IHNjaGVtYUlkcyA9IHRoaXMuc2NoZW1hU2VydmljZS5nZXRSZWdpc3RlcmVkU2NoZW1hSWRzKChzY2hlbWEpID0+IHNjaGVtYSA9PT0gXCJodHRwXCIgfHwgc2NoZW1hID09PSBcImh0dHBzXCIpO1xyXG4gICAgc2NoZW1hSWRzLmZvckVhY2goKHNjaGVtYUlkKSA9PiB7XHJcbiAgICAgIGlmIChzY2hlbWFJZC5zdGFydHNXaXRoKFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC1cIikpIHtcclxuICAgICAgICBzY2hlbWFJZCA9IHNjaGVtYUlkICsgXCIjXCI7XHJcbiAgICAgIH1cclxuICAgICAgY29sbGVjdG9yLmFkZCh7XHJcbiAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSxcclxuICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHNjaGVtYUlkKSxcclxuICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShzY2hlbWFJZCksXHJcbiAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoc2NoZW1hSWQsIHNlcGFyYXRvckFmdGVyKSxcclxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogXCJcIlxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gIH1cclxuICBnZXRWYWx1ZUZyb21MYWJlbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xyXG4gIH1cclxuICBnZXRGaWx0ZXJUZXh0Rm9yVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgfVxyXG4gIGdldEZpbHRlclRleHRGb3JTbmlwcGV0VmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgXCIkMVwiKTtcclxuICB9XHJcbiAgZ2V0TGFiZWxGb3JTbmlwcGV0VmFsdWUodmFsdWUpIHtcclxuICAgIGNvbnN0IGxhYmVsID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgcmV0dXJuIGxhYmVsLnJlcGxhY2UoL1xcJFxce1xcZCs6KFtefV0rKVxcfXxcXCRcXGQrL2csIFwiJDFcIik7XHJcbiAgfVxyXG4gIGdldEluc2VydFRleHRGb3JQbGFpblRleHQodGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW1xcXFxcXCRcXH1dL2csIFwiXFxcXCQmXCIpO1xyXG4gIH1cclxuICBnZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XHJcbiAgICBjb25zdCB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIFwiXHRcIik7XHJcbiAgICBpZiAodGV4dCA9PT0gXCJ7fVwiKSB7XHJcbiAgICAgIHJldHVybiBcInskMX1cIiArIHNlcGFyYXRvckFmdGVyO1xyXG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcIltdXCIpIHtcclxuICAgICAgcmV0dXJuIFwiWyQxXVwiICsgc2VwYXJhdG9yQWZ0ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUGxhaW5UZXh0KHRleHQgKyBzZXBhcmF0b3JBZnRlcik7XHJcbiAgfVxyXG4gIGdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XHJcbiAgICBjb25zdCByZXBsYWNlciA9ICh2YWx1ZTIpID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZTIgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAodmFsdWUyWzBdID09PSBcIl5cIikge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlMi5zdWJzdHIoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZTIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUsIFwiXCIsIHJlcGxhY2VyKSArIHNlcGFyYXRvckFmdGVyO1xyXG4gIH1cclxuICBnZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xyXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcclxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIFwiJHsxOm51bGx9XCIgKyBzZXBhcmF0b3JBZnRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XHJcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICBsZXQgc25pcHBldFZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIHNuaXBwZXRWYWx1ZSA9IHNuaXBwZXRWYWx1ZS5zdWJzdHIoMSwgc25pcHBldFZhbHVlLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgIHNuaXBwZXRWYWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChzbmlwcGV0VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiAnXCIkezE6JyArIHNuaXBwZXRWYWx1ZSArICd9XCInICsgc2VwYXJhdG9yQWZ0ZXI7XHJcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICByZXR1cm4gXCIkezE6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyBcIn1cIiArIHNlcGFyYXRvckFmdGVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XHJcbiAgfVxyXG4gIGdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XHJcbiAgICAgIGNvbnN0IGFycmF5ID0gdHlwZTtcclxuICAgICAgdHlwZSA9IGFycmF5Lmxlbmd0aCA+IDAgPyBhcnJheVswXSA6IHZvaWQgMDtcclxuICAgIH1cclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICByZXR1cm4gQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICByZXR1cm4gQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlO1xyXG4gICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgcmV0dXJuIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XHJcbiAgICAgIGNhc2UgXCJwcm9wZXJ0eVwiOlxyXG4gICAgICAgIHJldHVybiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIENvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0TGFiZWxUZXh0Rm9yTWF0Y2hpbmdOb2RlKG5vZGUsIGRvY3VtZW50KSB7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICBjYXNlIFwiYXJyYXlcIjpcclxuICAgICAgICByZXR1cm4gXCJbXVwiO1xyXG4gICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgcmV0dXJuIFwie31cIjtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihub2RlLm9mZnNldCwgbm9kZS5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRJbnNlcnRUZXh0Rm9yTWF0Y2hpbmdOb2RlKG5vZGUsIGRvY3VtZW50LCBzZXBhcmF0b3JBZnRlcikge1xyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKFtdLCBzZXBhcmF0b3JBZnRlcik7XHJcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoe30sIHNlcGFyYXRvckFmdGVyKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihub2RlLm9mZnNldCwgbm9kZS5sZW5ndGgpICsgc2VwYXJhdG9yQWZ0ZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChjb250ZW50KTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KGtleSwgcHJvcGVydHlTY2hlbWEsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xyXG4gICAgY29uc3QgcHJvcGVydHlUZXh0ID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoa2V5LCBcIlwiKTtcclxuICAgIGlmICghYWRkVmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHByb3BlcnR5VGV4dDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdFRleHQgPSBwcm9wZXJ0eVRleHQgKyBcIjogXCI7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBsZXQgblZhbHVlUHJvcG9zYWxzID0gMDtcclxuICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMpKSB7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hLmRlZmF1bHRTbmlwcGV0cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIGNvbnN0IGJvZHkgPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHNbMF0uYm9keTtcclxuICAgICAgICAgIGlmIChpc0RlZmluZWQoYm9keSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUoYm9keSwgXCJcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5lbnVtKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBwcm9wZXJ0eVNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUocHJvcGVydHlTY2hlbWEuZW51bVswXSwgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5lbnVtLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnR5U2NoZW1hLmNvbnN0KSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmNvbnN0LCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgblZhbHVlUHJvcG9zYWxzKys7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0KSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmRlZmF1bHQsIFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuVmFsdWVQcm9wb3NhbHMrKztcclxuICAgICAgfVxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcykgJiYgcHJvcGVydHlTY2hlbWEuZXhhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUocHJvcGVydHlTY2hlbWEuZXhhbXBsZXNbMF0sIFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuVmFsdWVQcm9wb3NhbHMgKz0gcHJvcGVydHlTY2hlbWEuZXhhbXBsZXMubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuVmFsdWVQcm9wb3NhbHMgPT09IDApIHtcclxuICAgICAgICBsZXQgdHlwZSA9IEFycmF5LmlzQXJyYXkocHJvcGVydHlTY2hlbWEudHlwZSkgPyBwcm9wZXJ0eVNjaGVtYS50eXBlWzBdIDogcHJvcGVydHlTY2hlbWEudHlwZTtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBcIm9iamVjdFwiO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVNjaGVtYS5pdGVtcykge1xyXG4gICAgICAgICAgICB0eXBlID0gXCJhcnJheVwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCIkMVwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgdmFsdWUgPSAnXCIkMVwiJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCJ7JDF9XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCJbJDFdXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcclxuICAgICAgICAgICAgdmFsdWUgPSBcIiR7MTowfVwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJudWxsXCI6XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCIkezE6bnVsbH1cIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF2YWx1ZSB8fCBuVmFsdWVQcm9wb3NhbHMgPiAxKSB7XHJcbiAgICAgIHZhbHVlID0gXCIkMVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFRleHQgKyB2YWx1ZSArIHNlcGFyYXRvckFmdGVyO1xyXG4gIH1cclxuICBnZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KSB7XHJcbiAgICBsZXQgaSA9IG9mZnNldCAtIDE7XHJcbiAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xyXG4gICAgd2hpbGUgKGkgPj0gMCAmJiAnIFx0XFxuXFxyXFx2XCI6e1ssXX0nLmluZGV4T2YodGV4dC5jaGFyQXQoaSkpID09PSAtMSkge1xyXG4gICAgICBpLS07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoaSArIDEsIG9mZnNldCk7XHJcbiAgfVxyXG4gIGV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldCkge1xyXG4gICAgY29uc3Qgc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIyKGRvY3VtZW50LmdldFRleHQoKSwgdHJ1ZSk7XHJcbiAgICBzY2FubmVyLnNldFBvc2l0aW9uKG9mZnNldCk7XHJcbiAgICBjb25zdCB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xyXG4gICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICBjYXNlIDU6XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgY2FzZSA0OlxyXG4gICAgICBjYXNlIDE3OlxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBcIixcIjtcclxuICAgIH1cclxuICB9XHJcbiAgZmluZEl0ZW1BdE9mZnNldChub2RlLCBkb2N1bWVudCwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBzY2FubmVyID0gY3JlYXRlU2Nhbm5lcjIoZG9jdW1lbnQuZ2V0VGV4dCgpLCB0cnVlKTtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5pdGVtcztcclxuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAob2Zmc2V0ID4gY2hpbGQub2Zmc2V0ICsgY2hpbGQubGVuZ3RoKSB7XHJcbiAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihjaGlsZC5vZmZzZXQgKyBjaGlsZC5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XHJcbiAgICAgICAgaWYgKHRva2VuID09PSA1ICYmIG9mZnNldCA+PSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpIHtcclxuICAgICAgICAgIHJldHVybiBpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID49IGNoaWxkLm9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgaXNJbkNvbW1lbnQoZG9jdW1lbnQsIHN0YXJ0LCBvZmZzZXQpIHtcclxuICAgIGNvbnN0IHNjYW5uZXIgPSBjcmVhdGVTY2FubmVyMihkb2N1bWVudC5nZXRUZXh0KCksIGZhbHNlKTtcclxuICAgIHNjYW5uZXIuc2V0UG9zaXRpb24oc3RhcnQpO1xyXG4gICAgbGV0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XHJcbiAgICB3aGlsZSAodG9rZW4gIT09IDE3ICYmIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSA8IG9mZnNldCkge1xyXG4gICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICh0b2tlbiA9PT0gMTIgfHwgdG9rZW4gPT09IDEzKSAmJiBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgPD0gb2Zmc2V0O1xyXG4gIH1cclxuICBmcm9tTWFya3VwKG1hcmt1cFN0cmluZykge1xyXG4gICAgaWYgKG1hcmt1cFN0cmluZyAmJiB0aGlzLmRvZXNTdXBwb3J0TWFya2Rvd24oKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGtpbmQ6IE1hcmt1cEtpbmQuTWFya2Rvd24sXHJcbiAgICAgICAgdmFsdWU6IG1hcmt1cFN0cmluZ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZvaWQgMDtcclxuICB9XHJcbiAgZG9lc1N1cHBvcnRNYXJrZG93bigpIHtcclxuICAgIGlmICghaXNEZWZpbmVkKHRoaXMuc3VwcG9ydHNNYXJrZG93bikpIHtcclxuICAgICAgY29uc3QgZG9jdW1lbnRhdGlvbkZvcm1hdCA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudD8uY29tcGxldGlvbj8uY29tcGxldGlvbkl0ZW0/LmRvY3VtZW50YXRpb25Gb3JtYXQ7XHJcbiAgICAgIHRoaXMuc3VwcG9ydHNNYXJrZG93biA9IEFycmF5LmlzQXJyYXkoZG9jdW1lbnRhdGlvbkZvcm1hdCkgJiYgZG9jdW1lbnRhdGlvbkZvcm1hdC5pbmRleE9mKE1hcmt1cEtpbmQuTWFya2Rvd24pICE9PSAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnN1cHBvcnRzTWFya2Rvd247XHJcbiAgfVxyXG4gIGRvZXNTdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMoKSB7XHJcbiAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycykpIHtcclxuICAgICAgdGhpcy5sYWJlbERldGFpbHNTdXBwb3J0ID0gdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50Py5jb21wbGV0aW9uPy5jb21wbGV0aW9uSXRlbT8uY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0c0NvbW1pdENoYXJhY3RlcnM7XHJcbiAgfVxyXG4gIGRvZXNTdXBwb3J0c0xhYmVsRGV0YWlscygpIHtcclxuICAgIGlmICghaXNEZWZpbmVkKHRoaXMubGFiZWxEZXRhaWxzU3VwcG9ydCkpIHtcclxuICAgICAgdGhpcy5sYWJlbERldGFpbHNTdXBwb3J0ID0gdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50Py5jb21wbGV0aW9uPy5jb21wbGV0aW9uSXRlbT8ubGFiZWxEZXRhaWxzU3VwcG9ydDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQ7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Ib3Zlci5qc1xyXG52YXIgSlNPTkhvdmVyID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKHNjaGVtYVNlcnZpY2UsIGNvbnRyaWJ1dGlvbnMgPSBbXSwgcHJvbWlzZUNvbnN0cnVjdG9yKSB7XHJcbiAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xyXG4gICAgdGhpcy5jb250cmlidXRpb25zID0gY29udHJpYnV0aW9ucztcclxuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xyXG4gIH1cclxuICBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbiwgZG9jKSB7XHJcbiAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChwb3NpdGlvbik7XHJcbiAgICBsZXQgbm9kZSA9IGRvYy5nZXROb2RlRnJvbU9mZnNldChvZmZzZXQpO1xyXG4gICAgaWYgKCFub2RlIHx8IChub2RlLnR5cGUgPT09IFwib2JqZWN0XCIgfHwgbm9kZS50eXBlID09PSBcImFycmF5XCIpICYmIG9mZnNldCA+IG5vZGUub2Zmc2V0ICsgMSAmJiBvZmZzZXQgPCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBob3ZlclJhbmdlTm9kZSA9IG5vZGU7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xyXG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcInByb3BlcnR5XCIgJiYgcGFyZW50LmtleU5vZGUgPT09IG5vZGUpIHtcclxuICAgICAgICBub2RlID0gcGFyZW50LnZhbHVlTm9kZTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGhvdmVyUmFuZ2UgPSBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChob3ZlclJhbmdlTm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KGhvdmVyUmFuZ2VOb2RlLm9mZnNldCArIGhvdmVyUmFuZ2VOb2RlLmxlbmd0aCkpO1xyXG4gICAgY29uc3QgY3JlYXRlSG92ZXIgPSAoY29udGVudHMpID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGNvbnRlbnRzLFxyXG4gICAgICAgIHJhbmdlOiBob3ZlclJhbmdlXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9jYXRpb24gPSBnZXROb2RlUGF0aDMobm9kZSk7XHJcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jb250cmlidXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbiA9IHRoaXMuY29udHJpYnV0aW9uc1tpXTtcclxuICAgICAgY29uc3QgcHJvbWlzZSA9IGNvbnRyaWJ1dGlvbi5nZXRJbmZvQ29udHJpYnV0aW9uKGRvY3VtZW50LnVyaSwgbG9jYXRpb24pO1xyXG4gICAgICBpZiAocHJvbWlzZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGh0bWxDb250ZW50KSA9PiBjcmVhdGVIb3ZlcihodG1sQ29udGVudCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFTZXJ2aWNlLmdldFNjaGVtYUZvclJlc291cmNlKGRvY3VtZW50LnVyaSwgZG9jKS50aGVuKChzY2hlbWEpID0+IHtcclxuICAgICAgaWYgKHNjaGVtYSAmJiBub2RlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XHJcbiAgICAgICAgbGV0IHRpdGxlID0gdm9pZCAwO1xyXG4gICAgICAgIGxldCBtYXJrZG93bkRlc2NyaXB0aW9uID0gdm9pZCAwO1xyXG4gICAgICAgIGxldCBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uID0gdm9pZCAwLCBlbnVtVmFsdWUgPSB2b2lkIDA7XHJcbiAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmV2ZXJ5KChzKSA9PiB7XHJcbiAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkICYmIHMuc2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gdGl0bGUgfHwgcy5zY2hlbWEudGl0bGU7XHJcbiAgICAgICAgICAgIG1hcmtkb3duRGVzY3JpcHRpb24gPSBtYXJrZG93bkRlc2NyaXB0aW9uIHx8IHMuc2NoZW1hLm1hcmtkb3duRGVzY3JpcHRpb24gfHwgdG9NYXJrZG93bihzLnNjaGVtYS5kZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChzLnNjaGVtYS5lbnVtKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgaWR4ID0gcy5zY2hlbWEuZW51bS5pbmRleE9mKGdldE5vZGVWYWx1ZTMobm9kZSkpO1xyXG4gICAgICAgICAgICAgIGlmIChzLnNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb24gPSBzLnNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnNbaWR4XTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHMuc2NoZW1hLmVudW1EZXNjcmlwdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb24gPSB0b01hcmtkb3duKHMuc2NoZW1hLmVudW1EZXNjcmlwdGlvbnNbaWR4XSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBlbnVtVmFsdWUgPSBzLnNjaGVtYS5lbnVtW2lkeF07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudW1WYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICBlbnVtVmFsdWUgPSBKU09OLnN0cmluZ2lmeShlbnVtVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHRpdGxlKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSB0b01hcmtkb3duKHRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hcmtkb3duRGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cXG5cIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdCArPSBtYXJrZG93bkRlc2NyaXB0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblxcblwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0ICs9IGBcXGAke3RvTWFya2Rvd25Db2RlQmxvY2soZW51bVZhbHVlKX1cXGA6ICR7bWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbn1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlSG92ZXIoW3Jlc3VsdF0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiB0b01hcmtkb3duKHBsYWluKSB7XHJcbiAgaWYgKHBsYWluKSB7XHJcbiAgICBjb25zdCByZXMgPSBwbGFpbi5yZXBsYWNlKC8oW15cXG5cXHJdKShcXHI/XFxuKShbXlxcblxccl0pL2dtLCBcIiQxXFxuXFxuJDNcIik7XHJcbiAgICByZXR1cm4gcmVzLnJlcGxhY2UoL1tcXFxcYCpfe31bXFxdKCkjK1xcLS4hXS9nLCBcIlxcXFwkJlwiKTtcclxuICB9XHJcbiAgcmV0dXJuIHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiB0b01hcmtkb3duQ29kZUJsb2NrKGNvbnRlbnQpIHtcclxuICBpZiAoY29udGVudC5pbmRleE9mKFwiYFwiKSAhPT0gLTEpIHtcclxuICAgIHJldHVybiBcImBgIFwiICsgY29udGVudCArIFwiIGBgXCI7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZW50O1xyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvblZhbGlkYXRpb24uanNcclxudmFyIEpTT05WYWxpZGF0aW9uID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKGpzb25TY2hlbWFTZXJ2aWNlLCBwcm9taXNlQ29uc3RydWN0b3IpIHtcclxuICAgIHRoaXMuanNvblNjaGVtYVNlcnZpY2UgPSBqc29uU2NoZW1hU2VydmljZTtcclxuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2VDb25zdHJ1Y3RvcjtcclxuICAgIHRoaXMudmFsaWRhdGlvbkVuYWJsZWQgPSB0cnVlO1xyXG4gIH1cclxuICBjb25maWd1cmUocmF3KSB7XHJcbiAgICBpZiAocmF3KSB7XHJcbiAgICAgIHRoaXMudmFsaWRhdGlvbkVuYWJsZWQgPSByYXcudmFsaWRhdGUgIT09IGZhbHNlO1xyXG4gICAgICB0aGlzLmNvbW1lbnRTZXZlcml0eSA9IHJhdy5hbGxvd0NvbW1lbnRzID8gdm9pZCAwIDogRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuICBkb1ZhbGlkYXRpb24odGV4dERvY3VtZW50LCBqc29uRG9jdW1lbnQsIGRvY3VtZW50U2V0dGluZ3MsIHNjaGVtYSkge1xyXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRpb25FbmFibGVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkaWFnbm9zdGljcyA9IFtdO1xyXG4gICAgY29uc3QgYWRkZWQgPSB7fTtcclxuICAgIGNvbnN0IGFkZFByb2JsZW0gPSAocHJvYmxlbSkgPT4ge1xyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBwcm9ibGVtLnJhbmdlLnN0YXJ0LmxpbmUgKyBcIiBcIiArIHByb2JsZW0ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyICsgXCIgXCIgKyBwcm9ibGVtLm1lc3NhZ2U7XHJcbiAgICAgIGlmICghYWRkZWRbc2lnbmF0dXJlXSkge1xyXG4gICAgICAgIGFkZGVkW3NpZ25hdHVyZV0gPSB0cnVlO1xyXG4gICAgICAgIGRpYWdub3N0aWNzLnB1c2gocHJvYmxlbSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXREaWFnbm9zdGljcyA9IChzY2hlbWEyKSA9PiB7XHJcbiAgICAgIGxldCB0cmFpbGluZ0NvbW1hU2V2ZXJpdHkgPSBkb2N1bWVudFNldHRpbmdzPy50cmFpbGluZ0NvbW1hcyA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3MudHJhaWxpbmdDb21tYXMpIDogRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xyXG4gICAgICBsZXQgY29tbWVudFNldmVyaXR5ID0gZG9jdW1lbnRTZXR0aW5ncz8uY29tbWVudHMgPyB0b0RpYWdub3N0aWNTZXZlcml0eShkb2N1bWVudFNldHRpbmdzLmNvbW1lbnRzKSA6IHRoaXMuY29tbWVudFNldmVyaXR5O1xyXG4gICAgICBsZXQgc2NoZW1hVmFsaWRhdGlvbiA9IGRvY3VtZW50U2V0dGluZ3M/LnNjaGVtYVZhbGlkYXRpb24gPyB0b0RpYWdub3N0aWNTZXZlcml0eShkb2N1bWVudFNldHRpbmdzLnNjaGVtYVZhbGlkYXRpb24pIDogRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc7XHJcbiAgICAgIGxldCBzY2hlbWFSZXF1ZXN0ID0gZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hUmVxdWVzdCA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hUmVxdWVzdCkgOiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcclxuICAgICAgaWYgKHNjaGVtYTIpIHtcclxuICAgICAgICBjb25zdCBhZGRTY2hlbWFQcm9ibGVtID0gKGVycm9yTWVzc2FnZSwgZXJyb3JDb2RlKSA9PiB7XHJcbiAgICAgICAgICBpZiAoanNvbkRvY3VtZW50LnJvb3QgJiYgc2NoZW1hUmVxdWVzdCkge1xyXG4gICAgICAgICAgICBjb25zdCBhc3RSb290ID0ganNvbkRvY3VtZW50LnJvb3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gYXN0Um9vdC50eXBlID09PSBcIm9iamVjdFwiID8gYXN0Um9vdC5wcm9wZXJ0aWVzWzBdIDogdm9pZCAwO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gXCIkc2NoZW1hXCIpIHtcclxuICAgICAgICAgICAgICBjb25zdCBub2RlID0gcHJvcGVydHkudmFsdWVOb2RlIHx8IHByb3BlcnR5O1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgIGFkZFByb2JsZW0oRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIGVycm9yTWVzc2FnZSwgc2NoZW1hUmVxdWVzdCwgZXJyb3JDb2RlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBSYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQoYXN0Um9vdC5vZmZzZXQpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChhc3RSb290Lm9mZnNldCArIDEpKTtcclxuICAgICAgICAgICAgICBhZGRQcm9ibGVtKERpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBlcnJvck1lc3NhZ2UsIHNjaGVtYVJlcXVlc3QsIGVycm9yQ29kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoc2NoZW1hMi5lcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBhZGRTY2hlbWFQcm9ibGVtKHNjaGVtYTIuZXJyb3JzWzBdLCBFcnJvckNvZGUuU2NoZW1hUmVzb2x2ZUVycm9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYVZhbGlkYXRpb24pIHtcclxuICAgICAgICAgIGZvciAoY29uc3Qgd2FybmluZyBvZiBzY2hlbWEyLndhcm5pbmdzKSB7XHJcbiAgICAgICAgICAgIGFkZFNjaGVtYVByb2JsZW0od2FybmluZywgRXJyb3JDb2RlLlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBzZW1hbnRpY0Vycm9ycyA9IGpzb25Eb2N1bWVudC52YWxpZGF0ZSh0ZXh0RG9jdW1lbnQsIHNjaGVtYTIuc2NoZW1hLCBzY2hlbWFWYWxpZGF0aW9uLCBkb2N1bWVudFNldHRpbmdzPy5zY2hlbWFEcmFmdCk7XHJcbiAgICAgICAgICBpZiAoc2VtYW50aWNFcnJvcnMpIHtcclxuICAgICAgICAgICAgc2VtYW50aWNFcnJvcnMuZm9yRWFjaChhZGRQcm9ibGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYTIuc2NoZW1hKSkge1xyXG4gICAgICAgICAgY29tbWVudFNldmVyaXR5ID0gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NoZW1hQWxsb3dzVHJhaWxpbmdDb21tYXMoc2NoZW1hMi5zY2hlbWEpKSB7XHJcbiAgICAgICAgICB0cmFpbGluZ0NvbW1hU2V2ZXJpdHkgPSB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgcCBvZiBqc29uRG9jdW1lbnQuc3ludGF4RXJyb3JzKSB7XHJcbiAgICAgICAgaWYgKHAuY29kZSA9PT0gRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdHJhaWxpbmdDb21tYVNldmVyaXR5ICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcC5zZXZlcml0eSA9IHRyYWlsaW5nQ29tbWFTZXZlcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkUHJvYmxlbShwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGNvbW1lbnRTZXZlcml0eSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0KFwiQ29tbWVudHMgYXJlIG5vdCBwZXJtaXR0ZWQgaW4gSlNPTi5cIik7XHJcbiAgICAgICAganNvbkRvY3VtZW50LmNvbW1lbnRzLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgIGFkZFByb2JsZW0oRGlhZ25vc3RpYy5jcmVhdGUoYywgbWVzc2FnZSwgY29tbWVudFNldmVyaXR5LCBFcnJvckNvZGUuQ29tbWVudE5vdFBlcm1pdHRlZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkaWFnbm9zdGljcztcclxuICAgIH07XHJcbiAgICBpZiAoc2NoZW1hKSB7XHJcbiAgICAgIGNvbnN0IHVyaSA9IHNjaGVtYS5pZCB8fCBcInNjaGVtYXNlcnZpY2U6Ly91bnRpdGxlZC9cIiArIGlkQ291bnRlcisrO1xyXG4gICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlLnJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEoeyB1cmksIHNjaGVtYSB9KTtcclxuICAgICAgcmV0dXJuIGhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpLnRoZW4oKHJlc29sdmVkU2NoZW1hKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpYWdub3N0aWNzKHJlc29sdmVkU2NoZW1hKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5qc29uU2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZSh0ZXh0RG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oKHNjaGVtYTIpID0+IHtcclxuICAgICAgcmV0dXJuIGdldERpYWdub3N0aWNzKHNjaGVtYTIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldExhbmd1YWdlU3RhdHVzKHRleHREb2N1bWVudCwganNvbkRvY3VtZW50KSB7XHJcbiAgICByZXR1cm4geyBzY2hlbWFzOiB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlLmdldFNjaGVtYVVSSXNGb3JSZXNvdXJjZSh0ZXh0RG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpIH07XHJcbiAgfVxyXG59O1xyXG52YXIgaWRDb3VudGVyID0gMDtcclxuZnVuY3Rpb24gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hUmVmKSB7XHJcbiAgaWYgKHNjaGVtYVJlZiAmJiB0eXBlb2Ygc2NoZW1hUmVmID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBpZiAoaXNCb29sZWFuKHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzKSkge1xyXG4gICAgICByZXR1cm4gc2NoZW1hUmVmLmFsbG93Q29tbWVudHM7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hUmVmLmFsbE9mKSB7XHJcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYVJlZi5hbGxPZikge1xyXG4gICAgICAgIGNvbnN0IGFsbG93ID0gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hKTtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKGFsbG93KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGFsbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdm9pZCAwO1xyXG59XHJcbmZ1bmN0aW9uIHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYVJlZikge1xyXG4gIGlmIChzY2hlbWFSZWYgJiYgdHlwZW9mIHNjaGVtYVJlZiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgaWYgKGlzQm9vbGVhbihzY2hlbWFSZWYuYWxsb3dUcmFpbGluZ0NvbW1hcykpIHtcclxuICAgICAgcmV0dXJuIHNjaGVtYVJlZi5hbGxvd1RyYWlsaW5nQ29tbWFzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVwclNjaGVtYVJlZiA9IHNjaGVtYVJlZjtcclxuICAgIGlmIChpc0Jvb2xlYW4oZGVwclNjaGVtYVJlZltcImFsbG93c1RyYWlsaW5nQ29tbWFzXCJdKSkge1xyXG4gICAgICByZXR1cm4gZGVwclNjaGVtYVJlZltcImFsbG93c1RyYWlsaW5nQ29tbWFzXCJdO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYVJlZi5hbGxPZikge1xyXG4gICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFSZWYuYWxsT2YpIHtcclxuICAgICAgICBjb25zdCBhbGxvdyA9IHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYSk7XHJcbiAgICAgICAgaWYgKGlzQm9vbGVhbihhbGxvdykpIHtcclxuICAgICAgICAgIHJldHVybiBhbGxvdztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eUxldmVsKSB7XHJcbiAgc3dpdGNoIChzZXZlcml0eUxldmVsKSB7XHJcbiAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgcmV0dXJuIERpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcclxuICAgIGNhc2UgXCJ3YXJuaW5nXCI6XHJcbiAgICAgIHJldHVybiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcclxuICAgIGNhc2UgXCJpZ25vcmVcIjpcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICB9XHJcbiAgcmV0dXJuIHZvaWQgMDtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2NvbG9ycy5qc1xyXG52YXIgRGlnaXQwID0gNDg7XHJcbnZhciBEaWdpdDkgPSA1NztcclxudmFyIEEgPSA2NTtcclxudmFyIGEgPSA5NztcclxudmFyIGYgPSAxMDI7XHJcbmZ1bmN0aW9uIGhleERpZ2l0KGNoYXJDb2RlKSB7XHJcbiAgaWYgKGNoYXJDb2RlIDwgRGlnaXQwKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgaWYgKGNoYXJDb2RlIDw9IERpZ2l0OSkge1xyXG4gICAgcmV0dXJuIGNoYXJDb2RlIC0gRGlnaXQwO1xyXG4gIH1cclxuICBpZiAoY2hhckNvZGUgPCBhKSB7XHJcbiAgICBjaGFyQ29kZSArPSBhIC0gQTtcclxuICB9XHJcbiAgaWYgKGNoYXJDb2RlID49IGEgJiYgY2hhckNvZGUgPD0gZikge1xyXG4gICAgcmV0dXJuIGNoYXJDb2RlIC0gYSArIDEwO1xyXG4gIH1cclxuICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBjb2xvckZyb21IZXgodGV4dCkge1xyXG4gIGlmICh0ZXh0WzBdICE9PSBcIiNcIikge1xyXG4gICAgcmV0dXJuIHZvaWQgMDtcclxuICB9XHJcbiAgc3dpdGNoICh0ZXh0Lmxlbmd0aCkge1xyXG4gICAgY2FzZSA0OlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZDogaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDEpKSAqIDE3IC8gMjU1LFxyXG4gICAgICAgIGdyZWVuOiBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMikpICogMTcgLyAyNTUsXHJcbiAgICAgICAgYmx1ZTogaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDMpKSAqIDE3IC8gMjU1LFxyXG4gICAgICAgIGFscGhhOiAxXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIDU6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVkOiBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMSkpICogMTcgLyAyNTUsXHJcbiAgICAgICAgZ3JlZW46IGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgyKSkgKiAxNyAvIDI1NSxcclxuICAgICAgICBibHVlOiBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMykpICogMTcgLyAyNTUsXHJcbiAgICAgICAgYWxwaGE6IGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCg0KSkgKiAxNyAvIDI1NVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSA3OlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAxNiArIGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgyKSkpIC8gMjU1LFxyXG4gICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDMpKSAqIDE2ICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUsXHJcbiAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCg1KSkgKiAxNiArIGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCg2KSkpIC8gMjU1LFxyXG4gICAgICAgIGFscGhhOiAxXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIDk6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVkOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDEpKSAqIDE2ICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUsXHJcbiAgICAgICAgZ3JlZW46IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMykpICogMTYgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNCkpKSAvIDI1NSxcclxuICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDE2ICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDYpKSkgLyAyNTUsXHJcbiAgICAgICAgYWxwaGE6IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNykpICogMTYgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoOCkpKSAvIDI1NVxyXG4gICAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gdm9pZCAwO1xyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvbkRvY3VtZW50U3ltYm9scy5qc1xyXG52YXIgSlNPTkRvY3VtZW50U3ltYm9scyA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihzY2hlbWFTZXJ2aWNlKSB7XHJcbiAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xyXG4gIH1cclxuICBmaW5kRG9jdW1lbnRTeW1ib2xzKGRvY3VtZW50LCBkb2MsIGNvbnRleHQgPSB7IHJlc3VsdExpbWl0OiBOdW1iZXIuTUFYX1ZBTFVFIH0pIHtcclxuICAgIGNvbnN0IHJvb3QgPSBkb2Mucm9vdDtcclxuICAgIGlmICghcm9vdCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBsZXQgbGltaXQgPSBjb250ZXh0LnJlc3VsdExpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBjb25zdCByZXNvdXJjZVN0cmluZyA9IGRvY3VtZW50LnVyaTtcclxuICAgIGlmIChyZXNvdXJjZVN0cmluZyA9PT0gXCJ2c2NvZGU6Ly9kZWZhdWx0c2V0dGluZ3Mva2V5YmluZGluZ3MuanNvblwiIHx8IGVuZHNXaXRoKHJlc291cmNlU3RyaW5nLnRvTG93ZXJDYXNlKCksIFwiL3VzZXIva2V5YmluZGluZ3MuanNvblwiKSkge1xyXG4gICAgICBpZiAocm9vdC50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQyID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJvb3QuaXRlbXMpIHtcclxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBpdGVtLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICBpZiAocHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gXCJrZXlcIiAmJiBwcm9wZXJ0eS52YWx1ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIGl0ZW0pKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogU3ltYm9sS2luZC5GdW5jdGlvbiwgbG9jYXRpb24gfSk7XHJcbiAgICAgICAgICAgICAgICBsaW1pdC0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB0b1Zpc2l0ID0gW1xyXG4gICAgICB7IG5vZGU6IHJvb3QsIGNvbnRhaW5lck5hbWU6IFwiXCIgfVxyXG4gICAgXTtcclxuICAgIGxldCBuZXh0VG9WaXNpdCA9IDA7XHJcbiAgICBsZXQgbGltaXRFeGNlZWRlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCBjb2xsZWN0T3V0bGluZUVudHJpZXMgPSAobm9kZSwgY29udGFpbmVyTmFtZSkgPT4ge1xyXG4gICAgICBpZiAobm9kZS50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICBub2RlLml0ZW1zLmZvckVhY2goKG5vZGUyKSA9PiB7XHJcbiAgICAgICAgICBpZiAobm9kZTIpIHtcclxuICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgbm9kZTogbm9kZTIsIGNvbnRhaW5lck5hbWUgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBwcm9wZXJ0eS52YWx1ZU5vZGU7XHJcbiAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcclxuICAgICAgICAgICAgICBsaW1pdC0tO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5KSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZSA/IGNvbnRhaW5lck5hbWUgKyBcIi5cIiArIHByb3BlcnR5LmtleU5vZGUudmFsdWUgOiBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlO1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogdGhpcy5nZXRLZXlMYWJlbChwcm9wZXJ0eSksIGtpbmQ6IHRoaXMuZ2V0U3ltYm9sS2luZCh2YWx1ZU5vZGUudHlwZSksIGxvY2F0aW9uLCBjb250YWluZXJOYW1lIH0pO1xyXG4gICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IG5vZGU6IHZhbHVlTm9kZSwgY29udGFpbmVyTmFtZTogY2hpbGRDb250YWluZXJOYW1lIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB3aGlsZSAobmV4dFRvVmlzaXQgPCB0b1Zpc2l0Lmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcclxuICAgICAgY29sbGVjdE91dGxpbmVFbnRyaWVzKG5leHQubm9kZSwgbmV4dC5jb250YWluZXJOYW1lKTtcclxuICAgIH1cclxuICAgIGlmIChsaW1pdEV4Y2VlZGVkICYmIGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcclxuICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgZmluZERvY3VtZW50U3ltYm9sczIoZG9jdW1lbnQsIGRvYywgY29udGV4dCA9IHsgcmVzdWx0TGltaXQ6IE51bWJlci5NQVhfVkFMVUUgfSkge1xyXG4gICAgY29uc3Qgcm9vdCA9IGRvYy5yb290O1xyXG4gICAgaWYgKCFyb290KSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGxldCBsaW1pdCA9IGNvbnRleHQucmVzdWx0TGltaXQgfHwgTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGNvbnN0IHJlc291cmNlU3RyaW5nID0gZG9jdW1lbnQudXJpO1xyXG4gICAgaWYgKHJlc291cmNlU3RyaW5nID09PSBcInZzY29kZTovL2RlZmF1bHRzZXR0aW5ncy9rZXliaW5kaW5ncy5qc29uXCIgfHwgZW5kc1dpdGgocmVzb3VyY2VTdHJpbmcudG9Mb3dlckNhc2UoKSwgXCIvdXNlci9rZXliaW5kaW5ncy5qc29uXCIpKSB7XHJcbiAgICAgIGlmIChyb290LnR5cGUgPT09IFwiYXJyYXlcIikge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDIgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygcm9vdC5pdGVtcykge1xyXG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGl0ZW0ucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSBcImtleVwiICYmIHByb3BlcnR5LnZhbHVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eS5rZXlOb2RlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogU3ltYm9sS2luZC5GdW5jdGlvbiwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlIH0pO1xyXG4gICAgICAgICAgICAgICAgbGltaXQtLTtcclxuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCB0b1Zpc2l0ID0gW1xyXG4gICAgICB7IG5vZGU6IHJvb3QsIHJlc3VsdCB9XHJcbiAgICBdO1xyXG4gICAgbGV0IG5leHRUb1Zpc2l0ID0gMDtcclxuICAgIGxldCBsaW1pdEV4Y2VlZGVkID0gZmFsc2U7XHJcbiAgICBjb25zdCBjb2xsZWN0T3V0bGluZUVudHJpZXMgPSAobm9kZSwgcmVzdWx0MikgPT4ge1xyXG4gICAgICBpZiAobm9kZS50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICBub2RlLml0ZW1zLmZvckVhY2goKG5vZGUyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgaWYgKG5vZGUyKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcclxuICAgICAgICAgICAgICBsaW1pdC0tO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIG5vZGUyKTtcclxuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBTdHJpbmcoaW5kZXgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHsgbmFtZSwga2luZDogdGhpcy5nZXRTeW1ib2xLaW5kKG5vZGUyLnR5cGUpLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuOiBbXSB9O1xyXG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IHJlc3VsdDogc3ltYm9sLmNoaWxkcmVuLCBub2RlOiBub2RlMiB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIG5vZGUucHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xyXG4gICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgbGltaXQtLTtcclxuICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkua2V5Tm9kZSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSB7IG5hbWU6IHRoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuLCBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKHZhbHVlTm9kZSkgfTtcclxuICAgICAgICAgICAgICByZXN1bHQyLnB1c2goc3ltYm9sKTtcclxuICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyByZXN1bHQ6IGNoaWxkcmVuLCBub2RlOiB2YWx1ZU5vZGUgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbGltaXRFeGNlZWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdoaWxlIChuZXh0VG9WaXNpdCA8IHRvVmlzaXQubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSB0b1Zpc2l0W25leHRUb1Zpc2l0KytdO1xyXG4gICAgICBjb2xsZWN0T3V0bGluZUVudHJpZXMobmV4dC5ub2RlLCBuZXh0LnJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBpZiAobGltaXRFeGNlZWRlZCAmJiBjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XHJcbiAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGdldFN5bWJvbEtpbmQobm9kZVR5cGUpIHtcclxuICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcclxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgIHJldHVybiBTeW1ib2xLaW5kLk1vZHVsZTtcclxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgIHJldHVybiBTeW1ib2xLaW5kLlN0cmluZztcclxuICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgIHJldHVybiBTeW1ib2xLaW5kLk51bWJlcjtcclxuICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuQXJyYXk7XHJcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuQm9vbGVhbjtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5WYXJpYWJsZTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0S2V5TGFiZWwocHJvcGVydHkpIHtcclxuICAgIGxldCBuYW1lID0gcHJvcGVydHkua2V5Tm9kZS52YWx1ZTtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXG5dL2csIFwiXFx1MjFCNVwiKTtcclxuICAgIH1cclxuICAgIGlmIChuYW1lICYmIG5hbWUudHJpbSgpKSB7XHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBcIiR7bmFtZX1cImA7XHJcbiAgfVxyXG4gIGdldERldGFpbChub2RlKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IG5vZGUudHlwZSA9PT0gXCJudW1iZXJcIiB8fCBub2RlLnR5cGUgPT09IFwibnVsbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXR1cm4gU3RyaW5nKG5vZGUudmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJhcnJheVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID8gdm9pZCAwIDogXCJbXVwiO1xyXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IHZvaWQgMCA6IFwie31cIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZvaWQgMDtcclxuICB9XHJcbiAgZmluZERvY3VtZW50Q29sb3JzKGRvY3VtZW50LCBkb2MsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgaWYgKHNjaGVtYSkge1xyXG4gICAgICAgIGxldCBsaW1pdCA9IGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQucmVzdWx0TGltaXQgPT09IFwibnVtYmVyXCIgPyBjb250ZXh0LnJlc3VsdExpbWl0IDogTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBjb25zdCBtYXRjaGluZ1NjaGVtYXMgPSBkb2MuZ2V0TWF0Y2hpbmdTY2hlbWFzKHNjaGVtYS5zY2hlbWEpO1xyXG4gICAgICAgIGNvbnN0IHZpc2l0ZWROb2RlID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIG1hdGNoaW5nU2NoZW1hcykge1xyXG4gICAgICAgICAgaWYgKCFzLmludmVydGVkICYmIHMuc2NoZW1hICYmIChzLnNjaGVtYS5mb3JtYXQgPT09IFwiY29sb3JcIiB8fCBzLnNjaGVtYS5mb3JtYXQgPT09IFwiY29sb3ItaGV4XCIpICYmIHMubm9kZSAmJiBzLm5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlSWQgPSBTdHJpbmcocy5ub2RlLm9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZE5vZGVbbm9kZUlkXSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JGcm9tSGV4KGdldE5vZGVWYWx1ZTMocy5ub2RlKSk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBjb2xvciwgcmFuZ2UgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHZpc2l0ZWROb2RlW25vZGVJZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGxpbWl0LS07XHJcbiAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldENvbG9yUHJlc2VudGF0aW9ucyhkb2N1bWVudCwgZG9jLCBjb2xvciwgcmFuZ2UpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgY29uc3QgcmVkMjU2ID0gTWF0aC5yb3VuZChjb2xvci5yZWQgKiAyNTUpLCBncmVlbjI1NiA9IE1hdGgucm91bmQoY29sb3IuZ3JlZW4gKiAyNTUpLCBibHVlMjU2ID0gTWF0aC5yb3VuZChjb2xvci5ibHVlICogMjU1KTtcclxuICAgIGZ1bmN0aW9uIHRvVHdvRGlnaXRIZXgobikge1xyXG4gICAgICBjb25zdCByID0gbi50b1N0cmluZygxNik7XHJcbiAgICAgIHJldHVybiByLmxlbmd0aCAhPT0gMiA/IFwiMFwiICsgciA6IHI7XHJcbiAgICB9XHJcbiAgICBsZXQgbGFiZWw7XHJcbiAgICBpZiAoY29sb3IuYWxwaGEgPT09IDEpIHtcclxuICAgICAgbGFiZWwgPSBgIyR7dG9Ud29EaWdpdEhleChyZWQyNTYpfSR7dG9Ud29EaWdpdEhleChncmVlbjI1Nil9JHt0b1R3b0RpZ2l0SGV4KGJsdWUyNTYpfWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsYWJlbCA9IGAjJHt0b1R3b0RpZ2l0SGV4KHJlZDI1Nil9JHt0b1R3b0RpZ2l0SGV4KGdyZWVuMjU2KX0ke3RvVHdvRGlnaXRIZXgoYmx1ZTI1Nil9JHt0b1R3b0RpZ2l0SGV4KE1hdGgucm91bmQoY29sb3IuYWxwaGEgKiAyNTUpKX1gO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnB1c2goeyBsYWJlbCwgdGV4dEVkaXQ6IFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIEpTT04uc3RyaW5naWZ5KGxhYmVsKSkgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0UmFuZ2UoZG9jdW1lbnQsIG5vZGUpIHtcclxuICByZXR1cm4gUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcclxufVxyXG5mdW5jdGlvbiBnZXROYW1lKG5vZGUpIHtcclxuICByZXR1cm4gZ2V0Tm9kZVZhbHVlMyhub2RlKSB8fCB0KFwiPGVtcHR5PlwiKTtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2NvbmZpZ3VyYXRpb24uanNcclxudmFyIHNjaGVtYUNvbnRyaWJ1dGlvbnMgPSB7XHJcbiAgc2NoZW1hQXNzb2NpYXRpb25zOiBbXSxcclxuICBzY2hlbWFzOiB7XHJcbiAgICAvLyBidW5kbGUgdGhlIHNjaGVtYS1zY2hlbWEgdG8gaW5jbHVkZSAobG9jYWxpemVkKSBkZXNjcmlwdGlvbnNcclxuICAgIFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCI6IHtcclxuICAgICAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXHJcbiAgICAgIFwiZGVmaW5pdGlvbnNcIjoge1xyXG4gICAgICAgIFwic2NoZW1hQXJyYXlcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcclxuICAgICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgICBcIiRyZWZcIjogXCIjXCJcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicG9zaXRpdmVJbnRlZ2VyXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcclxuICAgICAgICAgIFwibWluaW11bVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvc2l0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCJkZWZhdWx0XCI6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzaW1wbGVUeXBlc1wiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZW51bVwiOiBbXHJcbiAgICAgICAgICAgIFwiYXJyYXlcIixcclxuICAgICAgICAgICAgXCJib29sZWFuXCIsXHJcbiAgICAgICAgICAgIFwiaW50ZWdlclwiLFxyXG4gICAgICAgICAgICBcIm51bGxcIixcclxuICAgICAgICAgICAgXCJudW1iZXJcIixcclxuICAgICAgICAgICAgXCJvYmplY3RcIixcclxuICAgICAgICAgICAgXCJzdHJpbmdcIlxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdHJpbmdBcnJheVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxyXG4gICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcImlkXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCIkc2NoZW1hXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZhdWx0XCI6IHt9LFxyXG4gICAgICAgIFwibXVsdGlwbGVPZlwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgICAgIFwibWluaW11bVwiOiAwLFxyXG4gICAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibWF4aW11bVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJleGNsdXNpdmVNYXhpbXVtXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcclxuICAgICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJtaW5pbXVtXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1heExlbmd0aFwiOiB7XHJcbiAgICAgICAgICBcImFsbE9mXCI6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJtaW5MZW5ndGhcIjoge1xyXG4gICAgICAgICAgXCJhbGxPZlwiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwYXR0ZXJuXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJmb3JtYXRcIjogXCJyZWdleFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImFkZGl0aW9uYWxJdGVtc1wiOiB7XHJcbiAgICAgICAgICBcImFueU9mXCI6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiI1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBcImRlZmF1bHRcIjoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgXCJhbnlPZlwiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1heEl0ZW1zXCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1pbkl0ZW1zXCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidW5pcXVlSXRlbXNcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1heFByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgICAgXCJhbGxPZlwiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibWluUHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgICBcImFsbE9mXCI6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDBcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInJlcXVpcmVkXCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgICAgXCJhbnlPZlwiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiNcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRlZmluaXRpb25zXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcIiNcIlxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcIiNcIlxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcclxuICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgICAgICBcIiRyZWZcIjogXCIjXCJcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcImRlZmF1bHRcIjoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgICAgIFwiYW55T2ZcIjogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiNcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwiXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImVudW1cIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcclxuICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0eXBlXCI6IHtcclxuICAgICAgICAgIFwiYW55T2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXHJcbiAgICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZm9ybWF0XCI6IHtcclxuICAgICAgICAgIFwiYW55T2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgXCJlbnVtXCI6IFtcclxuICAgICAgICAgICAgICAgIFwiZGF0ZS10aW1lXCIsXHJcbiAgICAgICAgICAgICAgICBcInVyaVwiLFxyXG4gICAgICAgICAgICAgICAgXCJlbWFpbFwiLFxyXG4gICAgICAgICAgICAgICAgXCJob3N0bmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJpcHY0XCIsXHJcbiAgICAgICAgICAgICAgICBcImlwdjZcIixcclxuICAgICAgICAgICAgICAgIFwicmVnZXhcIlxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYWxsT2ZcIjoge1xyXG4gICAgICAgICAgXCJhbGxPZlwiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJhbnlPZlwiOiB7XHJcbiAgICAgICAgICBcImFsbE9mXCI6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm9uZU9mXCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibm90XCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiI1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcclxuICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjogW1xyXG4gICAgICAgICAgXCJtYXhpbXVtXCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiBbXHJcbiAgICAgICAgICBcIm1pbmltdW1cIlxyXG4gICAgICAgIF1cclxuICAgICAgfSxcclxuICAgICAgXCJkZWZhdWx0XCI6IHt9XHJcbiAgICB9LFxyXG4gICAgXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIjoge1xyXG4gICAgICBcImRlZmluaXRpb25zXCI6IHtcclxuICAgICAgICBcInNjaGVtYUFycmF5XCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXHJcbiAgICAgICAgICBcIml0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcclxuICAgICAgICAgIFwibWluaW11bVwiOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcclxuICAgICAgICAgIFwiYWxsT2ZcIjogW1xyXG4gICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCIgfSxcclxuICAgICAgICAgICAgeyBcImRlZmF1bHRcIjogMCB9XHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNpbXBsZVR5cGVzXCI6IHtcclxuICAgICAgICAgIFwiZW51bVwiOiBbXHJcbiAgICAgICAgICAgIFwiYXJyYXlcIixcclxuICAgICAgICAgICAgXCJib29sZWFuXCIsXHJcbiAgICAgICAgICAgIFwiaW50ZWdlclwiLFxyXG4gICAgICAgICAgICBcIm51bGxcIixcclxuICAgICAgICAgICAgXCJudW1iZXJcIixcclxuICAgICAgICAgICAgXCJvYmplY3RcIixcclxuICAgICAgICAgICAgXCJzdHJpbmdcIlxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdHJpbmdBcnJheVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICAgICAgXCJpdGVtc1wiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXHJcbiAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWUsXHJcbiAgICAgICAgICBcImRlZmF1bHRcIjogW11cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwidHlwZVwiOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwiJGlkXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiJHNjaGVtYVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZm9ybWF0XCI6IFwidXJpXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiJHJlZlwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIiRjb21tZW50XCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRpdGxlXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcclxuICAgICAgICBcInJlYWRPbmx5XCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcclxuICAgICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJleGFtcGxlc1wiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICAgICAgXCJpdGVtc1wiOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm11bHRpcGxlT2ZcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJtYXhpbXVtXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibWluaW11bVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1heExlbmd0aFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCIgfSxcclxuICAgICAgICBcIm1pbkxlbmd0aFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxyXG4gICAgICAgIFwicGF0dGVyblwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJhZGRpdGlvbmFsSXRlbXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcclxuICAgICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICAgIFwiYW55T2ZcIjogW1xyXG4gICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9LFxyXG4gICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibWF4SXRlbXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwiIH0sXHJcbiAgICAgICAgXCJtaW5JdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxyXG4gICAgICAgIFwidW5pcXVlSXRlbXNcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvbnRhaW5zXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXHJcbiAgICAgICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxyXG4gICAgICAgIFwibWluUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxyXG4gICAgICAgIFwicmVxdWlyZWRcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfSxcclxuICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXHJcbiAgICAgICAgXCJkZWZpbml0aW9uc1wiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcclxuICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcclxuICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxyXG4gICAgICAgICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHsgXCJmb3JtYXRcIjogXCJyZWdleFwiIH0sXHJcbiAgICAgICAgICBcImRlZmF1bHRcIjoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgICAgIFwiYW55T2ZcIjogW1xyXG4gICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiI1wiIH0sXHJcbiAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInByb3BlcnR5TmFtZXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcclxuICAgICAgICBcImNvbnN0XCI6IHRydWUsXHJcbiAgICAgICAgXCJlbnVtXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICBcIml0ZW1zXCI6IHRydWUsXHJcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXHJcbiAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidHlwZVwiOiB7XHJcbiAgICAgICAgICBcImFueU9mXCI6IFtcclxuICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCIgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgICAgXCJpdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIiB9LFxyXG4gICAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcclxuICAgICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmb3JtYXRcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxyXG4gICAgICAgIFwiY29udGVudE1lZGlhVHlwZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXHJcbiAgICAgICAgXCJjb250ZW50RW5jb2RpbmdcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxyXG4gICAgICAgIFwiaWZcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcclxuICAgICAgICBcInRoZW5cIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcclxuICAgICAgICBcImVsc2VcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcclxuICAgICAgICBcImFsbE9mXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXHJcbiAgICAgICAgXCJhbnlPZlwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxyXG4gICAgICAgIFwib25lT2ZcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcclxuICAgICAgICBcIm5vdFwiOiB7IFwiJHJlZlwiOiBcIiNcIiB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG52YXIgZGVzY3JpcHRpb25zID0ge1xyXG4gIGlkOiB0KFwiQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVtYS5cIiksXHJcbiAgJHNjaGVtYTogdChcIlRoZSBzY2hlbWEgdG8gdmVyaWZ5IHRoaXMgZG9jdW1lbnQgYWdhaW5zdC5cIiksXHJcbiAgdGl0bGU6IHQoXCJBIGRlc2NyaXB0aXZlIHRpdGxlIG9mIHRoZSBlbGVtZW50LlwiKSxcclxuICBkZXNjcmlwdGlvbjogdChcIkEgbG9uZyBkZXNjcmlwdGlvbiBvZiB0aGUgZWxlbWVudC4gVXNlZCBpbiBob3ZlciBtZW51cyBhbmQgc3VnZ2VzdGlvbnMuXCIpLFxyXG4gIGRlZmF1bHQ6IHQoXCJBIGRlZmF1bHQgdmFsdWUuIFVzZWQgYnkgc3VnZ2VzdGlvbnMuXCIpLFxyXG4gIG11bHRpcGxlT2Y6IHQoXCJBIG51bWJlciB0aGF0IHNob3VsZCBjbGVhbmx5IGRpdmlkZSB0aGUgY3VycmVudCB2YWx1ZSAoaS5lLiBoYXZlIG5vIHJlbWFpbmRlcikuXCIpLFxyXG4gIG1heGltdW06IHQoXCJUaGUgbWF4aW11bSBudW1lcmljYWwgdmFsdWUsIGluY2x1c2l2ZSBieSBkZWZhdWx0LlwiKSxcclxuICBleGNsdXNpdmVNYXhpbXVtOiB0KFwiTWFrZXMgdGhlIG1heGltdW0gcHJvcGVydHkgZXhjbHVzaXZlLlwiKSxcclxuICBtaW5pbXVtOiB0KFwiVGhlIG1pbmltdW0gbnVtZXJpY2FsIHZhbHVlLCBpbmNsdXNpdmUgYnkgZGVmYXVsdC5cIiksXHJcbiAgZXhjbHVzaXZlTWluaW11bTogdChcIk1ha2VzIHRoZSBtaW5pbXVtIHByb3BlcnR5IGV4Y2x1c2l2ZS5cIiksXHJcbiAgbWF4TGVuZ3RoOiB0KFwiVGhlIG1heGltdW0gbGVuZ3RoIG9mIGEgc3RyaW5nLlwiKSxcclxuICBtaW5MZW5ndGg6IHQoXCJUaGUgbWluaW11bSBsZW5ndGggb2YgYSBzdHJpbmcuXCIpLFxyXG4gIHBhdHRlcm46IHQoXCJBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgc3RyaW5nIGFnYWluc3QuIEl0IGlzIG5vdCBpbXBsaWNpdGx5IGFuY2hvcmVkLlwiKSxcclxuICBhZGRpdGlvbmFsSXRlbXM6IHQoXCJGb3IgYXJyYXlzLCBvbmx5IHdoZW4gaXRlbXMgaXMgc2V0IGFzIGFuIGFycmF5LiBJZiBpdCBpcyBhIHNjaGVtYSwgdGhlbiB0aGlzIHNjaGVtYSB2YWxpZGF0ZXMgaXRlbXMgYWZ0ZXIgdGhlIG9uZXMgc3BlY2lmaWVkIGJ5IHRoZSBpdGVtcyBhcnJheS4gSWYgaXQgaXMgZmFsc2UsIHRoZW4gYWRkaXRpb25hbCBpdGVtcyB3aWxsIGNhdXNlIHZhbGlkYXRpb24gdG8gZmFpbC5cIiksXHJcbiAgaXRlbXM6IHQoXCJGb3IgYXJyYXlzLiBDYW4gZWl0aGVyIGJlIGEgc2NoZW1hIHRvIHZhbGlkYXRlIGV2ZXJ5IGVsZW1lbnQgYWdhaW5zdCBvciBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHZhbGlkYXRlIGVhY2ggaXRlbSBhZ2FpbnN0IGluIG9yZGVyICh0aGUgZmlyc3Qgc2NoZW1hIHdpbGwgdmFsaWRhdGUgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBzZWNvbmQgc2NoZW1hIHdpbGwgdmFsaWRhdGUgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXCIpLFxyXG4gIG1heEl0ZW1zOiB0KFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIGluc2lkZSBhbiBhcnJheS4gSW5jbHVzaXZlLlwiKSxcclxuICBtaW5JdGVtczogdChcIlRoZSBtaW5pbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbnNpZGUgYW4gYXJyYXkuIEluY2x1c2l2ZS5cIiksXHJcbiAgdW5pcXVlSXRlbXM6IHQoXCJJZiBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBtdXN0IGJlIHVuaXF1ZS4gRGVmYXVsdHMgdG8gZmFsc2UuXCIpLFxyXG4gIG1heFByb3BlcnRpZXM6IHQoXCJUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgY2FuIGhhdmUuIEluY2x1c2l2ZS5cIiksXHJcbiAgbWluUHJvcGVydGllczogdChcIlRoZSBtaW5pbXVtIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFuIG9iamVjdCBjYW4gaGF2ZS4gSW5jbHVzaXZlLlwiKSxcclxuICByZXF1aXJlZDogdChcIkFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBsaXN0cyB0aGUgbmFtZXMgb2YgYWxsIHByb3BlcnRpZXMgcmVxdWlyZWQgb24gdGhpcyBvYmplY3QuXCIpLFxyXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0KFwiRWl0aGVyIGEgc2NoZW1hIG9yIGEgYm9vbGVhbi4gSWYgYSBzY2hlbWEsIHRoZW4gdXNlZCB0byB2YWxpZGF0ZSBhbGwgcHJvcGVydGllcyBub3QgbWF0Y2hlZCBieSAncHJvcGVydGllcycgb3IgJ3BhdHRlcm5Qcm9wZXJ0aWVzJy4gSWYgZmFsc2UsIHRoZW4gYW55IHByb3BlcnRpZXMgbm90IG1hdGNoZWQgYnkgZWl0aGVyIHdpbGwgY2F1c2UgdGhpcyBzY2hlbWEgdG8gZmFpbC5cIiksXHJcbiAgZGVmaW5pdGlvbnM6IHQoXCJOb3QgdXNlZCBmb3IgdmFsaWRhdGlvbi4gUGxhY2Ugc3Vic2NoZW1hcyBoZXJlIHRoYXQgeW91IHdpc2ggdG8gcmVmZXJlbmNlIGlubGluZSB3aXRoICRyZWYuXCIpLFxyXG4gIHByb3BlcnRpZXM6IHQoXCJBIG1hcCBvZiBwcm9wZXJ0eSBuYW1lcyB0byBzY2hlbWFzIGZvciBlYWNoIHByb3BlcnR5LlwiKSxcclxuICBwYXR0ZXJuUHJvcGVydGllczogdChcIkEgbWFwIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb24gcHJvcGVydHkgbmFtZXMgdG8gc2NoZW1hcyBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcy5cIiksXHJcbiAgZGVwZW5kZW5jaWVzOiB0KFwiQSBtYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gZWl0aGVyIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9yIGEgc2NoZW1hLiBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBtZWFucyB0aGUgcHJvcGVydHkgbmFtZWQgaW4gdGhlIGtleSBkZXBlbmRzIG9uIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBhcnJheSBiZWluZyBwcmVzZW50IGluIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gYmUgdmFsaWQuIElmIHRoZSB2YWx1ZSBpcyBhIHNjaGVtYSwgdGhlbiB0aGUgc2NoZW1hIGlzIG9ubHkgYXBwbGllZCB0byB0aGUgb2JqZWN0IGlmIHRoZSBwcm9wZXJ0eSBpbiB0aGUga2V5IGV4aXN0cyBvbiB0aGUgb2JqZWN0LlwiKSxcclxuICBlbnVtOiB0KFwiVGhlIHNldCBvZiBsaXRlcmFsIHZhbHVlcyB0aGF0IGFyZSB2YWxpZC5cIiksXHJcbiAgdHlwZTogdChcIkVpdGhlciBhIHN0cmluZyBvZiBvbmUgb2YgdGhlIGJhc2ljIHNjaGVtYSB0eXBlcyAobnVtYmVyLCBpbnRlZ2VyLCBudWxsLCBhcnJheSwgb2JqZWN0LCBib29sZWFuLCBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3Mgc3BlY2lmeWluZyBhIHN1YnNldCBvZiB0aG9zZSB0eXBlcy5cIiksXHJcbiAgZm9ybWF0OiB0KFwiRGVzY3JpYmVzIHRoZSBmb3JtYXQgZXhwZWN0ZWQgZm9yIHRoZSB2YWx1ZS5cIiksXHJcbiAgYWxsT2Y6IHQoXCJBbiBhcnJheSBvZiBzY2hlbWFzLCBhbGwgb2Ygd2hpY2ggbXVzdCBtYXRjaC5cIiksXHJcbiAgYW55T2Y6IHQoXCJBbiBhcnJheSBvZiBzY2hlbWFzLCB3aGVyZSBhdCBsZWFzdCBvbmUgbXVzdCBtYXRjaC5cIiksXHJcbiAgb25lT2Y6IHQoXCJBbiBhcnJheSBvZiBzY2hlbWFzLCBleGFjdGx5IG9uZSBvZiB3aGljaCBtdXN0IG1hdGNoLlwiKSxcclxuICBub3Q6IHQoXCJBIHNjaGVtYSB3aGljaCBtdXN0IG5vdCBtYXRjaC5cIiksXHJcbiAgJGlkOiB0KFwiQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVtYS5cIiksXHJcbiAgJHJlZjogdChcIlJlZmVyZW5jZSBhIGRlZmluaXRpb24gaG9zdGVkIG9uIGFueSBsb2NhdGlvbi5cIiksXHJcbiAgJGNvbW1lbnQ6IHQoXCJDb21tZW50cyBmcm9tIHNjaGVtYSBhdXRob3JzIHRvIHJlYWRlcnMgb3IgbWFpbnRhaW5lcnMgb2YgdGhlIHNjaGVtYS5cIiksXHJcbiAgcmVhZE9ubHk6IHQoXCJJbmRpY2F0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGluc3RhbmNlIGlzIG1hbmFnZWQgZXhjbHVzaXZlbHkgYnkgdGhlIG93bmluZyBhdXRob3JpdHkuXCIpLFxyXG4gIGV4YW1wbGVzOiB0KFwiU2FtcGxlIEpTT04gdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgc2NoZW1hLCBmb3IgdGhlIHB1cnBvc2Ugb2YgaWxsdXN0cmF0aW5nIHVzYWdlLlwiKSxcclxuICBjb250YWluczogdCgnQW4gYXJyYXkgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCBcImNvbnRhaW5zXCIgaWYgYXQgbGVhc3Qgb25lIG9mIGl0cyBlbGVtZW50cyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBnaXZlbiBzY2hlbWEuJyksXHJcbiAgcHJvcGVydHlOYW1lczogdChcIklmIHRoZSBpbnN0YW5jZSBpcyBhbiBvYmplY3QsIHRoaXMga2V5d29yZCB2YWxpZGF0ZXMgaWYgZXZlcnkgcHJvcGVydHkgbmFtZSBpbiB0aGUgaW5zdGFuY2UgdmFsaWRhdGVzIGFnYWluc3QgdGhlIHByb3ZpZGVkIHNjaGVtYS5cIiksXHJcbiAgY29uc3Q6IHQoXCJBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgdGhlIGtleXdvcmQuXCIpLFxyXG4gIGNvbnRlbnRNZWRpYVR5cGU6IHQoXCJEZXNjcmliZXMgdGhlIG1lZGlhIHR5cGUgb2YgYSBzdHJpbmcgcHJvcGVydHkuXCIpLFxyXG4gIGNvbnRlbnRFbmNvZGluZzogdChcIkRlc2NyaWJlcyB0aGUgY29udGVudCBlbmNvZGluZyBvZiBhIHN0cmluZyBwcm9wZXJ0eS5cIiksXHJcbiAgaWY6IHQoJ1RoZSB2YWxpZGF0aW9uIG91dGNvbWUgb2YgdGhlIFwiaWZcIiBzdWJzY2hlbWEgY29udHJvbHMgd2hpY2ggb2YgdGhlIFwidGhlblwiIG9yIFwiZWxzZVwiIGtleXdvcmRzIGFyZSBldmFsdWF0ZWQuJyksXHJcbiAgdGhlbjogdCgnVGhlIFwiaWZcIiBzdWJzY2hlbWEgaXMgdXNlZCBmb3IgdmFsaWRhdGlvbiB3aGVuIHRoZSBcImlmXCIgc3Vic2NoZW1hIHN1Y2NlZWRzLicpLFxyXG4gIGVsc2U6IHQoJ1RoZSBcImVsc2VcIiBzdWJzY2hlbWEgaXMgdXNlZCBmb3IgdmFsaWRhdGlvbiB3aGVuIHRoZSBcImlmXCIgc3Vic2NoZW1hIGZhaWxzLicpXHJcbn07XHJcbmZvciAoY29uc3Qgc2NoZW1hTmFtZSBpbiBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXMpIHtcclxuICBjb25zdCBzY2hlbWEgPSBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXNbc2NoZW1hTmFtZV07XHJcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xyXG4gICAgbGV0IHByb3BlcnR5T2JqZWN0ID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldO1xyXG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eU9iamVjdCA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgcHJvcGVydHlPYmplY3QgPSBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV0gPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25zW3Byb3BlcnR5XTtcclxuICAgIGlmIChkZXNjcmlwdGlvbikge1xyXG4gICAgICBwcm9wZXJ0eU9iamVjdFtcImRlc2NyaXB0aW9uXCJdID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLXVyaS9saWIvZXNtL2luZGV4Lm1qc1xyXG52YXIgTElCO1xyXG4oKCkgPT4ge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG4gIHZhciB0MiA9IHsgNDcwOiAodDMpID0+IHtcclxuICAgIGZ1bmN0aW9uIGUyKHQ0KSB7XHJcbiAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0NClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHQ0KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByMih0NCwgZTMpIHtcclxuICAgICAgZm9yICh2YXIgcjMsIG4zID0gXCJcIiwgaSA9IDAsIG8gPSAtMSwgcyA9IDAsIGggPSAwOyBoIDw9IHQ0Lmxlbmd0aDsgKytoKSB7XHJcbiAgICAgICAgaWYgKGggPCB0NC5sZW5ndGgpXHJcbiAgICAgICAgICByMyA9IHQ0LmNoYXJDb2RlQXQoaCk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpZiAoNDcgPT09IHIzKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIHIzID0gNDc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICg0NyA9PT0gcjMpIHtcclxuICAgICAgICAgIGlmIChvID09PSBoIC0gMSB8fCAxID09PSBzKVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICBlbHNlIGlmIChvICE9PSBoIC0gMSAmJiAyID09PSBzKSB7XHJcbiAgICAgICAgICAgIGlmIChuMy5sZW5ndGggPCAyIHx8IDIgIT09IGkgfHwgNDYgIT09IG4zLmNoYXJDb2RlQXQobjMubGVuZ3RoIC0gMSkgfHwgNDYgIT09IG4zLmNoYXJDb2RlQXQobjMubGVuZ3RoIC0gMikpIHtcclxuICAgICAgICAgICAgICBpZiAobjMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEyID0gbjMubGFzdEluZGV4T2YoXCIvXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEyICE9PSBuMy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIC0xID09PSBhMiA/IChuMyA9IFwiXCIsIGkgPSAwKSA6IGkgPSAobjMgPSBuMy5zbGljZSgwLCBhMikpLmxlbmd0aCAtIDEgLSBuMy5sYXN0SW5kZXhPZihcIi9cIiksIG8gPSBoLCBzID0gMDtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgyID09PSBuMy5sZW5ndGggfHwgMSA9PT0gbjMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBuMyA9IFwiXCIsIGkgPSAwLCBvID0gaCwgcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZTMgJiYgKG4zLmxlbmd0aCA+IDAgPyBuMyArPSBcIi8uLlwiIDogbjMgPSBcIi4uXCIsIGkgPSAyKTtcclxuICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBuMy5sZW5ndGggPiAwID8gbjMgKz0gXCIvXCIgKyB0NC5zbGljZShvICsgMSwgaCkgOiBuMyA9IHQ0LnNsaWNlKG8gKyAxLCBoKSwgaSA9IGggLSBvIC0gMTtcclxuICAgICAgICAgIG8gPSBoLCBzID0gMDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgIDQ2ID09PSByMyAmJiAtMSAhPT0gcyA/ICsrcyA6IHMgPSAtMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbjM7XHJcbiAgICB9XHJcbiAgICB2YXIgbjIgPSB7IHJlc29sdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBmb3IgKHZhciB0NCwgbjMgPSBcIlwiLCBpID0gZmFsc2UsIG8gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgbyA+PSAtMSAmJiAhaTsgby0tKSB7XHJcbiAgICAgICAgdmFyIHM7XHJcbiAgICAgICAgbyA+PSAwID8gcyA9IGFyZ3VtZW50c1tvXSA6ICh2b2lkIDAgPT09IHQ0ICYmICh0NCA9IHByb2Nlc3MuY3dkKCkpLCBzID0gdDQpLCBlMihzKSwgMCAhPT0gcy5sZW5ndGggJiYgKG4zID0gcyArIFwiL1wiICsgbjMsIGkgPSA0NyA9PT0gcy5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbjMgPSByMihuMywgIWkpLCBpID8gbjMubGVuZ3RoID4gMCA/IFwiL1wiICsgbjMgOiBcIi9cIiA6IG4zLmxlbmd0aCA+IDAgPyBuMyA6IFwiLlwiO1xyXG4gICAgfSwgbm9ybWFsaXplOiBmdW5jdGlvbih0NCkge1xyXG4gICAgICBpZiAoZTIodDQpLCAwID09PSB0NC5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIFwiLlwiO1xyXG4gICAgICB2YXIgbjMgPSA0NyA9PT0gdDQuY2hhckNvZGVBdCgwKSwgaSA9IDQ3ID09PSB0NC5jaGFyQ29kZUF0KHQ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICByZXR1cm4gMCAhPT0gKHQ0ID0gcjIodDQsICFuMykpLmxlbmd0aCB8fCBuMyB8fCAodDQgPSBcIi5cIiksIHQ0Lmxlbmd0aCA+IDAgJiYgaSAmJiAodDQgKz0gXCIvXCIpLCBuMyA/IFwiL1wiICsgdDQgOiB0NDtcclxuICAgIH0sIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKHQ0KSB7XHJcbiAgICAgIHJldHVybiBlMih0NCksIHQ0Lmxlbmd0aCA+IDAgJiYgNDcgPT09IHQ0LmNoYXJDb2RlQXQoMCk7XHJcbiAgICB9LCBqb2luOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIFwiLlwiO1xyXG4gICAgICBmb3IgKHZhciB0NCwgcjMgPSAwOyByMyA8IGFyZ3VtZW50cy5sZW5ndGg7ICsrcjMpIHtcclxuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50c1tyM107XHJcbiAgICAgICAgZTIoaSksIGkubGVuZ3RoID4gMCAmJiAodm9pZCAwID09PSB0NCA/IHQ0ID0gaSA6IHQ0ICs9IFwiL1wiICsgaSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdDQgPyBcIi5cIiA6IG4yLm5vcm1hbGl6ZSh0NCk7XHJcbiAgICB9LCByZWxhdGl2ZTogZnVuY3Rpb24odDQsIHIzKSB7XHJcbiAgICAgIGlmIChlMih0NCksIGUyKHIzKSwgdDQgPT09IHIzKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICBpZiAoKHQ0ID0gbjIucmVzb2x2ZSh0NCkpID09PSAocjMgPSBuMi5yZXNvbHZlKHIzKSkpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdDQubGVuZ3RoICYmIDQ3ID09PSB0NC5jaGFyQ29kZUF0KGkpOyArK2kpXHJcbiAgICAgICAgO1xyXG4gICAgICBmb3IgKHZhciBvID0gdDQubGVuZ3RoLCBzID0gbyAtIGksIGggPSAxOyBoIDwgcjMubGVuZ3RoICYmIDQ3ID09PSByMy5jaGFyQ29kZUF0KGgpOyArK2gpXHJcbiAgICAgICAgO1xyXG4gICAgICBmb3IgKHZhciBhMiA9IHIzLmxlbmd0aCAtIGgsIGMgPSBzIDwgYTIgPyBzIDogYTIsIGYyID0gLTEsIHUgPSAwOyB1IDw9IGM7ICsrdSkge1xyXG4gICAgICAgIGlmICh1ID09PSBjKSB7XHJcbiAgICAgICAgICBpZiAoYTIgPiBjKSB7XHJcbiAgICAgICAgICAgIGlmICg0NyA9PT0gcjMuY2hhckNvZGVBdChoICsgdSkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHIzLnNsaWNlKGggKyB1ICsgMSk7XHJcbiAgICAgICAgICAgIGlmICgwID09PSB1KVxyXG4gICAgICAgICAgICAgIHJldHVybiByMy5zbGljZShoICsgdSk7XHJcbiAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcyA+IGMgJiYgKDQ3ID09PSB0NC5jaGFyQ29kZUF0KGkgKyB1KSA/IGYyID0gdSA6IDAgPT09IHUgJiYgKGYyID0gMCkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsID0gdDQuY2hhckNvZGVBdChpICsgdSk7XHJcbiAgICAgICAgaWYgKGwgIT09IHIzLmNoYXJDb2RlQXQoaCArIHUpKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgNDcgPT09IGwgJiYgKGYyID0gdSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGcgPSBcIlwiO1xyXG4gICAgICBmb3IgKHUgPSBpICsgZjIgKyAxOyB1IDw9IG87ICsrdSlcclxuICAgICAgICB1ICE9PSBvICYmIDQ3ICE9PSB0NC5jaGFyQ29kZUF0KHUpIHx8ICgwID09PSBnLmxlbmd0aCA/IGcgKz0gXCIuLlwiIDogZyArPSBcIi8uLlwiKTtcclxuICAgICAgcmV0dXJuIGcubGVuZ3RoID4gMCA/IGcgKyByMy5zbGljZShoICsgZjIpIDogKGggKz0gZjIsIDQ3ID09PSByMy5jaGFyQ29kZUF0KGgpICYmICsraCwgcjMuc2xpY2UoaCkpO1xyXG4gICAgfSwgX21ha2VMb25nOiBmdW5jdGlvbih0NCkge1xyXG4gICAgICByZXR1cm4gdDQ7XHJcbiAgICB9LCBkaXJuYW1lOiBmdW5jdGlvbih0NCkge1xyXG4gICAgICBpZiAoZTIodDQpLCAwID09PSB0NC5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIFwiLlwiO1xyXG4gICAgICBmb3IgKHZhciByMyA9IHQ0LmNoYXJDb2RlQXQoMCksIG4zID0gNDcgPT09IHIzLCBpID0gLTEsIG8gPSB0cnVlLCBzID0gdDQubGVuZ3RoIC0gMTsgcyA+PSAxOyAtLXMpXHJcbiAgICAgICAgaWYgKDQ3ID09PSAocjMgPSB0NC5jaGFyQ29kZUF0KHMpKSkge1xyXG4gICAgICAgICAgaWYgKCFvKSB7XHJcbiAgICAgICAgICAgIGkgPSBzO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgIG8gPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIC0xID09PSBpID8gbjMgPyBcIi9cIiA6IFwiLlwiIDogbjMgJiYgMSA9PT0gaSA/IFwiLy9cIiA6IHQ0LnNsaWNlKDAsIGkpO1xyXG4gICAgfSwgYmFzZW5hbWU6IGZ1bmN0aW9uKHQ0LCByMykge1xyXG4gICAgICBpZiAodm9pZCAwICE9PSByMyAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiByMylcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICAgICAgZTIodDQpO1xyXG4gICAgICB2YXIgbjMsIGkgPSAwLCBvID0gLTEsIHMgPSB0cnVlO1xyXG4gICAgICBpZiAodm9pZCAwICE9PSByMyAmJiByMy5sZW5ndGggPiAwICYmIHIzLmxlbmd0aCA8PSB0NC5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocjMubGVuZ3RoID09PSB0NC5sZW5ndGggJiYgcjMgPT09IHQ0KVxyXG4gICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgdmFyIGggPSByMy5sZW5ndGggLSAxLCBhMiA9IC0xO1xyXG4gICAgICAgIGZvciAobjMgPSB0NC5sZW5ndGggLSAxOyBuMyA+PSAwOyAtLW4zKSB7XHJcbiAgICAgICAgICB2YXIgYyA9IHQ0LmNoYXJDb2RlQXQobjMpO1xyXG4gICAgICAgICAgaWYgKDQ3ID09PSBjKSB7XHJcbiAgICAgICAgICAgIGlmICghcykge1xyXG4gICAgICAgICAgICAgIGkgPSBuMyArIDE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAtMSA9PT0gYTIgJiYgKHMgPSBmYWxzZSwgYTIgPSBuMyArIDEpLCBoID49IDAgJiYgKGMgPT09IHIzLmNoYXJDb2RlQXQoaCkgPyAtMSA9PSAtLWggJiYgKG8gPSBuMykgOiAoaCA9IC0xLCBvID0gYTIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGkgPT09IG8gPyBvID0gYTIgOiAtMSA9PT0gbyAmJiAobyA9IHQ0Lmxlbmd0aCksIHQ0LnNsaWNlKGksIG8pO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobjMgPSB0NC5sZW5ndGggLSAxOyBuMyA+PSAwOyAtLW4zKVxyXG4gICAgICAgIGlmICg0NyA9PT0gdDQuY2hhckNvZGVBdChuMykpIHtcclxuICAgICAgICAgIGlmICghcykge1xyXG4gICAgICAgICAgICBpID0gbjMgKyAxO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgIC0xID09PSBvICYmIChzID0gZmFsc2UsIG8gPSBuMyArIDEpO1xyXG4gICAgICByZXR1cm4gLTEgPT09IG8gPyBcIlwiIDogdDQuc2xpY2UoaSwgbyk7XHJcbiAgICB9LCBleHRuYW1lOiBmdW5jdGlvbih0NCkge1xyXG4gICAgICBlMih0NCk7XHJcbiAgICAgIGZvciAodmFyIHIzID0gLTEsIG4zID0gMCwgaSA9IC0xLCBvID0gdHJ1ZSwgcyA9IDAsIGggPSB0NC5sZW5ndGggLSAxOyBoID49IDA7IC0taCkge1xyXG4gICAgICAgIHZhciBhMiA9IHQ0LmNoYXJDb2RlQXQoaCk7XHJcbiAgICAgICAgaWYgKDQ3ICE9PSBhMilcclxuICAgICAgICAgIC0xID09PSBpICYmIChvID0gZmFsc2UsIGkgPSBoICsgMSksIDQ2ID09PSBhMiA/IC0xID09PSByMyA/IHIzID0gaCA6IDEgIT09IHMgJiYgKHMgPSAxKSA6IC0xICE9PSByMyAmJiAocyA9IC0xKTtcclxuICAgICAgICBlbHNlIGlmICghbykge1xyXG4gICAgICAgICAgbjMgPSBoICsgMTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTEgPT09IHIzIHx8IC0xID09PSBpIHx8IDAgPT09IHMgfHwgMSA9PT0gcyAmJiByMyA9PT0gaSAtIDEgJiYgcjMgPT09IG4zICsgMSA/IFwiXCIgOiB0NC5zbGljZShyMywgaSk7XHJcbiAgICB9LCBmb3JtYXQ6IGZ1bmN0aW9uKHQ0KSB7XHJcbiAgICAgIGlmIChudWxsID09PSB0NCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiB0NClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHQ0KTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQ1LCBlMykge1xyXG4gICAgICAgIHZhciByMyA9IGUzLmRpciB8fCBlMy5yb290LCBuMyA9IGUzLmJhc2UgfHwgKGUzLm5hbWUgfHwgXCJcIikgKyAoZTMuZXh0IHx8IFwiXCIpO1xyXG4gICAgICAgIHJldHVybiByMyA/IHIzID09PSBlMy5yb290ID8gcjMgKyBuMyA6IHIzICsgXCIvXCIgKyBuMyA6IG4zO1xyXG4gICAgICB9KDAsIHQ0KTtcclxuICAgIH0sIHBhcnNlOiBmdW5jdGlvbih0NCkge1xyXG4gICAgICBlMih0NCk7XHJcbiAgICAgIHZhciByMyA9IHsgcm9vdDogXCJcIiwgZGlyOiBcIlwiLCBiYXNlOiBcIlwiLCBleHQ6IFwiXCIsIG5hbWU6IFwiXCIgfTtcclxuICAgICAgaWYgKDAgPT09IHQ0Lmxlbmd0aClcclxuICAgICAgICByZXR1cm4gcjM7XHJcbiAgICAgIHZhciBuMywgaSA9IHQ0LmNoYXJDb2RlQXQoMCksIG8gPSA0NyA9PT0gaTtcclxuICAgICAgbyA/IChyMy5yb290ID0gXCIvXCIsIG4zID0gMSkgOiBuMyA9IDA7XHJcbiAgICAgIGZvciAodmFyIHMgPSAtMSwgaCA9IDAsIGEyID0gLTEsIGMgPSB0cnVlLCBmMiA9IHQ0Lmxlbmd0aCAtIDEsIHUgPSAwOyBmMiA+PSBuMzsgLS1mMilcclxuICAgICAgICBpZiAoNDcgIT09IChpID0gdDQuY2hhckNvZGVBdChmMikpKVxyXG4gICAgICAgICAgLTEgPT09IGEyICYmIChjID0gZmFsc2UsIGEyID0gZjIgKyAxKSwgNDYgPT09IGkgPyAtMSA9PT0gcyA/IHMgPSBmMiA6IDEgIT09IHUgJiYgKHUgPSAxKSA6IC0xICE9PSBzICYmICh1ID0gLTEpO1xyXG4gICAgICAgIGVsc2UgaWYgKCFjKSB7XHJcbiAgICAgICAgICBoID0gZjIgKyAxO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICByZXR1cm4gLTEgPT09IHMgfHwgLTEgPT09IGEyIHx8IDAgPT09IHUgfHwgMSA9PT0gdSAmJiBzID09PSBhMiAtIDEgJiYgcyA9PT0gaCArIDEgPyAtMSAhPT0gYTIgJiYgKHIzLmJhc2UgPSByMy5uYW1lID0gMCA9PT0gaCAmJiBvID8gdDQuc2xpY2UoMSwgYTIpIDogdDQuc2xpY2UoaCwgYTIpKSA6ICgwID09PSBoICYmIG8gPyAocjMubmFtZSA9IHQ0LnNsaWNlKDEsIHMpLCByMy5iYXNlID0gdDQuc2xpY2UoMSwgYTIpKSA6IChyMy5uYW1lID0gdDQuc2xpY2UoaCwgcyksIHIzLmJhc2UgPSB0NC5zbGljZShoLCBhMikpLCByMy5leHQgPSB0NC5zbGljZShzLCBhMikpLCBoID4gMCA/IHIzLmRpciA9IHQ0LnNsaWNlKDAsIGggLSAxKSA6IG8gJiYgKHIzLmRpciA9IFwiL1wiKSwgcjM7XHJcbiAgICB9LCBzZXA6IFwiL1wiLCBkZWxpbWl0ZXI6IFwiOlwiLCB3aW4zMjogbnVsbCwgcG9zaXg6IG51bGwgfTtcclxuICAgIG4yLnBvc2l4ID0gbjIsIHQzLmV4cG9ydHMgPSBuMjtcclxuICB9IH0sIGUgPSB7fTtcclxuICBmdW5jdGlvbiByKG4yKSB7XHJcbiAgICB2YXIgaSA9IGVbbjJdO1xyXG4gICAgaWYgKHZvaWQgMCAhPT0gaSlcclxuICAgICAgcmV0dXJuIGkuZXhwb3J0cztcclxuICAgIHZhciBvID0gZVtuMl0gPSB7IGV4cG9ydHM6IHt9IH07XHJcbiAgICByZXR1cm4gdDJbbjJdKG8sIG8uZXhwb3J0cywgciksIG8uZXhwb3J0cztcclxuICB9XHJcbiAgci5kID0gKHQzLCBlMikgPT4ge1xyXG4gICAgZm9yICh2YXIgbjIgaW4gZTIpXHJcbiAgICAgIHIubyhlMiwgbjIpICYmICFyLm8odDMsIG4yKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodDMsIG4yLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZTJbbjJdIH0pO1xyXG4gIH0sIHIubyA9ICh0MywgZTIpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0MywgZTIpLCByLnIgPSAodDMpID0+IHtcclxuICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0MywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgfTtcclxuICB2YXIgbiA9IHt9O1xyXG4gICgoKSA9PiB7XHJcbiAgICBsZXQgdDM7XHJcbiAgICBpZiAoci5yKG4pLCByLmQobiwgeyBVUkk6ICgpID0+IGYyLCBVdGlsczogKCkgPT4gUCB9KSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgcHJvY2VzcylcclxuICAgICAgdDMgPSBcIndpbjMyXCIgPT09IHByb2Nlc3MucGxhdGZvcm07XHJcbiAgICBlbHNlIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBuYXZpZ2F0b3IpIHtcclxuICAgICAgbGV0IGUzID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgICAgdDMgPSBlMy5pbmRleE9mKFwiV2luZG93c1wiKSA+PSAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZTIgPSAvXlxcd1tcXHdcXGQrLi1dKiQvLCBpID0gL15cXC8vLCBvID0gL15cXC9cXC8vO1xyXG4gICAgZnVuY3Rpb24gcyh0NCwgcjIpIHtcclxuICAgICAgaWYgKCF0NC5zY2hlbWUgJiYgcjIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBTY2hlbWUgaXMgbWlzc2luZzoge3NjaGVtZTogXCJcIiwgYXV0aG9yaXR5OiBcIiR7dDQuYXV0aG9yaXR5fVwiLCBwYXRoOiBcIiR7dDQucGF0aH1cIiwgcXVlcnk6IFwiJHt0NC5xdWVyeX1cIiwgZnJhZ21lbnQ6IFwiJHt0NC5mcmFnbWVudH1cIn1gKTtcclxuICAgICAgaWYgKHQ0LnNjaGVtZSAmJiAhZTIudGVzdCh0NC5zY2hlbWUpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltVcmlFcnJvcl06IFNjaGVtZSBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMuXCIpO1xyXG4gICAgICBpZiAodDQucGF0aCkge1xyXG4gICAgICAgIGlmICh0NC5hdXRob3JpdHkpIHtcclxuICAgICAgICAgIGlmICghaS50ZXN0KHQ0LnBhdGgpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGNvbnRhaW5zIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY29tcG9uZW50IG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSBzbGFzaCAoXCIvXCIpIGNoYXJhY3RlcicpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoby50ZXN0KHQ0LnBhdGgpKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBkb2VzIG5vdCBjb250YWluIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY2Fubm90IGJlZ2luIHdpdGggdHdvIHNsYXNoIGNoYXJhY3RlcnMgKFwiLy9cIiknKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgaCA9IFwiXCIsIGEyID0gXCIvXCIsIGMgPSAvXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztcclxuICAgIGNsYXNzIGYyIHtcclxuICAgICAgc3RhdGljIGlzVXJpKHQ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQ0IGluc3RhbmNlb2YgZjIgfHwgISF0NCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0NC5hdXRob3JpdHkgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdDQuZnJhZ21lbnQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdDQucGF0aCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0NC5xdWVyeSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0NC5zY2hlbWUgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdDQuZnNQYXRoICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdDQud2l0aCAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQ0LnRvU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHNjaGVtZTtcclxuICAgICAgYXV0aG9yaXR5O1xyXG4gICAgICBwYXRoO1xyXG4gICAgICBxdWVyeTtcclxuICAgICAgZnJhZ21lbnQ7XHJcbiAgICAgIGNvbnN0cnVjdG9yKHQ0LCBlMywgcjIsIG4yLCBpMiwgbzIgPSBmYWxzZSkge1xyXG4gICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQ0ID8gKHRoaXMuc2NoZW1lID0gdDQuc2NoZW1lIHx8IGgsIHRoaXMuYXV0aG9yaXR5ID0gdDQuYXV0aG9yaXR5IHx8IGgsIHRoaXMucGF0aCA9IHQ0LnBhdGggfHwgaCwgdGhpcy5xdWVyeSA9IHQ0LnF1ZXJ5IHx8IGgsIHRoaXMuZnJhZ21lbnQgPSB0NC5mcmFnbWVudCB8fCBoKSA6ICh0aGlzLnNjaGVtZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbih0NSwgZTQpIHtcclxuICAgICAgICAgIHJldHVybiB0NSB8fCBlNCA/IHQ1IDogXCJmaWxlXCI7XHJcbiAgICAgICAgfSh0NCwgbzIpLCB0aGlzLmF1dGhvcml0eSA9IGUzIHx8IGgsIHRoaXMucGF0aCA9IGZ1bmN0aW9uKHQ1LCBlNCkge1xyXG4gICAgICAgICAgc3dpdGNoICh0NSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcclxuICAgICAgICAgICAgY2FzZSBcImh0dHBcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcclxuICAgICAgICAgICAgICBlNCA/IGU0WzBdICE9PSBhMiAmJiAoZTQgPSBhMiArIGU0KSA6IGU0ID0gYTI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZTQ7XHJcbiAgICAgICAgfSh0aGlzLnNjaGVtZSwgcjIgfHwgaCksIHRoaXMucXVlcnkgPSBuMiB8fCBoLCB0aGlzLmZyYWdtZW50ID0gaTIgfHwgaCwgcyh0aGlzLCBvMikpO1xyXG4gICAgICB9XHJcbiAgICAgIGdldCBmc1BhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG0odGhpcywgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHdpdGgodDQpIHtcclxuICAgICAgICBpZiAoIXQ0KVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgbGV0IHsgc2NoZW1lOiBlMywgYXV0aG9yaXR5OiByMiwgcGF0aDogbjIsIHF1ZXJ5OiBpMiwgZnJhZ21lbnQ6IG8yIH0gPSB0NDtcclxuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlMyA/IGUzID0gdGhpcy5zY2hlbWUgOiBudWxsID09PSBlMyAmJiAoZTMgPSBoKSwgdm9pZCAwID09PSByMiA/IHIyID0gdGhpcy5hdXRob3JpdHkgOiBudWxsID09PSByMiAmJiAocjIgPSBoKSwgdm9pZCAwID09PSBuMiA/IG4yID0gdGhpcy5wYXRoIDogbnVsbCA9PT0gbjIgJiYgKG4yID0gaCksIHZvaWQgMCA9PT0gaTIgPyBpMiA9IHRoaXMucXVlcnkgOiBudWxsID09PSBpMiAmJiAoaTIgPSBoKSwgdm9pZCAwID09PSBvMiA/IG8yID0gdGhpcy5mcmFnbWVudCA6IG51bGwgPT09IG8yICYmIChvMiA9IGgpLCBlMyA9PT0gdGhpcy5zY2hlbWUgJiYgcjIgPT09IHRoaXMuYXV0aG9yaXR5ICYmIG4yID09PSB0aGlzLnBhdGggJiYgaTIgPT09IHRoaXMucXVlcnkgJiYgbzIgPT09IHRoaXMuZnJhZ21lbnQgPyB0aGlzIDogbmV3IGwoZTMsIHIyLCBuMiwgaTIsIG8yKTtcclxuICAgICAgfVxyXG4gICAgICBzdGF0aWMgcGFyc2UodDQsIGUzID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCByMiA9IGMuZXhlYyh0NCk7XHJcbiAgICAgICAgcmV0dXJuIHIyID8gbmV3IGwocjJbMl0gfHwgaCwgQyhyMls0XSB8fCBoKSwgQyhyMls1XSB8fCBoKSwgQyhyMls3XSB8fCBoKSwgQyhyMls5XSB8fCBoKSwgZTMpIDogbmV3IGwoaCwgaCwgaCwgaCwgaCk7XHJcbiAgICAgIH1cclxuICAgICAgc3RhdGljIGZpbGUoZTMpIHtcclxuICAgICAgICBsZXQgcjIgPSBoO1xyXG4gICAgICAgIGlmICh0MyAmJiAoZTMgPSBlMy5yZXBsYWNlKC9cXFxcL2csIGEyKSksIGUzWzBdID09PSBhMiAmJiBlM1sxXSA9PT0gYTIpIHtcclxuICAgICAgICAgIGNvbnN0IHQ0ID0gZTMuaW5kZXhPZihhMiwgMik7XHJcbiAgICAgICAgICAtMSA9PT0gdDQgPyAocjIgPSBlMy5zdWJzdHJpbmcoMiksIGUzID0gYTIpIDogKHIyID0gZTMuc3Vic3RyaW5nKDIsIHQ0KSwgZTMgPSBlMy5zdWJzdHJpbmcodDQpIHx8IGEyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBsKFwiZmlsZVwiLCByMiwgZTMsIGgsIGgpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0YXRpYyBmcm9tKHQ0KSB7XHJcbiAgICAgICAgY29uc3QgZTMgPSBuZXcgbCh0NC5zY2hlbWUsIHQ0LmF1dGhvcml0eSwgdDQucGF0aCwgdDQucXVlcnksIHQ0LmZyYWdtZW50KTtcclxuICAgICAgICByZXR1cm4gcyhlMywgdHJ1ZSksIGUzO1xyXG4gICAgICB9XHJcbiAgICAgIHRvU3RyaW5nKHQ0ID0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4geSh0aGlzLCB0NCk7XHJcbiAgICAgIH1cclxuICAgICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHN0YXRpYyByZXZpdmUodDQpIHtcclxuICAgICAgICBpZiAodDQpIHtcclxuICAgICAgICAgIGlmICh0NCBpbnN0YW5jZW9mIGYyKVxyXG4gICAgICAgICAgICByZXR1cm4gdDQ7XHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUzID0gbmV3IGwodDQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZTMuX2Zvcm1hdHRlZCA9IHQ0LmV4dGVybmFsLCBlMy5fZnNQYXRoID0gdDQuX3NlcCA9PT0gdSA/IHQ0LmZzUGF0aCA6IG51bGwsIGUzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHUgPSB0MyA/IDEgOiB2b2lkIDA7XHJcbiAgICBjbGFzcyBsIGV4dGVuZHMgZjIge1xyXG4gICAgICBfZm9ybWF0dGVkID0gbnVsbDtcclxuICAgICAgX2ZzUGF0aCA9IG51bGw7XHJcbiAgICAgIGdldCBmc1BhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZzUGF0aCB8fCAodGhpcy5fZnNQYXRoID0gbSh0aGlzLCBmYWxzZSkpLCB0aGlzLl9mc1BhdGg7XHJcbiAgICAgIH1cclxuICAgICAgdG9TdHJpbmcodDQgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB0NCA/IHkodGhpcywgdHJ1ZSkgOiAodGhpcy5fZm9ybWF0dGVkIHx8ICh0aGlzLl9mb3JtYXR0ZWQgPSB5KHRoaXMsIGZhbHNlKSksIHRoaXMuX2Zvcm1hdHRlZCk7XHJcbiAgICAgIH1cclxuICAgICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IHQ0ID0geyAkbWlkOiAxIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZzUGF0aCAmJiAodDQuZnNQYXRoID0gdGhpcy5fZnNQYXRoLCB0NC5fc2VwID0gdSksIHRoaXMuX2Zvcm1hdHRlZCAmJiAodDQuZXh0ZXJuYWwgPSB0aGlzLl9mb3JtYXR0ZWQpLCB0aGlzLnBhdGggJiYgKHQ0LnBhdGggPSB0aGlzLnBhdGgpLCB0aGlzLnNjaGVtZSAmJiAodDQuc2NoZW1lID0gdGhpcy5zY2hlbWUpLCB0aGlzLmF1dGhvcml0eSAmJiAodDQuYXV0aG9yaXR5ID0gdGhpcy5hdXRob3JpdHkpLCB0aGlzLnF1ZXJ5ICYmICh0NC5xdWVyeSA9IHRoaXMucXVlcnkpLCB0aGlzLmZyYWdtZW50ICYmICh0NC5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQpLCB0NDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZyA9IHsgNTg6IFwiJTNBXCIsIDQ3OiBcIiUyRlwiLCA2MzogXCIlM0ZcIiwgMzU6IFwiJTIzXCIsIDkxOiBcIiU1QlwiLCA5MzogXCIlNURcIiwgNjQ6IFwiJTQwXCIsIDMzOiBcIiUyMVwiLCAzNjogXCIlMjRcIiwgMzg6IFwiJTI2XCIsIDM5OiBcIiUyN1wiLCA0MDogXCIlMjhcIiwgNDE6IFwiJTI5XCIsIDQyOiBcIiUyQVwiLCA0MzogXCIlMkJcIiwgNDQ6IFwiJTJDXCIsIDU5OiBcIiUzQlwiLCA2MTogXCIlM0RcIiwgMzI6IFwiJTIwXCIgfTtcclxuICAgIGZ1bmN0aW9uIGQodDQsIGUzLCByMikge1xyXG4gICAgICBsZXQgbjIsIGkyID0gLTE7XHJcbiAgICAgIGZvciAobGV0IG8yID0gMDsgbzIgPCB0NC5sZW5ndGg7IG8yKyspIHtcclxuICAgICAgICBjb25zdCBzMiA9IHQ0LmNoYXJDb2RlQXQobzIpO1xyXG4gICAgICAgIGlmIChzMiA+PSA5NyAmJiBzMiA8PSAxMjIgfHwgczIgPj0gNjUgJiYgczIgPD0gOTAgfHwgczIgPj0gNDggJiYgczIgPD0gNTcgfHwgNDUgPT09IHMyIHx8IDQ2ID09PSBzMiB8fCA5NSA9PT0gczIgfHwgMTI2ID09PSBzMiB8fCBlMyAmJiA0NyA9PT0gczIgfHwgcjIgJiYgOTEgPT09IHMyIHx8IHIyICYmIDkzID09PSBzMiB8fCByMiAmJiA1OCA9PT0gczIpXHJcbiAgICAgICAgICAtMSAhPT0gaTIgJiYgKG4yICs9IGVuY29kZVVSSUNvbXBvbmVudCh0NC5zdWJzdHJpbmcoaTIsIG8yKSksIGkyID0gLTEpLCB2b2lkIDAgIT09IG4yICYmIChuMiArPSB0NC5jaGFyQXQobzIpKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZvaWQgMCA9PT0gbjIgJiYgKG4yID0gdDQuc3Vic3RyKDAsIG8yKSk7XHJcbiAgICAgICAgICBjb25zdCBlNCA9IGdbczJdO1xyXG4gICAgICAgICAgdm9pZCAwICE9PSBlNCA/ICgtMSAhPT0gaTIgJiYgKG4yICs9IGVuY29kZVVSSUNvbXBvbmVudCh0NC5zdWJzdHJpbmcoaTIsIG8yKSksIGkyID0gLTEpLCBuMiArPSBlNCkgOiAtMSA9PT0gaTIgJiYgKGkyID0gbzIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTEgIT09IGkyICYmIChuMiArPSBlbmNvZGVVUklDb21wb25lbnQodDQuc3Vic3RyaW5nKGkyKSkpLCB2b2lkIDAgIT09IG4yID8gbjIgOiB0NDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHAodDQpIHtcclxuICAgICAgbGV0IGUzO1xyXG4gICAgICBmb3IgKGxldCByMiA9IDA7IHIyIDwgdDQubGVuZ3RoOyByMisrKSB7XHJcbiAgICAgICAgY29uc3QgbjIgPSB0NC5jaGFyQ29kZUF0KHIyKTtcclxuICAgICAgICAzNSA9PT0gbjIgfHwgNjMgPT09IG4yID8gKHZvaWQgMCA9PT0gZTMgJiYgKGUzID0gdDQuc3Vic3RyKDAsIHIyKSksIGUzICs9IGdbbjJdKSA6IHZvaWQgMCAhPT0gZTMgJiYgKGUzICs9IHQ0W3IyXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gZTMgPyBlMyA6IHQ0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbShlMywgcjIpIHtcclxuICAgICAgbGV0IG4yO1xyXG4gICAgICByZXR1cm4gbjIgPSBlMy5hdXRob3JpdHkgJiYgZTMucGF0aC5sZW5ndGggPiAxICYmIFwiZmlsZVwiID09PSBlMy5zY2hlbWUgPyBgLy8ke2UzLmF1dGhvcml0eX0ke2UzLnBhdGh9YCA6IDQ3ID09PSBlMy5wYXRoLmNoYXJDb2RlQXQoMCkgJiYgKGUzLnBhdGguY2hhckNvZGVBdCgxKSA+PSA2NSAmJiBlMy5wYXRoLmNoYXJDb2RlQXQoMSkgPD0gOTAgfHwgZTMucGF0aC5jaGFyQ29kZUF0KDEpID49IDk3ICYmIGUzLnBhdGguY2hhckNvZGVBdCgxKSA8PSAxMjIpICYmIDU4ID09PSBlMy5wYXRoLmNoYXJDb2RlQXQoMikgPyByMiA/IGUzLnBhdGguc3Vic3RyKDEpIDogZTMucGF0aFsxXS50b0xvd2VyQ2FzZSgpICsgZTMucGF0aC5zdWJzdHIoMikgOiBlMy5wYXRoLCB0MyAmJiAobjIgPSBuMi5yZXBsYWNlKC9cXC8vZywgXCJcXFxcXCIpKSwgbjI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB5KHQ0LCBlMykge1xyXG4gICAgICBjb25zdCByMiA9IGUzID8gcCA6IGQ7XHJcbiAgICAgIGxldCBuMiA9IFwiXCIsIHsgc2NoZW1lOiBpMiwgYXV0aG9yaXR5OiBvMiwgcGF0aDogczIsIHF1ZXJ5OiBoMiwgZnJhZ21lbnQ6IGMyIH0gPSB0NDtcclxuICAgICAgaWYgKGkyICYmIChuMiArPSBpMiwgbjIgKz0gXCI6XCIpLCAobzIgfHwgXCJmaWxlXCIgPT09IGkyKSAmJiAobjIgKz0gYTIsIG4yICs9IGEyKSwgbzIpIHtcclxuICAgICAgICBsZXQgdDUgPSBvMi5pbmRleE9mKFwiQFwiKTtcclxuICAgICAgICBpZiAoLTEgIT09IHQ1KSB7XHJcbiAgICAgICAgICBjb25zdCBlNCA9IG8yLnN1YnN0cigwLCB0NSk7XHJcbiAgICAgICAgICBvMiA9IG8yLnN1YnN0cih0NSArIDEpLCB0NSA9IGU0Lmxhc3RJbmRleE9mKFwiOlwiKSwgLTEgPT09IHQ1ID8gbjIgKz0gcjIoZTQsIGZhbHNlLCBmYWxzZSkgOiAobjIgKz0gcjIoZTQuc3Vic3RyKDAsIHQ1KSwgZmFsc2UsIGZhbHNlKSwgbjIgKz0gXCI6XCIsIG4yICs9IHIyKGU0LnN1YnN0cih0NSArIDEpLCBmYWxzZSwgdHJ1ZSkpLCBuMiArPSBcIkBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbzIgPSBvMi50b0xvd2VyQ2FzZSgpLCB0NSA9IG8yLmxhc3RJbmRleE9mKFwiOlwiKSwgLTEgPT09IHQ1ID8gbjIgKz0gcjIobzIsIGZhbHNlLCB0cnVlKSA6IChuMiArPSByMihvMi5zdWJzdHIoMCwgdDUpLCBmYWxzZSwgdHJ1ZSksIG4yICs9IG8yLnN1YnN0cih0NSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzMikge1xyXG4gICAgICAgIGlmIChzMi5sZW5ndGggPj0gMyAmJiA0NyA9PT0gczIuY2hhckNvZGVBdCgwKSAmJiA1OCA9PT0gczIuY2hhckNvZGVBdCgyKSkge1xyXG4gICAgICAgICAgY29uc3QgdDUgPSBzMi5jaGFyQ29kZUF0KDEpO1xyXG4gICAgICAgICAgdDUgPj0gNjUgJiYgdDUgPD0gOTAgJiYgKHMyID0gYC8ke1N0cmluZy5mcm9tQ2hhckNvZGUodDUgKyAzMil9OiR7czIuc3Vic3RyKDMpfWApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoczIubGVuZ3RoID49IDIgJiYgNTggPT09IHMyLmNoYXJDb2RlQXQoMSkpIHtcclxuICAgICAgICAgIGNvbnN0IHQ1ID0gczIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgIHQ1ID49IDY1ICYmIHQ1IDw9IDkwICYmIChzMiA9IGAke1N0cmluZy5mcm9tQ2hhckNvZGUodDUgKyAzMil9OiR7czIuc3Vic3RyKDIpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuMiArPSByMihzMiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoMiAmJiAobjIgKz0gXCI/XCIsIG4yICs9IHIyKGgyLCBmYWxzZSwgZmFsc2UpKSwgYzIgJiYgKG4yICs9IFwiI1wiLCBuMiArPSBlMyA/IGMyIDogZChjMiwgZmFsc2UsIGZhbHNlKSksIG4yO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdih0NCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodDQpO1xyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICByZXR1cm4gdDQubGVuZ3RoID4gMyA/IHQ0LnN1YnN0cigwLCAzKSArIHYodDQuc3Vic3RyKDMpKSA6IHQ0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBiID0gLyglWzAtOUEtWmEtel1bMC05QS1aYS16XSkrL2c7XHJcbiAgICBmdW5jdGlvbiBDKHQ0KSB7XHJcbiAgICAgIHJldHVybiB0NC5tYXRjaChiKSA/IHQ0LnJlcGxhY2UoYiwgKHQ1KSA9PiB2KHQ1KSkgOiB0NDtcclxuICAgIH1cclxuICAgIHZhciBBMiA9IHIoNDcwKTtcclxuICAgIGNvbnN0IHcgPSBBMi5wb3NpeCB8fCBBMiwgeCA9IFwiL1wiO1xyXG4gICAgdmFyIFA7XHJcbiAgICAhZnVuY3Rpb24odDQpIHtcclxuICAgICAgdDQuam9pblBhdGggPSBmdW5jdGlvbih0NSwgLi4uZTMpIHtcclxuICAgICAgICByZXR1cm4gdDUud2l0aCh7IHBhdGg6IHcuam9pbih0NS5wYXRoLCAuLi5lMykgfSk7XHJcbiAgICAgIH0sIHQ0LnJlc29sdmVQYXRoID0gZnVuY3Rpb24odDUsIC4uLmUzKSB7XHJcbiAgICAgICAgbGV0IHIyID0gdDUucGF0aCwgbjIgPSBmYWxzZTtcclxuICAgICAgICByMlswXSAhPT0geCAmJiAocjIgPSB4ICsgcjIsIG4yID0gdHJ1ZSk7XHJcbiAgICAgICAgbGV0IGkyID0gdy5yZXNvbHZlKHIyLCAuLi5lMyk7XHJcbiAgICAgICAgcmV0dXJuIG4yICYmIGkyWzBdID09PSB4ICYmICF0NS5hdXRob3JpdHkgJiYgKGkyID0gaTIuc3Vic3RyaW5nKDEpKSwgdDUud2l0aCh7IHBhdGg6IGkyIH0pO1xyXG4gICAgICB9LCB0NC5kaXJuYW1lID0gZnVuY3Rpb24odDUpIHtcclxuICAgICAgICBpZiAoMCA9PT0gdDUucGF0aC5sZW5ndGggfHwgdDUucGF0aCA9PT0geClcclxuICAgICAgICAgIHJldHVybiB0NTtcclxuICAgICAgICBsZXQgZTMgPSB3LmRpcm5hbWUodDUucGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIDEgPT09IGUzLmxlbmd0aCAmJiA0NiA9PT0gZTMuY2hhckNvZGVBdCgwKSAmJiAoZTMgPSBcIlwiKSwgdDUud2l0aCh7IHBhdGg6IGUzIH0pO1xyXG4gICAgICB9LCB0NC5iYXNlbmFtZSA9IGZ1bmN0aW9uKHQ1KSB7XHJcbiAgICAgICAgcmV0dXJuIHcuYmFzZW5hbWUodDUucGF0aCk7XHJcbiAgICAgIH0sIHQ0LmV4dG5hbWUgPSBmdW5jdGlvbih0NSkge1xyXG4gICAgICAgIHJldHVybiB3LmV4dG5hbWUodDUucGF0aCk7XHJcbiAgICAgIH07XHJcbiAgICB9KFAgfHwgKFAgPSB7fSkpO1xyXG4gIH0pKCksIExJQiA9IG47XHJcbn0pKCk7XHJcbnZhciB7IFVSSTogVVJJMiwgVXRpbHMgfSA9IExJQjtcclxuXHJcbi8vIG5vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9nbG9iLmpzXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZ2V4KGdsb2IsIG9wdHMpIHtcclxuICBpZiAodHlwZW9mIGdsb2IgIT09IFwic3RyaW5nXCIpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtcclxuICB9XHJcbiAgY29uc3Qgc3RyID0gU3RyaW5nKGdsb2IpO1xyXG4gIGxldCByZVN0ciA9IFwiXCI7XHJcbiAgY29uc3QgZXh0ZW5kZWQgPSBvcHRzID8gISFvcHRzLmV4dGVuZGVkIDogZmFsc2U7XHJcbiAgY29uc3QgZ2xvYnN0YXIgPSBvcHRzID8gISFvcHRzLmdsb2JzdGFyIDogZmFsc2U7XHJcbiAgbGV0IGluR3JvdXAgPSBmYWxzZTtcclxuICBjb25zdCBmbGFncyA9IG9wdHMgJiYgdHlwZW9mIG9wdHMuZmxhZ3MgPT09IFwic3RyaW5nXCIgPyBvcHRzLmZsYWdzIDogXCJcIjtcclxuICBsZXQgYztcclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBjID0gc3RyW2ldO1xyXG4gICAgc3dpdGNoIChjKSB7XHJcbiAgICAgIGNhc2UgXCIvXCI6XHJcbiAgICAgIGNhc2UgXCIkXCI6XHJcbiAgICAgIGNhc2UgXCJeXCI6XHJcbiAgICAgIGNhc2UgXCIrXCI6XHJcbiAgICAgIGNhc2UgXCIuXCI6XHJcbiAgICAgIGNhc2UgXCIoXCI6XHJcbiAgICAgIGNhc2UgXCIpXCI6XHJcbiAgICAgIGNhc2UgXCI9XCI6XHJcbiAgICAgIGNhc2UgXCIhXCI6XHJcbiAgICAgIGNhc2UgXCJ8XCI6XHJcbiAgICAgICAgcmVTdHIgKz0gXCJcXFxcXCIgKyBjO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiP1wiOlxyXG4gICAgICAgIGlmIChleHRlbmRlZCkge1xyXG4gICAgICAgICAgcmVTdHIgKz0gXCIuXCI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIGNhc2UgXCJbXCI6XHJcbiAgICAgIGNhc2UgXCJdXCI6XHJcbiAgICAgICAgaWYgKGV4dGVuZGVkKSB7XHJcbiAgICAgICAgICByZVN0ciArPSBjO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICBjYXNlIFwie1wiOlxyXG4gICAgICAgIGlmIChleHRlbmRlZCkge1xyXG4gICAgICAgICAgaW5Hcm91cCA9IHRydWU7XHJcbiAgICAgICAgICByZVN0ciArPSBcIihcIjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgY2FzZSBcIn1cIjpcclxuICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcclxuICAgICAgICAgIGluR3JvdXAgPSBmYWxzZTtcclxuICAgICAgICAgIHJlU3RyICs9IFwiKVwiO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICBjYXNlIFwiLFwiOlxyXG4gICAgICAgIGlmIChpbkdyb3VwKSB7XHJcbiAgICAgICAgICByZVN0ciArPSBcInxcIjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZVN0ciArPSBcIlxcXFxcIiArIGM7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCIqXCI6XHJcbiAgICAgICAgY29uc3QgcHJldkNoYXIgPSBzdHJbaSAtIDFdO1xyXG4gICAgICAgIGxldCBzdGFyQ291bnQgPSAxO1xyXG4gICAgICAgIHdoaWxlIChzdHJbaSArIDFdID09PSBcIipcIikge1xyXG4gICAgICAgICAgc3RhckNvdW50Kys7XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gc3RyW2kgKyAxXTtcclxuICAgICAgICBpZiAoIWdsb2JzdGFyKSB7XHJcbiAgICAgICAgICByZVN0ciArPSBcIi4qXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGlzR2xvYnN0YXIgPSBzdGFyQ291bnQgPiAxICYmIChwcmV2Q2hhciA9PT0gXCIvXCIgfHwgcHJldkNoYXIgPT09IHZvaWQgMCB8fCBwcmV2Q2hhciA9PT0gXCJ7XCIgfHwgcHJldkNoYXIgPT09IFwiLFwiKSAmJiAobmV4dENoYXIgPT09IFwiL1wiIHx8IG5leHRDaGFyID09PSB2b2lkIDAgfHwgbmV4dENoYXIgPT09IFwiLFwiIHx8IG5leHRDaGFyID09PSBcIn1cIik7XHJcbiAgICAgICAgICBpZiAoaXNHbG9ic3Rhcikge1xyXG4gICAgICAgICAgICBpZiAobmV4dENoYXIgPT09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZDaGFyID09PSBcIi9cIiAmJiByZVN0ci5lbmRzV2l0aChcIlxcXFwvXCIpKSB7XHJcbiAgICAgICAgICAgICAgcmVTdHIgPSByZVN0ci5zdWJzdHIoMCwgcmVTdHIubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVTdHIgKz0gXCIoKD86W14vXSooPzovfCQpKSopXCI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZVN0ciArPSBcIihbXi9dKilcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmVTdHIgKz0gYztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFmbGFncyB8fCAhfmZsYWdzLmluZGV4T2YoXCJnXCIpKSB7XHJcbiAgICByZVN0ciA9IFwiXlwiICsgcmVTdHIgKyBcIiRcIjtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVTdHIsIGZsYWdzKTtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25TY2hlbWFTZXJ2aWNlLmpzXHJcbnZhciBCQU5HID0gXCIhXCI7XHJcbnZhciBQQVRIX1NFUCA9IFwiL1wiO1xyXG52YXIgRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbiA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBmb2xkZXJVcmksIHVyaXMpIHtcclxuICAgIHRoaXMuZm9sZGVyVXJpID0gZm9sZGVyVXJpO1xyXG4gICAgdGhpcy51cmlzID0gdXJpcztcclxuICAgIHRoaXMuZ2xvYldyYXBwZXJzID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICBmb3IgKGxldCBwYXR0ZXJuU3RyaW5nIG9mIHBhdHRlcm4pIHtcclxuICAgICAgICBjb25zdCBpbmNsdWRlID0gcGF0dGVyblN0cmluZ1swXSAhPT0gQkFORztcclxuICAgICAgICBpZiAoIWluY2x1ZGUpIHtcclxuICAgICAgICAgIHBhdHRlcm5TdHJpbmcgPSBwYXR0ZXJuU3RyaW5nLnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdHRlcm5TdHJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgaWYgKHBhdHRlcm5TdHJpbmdbMF0gPT09IFBBVEhfU0VQKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm5TdHJpbmcgPSBwYXR0ZXJuU3RyaW5nLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzLnB1c2goe1xyXG4gICAgICAgICAgICByZWdleHA6IGNyZWF0ZVJlZ2V4KFwiKiovXCIgKyBwYXR0ZXJuU3RyaW5nLCB7IGV4dGVuZGVkOiB0cnVlLCBnbG9ic3RhcjogdHJ1ZSB9KSxcclxuICAgICAgICAgICAgaW5jbHVkZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIDtcclxuICAgICAgaWYgKGZvbGRlclVyaSkge1xyXG4gICAgICAgIGZvbGRlclVyaSA9IG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcoZm9sZGVyVXJpKTtcclxuICAgICAgICBpZiAoIWZvbGRlclVyaS5lbmRzV2l0aChcIi9cIikpIHtcclxuICAgICAgICAgIGZvbGRlclVyaSA9IGZvbGRlclVyaSArIFwiL1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvbGRlclVyaSA9IGZvbGRlclVyaTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aGlzLmdsb2JXcmFwcGVycy5sZW5ndGggPSAwO1xyXG4gICAgICB0aGlzLnVyaXMgPSBbXTtcclxuICAgIH1cclxuICB9XHJcbiAgbWF0Y2hlc1BhdHRlcm4oZmlsZU5hbWUpIHtcclxuICAgIGlmICh0aGlzLmZvbGRlclVyaSAmJiAhZmlsZU5hbWUuc3RhcnRzV2l0aCh0aGlzLmZvbGRlclVyaSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IHsgcmVnZXhwLCBpbmNsdWRlIH0gb2YgdGhpcy5nbG9iV3JhcHBlcnMpIHtcclxuICAgICAgaWYgKHJlZ2V4cC50ZXN0KGZpbGVOYW1lKSkge1xyXG4gICAgICAgIG1hdGNoID0gaW5jbHVkZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoO1xyXG4gIH1cclxuICBnZXRVUklzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXJpcztcclxuICB9XHJcbn07XHJcbnZhciBTY2hlbWFIYW5kbGUgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3Ioc2VydmljZSwgdXJpLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xyXG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcclxuICAgIHRoaXMudXJpID0gdXJpO1xyXG4gICAgdGhpcy5kZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5hbmNob3JzID0gdm9pZCAwO1xyXG4gICAgaWYgKHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XHJcbiAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0VW5yZXNvbHZlZFNjaGVtYSgpIHtcclxuICAgIGlmICghdGhpcy51bnJlc29sdmVkU2NoZW1hKSB7XHJcbiAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5sb2FkU2NoZW1hKHRoaXMudXJpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnVucmVzb2x2ZWRTY2hlbWE7XHJcbiAgfVxyXG4gIGdldFJlc29sdmVkU2NoZW1hKCkge1xyXG4gICAgaWYgKCF0aGlzLnJlc29sdmVkU2NoZW1hKSB7XHJcbiAgICAgIHRoaXMucmVzb2x2ZWRTY2hlbWEgPSB0aGlzLmdldFVucmVzb2x2ZWRTY2hlbWEoKS50aGVuKCh1bnJlc29sdmVkKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5yZXNvbHZlU2NoZW1hQ29udGVudCh1bnJlc29sdmVkLCB0aGlzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFNjaGVtYTtcclxuICB9XHJcbiAgY2xlYXJTY2hlbWEoKSB7XHJcbiAgICBjb25zdCBoYXNDaGFuZ2VzID0gISF0aGlzLnVucmVzb2x2ZWRTY2hlbWE7XHJcbiAgICB0aGlzLnJlc29sdmVkU2NoZW1hID0gdm9pZCAwO1xyXG4gICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdm9pZCAwO1xyXG4gICAgdGhpcy5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcclxuICAgIHRoaXMuYW5jaG9ycyA9IHZvaWQgMDtcclxuICAgIHJldHVybiBoYXNDaGFuZ2VzO1xyXG4gIH1cclxufTtcclxudmFyIFVucmVzb2x2ZWRTY2hlbWEgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3Ioc2NoZW1hLCBlcnJvcnMgPSBbXSkge1xyXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XHJcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICB9XHJcbn07XHJcbnZhciBSZXNvbHZlZFNjaGVtYSA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihzY2hlbWEsIGVycm9ycyA9IFtdLCB3YXJuaW5ncyA9IFtdLCBzY2hlbWFEcmFmdCkge1xyXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XHJcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcclxuICAgIHRoaXMuc2NoZW1hRHJhZnQgPSBzY2hlbWFEcmFmdDtcclxuICB9XHJcbiAgZ2V0U2VjdGlvbihwYXRoKSB7XHJcbiAgICBjb25zdCBzY2hlbWFSZWYgPSB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgdGhpcy5zY2hlbWEpO1xyXG4gICAgaWYgKHNjaGVtYVJlZikge1xyXG4gICAgICByZXR1cm4gYXNTY2hlbWEoc2NoZW1hUmVmKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2b2lkIDA7XHJcbiAgfVxyXG4gIGdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hKSB7XHJcbiAgICBpZiAoIXNjaGVtYSB8fCB0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIiB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV4dCA9IHBhdGguc2hpZnQoKTtcclxuICAgIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEucHJvcGVydGllc1tuZXh0XSk7XHJcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xyXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gZXh0ZW5kZWRSZWdFeHAocGF0dGVybik7XHJcbiAgICAgICAgaWYgKHJlZ2V4Py50ZXN0KG5leHQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xyXG4gICAgfSBlbHNlIGlmIChuZXh0Lm1hdGNoKFwiWzAtOV0rXCIpKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KG5leHQsIDEwKTtcclxuICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiBzY2hlbWEuaXRlbXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5pdGVtc1tpbmRleF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChzY2hlbWEuaXRlbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5pdGVtcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2b2lkIDA7XHJcbiAgfVxyXG59O1xyXG52YXIgSlNPTlNjaGVtYVNlcnZpY2UgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IocmVxdWVzdFNlcnZpY2UsIGNvbnRleHRTZXJ2aWNlLCBwcm9taXNlQ29uc3RydWN0b3IpIHtcclxuICAgIHRoaXMuY29udGV4dFNlcnZpY2UgPSBjb250ZXh0U2VydmljZTtcclxuICAgIHRoaXMucmVxdWVzdFNlcnZpY2UgPSByZXF1ZXN0U2VydmljZTtcclxuICAgIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZUNvbnN0cnVjdG9yIHx8IFByb21pc2U7XHJcbiAgICB0aGlzLmNhbGxPbkRpc3Bvc2UgPSBbXTtcclxuICAgIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hcyA9IHt9O1xyXG4gICAgdGhpcy5jb250cmlidXRpb25Bc3NvY2lhdGlvbnMgPSBbXTtcclxuICAgIHRoaXMuc2NoZW1hc0J5SWQgPSB7fTtcclxuICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMgPSBbXTtcclxuICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHMgPSB7fTtcclxuICB9XHJcbiAgZ2V0UmVnaXN0ZXJlZFNjaGVtYUlkcyhmaWx0ZXIpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzKS5maWx0ZXIoKGlkKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNjaGVtZSA9IFVSSTIucGFyc2UoaWQpLnNjaGVtZTtcclxuICAgICAgcmV0dXJuIHNjaGVtZSAhPT0gXCJzY2hlbWFzZXJ2aWNlXCIgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNjaGVtZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldCBwcm9taXNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yO1xyXG4gIH1cclxuICBkaXNwb3NlKCkge1xyXG4gICAgd2hpbGUgKHRoaXMuY2FsbE9uRGlzcG9zZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuY2FsbE9uRGlzcG9zZS5wb3AoKSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBvblJlc291cmNlQ2hhbmdlKHVyaSkge1xyXG4gICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHZvaWQgMDtcclxuICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XHJcbiAgICB1cmkgPSBub3JtYWxpemVJZCh1cmkpO1xyXG4gICAgY29uc3QgdG9XYWxrID0gW3VyaV07XHJcbiAgICBjb25zdCBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLnNjaGVtYXNCeUlkKS5tYXAoKGtleSkgPT4gdGhpcy5zY2hlbWFzQnlJZFtrZXldKTtcclxuICAgIHdoaWxlICh0b1dhbGsubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGN1cnIgPSB0b1dhbGsucG9wKCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gYWxsW2ldO1xyXG4gICAgICAgIGlmIChoYW5kbGUgJiYgKGhhbmRsZS51cmkgPT09IGN1cnIgfHwgaGFuZGxlLmRlcGVuZGVuY2llcy5oYXMoY3VycikpKSB7XHJcbiAgICAgICAgICBpZiAoaGFuZGxlLnVyaSAhPT0gY3Vycikge1xyXG4gICAgICAgICAgICB0b1dhbGsucHVzaChoYW5kbGUudXJpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChoYW5kbGUuY2xlYXJTY2hlbWEoKSkge1xyXG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGFsbFtpXSA9IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYXNDaGFuZ2VzO1xyXG4gIH1cclxuICBzZXRTY2hlbWFDb250cmlidXRpb25zKHNjaGVtYUNvbnRyaWJ1dGlvbnMyKSB7XHJcbiAgICBpZiAoc2NoZW1hQ29udHJpYnV0aW9uczIuc2NoZW1hcykge1xyXG4gICAgICBjb25zdCBzY2hlbWFzID0gc2NoZW1hQ29udHJpYnV0aW9uczIuc2NoZW1hcztcclxuICAgICAgZm9yIChjb25zdCBpZCBpbiBzY2hlbWFzKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkID0gbm9ybWFsaXplSWQoaWQpO1xyXG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hc1tub3JtYWxpemVkSWRdID0gdGhpcy5hZGRTY2hlbWFIYW5kbGUobm9ybWFsaXplZElkLCBzY2hlbWFzW2lkXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYUNvbnRyaWJ1dGlvbnMyLnNjaGVtYUFzc29jaWF0aW9ucykpIHtcclxuICAgICAgY29uc3Qgc2NoZW1hQXNzb2NpYXRpb25zID0gc2NoZW1hQ29udHJpYnV0aW9uczIuc2NoZW1hQXNzb2NpYXRpb25zO1xyXG4gICAgICBmb3IgKGxldCBzY2hlbWFBc3NvY2lhdGlvbiBvZiBzY2hlbWFBc3NvY2lhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB1cmlzID0gc2NoZW1hQXNzb2NpYXRpb24udXJpcy5tYXAobm9ybWFsaXplSWQpO1xyXG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcy5hZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uKHNjaGVtYUFzc29jaWF0aW9uLnBhdHRlcm4sIHNjaGVtYUFzc29jaWF0aW9uLmZvbGRlclVyaSwgdXJpcyk7XHJcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25Bc3NvY2lhdGlvbnMucHVzaChhc3NvY2lhdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgYWRkU2NoZW1hSGFuZGxlKGlkLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xyXG4gICAgY29uc3Qgc2NoZW1hSGFuZGxlID0gbmV3IFNjaGVtYUhhbmRsZSh0aGlzLCBpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpO1xyXG4gICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSBzY2hlbWFIYW5kbGU7XHJcbiAgICByZXR1cm4gc2NoZW1hSGFuZGxlO1xyXG4gIH1cclxuICBnZXRPckFkZFNjaGVtYUhhbmRsZShpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcclxuICAgIHJldHVybiB0aGlzLnNjaGVtYXNCeUlkW2lkXSB8fCB0aGlzLmFkZFNjaGVtYUhhbmRsZShpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpO1xyXG4gIH1cclxuICBhZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uKHBhdHRlcm4sIGZvbGRlclVyaSwgdXJpcykge1xyXG4gICAgY29uc3QgZnBhID0gbmV3IEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ocGF0dGVybiwgZm9sZGVyVXJpLCB1cmlzKTtcclxuICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMucHVzaChmcGEpO1xyXG4gICAgcmV0dXJuIGZwYTtcclxuICB9XHJcbiAgcmVnaXN0ZXJFeHRlcm5hbFNjaGVtYShjb25maWcpIHtcclxuICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoY29uZmlnLnVyaSk7XHJcbiAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzW2lkXSA9IHRydWU7XHJcbiAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0gdm9pZCAwO1xyXG4gICAgaWYgKGNvbmZpZy5maWxlTWF0Y2ggJiYgY29uZmlnLmZpbGVNYXRjaC5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5hZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uKGNvbmZpZy5maWxlTWF0Y2gsIGNvbmZpZy5mb2xkZXJVcmksIFtpZF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbmZpZy5zY2hlbWEgPyB0aGlzLmFkZFNjaGVtYUhhbmRsZShpZCwgY29uZmlnLnNjaGVtYSkgOiB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKGlkKTtcclxuICB9XHJcbiAgY2xlYXJFeHRlcm5hbFNjaGVtYXMoKSB7XHJcbiAgICB0aGlzLnNjaGVtYXNCeUlkID0ge307XHJcbiAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zID0gW107XHJcbiAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzID0ge307XHJcbiAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0gdm9pZCAwO1xyXG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXMpIHtcclxuICAgICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXNbaWRdO1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzW2lkXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRyaWJ1dGlvbkFzc29jaWF0aW9uIG9mIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zKSB7XHJcbiAgICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMucHVzaChjb250cmlidXRpb25Bc3NvY2lhdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFJlc29sdmVkU2NoZW1hKHNjaGVtYUlkKSB7XHJcbiAgICBjb25zdCBpZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYUlkKTtcclxuICAgIGNvbnN0IHNjaGVtYUhhbmRsZSA9IHRoaXMuc2NoZW1hc0J5SWRbaWRdO1xyXG4gICAgaWYgKHNjaGVtYUhhbmRsZSkge1xyXG4gICAgICByZXR1cm4gc2NoZW1hSGFuZGxlLmdldFJlc29sdmVkU2NoZW1hKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUodm9pZCAwKTtcclxuICB9XHJcbiAgbG9hZFNjaGVtYSh1cmwpIHtcclxuICAgIGlmICghdGhpcy5yZXF1ZXN0U2VydmljZSkge1xyXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB0KFwiVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gJ3swfScuIE5vIHNjaGVtYSByZXF1ZXN0IHNlcnZpY2UgYXZhaWxhYmxlXCIsIHRvRGlzcGxheVN0cmluZyh1cmwpKTtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKG5ldyBVbnJlc29sdmVkU2NoZW1hKHt9LCBbZXJyb3JNZXNzYWdlXSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9cIikpIHtcclxuICAgICAgdXJsID0gXCJodHRwc1wiICsgdXJsLnN1YnN0cmluZyg0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3RTZXJ2aWNlKHVybCkudGhlbigoY29udGVudCkgPT4ge1xyXG4gICAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB0KFwiVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gJ3swfSc6IE5vIGNvbnRlbnQuXCIsIHRvRGlzcGxheVN0cmluZyh1cmwpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFtlcnJvck1lc3NhZ2VdKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcclxuICAgICAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkpIHtcclxuICAgICAgICBlcnJvcnMucHVzaCh0KFwiUHJvYmxlbSByZWFkaW5nIGNvbnRlbnQgZnJvbSAnezB9JzogVVRGLTggd2l0aCBCT00gZGV0ZWN0ZWQsIG9ubHkgVVRGIDggaXMgYWxsb3dlZC5cIiwgdG9EaXNwbGF5U3RyaW5nKHVybCkpKTtcclxuICAgICAgICBjb250ZW50ID0gY29udGVudC50cmltU3RhcnQoKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc2NoZW1hQ29udGVudCA9IHt9O1xyXG4gICAgICBjb25zdCBqc29uRXJyb3JzID0gW107XHJcbiAgICAgIHNjaGVtYUNvbnRlbnQgPSBwYXJzZTIoY29udGVudCwganNvbkVycm9ycyk7XHJcbiAgICAgIGlmIChqc29uRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIGVycm9ycy5wdXNoKHQoXCJVbmFibGUgdG8gcGFyc2UgY29udGVudCBmcm9tICd7MH0nOiBQYXJzZSBlcnJvciBhdCBvZmZzZXQgezF9LlwiLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSwganNvbkVycm9yc1swXS5vZmZzZXQpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoc2NoZW1hQ29udGVudCwgZXJyb3JzKTtcclxuICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcclxuICAgICAgY29uc3QgZXJyb3JTcGxpdCA9IGVycm9yLnRvU3RyaW5nKCkuc3BsaXQoXCJFcnJvcjogXCIpO1xyXG4gICAgICBpZiAoZXJyb3JTcGxpdC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JTcGxpdFsxXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW5kc1dpdGgoZXJyb3JNZXNzYWdlLCBcIi5cIikpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2Uuc3Vic3RyKDAsIGVycm9yTWVzc2FnZS5sZW5ndGggLSAxKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFt0KFwiVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gJ3swfSc6IHsxfS5cIiwgdG9EaXNwbGF5U3RyaW5nKHVybCksIGVycm9yTWVzc2FnZSldKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXNvbHZlU2NoZW1hQ29udGVudChzY2hlbWFUb1Jlc29sdmUsIGhhbmRsZSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZUVycm9ycyA9IHNjaGVtYVRvUmVzb2x2ZS5lcnJvcnMuc2xpY2UoMCk7XHJcbiAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFUb1Jlc29sdmUuc2NoZW1hO1xyXG4gICAgbGV0IHNjaGVtYURyYWZ0ID0gc2NoZW1hLiRzY2hlbWEgPyBub3JtYWxpemVJZChzY2hlbWEuJHNjaGVtYSkgOiB2b2lkIDA7XHJcbiAgICBpZiAoc2NoZW1hRHJhZnQgPT09IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wMy9zY2hlbWFcIikge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobmV3IFJlc29sdmVkU2NoZW1hKHt9LCBbdChcIkRyYWZ0LTAzIHNjaGVtYXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpXSwgW10sIHNjaGVtYURyYWZ0KSk7XHJcbiAgICB9XHJcbiAgICBsZXQgdXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgY29udGV4dFNlcnZpY2UgPSB0aGlzLmNvbnRleHRTZXJ2aWNlO1xyXG4gICAgY29uc3QgZmluZFNlY3Rpb25CeUpTT05Qb2ludGVyID0gKHNjaGVtYTIsIHBhdGgpID0+IHtcclxuICAgICAgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXRoKTtcclxuICAgICAgbGV0IGN1cnJlbnQgPSBzY2hlbWEyO1xyXG4gICAgICBpZiAocGF0aFswXSA9PT0gXCIvXCIpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aC5zcGxpdChcIi9cIikuc29tZSgocGFydCkgPT4ge1xyXG4gICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XHJcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XHJcbiAgICAgICAgcmV0dXJuICFjdXJyZW50O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZmluZFNjaGVtYUJ5SWQgPSAoc2NoZW1hMiwgaGFuZGxlMiwgaWQpID0+IHtcclxuICAgICAgaWYgKCFoYW5kbGUyLmFuY2hvcnMpIHtcclxuICAgICAgICBoYW5kbGUyLmFuY2hvcnMgPSBjb2xsZWN0QW5jaG9ycyhzY2hlbWEyKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGFuZGxlMi5hbmNob3JzLmdldChpZCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWVyZ2UgPSAodGFyZ2V0LCBzZWN0aW9uKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHNlY3Rpb24pIHtcclxuICAgICAgICBpZiAoc2VjdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gXCJpZFwiICYmIGtleSAhPT0gXCIkaWRcIikge1xyXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzZWN0aW9uW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWVyZ2VSZWYgPSAodGFyZ2V0LCBzb3VyY2VSb290LCBzb3VyY2VIYW5kbGUsIHJlZlNlZ21lbnQpID0+IHtcclxuICAgICAgbGV0IHNlY3Rpb247XHJcbiAgICAgIGlmIChyZWZTZWdtZW50ID09PSB2b2lkIDAgfHwgcmVmU2VnbWVudC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBzZWN0aW9uID0gc291cmNlUm9vdDtcclxuICAgICAgfSBlbHNlIGlmIChyZWZTZWdtZW50LmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcclxuICAgICAgICBzZWN0aW9uID0gZmluZFNlY3Rpb25CeUpTT05Qb2ludGVyKHNvdXJjZVJvb3QsIHJlZlNlZ21lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlY3Rpb24gPSBmaW5kU2NoZW1hQnlJZChzb3VyY2VSb290LCBzb3VyY2VIYW5kbGUsIHJlZlNlZ21lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWN0aW9uKSB7XHJcbiAgICAgICAgbWVyZ2UodGFyZ2V0LCBzZWN0aW9uKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXNvbHZlRXJyb3JzLnB1c2godChcIiRyZWYgJ3swfScgaW4gJ3sxfScgY2FuIG5vdCBiZSByZXNvbHZlZC5cIiwgcmVmU2VnbWVudCB8fCBcIlwiLCBzb3VyY2VIYW5kbGUudXJpKSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZXNvbHZlRXh0ZXJuYWxMaW5rID0gKG5vZGUsIHVyaSwgcmVmU2VnbWVudCwgcGFyZW50SGFuZGxlKSA9PiB7XHJcbiAgICAgIGlmIChjb250ZXh0U2VydmljZSAmJiAhL15bQS1aYS16XVtBLVphLXowLTkrXFwtLitdKjpcXC9cXC8uKi8udGVzdCh1cmkpKSB7XHJcbiAgICAgICAgdXJpID0gY29udGV4dFNlcnZpY2UucmVzb2x2ZVJlbGF0aXZlUGF0aCh1cmksIHBhcmVudEhhbmRsZS51cmkpO1xyXG4gICAgICB9XHJcbiAgICAgIHVyaSA9IG5vcm1hbGl6ZUlkKHVyaSk7XHJcbiAgICAgIGNvbnN0IHJlZmVyZW5jZWRIYW5kbGUgPSB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKHVyaSk7XHJcbiAgICAgIHJldHVybiByZWZlcmVuY2VkSGFuZGxlLmdldFVucmVzb2x2ZWRTY2hlbWEoKS50aGVuKCh1bnJlc29sdmVkU2NoZW1hKSA9PiB7XHJcbiAgICAgICAgcGFyZW50SGFuZGxlLmRlcGVuZGVuY2llcy5hZGQodXJpKTtcclxuICAgICAgICBpZiAodW5yZXNvbHZlZFNjaGVtYS5lcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjb25zdCBsb2MgPSByZWZTZWdtZW50ID8gdXJpICsgXCIjXCIgKyByZWZTZWdtZW50IDogdXJpO1xyXG4gICAgICAgICAgcmVzb2x2ZUVycm9ycy5wdXNoKHQoXCJQcm9ibGVtcyBsb2FkaW5nIHJlZmVyZW5jZSAnezB9JzogezF9XCIsIGxvYywgdW5yZXNvbHZlZFNjaGVtYS5lcnJvcnNbMF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VSZWYobm9kZSwgdW5yZXNvbHZlZFNjaGVtYS5zY2hlbWEsIHJlZmVyZW5jZWRIYW5kbGUsIHJlZlNlZ21lbnQpO1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlUmVmcyhub2RlLCB1bnJlc29sdmVkU2NoZW1hLnNjaGVtYSwgcmVmZXJlbmNlZEhhbmRsZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc29sdmVSZWZzID0gKG5vZGUsIHBhcmVudFNjaGVtYSwgcGFyZW50SGFuZGxlKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9wZW5Qcm9taXNlcyA9IFtdO1xyXG4gICAgICB0aGlzLnRyYXZlcnNlTm9kZXMobm9kZSwgKG5leHQpID0+IHtcclxuICAgICAgICBjb25zdCBzZWVuUmVmcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgICAgICAgd2hpbGUgKG5leHQuJHJlZikge1xyXG4gICAgICAgICAgY29uc3QgcmVmID0gbmV4dC4kcmVmO1xyXG4gICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSByZWYuc3BsaXQoXCIjXCIsIDIpO1xyXG4gICAgICAgICAgZGVsZXRlIG5leHQuJHJlZjtcclxuICAgICAgICAgIGlmIChzZWdtZW50c1swXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG9wZW5Qcm9taXNlcy5wdXNoKHJlc29sdmVFeHRlcm5hbExpbmsobmV4dCwgc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdLCBwYXJlbnRIYW5kbGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFzZWVuUmVmcy5oYXMocmVmKSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gc2VnbWVudHNbMV07XHJcbiAgICAgICAgICAgICAgbWVyZ2VSZWYobmV4dCwgcGFyZW50U2NoZW1hLCBwYXJlbnRIYW5kbGUsIGlkKTtcclxuICAgICAgICAgICAgICBzZWVuUmVmcy5hZGQocmVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dC4kcmVjdXJzaXZlUmVmKSB7XHJcbiAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoXCIkcmVjdXJzaXZlUmVmXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dC4kZHluYW1pY1JlZikge1xyXG4gICAgICAgICAgdXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMuYWRkKFwiJGR5bmFtaWNSZWZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5hbGwob3BlblByb21pc2VzKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBjb2xsZWN0QW5jaG9ycyA9IChyb290KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgICAgIHRoaXMudHJhdmVyc2VOb2Rlcyhyb290LCAobmV4dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlkID0gbmV4dC4kaWQgfHwgbmV4dC5pZDtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSBpc1N0cmluZyhpZCkgJiYgaWQuY2hhckF0KDApID09PSBcIiNcIiA/IGlkLnN1YnN0cmluZygxKSA6IG5leHQuJGFuY2hvcjtcclxuICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICBpZiAocmVzdWx0LmhhcyhhbmNob3IpKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KFwiRHVwbGljYXRlIGFuY2hvciBkZWNsYXJhdGlvbjogJ3swfSdcIiwgYW5jaG9yKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGFuY2hvciwgbmV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0LiRyZWN1cnNpdmVBbmNob3IpIHtcclxuICAgICAgICAgIHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzLmFkZChcIiRyZWN1cnNpdmVBbmNob3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0LiRkeW5hbWljQW5jaG9yKSB7XHJcbiAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoXCIkZHluYW1pY0FuY2hvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiByZXNvbHZlUmVmcyhzY2hlbWEsIHNjaGVtYSwgaGFuZGxlKS50aGVuKChfKSA9PiB7XHJcbiAgICAgIGxldCByZXNvbHZlV2FybmluZ3MgPSBbXTtcclxuICAgICAgaWYgKHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzLnNpemUpIHtcclxuICAgICAgICByZXNvbHZlV2FybmluZ3MucHVzaCh0KFwiVGhlIHNjaGVtYSB1c2VzIG1ldGEtc2NoZW1hIGZlYXR1cmVzICh7MH0pIHRoYXQgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IHRoZSB2YWxpZGF0b3IuXCIsIEFycmF5LmZyb20odXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMua2V5cygpKS5qb2luKFwiLCBcIikpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IFJlc29sdmVkU2NoZW1hKHNjaGVtYSwgcmVzb2x2ZUVycm9ycywgcmVzb2x2ZVdhcm5pbmdzLCBzY2hlbWFEcmFmdCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdHJhdmVyc2VOb2Rlcyhyb290LCBoYW5kbGUpIHtcclxuICAgIGlmICghcm9vdCB8fCB0eXBlb2Ygcm9vdCAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBjb2xsZWN0RW50cmllcyA9ICguLi5lbnRyaWVzKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICAgIGlmIChpc09iamVjdChlbnRyeSkpIHtcclxuICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBjb2xsZWN0TWFwRW50cmllcyA9ICguLi5tYXBzKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QobWFwKSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBrIGluIG1hcCkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrO1xyXG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IG1hcFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZW50cnkpKSB7XHJcbiAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29sbGVjdEFycmF5RW50cmllcyA9ICguLi5hcnJheXMpID0+IHtcclxuICAgICAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgYXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvbGxlY3RFbnRyeU9yQXJyYXlFbnRyaWVzID0gKGl0ZW1zKSA9PiB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlbXMpIHtcclxuICAgICAgICAgIGlmIChpc09iamVjdChlbnRyeSkpIHtcclxuICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpdGVtcykpIHtcclxuICAgICAgICB0b1dhbGsucHVzaChpdGVtcyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB0b1dhbGsgPSBbcm9vdF07XHJcbiAgICBsZXQgbmV4dCA9IHRvV2Fsay5wb3AoKTtcclxuICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgIGlmICghc2Vlbi5oYXMobmV4dCkpIHtcclxuICAgICAgICBzZWVuLmFkZChuZXh0KTtcclxuICAgICAgICBoYW5kbGUobmV4dCk7XHJcbiAgICAgICAgY29sbGVjdEVudHJpZXMobmV4dC5hZGRpdGlvbmFsSXRlbXMsIG5leHQuYWRkaXRpb25hbFByb3BlcnRpZXMsIG5leHQubm90LCBuZXh0LmNvbnRhaW5zLCBuZXh0LnByb3BlcnR5TmFtZXMsIG5leHQuaWYsIG5leHQudGhlbiwgbmV4dC5lbHNlLCBuZXh0LnVuZXZhbHVhdGVkSXRlbXMsIG5leHQudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKTtcclxuICAgICAgICBjb2xsZWN0TWFwRW50cmllcyhuZXh0LmRlZmluaXRpb25zLCBuZXh0LiRkZWZzLCBuZXh0LnByb3BlcnRpZXMsIG5leHQucGF0dGVyblByb3BlcnRpZXMsIG5leHQuZGVwZW5kZW5jaWVzLCBuZXh0LmRlcGVuZGVudFNjaGVtYXMpO1xyXG4gICAgICAgIGNvbGxlY3RBcnJheUVudHJpZXMobmV4dC5hbnlPZiwgbmV4dC5hbGxPZiwgbmV4dC5vbmVPZiwgbmV4dC5wcmVmaXhJdGVtcyk7XHJcbiAgICAgICAgY29sbGVjdEVudHJ5T3JBcnJheUVudHJpZXMobmV4dC5pdGVtcyk7XHJcbiAgICAgIH1cclxuICAgICAgbmV4dCA9IHRvV2Fsay5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0U2NoZW1hRnJvbVByb3BlcnR5KHJlc291cmNlLCBkb2N1bWVudCkge1xyXG4gICAgaWYgKGRvY3VtZW50LnJvb3Q/LnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgZm9yIChjb25zdCBwIG9mIGRvY3VtZW50LnJvb3QucHJvcGVydGllcykge1xyXG4gICAgICAgIGlmIChwLmtleU5vZGUudmFsdWUgPT09IFwiJHNjaGVtYVwiICYmIHAudmFsdWVOb2RlPy50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBsZXQgc2NoZW1hSWQgPSBwLnZhbHVlTm9kZS52YWx1ZTtcclxuICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRTZXJ2aWNlICYmICEvXlxcd1tcXHdcXGQrLi1dKjovLnRlc3Qoc2NoZW1hSWQpKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYUlkID0gdGhpcy5jb250ZXh0U2VydmljZS5yZXNvbHZlUmVsYXRpdmVQYXRoKHNjaGVtYUlkLCByZXNvdXJjZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gc2NoZW1hSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm9pZCAwO1xyXG4gIH1cclxuICBnZXRBc3NvY2lhdGVkU2NoZW1hcyhyZXNvdXJjZSkge1xyXG4gICAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgY29uc3Qgc2NoZW1hcyA9IFtdO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZFJlc291cmNlID0gbm9ybWFsaXplUmVzb3VyY2VGb3JNYXRjaGluZyhyZXNvdXJjZSk7XHJcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMpIHtcclxuICAgICAgaWYgKGVudHJ5Lm1hdGNoZXNQYXR0ZXJuKG5vcm1hbGl6ZWRSZXNvdXJjZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYUlkIG9mIGVudHJ5LmdldFVSSXMoKSkge1xyXG4gICAgICAgICAgaWYgKCFzZWVuW3NjaGVtYUlkXSkge1xyXG4gICAgICAgICAgICBzY2hlbWFzLnB1c2goc2NoZW1hSWQpO1xyXG4gICAgICAgICAgICBzZWVuW3NjaGVtYUlkXSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2NoZW1hcztcclxuICB9XHJcbiAgZ2V0U2NoZW1hVVJJc0ZvclJlc291cmNlKHJlc291cmNlLCBkb2N1bWVudCkge1xyXG4gICAgbGV0IHNjaGVtZUlkID0gZG9jdW1lbnQgJiYgdGhpcy5nZXRTY2hlbWFGcm9tUHJvcGVydHkocmVzb3VyY2UsIGRvY3VtZW50KTtcclxuICAgIGlmIChzY2hlbWVJZCkge1xyXG4gICAgICByZXR1cm4gW3NjaGVtZUlkXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldEFzc29jaWF0ZWRTY2hlbWFzKHJlc291cmNlKTtcclxuICB9XHJcbiAgZ2V0U2NoZW1hRm9yUmVzb3VyY2UocmVzb3VyY2UsIGRvY3VtZW50KSB7XHJcbiAgICBpZiAoZG9jdW1lbnQpIHtcclxuICAgICAgbGV0IHNjaGVtZUlkID0gdGhpcy5nZXRTY2hlbWFGcm9tUHJvcGVydHkocmVzb3VyY2UsIGRvY3VtZW50KTtcclxuICAgICAgaWYgKHNjaGVtZUlkKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBub3JtYWxpemVJZChzY2hlbWVJZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JBZGRTY2hlbWFIYW5kbGUoaWQpLmdldFJlc29sdmVkU2NoZW1hKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlICYmIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlLnJlc29sdmVkU2NoZW1hO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2NoZW1hcyA9IHRoaXMuZ2V0QXNzb2NpYXRlZFNjaGVtYXMocmVzb3VyY2UpO1xyXG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBzY2hlbWFzLmxlbmd0aCA+IDAgPyB0aGlzLmNyZWF0ZUNvbWJpbmVkU2NoZW1hKHJlc291cmNlLCBzY2hlbWFzKS5nZXRSZXNvbHZlZFNjaGVtYSgpIDogdGhpcy5wcm9taXNlLnJlc29sdmUodm9pZCAwKTtcclxuICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB7IHJlc291cmNlLCByZXNvbHZlZFNjaGVtYSB9O1xyXG4gICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xyXG4gIH1cclxuICBjcmVhdGVDb21iaW5lZFNjaGVtYShyZXNvdXJjZSwgc2NoZW1hSWRzKSB7XHJcbiAgICBpZiAoc2NoZW1hSWRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShzY2hlbWFJZHNbMF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgY29tYmluZWRTY2hlbWFJZCA9IFwic2NoZW1hc2VydmljZTovL2NvbWJpbmVkU2NoZW1hL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlc291cmNlKTtcclxuICAgICAgY29uc3QgY29tYmluZWRTY2hlbWEgPSB7XHJcbiAgICAgICAgYWxsT2Y6IHNjaGVtYUlkcy5tYXAoKHNjaGVtYUlkKSA9PiAoeyAkcmVmOiBzY2hlbWFJZCB9KSlcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHRoaXMuYWRkU2NoZW1hSGFuZGxlKGNvbWJpbmVkU2NoZW1hSWQsIGNvbWJpbmVkU2NoZW1hKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0TWF0Y2hpbmdTY2hlbWFzKGRvY3VtZW50LCBqc29uRG9jdW1lbnQsIHNjaGVtYSkge1xyXG4gICAgaWYgKHNjaGVtYSkge1xyXG4gICAgICBjb25zdCBpZCA9IHNjaGVtYS5pZCB8fCBcInNjaGVtYXNlcnZpY2U6Ly91bnRpdGxlZC9tYXRjaGluZ1NjaGVtYXMvXCIgKyBpZENvdW50ZXIyKys7XHJcbiAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuYWRkU2NoZW1hSGFuZGxlKGlkLCBzY2hlbWEpO1xyXG4gICAgICByZXR1cm4gaGFuZGxlLmdldFJlc29sdmVkU2NoZW1hKCkudGhlbigocmVzb2x2ZWRTY2hlbWEpID0+IHtcclxuICAgICAgICByZXR1cm4ganNvbkRvY3VtZW50LmdldE1hdGNoaW5nU2NoZW1hcyhyZXNvbHZlZFNjaGVtYS5zY2hlbWEpLmZpbHRlcigocykgPT4gIXMuaW52ZXJ0ZWQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldFNjaGVtYUZvclJlc291cmNlKGRvY3VtZW50LnVyaSwganNvbkRvY3VtZW50KS50aGVuKChzY2hlbWEyKSA9PiB7XHJcbiAgICAgIGlmIChzY2hlbWEyKSB7XHJcbiAgICAgICAgcmV0dXJuIGpzb25Eb2N1bWVudC5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hMi5zY2hlbWEpLmZpbHRlcigocykgPT4gIXMuaW52ZXJ0ZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxudmFyIGlkQ291bnRlcjIgPSAwO1xyXG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gVVJJMi5wYXJzZShpZCkudG9TdHJpbmcodHJ1ZSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGlkO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVSZXNvdXJjZUZvck1hdGNoaW5nKHJlc291cmNlKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBVUkkyLnBhcnNlKHJlc291cmNlKS53aXRoKHsgZnJhZ21lbnQ6IG51bGwsIHF1ZXJ5OiBudWxsIH0pLnRvU3RyaW5nKHRydWUpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiByZXNvdXJjZTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdG9EaXNwbGF5U3RyaW5nKHVybCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1cmkgPSBVUkkyLnBhcnNlKHVybCk7XHJcbiAgICBpZiAodXJpLnNjaGVtZSA9PT0gXCJmaWxlXCIpIHtcclxuICAgICAgcmV0dXJuIHVyaS5mc1BhdGg7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gIH1cclxuICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvbkZvbGRpbmcuanNcclxuZnVuY3Rpb24gZ2V0Rm9sZGluZ1Jhbmdlcyhkb2N1bWVudCwgY29udGV4dCkge1xyXG4gIGNvbnN0IHJhbmdlcyA9IFtdO1xyXG4gIGNvbnN0IG5lc3RpbmdMZXZlbHMgPSBbXTtcclxuICBjb25zdCBzdGFjayA9IFtdO1xyXG4gIGxldCBwcmV2U3RhcnQgPSAtMTtcclxuICBjb25zdCBzY2FubmVyID0gY3JlYXRlU2Nhbm5lcjIoZG9jdW1lbnQuZ2V0VGV4dCgpLCBmYWxzZSk7XHJcbiAgbGV0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XHJcbiAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2UpIHtcclxuICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcclxuICAgIG5lc3RpbmdMZXZlbHMucHVzaChzdGFjay5sZW5ndGgpO1xyXG4gIH1cclxuICB3aGlsZSAodG9rZW4gIT09IDE3KSB7XHJcbiAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgY2FzZSAzOiB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0TGluZSwgZW5kTGluZTogc3RhcnRMaW5lLCBraW5kOiB0b2tlbiA9PT0gMSA/IFwib2JqZWN0XCIgOiBcImFycmF5XCIgfTtcclxuICAgICAgICBzdGFjay5wdXNoKHJhbmdlKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgIGNhc2UgNDoge1xyXG4gICAgICAgIGNvbnN0IGtpbmQgPSB0b2tlbiA9PT0gMiA/IFwib2JqZWN0XCIgOiBcImFycmF5XCI7XHJcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ua2luZCA9PT0ga2luZCkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcclxuICAgICAgICAgIGlmIChyYW5nZSAmJiBsaW5lID4gcmFuZ2Uuc3RhcnRMaW5lICsgMSAmJiBwcmV2U3RhcnQgIT09IHJhbmdlLnN0YXJ0TGluZSkge1xyXG4gICAgICAgICAgICByYW5nZS5lbmRMaW5lID0gbGluZSAtIDE7XHJcbiAgICAgICAgICAgIGFkZFJhbmdlKHJhbmdlKTtcclxuICAgICAgICAgICAgcHJldlN0YXJ0ID0gcmFuZ2Uuc3RhcnRMaW5lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDEzOiB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XHJcbiAgICAgICAgY29uc3QgZW5kTGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKS5saW5lO1xyXG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuRXJyb3IoKSA9PT0gMSAmJiBzdGFydExpbmUgKyAxIDwgZG9jdW1lbnQubGluZUNvdW50KSB7XHJcbiAgICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKGRvY3VtZW50Lm9mZnNldEF0KFBvc2l0aW9uLmNyZWF0ZShzdGFydExpbmUgKyAxLCAwKSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoc3RhcnRMaW5lIDwgZW5kTGluZSkge1xyXG4gICAgICAgICAgICBhZGRSYW5nZSh7IHN0YXJ0TGluZSwgZW5kTGluZSwga2luZDogRm9sZGluZ1JhbmdlS2luZC5Db21tZW50IH0pO1xyXG4gICAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydExpbmU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMTI6IHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7XHJcbiAgICAgICAgY29uc3QgbSA9IHRleHQubWF0Y2goL15cXC9cXC9cXHMqIyhyZWdpb25cXGIpfChlbmRyZWdpb25cXGIpLyk7XHJcbiAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcclxuICAgICAgICAgIGlmIChtWzFdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBzdGFydExpbmU6IGxpbmUsIGVuZExpbmU6IGxpbmUsIGtpbmQ6IEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uIH07XHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocmFuZ2UpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHN0YWNrW2ldLmtpbmQgIT09IEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHN0YWNrW2ldO1xyXG4gICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGk7XHJcbiAgICAgICAgICAgICAgaWYgKGxpbmUgPiByYW5nZS5zdGFydExpbmUgJiYgcHJldlN0YXJ0ICE9PSByYW5nZS5zdGFydExpbmUpIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlLmVuZExpbmUgPSBsaW5lO1xyXG4gICAgICAgICAgICAgICAgYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgcHJldlN0YXJ0ID0gcmFuZ2Uuc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcclxuICB9XHJcbiAgY29uc3QgcmFuZ2VMaW1pdCA9IGNvbnRleHQgJiYgY29udGV4dC5yYW5nZUxpbWl0O1xyXG4gIGlmICh0eXBlb2YgcmFuZ2VMaW1pdCAhPT0gXCJudW1iZXJcIiB8fCByYW5nZXMubGVuZ3RoIDw9IHJhbmdlTGltaXQpIHtcclxuICAgIHJldHVybiByYW5nZXM7XHJcbiAgfVxyXG4gIGlmIChjb250ZXh0ICYmIGNvbnRleHQub25SYW5nZUxpbWl0RXhjZWVkZWQpIHtcclxuICAgIGNvbnRleHQub25SYW5nZUxpbWl0RXhjZWVkZWQoZG9jdW1lbnQudXJpKTtcclxuICB9XHJcbiAgY29uc3QgY291bnRzID0gW107XHJcbiAgZm9yIChsZXQgbGV2ZWwgb2YgbmVzdGluZ0xldmVscykge1xyXG4gICAgaWYgKGxldmVsIDwgMzApIHtcclxuICAgICAgY291bnRzW2xldmVsXSA9IChjb3VudHNbbGV2ZWxdIHx8IDApICsgMTtcclxuICAgIH1cclxuICB9XHJcbiAgbGV0IGVudHJpZXMgPSAwO1xyXG4gIGxldCBtYXhMZXZlbCA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IG4gPSBjb3VudHNbaV07XHJcbiAgICBpZiAobikge1xyXG4gICAgICBpZiAobiArIGVudHJpZXMgPiByYW5nZUxpbWl0KSB7XHJcbiAgICAgICAgbWF4TGV2ZWwgPSBpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGVudHJpZXMgKz0gbjtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGxldmVsID0gbmVzdGluZ0xldmVsc1tpXTtcclxuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgaWYgKGxldmVsIDwgbWF4TGV2ZWwgfHwgbGV2ZWwgPT09IG1heExldmVsICYmIGVudHJpZXMrKyA8IHJhbmdlTGltaXQpIHtcclxuICAgICAgICByZXN1bHQucHVzaChyYW5nZXNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8vIG5vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uU2VsZWN0aW9uUmFuZ2VzLmpzXHJcbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlcyhkb2N1bWVudCwgcG9zaXRpb25zLCBkb2MpIHtcclxuICBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZShwb3NpdGlvbikge1xyXG4gICAgbGV0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcclxuICAgIGxldCBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCwgdHJ1ZSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcclxuICAgICAgICAgIGNvbnN0IGNTdGFydCA9IG5vZGUub2Zmc2V0ICsgMSwgY0VuZCA9IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgaWYgKGNTdGFydCA8IGNFbmQgJiYgb2Zmc2V0ID49IGNTdGFydCAmJiBvZmZzZXQgPD0gY0VuZCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShjU3RhcnQsIGNFbmQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1JhbmdlKG5vZGUub2Zmc2V0LCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICBjYXNlIFwibnVsbFwiOlxyXG4gICAgICAgIGNhc2UgXCJwcm9wZXJ0eVwiOlxyXG4gICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwicHJvcGVydHlcIiB8fCBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICBjb25zdCBhZnRlckNvbW1hT2Zmc2V0ID0gZ2V0T2Zmc2V0QWZ0ZXJOZXh0VG9rZW4oXHJcbiAgICAgICAgICBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoLFxyXG4gICAgICAgICAgNVxyXG4gICAgICAgICAgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoYWZ0ZXJDb21tYU9mZnNldCAhPT0gLTEpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1JhbmdlKG5vZGUub2Zmc2V0LCBhZnRlckNvbW1hT2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIGxldCBjdXJyZW50ID0gdm9pZCAwO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSByZXN1bHQubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xyXG4gICAgICBjdXJyZW50ID0gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHJlc3VsdFtpbmRleF0sIGN1cnJlbnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjdXJyZW50KSB7XHJcbiAgICAgIGN1cnJlbnQgPSBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoUmFuZ2UuY3JlYXRlKHBvc2l0aW9uLCBwb3NpdGlvbikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG5ld1JhbmdlKHN0YXJ0LCBlbmQpIHtcclxuICAgIHJldHVybiBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChzdGFydCksIGRvY3VtZW50LnBvc2l0aW9uQXQoZW5kKSk7XHJcbiAgfVxyXG4gIGNvbnN0IHNjYW5uZXIgPSBjcmVhdGVTY2FubmVyMihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xyXG4gIGZ1bmN0aW9uIGdldE9mZnNldEFmdGVyTmV4dFRva2VuKG9mZnNldCwgZXhwZWN0ZWRUb2tlbikge1xyXG4gICAgc2Nhbm5lci5zZXRQb3NpdGlvbihvZmZzZXQpO1xyXG4gICAgbGV0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XHJcbiAgICBpZiAodG9rZW4gPT09IGV4cGVjdGVkVG9rZW4pIHtcclxuICAgICAgcmV0dXJuIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKTtcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbiAgcmV0dXJuIHBvc2l0aW9ucy5tYXAoZ2V0U2VsZWN0aW9uUmFuZ2UpO1xyXG59XHJcblxyXG4vLyBub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvZm9ybWF0LmpzXHJcbmZ1bmN0aW9uIGZvcm1hdDQoZG9jdW1lbnRUb0Zvcm1hdCwgZm9ybWF0dGluZ09wdGlvbnMsIGZvcm1hdHRpbmdSYW5nZSkge1xyXG4gIGxldCByYW5nZSA9IHZvaWQgMDtcclxuICBpZiAoZm9ybWF0dGluZ1JhbmdlKSB7XHJcbiAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudFRvRm9ybWF0Lm9mZnNldEF0KGZvcm1hdHRpbmdSYW5nZS5zdGFydCk7XHJcbiAgICBjb25zdCBsZW5ndGggPSBkb2N1bWVudFRvRm9ybWF0Lm9mZnNldEF0KGZvcm1hdHRpbmdSYW5nZS5lbmQpIC0gb2Zmc2V0O1xyXG4gICAgcmFuZ2UgPSB7IG9mZnNldCwgbGVuZ3RoIH07XHJcbiAgfVxyXG4gIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICB0YWJTaXplOiBmb3JtYXR0aW5nT3B0aW9ucyA/IGZvcm1hdHRpbmdPcHRpb25zLnRhYlNpemUgOiA0LFxyXG4gICAgaW5zZXJ0U3BhY2VzOiBmb3JtYXR0aW5nT3B0aW9ucz8uaW5zZXJ0U3BhY2VzID09PSB0cnVlLFxyXG4gICAgaW5zZXJ0RmluYWxOZXdsaW5lOiBmb3JtYXR0aW5nT3B0aW9ucz8uaW5zZXJ0RmluYWxOZXdsaW5lID09PSB0cnVlLFxyXG4gICAgZW9sOiBcIlxcblwiLFxyXG4gICAga2VlcExpbmVzOiBmb3JtYXR0aW5nT3B0aW9ucz8ua2VlcExpbmVzID09PSB0cnVlXHJcbiAgfTtcclxuICByZXR1cm4gZm9ybWF0Mihkb2N1bWVudFRvRm9ybWF0LmdldFRleHQoKSwgcmFuZ2UsIG9wdGlvbnMpLm1hcCgoZWRpdCkgPT4ge1xyXG4gICAgcmV0dXJuIFRleHRFZGl0LnJlcGxhY2UoUmFuZ2UuY3JlYXRlKGRvY3VtZW50VG9Gb3JtYXQucG9zaXRpb25BdChlZGl0Lm9mZnNldCksIGRvY3VtZW50VG9Gb3JtYXQucG9zaXRpb25BdChlZGl0Lm9mZnNldCArIGVkaXQubGVuZ3RoKSksIGVkaXQuY29udGVudCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIG5vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9wcm9wZXJ0eVRyZWUuanNcclxudmFyIENvbnRhaW5lcjtcclxuKGZ1bmN0aW9uKENvbnRhaW5lcjIpIHtcclxuICBDb250YWluZXIyW0NvbnRhaW5lcjJbXCJPYmplY3RcIl0gPSAwXSA9IFwiT2JqZWN0XCI7XHJcbiAgQ29udGFpbmVyMltDb250YWluZXIyW1wiQXJyYXlcIl0gPSAxXSA9IFwiQXJyYXlcIjtcclxufSkoQ29udGFpbmVyIHx8IChDb250YWluZXIgPSB7fSkpO1xyXG52YXIgUHJvcGVydHlUcmVlID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5TmFtZSwgYmVnaW5uaW5nTGluZU51bWJlcikge1xyXG4gICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWUgPz8gXCJcIjtcclxuICAgIHRoaXMuYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXI7XHJcbiAgICB0aGlzLmNoaWxkcmVuUHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5sYXN0UHJvcGVydHkgPSBmYWxzZTtcclxuICAgIHRoaXMubm9LZXlOYW1lID0gZmFsc2U7XHJcbiAgfVxyXG4gIGFkZENoaWxkUHJvcGVydHkoY2hpbGRQcm9wZXJ0eSkge1xyXG4gICAgY2hpbGRQcm9wZXJ0eS5wYXJlbnQgPSB0aGlzO1xyXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgbGV0IGluc2VydGlvbkluZGV4ID0gMDtcclxuICAgICAgaWYgKGNoaWxkUHJvcGVydHkubm9LZXlOYW1lKSB7XHJcbiAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2hPblByb3BlcnR5QXJyYXkodGhpcy5jaGlsZHJlblByb3BlcnRpZXMsIGNoaWxkUHJvcGVydHksIGNvbXBhcmVQcm9wZXJ0aWVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5zZXJ0aW9uSW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSBpbnNlcnRpb25JbmRleCAqIC0xIC0gMTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIGNoaWxkUHJvcGVydHkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jaGlsZHJlblByb3BlcnRpZXMucHVzaChjaGlsZFByb3BlcnR5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZFByb3BlcnR5O1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gY29tcGFyZVByb3BlcnRpZXMocHJvcGVydHlUcmVlMSwgcHJvcGVydHlUcmVlMikge1xyXG4gIGNvbnN0IHByb3BlcnR5TmFtZTEgPSBwcm9wZXJ0eVRyZWUxLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGNvbnN0IHByb3BlcnR5TmFtZTIgPSBwcm9wZXJ0eVRyZWUyLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChwcm9wZXJ0eU5hbWUxIDwgcHJvcGVydHlOYW1lMikge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH0gZWxzZSBpZiAocHJvcGVydHlOYW1lMSA+IHByb3BlcnR5TmFtZTIpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2hPblByb3BlcnR5QXJyYXkocHJvcGVydHlUcmVlQXJyYXksIHByb3BlcnR5VHJlZSwgY29tcGFyZV9mbikge1xyXG4gIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5VHJlZS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICBjb25zdCBmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUgPSBwcm9wZXJ0eVRyZWVBcnJheVswXS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICBjb25zdCBsYXN0UHJvcGVydHlJbkFycmF5TmFtZSA9IHByb3BlcnR5VHJlZUFycmF5W3Byb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDFdLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChwcm9wZXJ0eU5hbWUgPCBmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBpZiAocHJvcGVydHlOYW1lID4gbGFzdFByb3BlcnR5SW5BcnJheU5hbWUpIHtcclxuICAgIHJldHVybiBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGg7XHJcbiAgfVxyXG4gIGxldCBtID0gMDtcclxuICBsZXQgbiA9IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgd2hpbGUgKG0gPD0gbikge1xyXG4gICAgbGV0IGsgPSBuICsgbSA+PiAxO1xyXG4gICAgbGV0IGNtcCA9IGNvbXBhcmVfZm4ocHJvcGVydHlUcmVlLCBwcm9wZXJ0eVRyZWVBcnJheVtrXSk7XHJcbiAgICBpZiAoY21wID4gMCkge1xyXG4gICAgICBtID0gayArIDE7XHJcbiAgICB9IGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgbiA9IGsgLSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAtbSAtIDE7XHJcbn1cclxuXHJcbi8vIG5vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9zb3J0LmpzXHJcbmZ1bmN0aW9uIHNvcnQoZG9jdW1lbnRUb1NvcnQsIGZvcm1hdHRpbmdPcHRpb25zKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgIC4uLmZvcm1hdHRpbmdPcHRpb25zLFxyXG4gICAga2VlcExpbmVzOiBmYWxzZVxyXG4gICAgLy8ga2VlcExpbmVzIG11c3QgYmUgZmFsc2Ugc28gdGhhdCB0aGUgcHJvcGVydGllcyBhcmUgb24gc2VwYXJhdGUgbGluZXMgZm9yIHRoZSBzb3J0aW5nXHJcbiAgfTtcclxuICBjb25zdCBmb3JtYXR0ZWRKc29uU3RyaW5nID0gVGV4dERvY3VtZW50Mi5hcHBseUVkaXRzKGRvY3VtZW50VG9Tb3J0LCBmb3JtYXQ0KGRvY3VtZW50VG9Tb3J0LCBvcHRpb25zLCB2b2lkIDApKTtcclxuICBjb25zdCBmb3JtYXR0ZWRKc29uRG9jdW1lbnQgPSBUZXh0RG9jdW1lbnQyLmNyZWF0ZShcInRlc3Q6Ly90ZXN0Lmpzb25cIiwgXCJqc29uXCIsIDAsIGZvcm1hdHRlZEpzb25TdHJpbmcpO1xyXG4gIGNvbnN0IGpzb25Qcm9wZXJ0eVRyZWUgPSBmaW5kSnNvbmNQcm9wZXJ0eVRyZWUoZm9ybWF0dGVkSnNvbkRvY3VtZW50KTtcclxuICBjb25zdCBzb3J0ZWRKc29uRG9jdW1lbnQgPSBzb3J0SnNvbmNEb2N1bWVudChmb3JtYXR0ZWRKc29uRG9jdW1lbnQsIGpzb25Qcm9wZXJ0eVRyZWUpO1xyXG4gIGNvbnN0IGVkaXRzID0gZm9ybWF0NChzb3J0ZWRKc29uRG9jdW1lbnQsIG9wdGlvbnMsIHZvaWQgMCk7XHJcbiAgY29uc3Qgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50ID0gVGV4dERvY3VtZW50Mi5hcHBseUVkaXRzKHNvcnRlZEpzb25Eb2N1bWVudCwgZWRpdHMpO1xyXG4gIHJldHVybiBbVGV4dEVkaXQucmVwbGFjZShSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKDAsIDApLCBkb2N1bWVudFRvU29ydC5wb3NpdGlvbkF0KGRvY3VtZW50VG9Tb3J0LmdldFRleHQoKS5sZW5ndGgpKSwgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50KV07XHJcbn1cclxuZnVuY3Rpb24gZmluZEpzb25jUHJvcGVydHlUcmVlKGZvcm1hdHRlZERvY3VtZW50KSB7XHJcbiAgY29uc3QgZm9ybWF0dGVkU3RyaW5nID0gZm9ybWF0dGVkRG9jdW1lbnQuZ2V0VGV4dCgpO1xyXG4gIGNvbnN0IHNjYW5uZXIgPSBjcmVhdGVTY2FubmVyMihmb3JtYXR0ZWRTdHJpbmcsIGZhbHNlKTtcclxuICBsZXQgcm9vdFRyZWUgPSBuZXcgUHJvcGVydHlUcmVlKCk7XHJcbiAgbGV0IGN1cnJlbnRUcmVlID0gcm9vdFRyZWU7XHJcbiAgbGV0IGN1cnJlbnRQcm9wZXJ0eSA9IHJvb3RUcmVlO1xyXG4gIGxldCBsYXN0UHJvcGVydHkgPSByb290VHJlZTtcclxuICBsZXQgdG9rZW4gPSB2b2lkIDA7XHJcbiAgbGV0IGxhc3RUb2tlbkxpbmUgPSAwO1xyXG4gIGxldCBudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXMgPSAwO1xyXG4gIGxldCBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gdm9pZCAwO1xyXG4gIGxldCBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSB2b2lkIDA7XHJcbiAgbGV0IGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSAtMTtcclxuICBsZXQgZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSAtMTtcclxuICBsZXQgYmVnaW5uaW5nTGluZU51bWJlciA9IDA7XHJcbiAgbGV0IGVuZExpbmVOdW1iZXIgPSAwO1xyXG4gIGxldCBjdXJyZW50Q29udGFpbmVyU3RhY2sgPSBbXTtcclxuICBsZXQgdXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9IGZhbHNlO1xyXG4gIGxldCB1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID0gZmFsc2U7XHJcbiAgd2hpbGUgKCh0b2tlbiA9IHNjYW5uZXIuc2NhbigpKSAhPT0gMTcpIHtcclxuICAgIGlmICh1cGRhdGVMYXN0UHJvcGVydHlFbmRMaW5lTnVtYmVyID09PSB0cnVlICYmIHRva2VuICE9PSAxNCAmJiB0b2tlbiAhPT0gMTUgJiYgdG9rZW4gIT09IDEyICYmIHRva2VuICE9PSAxMyAmJiBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGxldCBlbmRMaW5lTnVtYmVyMiA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcclxuICAgICAgaWYgKHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMiB8fCBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQpIHtcclxuICAgICAgICBsYXN0UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIyIC0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIyIC0gMTtcclxuICAgICAgfVxyXG4gICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjI7XHJcbiAgICAgIHVwZGF0ZUxhc3RQcm9wZXJ0eUVuZExpbmVOdW1iZXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID09PSB0cnVlICYmIHRva2VuICE9PSAxNCAmJiB0b2tlbiAhPT0gMTUgJiYgdG9rZW4gIT09IDEyICYmIHRva2VuICE9PSAxMykge1xyXG4gICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xyXG4gICAgICB1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpICE9PSBsYXN0VG9rZW5MaW5lKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSBsYXN0VG9rZW5MaW5lOyBpIDwgc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsZW5ndGhPZkxpbmUgPSBmb3JtYXR0ZWREb2N1bWVudC5nZXRUZXh0KFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUoaSwgMCksIFBvc2l0aW9uLmNyZWF0ZShpICsgMSwgMCkpKS5sZW5ndGg7XHJcbiAgICAgICAgbnVtYmVyT2ZDaGFyYWN0ZXJzT25QcmV2aW91c0xpbmVzID0gbnVtYmVyT2ZDaGFyYWN0ZXJzT25QcmV2aW91c0xpbmVzICsgbGVuZ3RoT2ZMaW5lO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RUb2tlbkxpbmUgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgIGNhc2UgMTA6IHtcclxuICAgICAgICBpZiAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gdm9pZCAwIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDEgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNSAmJiBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZFByb3BlcnR5ID0gbmV3IFByb3BlcnR5VHJlZShzY2FubmVyLmdldFRva2VuVmFsdWUoKSwgYmVnaW5uaW5nTGluZU51bWJlcik7XHJcbiAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDM6IHtcclxuICAgICAgICBpZiAocm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICByb290VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLk9iamVjdCkge1xyXG4gICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuQXJyYXkpIHtcclxuICAgICAgICAgIGNvbnN0IGNoaWxkUHJvcGVydHkgPSBuZXcgUHJvcGVydHlUcmVlKHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcclxuICAgICAgICAgIGNoaWxkUHJvcGVydHkubm9LZXlOYW1lID0gdHJ1ZTtcclxuICAgICAgICAgIGxhc3RQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eTtcclxuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRUcmVlLmFkZENoaWxkUHJvcGVydHkoY2hpbGRQcm9wZXJ0eSk7XHJcbiAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudENvbnRhaW5lclN0YWNrLnB1c2goQ29udGFpbmVyLkFycmF5KTtcclxuICAgICAgICBjdXJyZW50UHJvcGVydHkudHlwZSA9IENvbnRhaW5lci5BcnJheTtcclxuICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xyXG4gICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIrKztcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDE6IHtcclxuICAgICAgICBpZiAocm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICByb290VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5KSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZFByb3BlcnR5ID0gbmV3IFByb3BlcnR5VHJlZShzY2FubmVyLmdldFRva2VuVmFsdWUoKSwgYmVnaW5uaW5nTGluZU51bWJlcik7XHJcbiAgICAgICAgICBjaGlsZFByb3BlcnR5Lm5vS2V5TmFtZSA9IHRydWU7XHJcbiAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UHJvcGVydHkudHlwZSA9IENvbnRhaW5lci5PYmplY3Q7XHJcbiAgICAgICAgY3VycmVudENvbnRhaW5lclN0YWNrLnB1c2goQ29udGFpbmVyLk9iamVjdCk7XHJcbiAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcclxuICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyKys7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY2FzZSA0OiB7XHJcbiAgICAgICAgZW5kTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcclxuICAgICAgICBjdXJyZW50Q29udGFpbmVyU3RhY2sucG9wKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID09PSB2b2lkIDAgJiYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCkpIHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlciAtIDE7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkubGFzdFByb3BlcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5saW5lV2hlcmVUb0FkZENvbW1hID0gbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcclxuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5pbmRleFdoZXJlVG9BZGRDb21hID0gZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XHJcbiAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgPyBjdXJyZW50UHJvcGVydHkucGFyZW50IDogdm9pZCAwO1xyXG4gICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3RUcmVlLmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyICsgMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDI6IHtcclxuICAgICAgICBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xyXG4gICAgICAgIGN1cnJlbnRDb250YWluZXJTdGFjay5wb3AoKTtcclxuICAgICAgICBpZiAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiAhPT0gMSkge1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyIC0gMTtcclxuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5Lmxhc3RQcm9wZXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5saW5lV2hlcmVUb0FkZENvbW1hID0gbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcclxuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmluZGV4V2hlcmVUb0FkZENvbWEgPSBlbmRJbmRleE9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxhc3RQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eTtcclxuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSA/IGN1cnJlbnRQcm9wZXJ0eS5wYXJlbnQgOiB2b2lkIDA7XHJcbiAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vdFRyZWUuZW5kTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcclxuICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlciArIDE7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY2FzZSA1OiB7XHJcbiAgICAgICAgZW5kTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcclxuICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPT09IHZvaWQgMCAmJiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLk9iamVjdCB8fCBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuQXJyYXkgJiYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCkpKSB7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkuY29tbWFJbmRleCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSAtIG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcztcclxuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5jb21tYUxpbmUgPSBlbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMiB8fCBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0KSB7XHJcbiAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgPyBjdXJyZW50UHJvcGVydHkucGFyZW50IDogdm9pZCAwO1xyXG4gICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyICsgMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDEzOiB7XHJcbiAgICAgICAgaWYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDUgJiYgbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpICYmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuQXJyYXkgJiYgKHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMiB8fCBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQpIHx8IGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5PYmplY3QpKSB7XHJcbiAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5ICYmIChzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0KSB8fCBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gdm9pZCAwO1xyXG4gICAgICAgICAgICB1cGRhdGVMYXN0UHJvcGVydHlFbmRMaW5lTnVtYmVyID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAxIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDMpICYmIGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKSkge1xyXG4gICAgICAgICAgdXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW4gIT09IDE0ICYmIHRva2VuICE9PSAxMyAmJiB0b2tlbiAhPT0gMTIgJiYgdG9rZW4gIT09IDE1KSB7XHJcbiAgICAgIHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XHJcbiAgICAgIGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSB0b2tlbjtcclxuICAgICAgbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcclxuICAgICAgZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgLSBudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXM7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByb290VHJlZTtcclxufVxyXG5mdW5jdGlvbiBzb3J0SnNvbmNEb2N1bWVudChqc29uRG9jdW1lbnQsIHByb3BlcnR5VHJlZSkge1xyXG4gIGlmIChwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIGpzb25Eb2N1bWVudDtcclxuICB9XHJcbiAgY29uc3Qgc29ydGVkSnNvbkRvY3VtZW50ID0gVGV4dERvY3VtZW50Mi5jcmVhdGUoXCJ0ZXN0Oi8vdGVzdC5qc29uXCIsIFwianNvblwiLCAwLCBqc29uRG9jdW1lbnQuZ2V0VGV4dCgpKTtcclxuICBjb25zdCBxdWV1ZVRvU29ydCA9IFtdO1xyXG4gIHVwZGF0ZVNvcnRpbmdRdWV1ZShxdWV1ZVRvU29ydCwgcHJvcGVydHlUcmVlLCBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlcik7XHJcbiAgd2hpbGUgKHF1ZXVlVG9Tb3J0Lmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnN0IGRhdGFUb1NvcnQgPSBxdWV1ZVRvU29ydC5zaGlmdCgpO1xyXG4gICAgY29uc3QgcHJvcGVydHlUcmVlQXJyYXkgPSBkYXRhVG9Tb3J0LnByb3BlcnR5VHJlZUFycmF5O1xyXG4gICAgbGV0IGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBkYXRhVG9Tb3J0LmJlZ2lubmluZ0xpbmVOdW1iZXI7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHByb3BlcnR5VHJlZTIgPSBwcm9wZXJ0eVRyZWVBcnJheVtpXTtcclxuICAgICAgY29uc3QgcmFuZ2UgPSBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKHByb3BlcnR5VHJlZTIuYmVnaW5uaW5nTGluZU51bWJlciwgMCksIFBvc2l0aW9uLmNyZWF0ZShwcm9wZXJ0eVRyZWUyLmVuZExpbmVOdW1iZXIgKyAxLCAwKSk7XHJcbiAgICAgIGNvbnN0IGpzb25Db250ZW50VG9SZXBsYWNlID0ganNvbkRvY3VtZW50LmdldFRleHQocmFuZ2UpO1xyXG4gICAgICBjb25zdCBqc29uRG9jdW1lbnRUb1JlcGxhY2UgPSBUZXh0RG9jdW1lbnQyLmNyZWF0ZShcInRlc3Q6Ly90ZXN0Lmpzb25cIiwgXCJqc29uXCIsIDAsIGpzb25Db250ZW50VG9SZXBsYWNlKTtcclxuICAgICAgaWYgKHByb3BlcnR5VHJlZTIubGFzdFByb3BlcnR5ID09PSB0cnVlICYmIGkgIT09IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBjb25zdCBsaW5lV2hlcmVUb0FkZENvbW1hID0gcHJvcGVydHlUcmVlMi5saW5lV2hlcmVUb0FkZENvbW1hIC0gcHJvcGVydHlUcmVlMi5iZWdpbm5pbmdMaW5lTnVtYmVyO1xyXG4gICAgICAgIGNvbnN0IGluZGV4V2hlcmVUb0FkZENvbW1hID0gcHJvcGVydHlUcmVlMi5pbmRleFdoZXJlVG9BZGRDb21hO1xyXG4gICAgICAgIGNvbnN0IGVkaXQyID0ge1xyXG4gICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZVdoZXJlVG9BZGRDb21tYSwgaW5kZXhXaGVyZVRvQWRkQ29tbWEpLCBQb3NpdGlvbi5jcmVhdGUobGluZVdoZXJlVG9BZGRDb21tYSwgaW5kZXhXaGVyZVRvQWRkQ29tbWEpKSxcclxuICAgICAgICAgIHRleHQ6IFwiLFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBUZXh0RG9jdW1lbnQyLnVwZGF0ZShqc29uRG9jdW1lbnRUb1JlcGxhY2UsIFtlZGl0Ml0sIDEpO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5VHJlZTIubGFzdFByb3BlcnR5ID09PSBmYWxzZSAmJiBpID09PSBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgY29uc3QgY29tbWFJbmRleCA9IHByb3BlcnR5VHJlZTIuY29tbWFJbmRleDtcclxuICAgICAgICBjb25zdCBjb21tYUxpbmUgPSBwcm9wZXJ0eVRyZWUyLmNvbW1hTGluZTtcclxuICAgICAgICBjb25zdCBsaW5lV2hlcmVUb1JlbW92ZUNvbW1hID0gY29tbWFMaW5lIC0gcHJvcGVydHlUcmVlMi5iZWdpbm5pbmdMaW5lTnVtYmVyO1xyXG4gICAgICAgIGNvbnN0IGVkaXQyID0ge1xyXG4gICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZVdoZXJlVG9SZW1vdmVDb21tYSwgY29tbWFJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lV2hlcmVUb1JlbW92ZUNvbW1hLCBjb21tYUluZGV4ICsgMSkpLFxyXG4gICAgICAgICAgdGV4dDogXCJcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGV4dERvY3VtZW50Mi51cGRhdGUoanNvbkRvY3VtZW50VG9SZXBsYWNlLCBbZWRpdDJdLCAxKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBsZW5ndGggPSBwcm9wZXJ0eVRyZWUyLmVuZExpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUyLmJlZ2lubmluZ0xpbmVOdW1iZXIgKyAxO1xyXG4gICAgICBjb25zdCBlZGl0ID0ge1xyXG4gICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGJlZ2lubmluZ0xpbmVOdW1iZXIsIDApLCBQb3NpdGlvbi5jcmVhdGUoYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aCwgMCkpLFxyXG4gICAgICAgIHRleHQ6IGpzb25Eb2N1bWVudFRvUmVwbGFjZS5nZXRUZXh0KClcclxuICAgICAgfTtcclxuICAgICAgVGV4dERvY3VtZW50Mi51cGRhdGUoc29ydGVkSnNvbkRvY3VtZW50LCBbZWRpdF0sIDEpO1xyXG4gICAgICB1cGRhdGVTb3J0aW5nUXVldWUocXVldWVUb1NvcnQsIHByb3BlcnR5VHJlZTIsIGJlZ2lubmluZ0xpbmVOdW1iZXIpO1xyXG4gICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHNvcnRlZEpzb25Eb2N1bWVudDtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVTb3J0aW5nUXVldWUocXVldWUsIHByb3BlcnR5VHJlZSwgYmVnaW5uaW5nTGluZU51bWJlcikge1xyXG4gIGlmIChwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAocHJvcGVydHlUcmVlLnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcclxuICAgIGxldCBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IEluZmluaXR5O1xyXG4gICAgZm9yIChjb25zdCBjaGlsZFByb3BlcnR5IG9mIHByb3BlcnR5VHJlZS5jaGlsZHJlblByb3BlcnRpZXMpIHtcclxuICAgICAgaWYgKGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlciA8IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgPSBjaGlsZFByb3BlcnR5LmJlZ2lubmluZ0xpbmVOdW1iZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGRpZmYgPSBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciAtIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyO1xyXG4gICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXIgKyBkaWZmO1xyXG4gICAgcXVldWUucHVzaChuZXcgU29ydGluZ1JhbmdlKGJlZ2lubmluZ0xpbmVOdW1iZXIsIHByb3BlcnR5VHJlZS5jaGlsZHJlblByb3BlcnRpZXMpKTtcclxuICB9IGVsc2UgaWYgKHByb3BlcnR5VHJlZS50eXBlID09PSBDb250YWluZXIuQXJyYXkpIHtcclxuICAgIHVwZGF0ZVNvcnRpbmdRdWV1ZUZvckFycmF5UHJvcGVydGllcyhxdWV1ZSwgcHJvcGVydHlUcmVlLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlU29ydGluZ1F1ZXVlRm9yQXJyYXlQcm9wZXJ0aWVzKHF1ZXVlLCBwcm9wZXJ0eVRyZWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcclxuICBmb3IgKGNvbnN0IHN1Yk9iamVjdCBvZiBwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzKSB7XHJcbiAgICBpZiAoc3ViT2JqZWN0LnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcclxuICAgICAgbGV0IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyID0gSW5maW5pdHk7XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGRQcm9wZXJ0eSBvZiBzdWJPYmplY3QuY2hpbGRyZW5Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlciA8IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGlmZiA9IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyIC0gc3ViT2JqZWN0LmJlZ2lubmluZ0xpbmVOdW1iZXI7XHJcbiAgICAgIHF1ZXVlLnB1c2gobmV3IFNvcnRpbmdSYW5nZShiZWdpbm5pbmdMaW5lTnVtYmVyICsgc3ViT2JqZWN0LmJlZ2lubmluZ0xpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlciArIGRpZmYsIHN1Yk9iamVjdC5jaGlsZHJlblByb3BlcnRpZXMpKTtcclxuICAgIH1cclxuICAgIGlmIChzdWJPYmplY3QudHlwZSA9PT0gQ29udGFpbmVyLkFycmF5KSB7XHJcbiAgICAgIHVwZGF0ZVNvcnRpbmdRdWV1ZUZvckFycmF5UHJvcGVydGllcyhxdWV1ZSwgc3ViT2JqZWN0LCBiZWdpbm5pbmdMaW5lTnVtYmVyICsgc3ViT2JqZWN0LmJlZ2lubmluZ0xpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlcik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbnZhciBTb3J0aW5nUmFuZ2UgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoYmVnaW5uaW5nTGluZU51bWJlciwgcHJvcGVydHlUcmVlQXJyYXkpIHtcclxuICAgIHRoaXMuYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXI7XHJcbiAgICB0aGlzLnByb3BlcnR5VHJlZUFycmF5ID0gcHJvcGVydHlUcmVlQXJyYXk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25MaW5rcy5qc1xyXG5mdW5jdGlvbiBmaW5kTGlua3MoZG9jdW1lbnQsIGRvYykge1xyXG4gIGNvbnN0IGxpbmtzID0gW107XHJcbiAgZG9jLnZpc2l0KChub2RlKSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSBcInByb3BlcnR5XCIgJiYgbm9kZS5rZXlOb2RlLnZhbHVlID09PSBcIiRyZWZcIiAmJiBub2RlLnZhbHVlTm9kZT8udHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBjb25zdCBwYXRoID0gbm9kZS52YWx1ZU5vZGUudmFsdWU7XHJcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBmaW5kVGFyZ2V0Tm9kZShkb2MsIHBhdGgpO1xyXG4gICAgICBpZiAodGFyZ2V0Tm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IGRvY3VtZW50LnBvc2l0aW9uQXQodGFyZ2V0Tm9kZS5vZmZzZXQpO1xyXG4gICAgICAgIGxpbmtzLnB1c2goe1xyXG4gICAgICAgICAgdGFyZ2V0OiBgJHtkb2N1bWVudC51cml9IyR7dGFyZ2V0UG9zLmxpbmUgKyAxfSwke3RhcmdldFBvcy5jaGFyYWN0ZXIgKyAxfWAsXHJcbiAgICAgICAgICByYW5nZTogY3JlYXRlUmFuZ2UoZG9jdW1lbnQsIG5vZGUudmFsdWVOb2RlKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9KTtcclxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxpbmtzKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSYW5nZShkb2N1bWVudCwgbm9kZSkge1xyXG4gIHJldHVybiBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCArIDEpLCBkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggLSAxKSk7XHJcbn1cclxuZnVuY3Rpb24gZmluZFRhcmdldE5vZGUoZG9jLCBwYXRoKSB7XHJcbiAgY29uc3QgdG9rZW5zID0gcGFyc2VKU09OUG9pbnRlcihwYXRoKTtcclxuICBpZiAoIXRva2Vucykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBmaW5kTm9kZSh0b2tlbnMsIGRvYy5yb290KTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTm9kZShwb2ludGVyLCBub2RlKSB7XHJcbiAgaWYgKCFub2RlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgaWYgKHBvaW50ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcbiAgY29uc3QgdG9rZW4gPSBwb2ludGVyLnNoaWZ0KCk7XHJcbiAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBub2RlLnByb3BlcnRpZXMuZmluZCgocHJvcGVydHlOb2RlMikgPT4gcHJvcGVydHlOb2RlMi5rZXlOb2RlLnZhbHVlID09PSB0b2tlbik7XHJcbiAgICBpZiAoIXByb3BlcnR5Tm9kZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBmaW5kTm9kZShwb2ludGVyLCBwcm9wZXJ0eU5vZGUudmFsdWVOb2RlKTtcclxuICB9IGVsc2UgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgIGlmICh0b2tlbi5tYXRjaCgvXigwfFsxLTldWzAtOV0qKSQvKSkge1xyXG4gICAgICBjb25zdCBpbmRleCA9IE51bWJlci5wYXJzZUludCh0b2tlbik7XHJcbiAgICAgIGNvbnN0IGFycmF5SXRlbSA9IG5vZGUuaXRlbXNbaW5kZXhdO1xyXG4gICAgICBpZiAoIWFycmF5SXRlbSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaW5kTm9kZShwb2ludGVyLCBhcnJheUl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUpTT05Qb2ludGVyKHBhdGgpIHtcclxuICBpZiAocGF0aCA9PT0gXCIjXCIpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgaWYgKHBhdGhbMF0gIT09IFwiI1wiIHx8IHBhdGhbMV0gIT09IFwiL1wiKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKDIpLnNwbGl0KC9cXC8vKS5tYXAodW5lc2NhcGUpO1xyXG59XHJcbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcclxufVxyXG5cclxuLy8gbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL2pzb25MYW5ndWFnZVNlcnZpY2UuanNcclxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VTZXJ2aWNlKHBhcmFtcykge1xyXG4gIGNvbnN0IHByb21pc2UgPSBwYXJhbXMucHJvbWlzZUNvbnN0cnVjdG9yIHx8IFByb21pc2U7XHJcbiAgY29uc3QganNvblNjaGVtYVNlcnZpY2UgPSBuZXcgSlNPTlNjaGVtYVNlcnZpY2UocGFyYW1zLnNjaGVtYVJlcXVlc3RTZXJ2aWNlLCBwYXJhbXMud29ya3NwYWNlQ29udGV4dCwgcHJvbWlzZSk7XHJcbiAganNvblNjaGVtYVNlcnZpY2Uuc2V0U2NoZW1hQ29udHJpYnV0aW9ucyhzY2hlbWFDb250cmlidXRpb25zKTtcclxuICBjb25zdCBqc29uQ29tcGxldGlvbiA9IG5ldyBKU09OQ29tcGxldGlvbihqc29uU2NoZW1hU2VydmljZSwgcGFyYW1zLmNvbnRyaWJ1dGlvbnMsIHByb21pc2UsIHBhcmFtcy5jbGllbnRDYXBhYmlsaXRpZXMpO1xyXG4gIGNvbnN0IGpzb25Ib3ZlciA9IG5ldyBKU09OSG92ZXIoanNvblNjaGVtYVNlcnZpY2UsIHBhcmFtcy5jb250cmlidXRpb25zLCBwcm9taXNlKTtcclxuICBjb25zdCBqc29uRG9jdW1lbnRTeW1ib2xzID0gbmV3IEpTT05Eb2N1bWVudFN5bWJvbHMoanNvblNjaGVtYVNlcnZpY2UpO1xyXG4gIGNvbnN0IGpzb25WYWxpZGF0aW9uID0gbmV3IEpTT05WYWxpZGF0aW9uKGpzb25TY2hlbWFTZXJ2aWNlLCBwcm9taXNlKTtcclxuICByZXR1cm4ge1xyXG4gICAgY29uZmlndXJlOiAoc2V0dGluZ3MpID0+IHtcclxuICAgICAganNvblNjaGVtYVNlcnZpY2UuY2xlYXJFeHRlcm5hbFNjaGVtYXMoKTtcclxuICAgICAgc2V0dGluZ3Muc2NoZW1hcz8uZm9yRWFjaChqc29uU2NoZW1hU2VydmljZS5yZWdpc3RlckV4dGVybmFsU2NoZW1hLmJpbmQoanNvblNjaGVtYVNlcnZpY2UpKTtcclxuICAgICAganNvblZhbGlkYXRpb24uY29uZmlndXJlKHNldHRpbmdzKTtcclxuICAgIH0sXHJcbiAgICByZXNldFNjaGVtYTogKHVyaSkgPT4ganNvblNjaGVtYVNlcnZpY2Uub25SZXNvdXJjZUNoYW5nZSh1cmkpLFxyXG4gICAgZG9WYWxpZGF0aW9uOiBqc29uVmFsaWRhdGlvbi5kb1ZhbGlkYXRpb24uYmluZChqc29uVmFsaWRhdGlvbiksXHJcbiAgICBnZXRMYW5ndWFnZVN0YXR1czoganNvblZhbGlkYXRpb24uZ2V0TGFuZ3VhZ2VTdGF0dXMuYmluZChqc29uVmFsaWRhdGlvbiksXHJcbiAgICBwYXJzZUpTT05Eb2N1bWVudDogKGRvY3VtZW50KSA9PiBwYXJzZTMoZG9jdW1lbnQsIHsgY29sbGVjdENvbW1lbnRzOiB0cnVlIH0pLFxyXG4gICAgbmV3SlNPTkRvY3VtZW50OiAocm9vdCwgZGlhZ25vc3RpY3MpID0+IG5ld0pTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcyksXHJcbiAgICBnZXRNYXRjaGluZ1NjaGVtYXM6IGpzb25TY2hlbWFTZXJ2aWNlLmdldE1hdGNoaW5nU2NoZW1hcy5iaW5kKGpzb25TY2hlbWFTZXJ2aWNlKSxcclxuICAgIGRvUmVzb2x2ZToganNvbkNvbXBsZXRpb24uZG9SZXNvbHZlLmJpbmQoanNvbkNvbXBsZXRpb24pLFxyXG4gICAgZG9Db21wbGV0ZToganNvbkNvbXBsZXRpb24uZG9Db21wbGV0ZS5iaW5kKGpzb25Db21wbGV0aW9uKSxcclxuICAgIGZpbmREb2N1bWVudFN5bWJvbHM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9scy5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxyXG4gICAgZmluZERvY3VtZW50U3ltYm9sczI6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9sczIuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcclxuICAgIGZpbmREb2N1bWVudENvbG9yczoganNvbkRvY3VtZW50U3ltYm9scy5maW5kRG9jdW1lbnRDb2xvcnMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcclxuICAgIGdldENvbG9yUHJlc2VudGF0aW9uczoganNvbkRvY3VtZW50U3ltYm9scy5nZXRDb2xvclByZXNlbnRhdGlvbnMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcclxuICAgIGRvSG92ZXI6IGpzb25Ib3Zlci5kb0hvdmVyLmJpbmQoanNvbkhvdmVyKSxcclxuICAgIGdldEZvbGRpbmdSYW5nZXMsXHJcbiAgICBnZXRTZWxlY3Rpb25SYW5nZXMsXHJcbiAgICBmaW5kRGVmaW5pdGlvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFtdKSxcclxuICAgIGZpbmRMaW5rcyxcclxuICAgIGZvcm1hdDogKGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucykgPT4gZm9ybWF0NChkb2N1bWVudCwgb3B0aW9ucywgcmFuZ2UpLFxyXG4gICAgc29ydDogKGRvY3VtZW50LCBvcHRpb25zKSA9PiBzb3J0KGRvY3VtZW50LCBvcHRpb25zKVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNyYy9sYW5ndWFnZS9qc29uL2pzb25Xb3JrZXIudHNcclxudmFyIGRlZmF1bHRTY2hlbWFSZXF1ZXN0U2VydmljZTtcclxuaWYgKHR5cGVvZiBmZXRjaCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gIGRlZmF1bHRTY2hlbWFSZXF1ZXN0U2VydmljZSA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgcmV0dXJuIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLnRleHQoKSk7XHJcbiAgfTtcclxufVxyXG52YXIgSlNPTldvcmtlciA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihjdHgsIGNyZWF0ZURhdGEpIHtcclxuICAgIHRoaXMuX2N0eCA9IGN0eDtcclxuICAgIHRoaXMuX2xhbmd1YWdlU2V0dGluZ3MgPSBjcmVhdGVEYXRhLmxhbmd1YWdlU2V0dGluZ3M7XHJcbiAgICB0aGlzLl9sYW5ndWFnZUlkID0gY3JlYXRlRGF0YS5sYW5ndWFnZUlkO1xyXG4gICAgdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlID0gZ2V0TGFuZ3VhZ2VTZXJ2aWNlKHtcclxuICAgICAgd29ya3NwYWNlQ29udGV4dDoge1xyXG4gICAgICAgIHJlc29sdmVSZWxhdGl2ZVBhdGg6IChyZWxhdGl2ZVBhdGgsIHJlc291cmNlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBiYXNlID0gcmVzb3VyY2Uuc3Vic3RyKDAsIHJlc291cmNlLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVQYXRoKGJhc2UsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBzY2hlbWFSZXF1ZXN0U2VydmljZTogY3JlYXRlRGF0YS5lbmFibGVTY2hlbWFSZXF1ZXN0ID8gZGVmYXVsdFNjaGVtYVJlcXVlc3RTZXJ2aWNlIDogdm9pZCAwLFxyXG4gICAgICBjbGllbnRDYXBhYmlsaXRpZXM6IENsaWVudENhcGFiaWxpdGllcy5MQVRFU1RcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmNvbmZpZ3VyZSh0aGlzLl9sYW5ndWFnZVNldHRpbmdzKTtcclxuICB9XHJcbiAgYXN5bmMgZG9WYWxpZGF0aW9uKHVyaSkge1xyXG4gICAgbGV0IGRvY3VtZW50ID0gdGhpcy5fZ2V0VGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICBpZiAoZG9jdW1lbnQpIHtcclxuICAgICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZG9WYWxpZGF0aW9uKGRvY3VtZW50LCBqc29uRG9jdW1lbnQsIHRoaXMuX2xhbmd1YWdlU2V0dGluZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgfVxyXG4gIGFzeW5jIGRvQ29tcGxldGUodXJpLCBwb3NpdGlvbikge1xyXG4gICAgbGV0IGRvY3VtZW50ID0gdGhpcy5fZ2V0VGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICBpZiAoIWRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uLCBqc29uRG9jdW1lbnQpO1xyXG4gIH1cclxuICBhc3luYyBkb1Jlc29sdmUoaXRlbSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlU2VydmljZS5kb1Jlc29sdmUoaXRlbSk7XHJcbiAgfVxyXG4gIGFzeW5jIGRvSG92ZXIodXJpLCBwb3NpdGlvbikge1xyXG4gICAgbGV0IGRvY3VtZW50ID0gdGhpcy5fZ2V0VGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICBpZiAoIWRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmRvSG92ZXIoZG9jdW1lbnQsIHBvc2l0aW9uLCBqc29uRG9jdW1lbnQpO1xyXG4gIH1cclxuICBhc3luYyBmb3JtYXQodXJpLCByYW5nZSwgb3B0aW9ucykge1xyXG4gICAgbGV0IGRvY3VtZW50ID0gdGhpcy5fZ2V0VGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICBpZiAoIWRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGxldCB0ZXh0RWRpdHMgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZm9ybWF0KGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHRFZGl0cyk7XHJcbiAgfVxyXG4gIGFzeW5jIHJlc2V0U2NoZW1hKHVyaSkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9sYW5ndWFnZVNlcnZpY2UucmVzZXRTY2hlbWEodXJpKSk7XHJcbiAgfVxyXG4gIGFzeW5jIGZpbmREb2N1bWVudFN5bWJvbHModXJpKSB7XHJcbiAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLl9nZXRUZXh0RG9jdW1lbnQodXJpKTtcclxuICAgIGlmICghZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICBsZXQgc3ltYm9scyA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5maW5kRG9jdW1lbnRTeW1ib2xzMihkb2N1bWVudCwganNvbkRvY3VtZW50KTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3ltYm9scyk7XHJcbiAgfVxyXG4gIGFzeW5jIGZpbmREb2N1bWVudENvbG9ycyh1cmkpIHtcclxuICAgIGxldCBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgaWYgKCFkb2N1bWVudCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBsZXQganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgIGxldCBjb2xvclN5bWJvbHMgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZmluZERvY3VtZW50Q29sb3JzKGRvY3VtZW50LCBqc29uRG9jdW1lbnQpO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb2xvclN5bWJvbHMpO1xyXG4gIH1cclxuICBhc3luYyBnZXRDb2xvclByZXNlbnRhdGlvbnModXJpLCBjb2xvciwgcmFuZ2UpIHtcclxuICAgIGxldCBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgaWYgKCFkb2N1bWVudCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBsZXQganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgIGxldCBjb2xvclByZXNlbnRhdGlvbnMgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZ2V0Q29sb3JQcmVzZW50YXRpb25zKFxyXG4gICAgICBkb2N1bWVudCxcclxuICAgICAganNvbkRvY3VtZW50LFxyXG4gICAgICBjb2xvcixcclxuICAgICAgcmFuZ2VcclxuICAgICk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbG9yUHJlc2VudGF0aW9ucyk7XHJcbiAgfVxyXG4gIGFzeW5jIGdldEZvbGRpbmdSYW5nZXModXJpLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLl9nZXRUZXh0RG9jdW1lbnQodXJpKTtcclxuICAgIGlmICghZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgbGV0IHJhbmdlcyA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5nZXRGb2xkaW5nUmFuZ2VzKGRvY3VtZW50LCBjb250ZXh0KTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmFuZ2VzKTtcclxuICB9XHJcbiAgYXN5bmMgZ2V0U2VsZWN0aW9uUmFuZ2VzKHVyaSwgcG9zaXRpb25zKSB7XHJcbiAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLl9nZXRUZXh0RG9jdW1lbnQodXJpKTtcclxuICAgIGlmICghZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICBsZXQgcmFuZ2VzID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmdldFNlbGVjdGlvblJhbmdlcyhkb2N1bWVudCwgcG9zaXRpb25zLCBqc29uRG9jdW1lbnQpO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyYW5nZXMpO1xyXG4gIH1cclxuICBhc3luYyBwYXJzZUpTT05Eb2N1bWVudCh1cmkpIHtcclxuICAgIGxldCBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgaWYgKCFkb2N1bWVudCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGxldCBqc29uRG9jdW1lbnQgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UucGFyc2VKU09ORG9jdW1lbnQoZG9jdW1lbnQpO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShqc29uRG9jdW1lbnQpO1xyXG4gIH1cclxuICBhc3luYyBnZXRNYXRjaGluZ1NjaGVtYXModXJpKSB7XHJcbiAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLl9nZXRUZXh0RG9jdW1lbnQodXJpKTtcclxuICAgIGlmICghZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2xhbmd1YWdlU2VydmljZS5nZXRNYXRjaGluZ1NjaGVtYXMoZG9jdW1lbnQsIGpzb25Eb2N1bWVudCkpO1xyXG4gIH1cclxuICBfZ2V0VGV4dERvY3VtZW50KHVyaSkge1xyXG4gICAgbGV0IG1vZGVscyA9IHRoaXMuX2N0eC5nZXRNaXJyb3JNb2RlbHMoKTtcclxuICAgIGZvciAobGV0IG1vZGVsIG9mIG1vZGVscykge1xyXG4gICAgICBpZiAobW9kZWwudXJpLnRvU3RyaW5nKCkgPT09IHVyaSkge1xyXG4gICAgICAgIHJldHVybiBUZXh0RG9jdW1lbnQyLmNyZWF0ZShcclxuICAgICAgICAgIHVyaSxcclxuICAgICAgICAgIHRoaXMuX2xhbmd1YWdlSWQsXHJcbiAgICAgICAgICBtb2RlbC52ZXJzaW9uLFxyXG4gICAgICAgICAgbW9kZWwuZ2V0VmFsdWUoKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxudmFyIFNsYXNoID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcclxudmFyIERvdCA9IFwiLlwiLmNoYXJDb2RlQXQoMCk7XHJcbmZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRoKHBhdGgpIHtcclxuICByZXR1cm4gcGF0aC5jaGFyQ29kZUF0KDApID09PSBTbGFzaDtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlUGF0aCh1cmlTdHJpbmcsIHBhdGgpIHtcclxuICBpZiAoaXNBYnNvbHV0ZVBhdGgocGF0aCkpIHtcclxuICAgIGNvbnN0IHVyaSA9IFVSSTIucGFyc2UodXJpU3RyaW5nKTtcclxuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICByZXR1cm4gdXJpLndpdGgoeyBwYXRoOiBub3JtYWxpemVQYXRoKHBhcnRzKSB9KS50b1N0cmluZygpO1xyXG4gIH1cclxuICByZXR1cm4gam9pblBhdGgodXJpU3RyaW5nLCBwYXRoKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhcnRzKSB7XHJcbiAgY29uc3QgbmV3UGFydHMgPSBbXTtcclxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcclxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCB8fCBwYXJ0Lmxlbmd0aCA9PT0gMSAmJiBwYXJ0LmNoYXJDb2RlQXQoMCkgPT09IERvdCkge1xyXG4gICAgfSBlbHNlIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMiAmJiBwYXJ0LmNoYXJDb2RlQXQoMCkgPT09IERvdCAmJiBwYXJ0LmNoYXJDb2RlQXQoMSkgPT09IERvdCkge1xyXG4gICAgICBuZXdQYXJ0cy5wb3AoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld1BhcnRzLnB1c2gocGFydCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgbmV3UGFydHMucHVzaChcIlwiKTtcclxuICB9XHJcbiAgbGV0IHJlcyA9IG5ld1BhcnRzLmpvaW4oXCIvXCIpO1xyXG4gIGlmIChwYXJ0c1swXS5sZW5ndGggPT09IDApIHtcclxuICAgIHJlcyA9IFwiL1wiICsgcmVzO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGpvaW5QYXRoKHVyaVN0cmluZywgLi4ucGF0aHMpIHtcclxuICBjb25zdCB1cmkgPSBVUkkyLnBhcnNlKHVyaVN0cmluZyk7XHJcbiAgY29uc3QgcGFydHMgPSB1cmkucGF0aC5zcGxpdChcIi9cIik7XHJcbiAgZm9yIChsZXQgcGF0aCBvZiBwYXRocykge1xyXG4gICAgcGFydHMucHVzaCguLi5wYXRoLnNwbGl0KFwiL1wiKSk7XHJcbiAgfVxyXG4gIHJldHVybiB1cmkud2l0aCh7IHBhdGg6IG5vcm1hbGl6ZVBhdGgocGFydHMpIH0pLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbi8vIHNyYy9sYW5ndWFnZS9qc29uL2pzb24ud29ya2VyLnRzXHJcbnNlbGYub25tZXNzYWdlID0gKCkgPT4ge1xyXG4gIHdvcmtlci5pbml0aWFsaXplKChjdHgsIGNyZWF0ZURhdGEpID0+IHtcclxuICAgIHJldHVybiBuZXcgSlNPTldvcmtlcihjdHgsIGNyZWF0ZURhdGEpO1xyXG4gIH0pO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/language/json/json.worker.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/nls.js":
/*!**************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/nls.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   getConfiguredDefaultLocale: () => (/* binding */ getConfiguredDefaultLocale),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   localize: () => (/* binding */ localize),\n/* harmony export */   localize2: () => (/* binding */ localize2),\n/* harmony export */   setPseudoTranslation: () => (/* binding */ setPseudoTranslation)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nlet isPseudo = (typeof document !== 'undefined' && document.location && document.location.hash.indexOf('pseudo=true') >= 0);\r\nconst DEFAULT_TAG = 'i-default';\r\nfunction _format(message, args) {\r\n    let result;\r\n    if (args.length === 0) {\r\n        result = message;\r\n    }\r\n    else {\r\n        result = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\r\n            const index = rest[0];\r\n            const arg = args[index];\r\n            let result = match;\r\n            if (typeof arg === 'string') {\r\n                result = arg;\r\n            }\r\n            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\r\n                result = String(arg);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    if (isPseudo) {\r\n        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\r\n        result = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\r\n    }\r\n    return result;\r\n}\r\nfunction findLanguageForModule(config, name) {\r\n    let result = config[name];\r\n    if (result) {\r\n        return result;\r\n    }\r\n    result = config['*'];\r\n    if (result) {\r\n        return result;\r\n    }\r\n    return null;\r\n}\r\nfunction endWithSlash(path) {\r\n    if (path.charAt(path.length - 1) === '/') {\r\n        return path;\r\n    }\r\n    return path + '/';\r\n}\r\nasync function getMessagesFromTranslationsService(translationServiceUrl, language, name) {\r\n    const url = endWithSlash(translationServiceUrl) + endWithSlash(language) + 'vscode/' + endWithSlash(name);\r\n    const res = await fetch(url);\r\n    if (res.ok) {\r\n        const messages = await res.json();\r\n        return messages;\r\n    }\r\n    throw new Error(`${res.status} - ${res.statusText}`);\r\n}\r\nfunction createScopedLocalize(scope) {\r\n    return function (idx, defaultValue) {\r\n        const restArgs = Array.prototype.slice.call(arguments, 2);\r\n        return _format(scope[idx], restArgs);\r\n    };\r\n}\r\nfunction createScopedLocalize2(scope) {\r\n    return (idx, defaultValue, ...args) => ({\r\n        value: _format(scope[idx], args),\r\n        original: _format(defaultValue, args)\r\n    });\r\n}\r\n/**\r\n * @skipMangle\r\n */\r\nfunction localize(data, message, ...args) {\r\n    return _format(message, args);\r\n}\r\n/**\r\n * @skipMangle\r\n */\r\nfunction localize2(data, message, ...args) {\r\n    const original = _format(message, args);\r\n    return {\r\n        value: original,\r\n        original\r\n    };\r\n}\r\n/**\r\n * @skipMangle\r\n */\r\nfunction getConfiguredDefaultLocale(_) {\r\n    // This returns undefined because this implementation isn't used and is overwritten by the loader\r\n    // when loaded.\r\n    return undefined;\r\n}\r\n/**\r\n * @skipMangle\r\n */\r\nfunction setPseudoTranslation(value) {\r\n    isPseudo = value;\r\n}\r\n/**\r\n * Invoked in a built product at run-time\r\n * @skipMangle\r\n */\r\nfunction create(key, data) {\r\n    var _a;\r\n    return {\r\n        localize: createScopedLocalize(data[key]),\r\n        localize2: createScopedLocalize2(data[key]),\r\n        getConfiguredDefaultLocale: (_a = data.getConfiguredDefaultLocale) !== null && _a !== void 0 ? _a : ((_) => undefined)\r\n    };\r\n}\r\n/**\r\n * Invoked by the loader at run-time\r\n * @skipMangle\r\n */\r\nfunction load(name, req, load, config) {\r\n    var _a;\r\n    const pluginConfig = (_a = config['vs/nls']) !== null && _a !== void 0 ? _a : {};\r\n    if (!name || name.length === 0) {\r\n        // TODO: We need to give back the mangled names here\r\n        return load({\r\n            localize: localize,\r\n            localize2: localize2,\r\n            getConfiguredDefaultLocale: () => { var _a; return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a['*']; }\r\n        });\r\n    }\r\n    const language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;\r\n    const useDefaultLanguage = language === null || language === DEFAULT_TAG;\r\n    let suffix = '.nls';\r\n    if (!useDefaultLanguage) {\r\n        suffix = suffix + '.' + language;\r\n    }\r\n    const messagesLoaded = (messages) => {\r\n        if (Array.isArray(messages)) {\r\n            messages.localize = createScopedLocalize(messages);\r\n            messages.localize2 = createScopedLocalize2(messages);\r\n        }\r\n        else {\r\n            messages.localize = createScopedLocalize(messages[name]);\r\n            messages.localize2 = createScopedLocalize2(messages[name]);\r\n        }\r\n        messages.getConfiguredDefaultLocale = () => { var _a; return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a['*']; };\r\n        load(messages);\r\n    };\r\n    if (typeof pluginConfig.loadBundle === 'function') {\r\n        pluginConfig.loadBundle(name, language, (err, messages) => {\r\n            // We have an error. Load the English default strings to not fail\r\n            if (err) {\r\n                req([name + '.nls'], messagesLoaded);\r\n            }\r\n            else {\r\n                messagesLoaded(messages);\r\n            }\r\n        });\r\n    }\r\n    else if (pluginConfig.translationServiceUrl && !useDefaultLanguage) {\r\n        (async () => {\r\n            var _a;\r\n            try {\r\n                const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, language, name);\r\n                return messagesLoaded(messages);\r\n            }\r\n            catch (err) {\r\n                // Language is already as generic as it gets, so require default messages\r\n                if (!language.includes('-')) {\r\n                    console.error(err);\r\n                    return req([name + '.nls'], messagesLoaded);\r\n                }\r\n                try {\r\n                    // Since there is a dash, the language configured is a specific sub-language of the same generic language.\r\n                    // Since we were unable to load the specific language, try to load the generic language. Ex. we failed to find a\r\n                    // Swiss German (de-CH), so try to load the generic German (de) messages instead.\r\n                    const genericLanguage = language.split('-')[0];\r\n                    const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, genericLanguage, name);\r\n                    // We got some messages, so we configure the configuration to use the generic language for this session.\r\n                    (_a = pluginConfig.availableLanguages) !== null && _a !== void 0 ? _a : (pluginConfig.availableLanguages = {});\r\n                    pluginConfig.availableLanguages['*'] = genericLanguage;\r\n                    return messagesLoaded(messages);\r\n                }\r\n                catch (err) {\r\n                    console.error(err);\r\n                    return req([name + '.nls'], messagesLoaded);\r\n                }\r\n            }\r\n        })();\r\n    }\r\n    else {\r\n        req([name + suffix], messagesLoaded, (err) => {\r\n            if (suffix === '.nls') {\r\n                console.error('Failed trying to load default language strings', err);\r\n                return;\r\n            }\r\n            console.error(`Failed to load message bundle for language ${language}. Falling back to the default language:`, err);\r\n            req([name + '.nls'], messagesLoaded);\r\n        });\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbmxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksSUFBSSxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9ubHMuanM/ZGZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxubGV0IGlzUHNldWRvID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQubG9jYXRpb24gJiYgZG9jdW1lbnQubG9jYXRpb24uaGFzaC5pbmRleE9mKCdwc2V1ZG89dHJ1ZScpID49IDApO1xyXG5jb25zdCBERUZBVUxUX1RBRyA9ICdpLWRlZmF1bHQnO1xyXG5mdW5jdGlvbiBfZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXN1bHQgPSBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbWVzc2FnZS5yZXBsYWNlKC9cXHsoXFxkKylcXH0vZywgKG1hdGNoLCByZXN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVzdFswXTtcclxuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF07XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8IGFyZyA9PT0gdm9pZCAwIHx8IGFyZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nKGFyZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChpc1BzZXVkbykge1xyXG4gICAgICAgIC8vIEZGM0IgYW5kIEZGM0QgaXMgdGhlIFVuaWNvZGUgemVua2FrdSByZXByZXNlbnRhdGlvbiBmb3IgWyBhbmQgXVxyXG4gICAgICAgIHJlc3VsdCA9ICdcXHVGRjNCJyArIHJlc3VsdC5yZXBsYWNlKC9bYW91ZWldL2csICckJiQmJykgKyAnXFx1RkYzRCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGZpbmRMYW5ndWFnZUZvck1vZHVsZShjb25maWcsIG5hbWUpIHtcclxuICAgIGxldCByZXN1bHQgPSBjb25maWdbbmFtZV07XHJcbiAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlc3VsdCA9IGNvbmZpZ1snKiddO1xyXG4gICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBlbmRXaXRoU2xhc2gocGF0aCkge1xyXG4gICAgaWYgKHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGggKyAnLyc7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0TWVzc2FnZXNGcm9tVHJhbnNsYXRpb25zU2VydmljZSh0cmFuc2xhdGlvblNlcnZpY2VVcmwsIGxhbmd1YWdlLCBuYW1lKSB7XHJcbiAgICBjb25zdCB1cmwgPSBlbmRXaXRoU2xhc2godHJhbnNsYXRpb25TZXJ2aWNlVXJsKSArIGVuZFdpdGhTbGFzaChsYW5ndWFnZSkgKyAndnNjb2RlLycgKyBlbmRXaXRoU2xhc2gobmFtZSk7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwpO1xyXG4gICAgaWYgKHJlcy5vaykge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gLSAke3Jlcy5zdGF0dXNUZXh0fWApO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlZExvY2FsaXplKHNjb3BlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlkeCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIHJldHVybiBfZm9ybWF0KHNjb3BlW2lkeF0sIHJlc3RBcmdzKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2NvcGVkTG9jYWxpemUyKHNjb3BlKSB7XHJcbiAgICByZXR1cm4gKGlkeCwgZGVmYXVsdFZhbHVlLCAuLi5hcmdzKSA9PiAoe1xyXG4gICAgICAgIHZhbHVlOiBfZm9ybWF0KHNjb3BlW2lkeF0sIGFyZ3MpLFxyXG4gICAgICAgIG9yaWdpbmFsOiBfZm9ybWF0KGRlZmF1bHRWYWx1ZSwgYXJncylcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAc2tpcE1hbmdsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsaXplKGRhdGEsIG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBfZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xyXG59XHJcbi8qKlxyXG4gKiBAc2tpcE1hbmdsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsaXplMihkYXRhLCBtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zdCBvcmlnaW5hbCA9IF9mb3JtYXQobWVzc2FnZSwgYXJncyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiBvcmlnaW5hbCxcclxuICAgICAgICBvcmlnaW5hbFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQHNraXBNYW5nbGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWd1cmVkRGVmYXVsdExvY2FsZShfKSB7XHJcbiAgICAvLyBUaGlzIHJldHVybnMgdW5kZWZpbmVkIGJlY2F1c2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBpc24ndCB1c2VkIGFuZCBpcyBvdmVyd3JpdHRlbiBieSB0aGUgbG9hZGVyXHJcbiAgICAvLyB3aGVuIGxvYWRlZC5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEBza2lwTWFuZ2xlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0UHNldWRvVHJhbnNsYXRpb24odmFsdWUpIHtcclxuICAgIGlzUHNldWRvID0gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIEludm9rZWQgaW4gYSBidWlsdCBwcm9kdWN0IGF0IHJ1bi10aW1lXHJcbiAqIEBza2lwTWFuZ2xlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGtleSwgZGF0YSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsb2NhbGl6ZTogY3JlYXRlU2NvcGVkTG9jYWxpemUoZGF0YVtrZXldKSxcclxuICAgICAgICBsb2NhbGl6ZTI6IGNyZWF0ZVNjb3BlZExvY2FsaXplMihkYXRhW2tleV0pLFxyXG4gICAgICAgIGdldENvbmZpZ3VyZWREZWZhdWx0TG9jYWxlOiAoX2EgPSBkYXRhLmdldENvbmZpZ3VyZWREZWZhdWx0TG9jYWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKF8pID0+IHVuZGVmaW5lZClcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEludm9rZWQgYnkgdGhlIGxvYWRlciBhdCBydW4tdGltZVxyXG4gKiBAc2tpcE1hbmdsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWQobmFtZSwgcmVxLCBsb2FkLCBjb25maWcpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHBsdWdpbkNvbmZpZyA9IChfYSA9IGNvbmZpZ1sndnMvbmxzJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xyXG4gICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byBnaXZlIGJhY2sgdGhlIG1hbmdsZWQgbmFtZXMgaGVyZVxyXG4gICAgICAgIHJldHVybiBsb2FkKHtcclxuICAgICAgICAgICAgbG9jYWxpemU6IGxvY2FsaXplLFxyXG4gICAgICAgICAgICBsb2NhbGl6ZTI6IGxvY2FsaXplMixcclxuICAgICAgICAgICAgZ2V0Q29uZmlndXJlZERlZmF1bHRMb2NhbGU6ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcGx1Z2luQ29uZmlnLmF2YWlsYWJsZUxhbmd1YWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWycqJ107IH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhbmd1YWdlID0gcGx1Z2luQ29uZmlnLmF2YWlsYWJsZUxhbmd1YWdlcyA/IGZpbmRMYW5ndWFnZUZvck1vZHVsZShwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzLCBuYW1lKSA6IG51bGw7XHJcbiAgICBjb25zdCB1c2VEZWZhdWx0TGFuZ3VhZ2UgPSBsYW5ndWFnZSA9PT0gbnVsbCB8fCBsYW5ndWFnZSA9PT0gREVGQVVMVF9UQUc7XHJcbiAgICBsZXQgc3VmZml4ID0gJy5ubHMnO1xyXG4gICAgaWYgKCF1c2VEZWZhdWx0TGFuZ3VhZ2UpIHtcclxuICAgICAgICBzdWZmaXggPSBzdWZmaXggKyAnLicgKyBsYW5ndWFnZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1lc3NhZ2VzTG9hZGVkID0gKG1lc3NhZ2VzKSA9PiB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VzLmxvY2FsaXplID0gY3JlYXRlU2NvcGVkTG9jYWxpemUobWVzc2FnZXMpO1xyXG4gICAgICAgICAgICBtZXNzYWdlcy5sb2NhbGl6ZTIgPSBjcmVhdGVTY29wZWRMb2NhbGl6ZTIobWVzc2FnZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZXMubG9jYWxpemUgPSBjcmVhdGVTY29wZWRMb2NhbGl6ZShtZXNzYWdlc1tuYW1lXSk7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VzLmxvY2FsaXplMiA9IGNyZWF0ZVNjb3BlZExvY2FsaXplMihtZXNzYWdlc1tuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc3NhZ2VzLmdldENvbmZpZ3VyZWREZWZhdWx0TG9jYWxlID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJyonXTsgfTtcclxuICAgICAgICBsb2FkKG1lc3NhZ2VzKTtcclxuICAgIH07XHJcbiAgICBpZiAodHlwZW9mIHBsdWdpbkNvbmZpZy5sb2FkQnVuZGxlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcGx1Z2luQ29uZmlnLmxvYWRCdW5kbGUobmFtZSwgbGFuZ3VhZ2UsIChlcnIsIG1lc3NhZ2VzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gZXJyb3IuIExvYWQgdGhlIEVuZ2xpc2ggZGVmYXVsdCBzdHJpbmdzIHRvIG5vdCBmYWlsXHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlcShbbmFtZSArICcubmxzJ10sIG1lc3NhZ2VzTG9hZGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzTG9hZGVkKG1lc3NhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGx1Z2luQ29uZmlnLnRyYW5zbGF0aW9uU2VydmljZVVybCAmJiAhdXNlRGVmYXVsdExhbmd1YWdlKSB7XHJcbiAgICAgICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCBnZXRNZXNzYWdlc0Zyb21UcmFuc2xhdGlvbnNTZXJ2aWNlKHBsdWdpbkNvbmZpZy50cmFuc2xhdGlvblNlcnZpY2VVcmwsIGxhbmd1YWdlLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlc0xvYWRlZChtZXNzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgLy8gTGFuZ3VhZ2UgaXMgYWxyZWFkeSBhcyBnZW5lcmljIGFzIGl0IGdldHMsIHNvIHJlcXVpcmUgZGVmYXVsdCBtZXNzYWdlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYW5ndWFnZS5pbmNsdWRlcygnLScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXEoW25hbWUgKyAnLm5scyddLCBtZXNzYWdlc0xvYWRlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIGEgZGFzaCwgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyZWQgaXMgYSBzcGVjaWZpYyBzdWItbGFuZ3VhZ2Ugb2YgdGhlIHNhbWUgZ2VuZXJpYyBsYW5ndWFnZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBsb2FkIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSwgdHJ5IHRvIGxvYWQgdGhlIGdlbmVyaWMgbGFuZ3VhZ2UuIEV4LiB3ZSBmYWlsZWQgdG8gZmluZCBhXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgR2VybWFuIChkZS1DSCksIHNvIHRyeSB0byBsb2FkIHRoZSBnZW5lcmljIEdlcm1hbiAoZGUpIG1lc3NhZ2VzIGluc3RlYWQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY0xhbmd1YWdlID0gbGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IGdldE1lc3NhZ2VzRnJvbVRyYW5zbGF0aW9uc1NlcnZpY2UocGx1Z2luQ29uZmlnLnRyYW5zbGF0aW9uU2VydmljZVVybCwgZ2VuZXJpY0xhbmd1YWdlLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnb3Qgc29tZSBtZXNzYWdlcywgc28gd2UgY29uZmlndXJlIHRoZSBjb25maWd1cmF0aW9uIHRvIHVzZSB0aGUgZ2VuZXJpYyBsYW5ndWFnZSBmb3IgdGhpcyBzZXNzaW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHBsdWdpbkNvbmZpZy5hdmFpbGFibGVMYW5ndWFnZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzID0ge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbkNvbmZpZy5hdmFpbGFibGVMYW5ndWFnZXNbJyonXSA9IGdlbmVyaWNMYW5ndWFnZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNMb2FkZWQobWVzc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxKFtuYW1lICsgJy5ubHMnXSwgbWVzc2FnZXNMb2FkZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlcShbbmFtZSArIHN1ZmZpeF0sIG1lc3NhZ2VzTG9hZGVkLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdWZmaXggPT09ICcubmxzJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRyeWluZyB0byBsb2FkIGRlZmF1bHQgbGFuZ3VhZ2Ugc3RyaW5ncycsIGVycik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgbWVzc2FnZSBidW5kbGUgZm9yIGxhbmd1YWdlICR7bGFuZ3VhZ2V9LiBGYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgbGFuZ3VhZ2U6YCwgZXJyKTtcclxuICAgICAgICAgICAgcmVxKFtuYW1lICsgJy5ubHMnXSwgbWVzc2FnZXNMb2FkZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/nls.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/monaco-editor/esm/vs/language/json/json.worker.js");
/******/ 	
/******/ })()
;